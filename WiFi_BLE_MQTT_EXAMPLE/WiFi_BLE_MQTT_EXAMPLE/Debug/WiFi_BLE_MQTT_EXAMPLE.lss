
WiFi_BLE_MQTT_EXAMPLE.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000115d4  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000000a0  20000000  000115d4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00002178  200000a0  00011674  000200a0  2**2
                  ALLOC
  3 .stack        00002000  20002218  000137ec  000200a0  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  000200a0  2**0
                  CONTENTS, READONLY
  5 .comment      000000cc  00000000  00000000  000200c8  2**0
                  CONTENTS, READONLY
  6 .debug_info   00057305  00000000  00000000  00020194  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000080d5  00000000  00000000  00077499  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00015178  00000000  00000000  0007f56e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000011b0  00000000  00000000  000946e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001628  00000000  00000000  00095896  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  000246d3  00000000  00000000  00096ebe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00021e80  00000000  00000000  000bb591  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0009cd3c  00000000  00000000  000dd411  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000039f4  00000000  00000000  0017a150  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20004218 	.word	0x20004218
       4:	000061fd 	.word	0x000061fd
       8:	000061f9 	.word	0x000061f9
       c:	000061f9 	.word	0x000061f9
	...
      2c:	000061f9 	.word	0x000061f9
	...
      38:	000061f9 	.word	0x000061f9
      3c:	000061f9 	.word	0x000061f9
      40:	000061f9 	.word	0x000061f9
      44:	000061f9 	.word	0x000061f9
      48:	000061f9 	.word	0x000061f9
      4c:	000061f9 	.word	0x000061f9
      50:	000042a5 	.word	0x000042a5
      54:	000061f9 	.word	0x000061f9
      58:	000061f9 	.word	0x000061f9
      5c:	000061f9 	.word	0x000061f9
      60:	000061f9 	.word	0x000061f9
      64:	000048ad 	.word	0x000048ad
      68:	000048bd 	.word	0x000048bd
      6c:	000048cd 	.word	0x000048cd
      70:	000048dd 	.word	0x000048dd
      74:	000048ed 	.word	0x000048ed
      78:	000048fd 	.word	0x000048fd
      7c:	000061c9 	.word	0x000061c9
      80:	000061d9 	.word	0x000061d9
      84:	000061e9 	.word	0x000061e9
      88:	00001c71 	.word	0x00001c71
      8c:	00001c81 	.word	0x00001c81
      90:	00001c91 	.word	0x00001c91
	...
      9c:	000061f9 	.word	0x000061f9
      a0:	000061f9 	.word	0x000061f9
      a4:	000061f9 	.word	0x000061f9
      a8:	000061f9 	.word	0x000061f9
      ac:	000061f9 	.word	0x000061f9
      b0:	00000000 	.word	0x00000000

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	200000a0 	.word	0x200000a0
      d4:	00000000 	.word	0x00000000
      d8:	000115d4 	.word	0x000115d4

000000dc <frame_dummy>:
      dc:	b508      	push	{r3, lr}
      de:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4807      	ldr	r0, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4908      	ldr	r1, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd08      	pop	{r3, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	000115d4 	.word	0x000115d4
     108:	200000a4 	.word	0x200000a4
     10c:	000115d4 	.word	0x000115d4
     110:	00000000 	.word	0x00000000

00000114 <_tc_get_inst_index>:
 *
 * \return Index of the given TC module instance.
 */
uint8_t _tc_get_inst_index(
		Tc *const hw)
{
     114:	b530      	push	{r4, r5, lr}
     116:	b085      	sub	sp, #20
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
     118:	aa01      	add	r2, sp, #4
     11a:	4b0b      	ldr	r3, [pc, #44]	; (148 <_tc_get_inst_index+0x34>)
     11c:	cb32      	ldmia	r3!, {r1, r4, r5}
     11e:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
     120:	9b01      	ldr	r3, [sp, #4]
     122:	4283      	cmp	r3, r0
     124:	d00a      	beq.n	13c <_tc_get_inst_index+0x28>
     126:	9b02      	ldr	r3, [sp, #8]
     128:	4283      	cmp	r3, r0
     12a:	d005      	beq.n	138 <_tc_get_inst_index+0x24>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
     12c:	2300      	movs	r3, #0
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
     12e:	9a03      	ldr	r2, [sp, #12]
     130:	4282      	cmp	r2, r0
     132:	d105      	bne.n	140 <_tc_get_inst_index+0x2c>
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
     134:	3302      	adds	r3, #2
     136:	e002      	b.n	13e <_tc_get_inst_index+0x2a>
     138:	2301      	movs	r3, #1
     13a:	e000      	b.n	13e <_tc_get_inst_index+0x2a>
     13c:	2300      	movs	r3, #0
		if (hw == tc_modules[i]) {
			return i;
     13e:	b2db      	uxtb	r3, r3
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
     140:	1c18      	adds	r0, r3, #0
     142:	b005      	add	sp, #20
     144:	bd30      	pop	{r4, r5, pc}
     146:	46c0      	nop			; (mov r8, r8)
     148:	0000e858 	.word	0x0000e858

0000014c <tc_init>:
 */
enum status_code tc_init(
		struct tc_module *const module_inst,
		Tc *const hw,
		const struct tc_config *const config)
{
     14c:	b5f0      	push	{r4, r5, r6, r7, lr}
     14e:	464f      	mov	r7, r9
     150:	4646      	mov	r6, r8
     152:	b4c0      	push	{r6, r7}
     154:	b087      	sub	sp, #28
     156:	1c04      	adds	r4, r0, #0
     158:	1c0e      	adds	r6, r1, #0
     15a:	4690      	mov	r8, r2
	uint8_t ctrlbset_tmp = 0;
	/* Temporary variable to hold all updates to the CTRLC
	 * register before they are written to it */
	uint8_t ctrlc_tmp = 0;
	/* Temporary variable to hold TC instance number */
	uint8_t instance = _tc_get_inst_index(hw);
     15c:	1c08      	adds	r0, r1, #0
     15e:	4b91      	ldr	r3, [pc, #580]	; (3a4 <tc_init+0x258>)
     160:	4798      	blx	r3
     162:	4681      	mov	r9, r0

	/* Array of GLCK ID for different TC instances */
	uint8_t inst_gclk_id[] = TC_INST_GCLK_ID;
     164:	4d90      	ldr	r5, [pc, #576]	; (3a8 <tc_init+0x25c>)
     166:	1c29      	adds	r1, r5, #0
     168:	310c      	adds	r1, #12
     16a:	a805      	add	r0, sp, #20
     16c:	2203      	movs	r2, #3
     16e:	4f8f      	ldr	r7, [pc, #572]	; (3ac <tc_init+0x260>)
     170:	47b8      	blx	r7
	/* Array of PM APBC mask bit position for different TC instances */
	uint16_t inst_pm_apbmask[] = TC_INST_PM_APBCMASK;
     172:	1c29      	adds	r1, r5, #0
     174:	3110      	adds	r1, #16
     176:	a803      	add	r0, sp, #12
     178:	2206      	movs	r2, #6
     17a:	47b8      	blx	r7
	struct system_gclk_chan_config gclk_chan_config;

#if TC_ASYNC == true
	/* Initialize parameters */
	for (uint8_t i = 0; i < TC_CALLBACK_N; i++) {
		module_inst->callback[i]        = NULL;
     17c:	2300      	movs	r3, #0
     17e:	60a3      	str	r3, [r4, #8]
     180:	60e3      	str	r3, [r4, #12]
     182:	6123      	str	r3, [r4, #16]
     184:	6163      	str	r3, [r4, #20]
	}
	module_inst->register_callback_mask     = 0x00;
     186:	7623      	strb	r3, [r4, #24]
	module_inst->enable_callback_mask       = 0x00;
     188:	7663      	strb	r3, [r4, #25]

	/* Register this instance for callbacks*/
	_tc_instances[instance] = module_inst;
     18a:	464b      	mov	r3, r9
     18c:	009a      	lsls	r2, r3, #2
     18e:	4b88      	ldr	r3, [pc, #544]	; (3b0 <tc_init+0x264>)
     190:	50d4      	str	r4, [r2, r3]
#endif

	/* Associate the given device instance with the hardware module */
	module_inst->hw = hw;
     192:	6026      	str	r6, [r4, #0]
#else
	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
     194:	4643      	mov	r3, r8
     196:	789b      	ldrb	r3, [r3, #2]
     198:	2b08      	cmp	r3, #8
     19a:	d104      	bne.n	1a6 <tc_init+0x5a>
			((instance + TC_INSTANCE_OFFSET) & 0x01)) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
     19c:	2017      	movs	r0, #23
#else
	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
     19e:	464a      	mov	r2, r9
     1a0:	07d2      	lsls	r2, r2, #31
     1a2:	d400      	bmi.n	1a6 <tc_init+0x5a>
     1a4:	e0f9      	b.n	39a <tc_init+0x24e>
#endif

	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;
     1a6:	7123      	strb	r3, [r4, #4]

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
     1a8:	8833      	ldrh	r3, [r6, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
     1aa:	2005      	movs	r0, #5
	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
     1ac:	07db      	lsls	r3, r3, #31
     1ae:	d500      	bpl.n	1b2 <tc_init+0x66>
     1b0:	e0f3      	b.n	39a <tc_init+0x24e>
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
     1b2:	7bf3      	ldrb	r3, [r6, #15]
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
     1b4:	3017      	adds	r0, #23
	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
     1b6:	06db      	lsls	r3, r3, #27
     1b8:	d500      	bpl.n	1bc <tc_init+0x70>
     1ba:	e0ee      	b.n	39a <tc_init+0x24e>
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
	}

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_ENABLE) {
     1bc:	8833      	ldrh	r3, [r6, #0]
     1be:	079b      	lsls	r3, r3, #30
     1c0:	d500      	bpl.n	1c4 <tc_init+0x78>
     1c2:	e0ea      	b.n	39a <tc_init+0x24e>
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
	}

	/* Set up the TC PWM out pin for channel 0 */
	if (config->pwm_channel[0].enabled) {
     1c4:	4643      	mov	r3, r8
     1c6:	7c1b      	ldrb	r3, [r3, #16]
     1c8:	2b00      	cmp	r3, #0
     1ca:	d00c      	beq.n	1e6 <tc_init+0x9a>
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
     1cc:	a902      	add	r1, sp, #8
     1ce:	2301      	movs	r3, #1
     1d0:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
     1d2:	2200      	movs	r2, #0
     1d4:	70ca      	strb	r2, [r1, #3]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[0].pin_mux;
     1d6:	4642      	mov	r2, r8
     1d8:	7e12      	ldrb	r2, [r2, #24]
     1da:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
     1dc:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
     1de:	4643      	mov	r3, r8
     1e0:	7d18      	ldrb	r0, [r3, #20]
     1e2:	4b74      	ldr	r3, [pc, #464]	; (3b4 <tc_init+0x268>)
     1e4:	4798      	blx	r3
				config->pwm_channel[0].pin_out, &pin_config);
	}

	/* Set up the TC PWM out pin for channel 1 */
	if (config->pwm_channel[1].enabled) {
     1e6:	4643      	mov	r3, r8
     1e8:	7f1b      	ldrb	r3, [r3, #28]
     1ea:	2b00      	cmp	r3, #0
     1ec:	d00d      	beq.n	20a <tc_init+0xbe>
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
     1ee:	a902      	add	r1, sp, #8
     1f0:	2301      	movs	r3, #1
     1f2:	708b      	strb	r3, [r1, #2]
	config->powersave    = false;
     1f4:	2200      	movs	r2, #0
     1f6:	70ca      	strb	r2, [r1, #3]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
     1f8:	4642      	mov	r2, r8
     1fa:	6a52      	ldr	r2, [r2, #36]	; 0x24
     1fc:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
     1fe:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
     200:	4643      	mov	r3, r8
     202:	6a1b      	ldr	r3, [r3, #32]
     204:	b2d8      	uxtb	r0, r3
     206:	4b6b      	ldr	r3, [pc, #428]	; (3b4 <tc_init+0x268>)
     208:	4798      	blx	r3
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
     20a:	496b      	ldr	r1, [pc, #428]	; (3b8 <tc_init+0x26c>)
     20c:	6a0b      	ldr	r3, [r1, #32]
				config->pwm_channel[1].pin_out, &pin_config);
	}

	/* Enable the user interface clock in the PM */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
			inst_pm_apbmask[instance]);
     20e:	464a      	mov	r2, r9
     210:	0052      	lsls	r2, r2, #1
		system_pinmux_pin_set_config(
				config->pwm_channel[1].pin_out, &pin_config);
	}

	/* Enable the user interface clock in the PM */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
     212:	a803      	add	r0, sp, #12
     214:	5a12      	ldrh	r2, [r2, r0]
     216:	4313      	orrs	r3, r2
     218:	620b      	str	r3, [r1, #32]
			inst_pm_apbmask[instance]);

	/* Enable the slave counter if counter_size is 32-bit */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT))
     21a:	4643      	mov	r3, r8
     21c:	789b      	ldrb	r3, [r3, #2]
     21e:	2b08      	cmp	r3, #8
     220:	d106      	bne.n	230 <tc_init+0xe4>
     222:	6a0b      	ldr	r3, [r1, #32]
	{
		/* Enable the user interface clock in the PM */
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
				inst_pm_apbmask[instance + 1]);
     224:	464a      	mov	r2, r9
     226:	3201      	adds	r2, #1
     228:	0052      	lsls	r2, r2, #1

	/* Enable the slave counter if counter_size is 32-bit */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT))
	{
		/* Enable the user interface clock in the PM */
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
     22a:	5a12      	ldrh	r2, [r2, r0]
     22c:	4313      	orrs	r3, r2
     22e:	620b      	str	r3, [r1, #32]
				inst_pm_apbmask[instance + 1]);
	}

	/* Setup clock for module */
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
	gclk_chan_config.source_generator = config->clock_source;
     230:	a901      	add	r1, sp, #4
     232:	4643      	mov	r3, r8
     234:	781b      	ldrb	r3, [r3, #0]
     236:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
     238:	ab05      	add	r3, sp, #20
     23a:	464a      	mov	r2, r9
     23c:	5c9d      	ldrb	r5, [r3, r2]
     23e:	1c28      	adds	r0, r5, #0
     240:	4b5e      	ldr	r3, [pc, #376]	; (3bc <tc_init+0x270>)
     242:	4798      	blx	r3
	system_gclk_chan_enable(inst_gclk_id[instance]);
     244:	1c28      	adds	r0, r5, #0
     246:	4b5e      	ldr	r3, [pc, #376]	; (3c0 <tc_init+0x274>)
     248:	4798      	blx	r3
     24a:	4643      	mov	r3, r8
     24c:	8898      	ldrh	r0, [r3, #4]
     24e:	891b      	ldrh	r3, [r3, #8]
     250:	4303      	orrs	r3, r0

	/* Set ctrla register */
	ctrla_tmp =
     252:	4642      	mov	r2, r8
     254:	7990      	ldrb	r0, [r2, #6]
     256:	7892      	ldrb	r2, [r2, #2]
     258:	4310      	orrs	r0, r2
     25a:	4318      	orrs	r0, r3
			(uint32_t)config->counter_size |
			(uint32_t)config->wave_generation |
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;

	if (config->run_in_standby) {
     25c:	4643      	mov	r3, r8
     25e:	785b      	ldrb	r3, [r3, #1]
     260:	2b00      	cmp	r3, #0
     262:	d002      	beq.n	26a <tc_init+0x11e>
		ctrla_tmp |= TC_CTRLA_RUNSTDBY;
     264:	2380      	movs	r3, #128	; 0x80
     266:	011b      	lsls	r3, r3, #4
     268:	4318      	orrs	r0, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     26a:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     26c:	227f      	movs	r2, #127	; 0x7f
     26e:	7bcb      	ldrb	r3, [r1, #15]
	}

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
     270:	4393      	bics	r3, r2
     272:	d1fc      	bne.n	26e <tc_init+0x122>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLA.reg = ctrla_tmp;
     274:	8030      	strh	r0, [r6, #0]

	/* Set ctrlb register */
	if (config->oneshot) {
     276:	4643      	mov	r3, r8
     278:	7b58      	ldrb	r0, [r3, #13]
		ctrlbset_tmp = TC_CTRLBSET_ONESHOT;
     27a:	1e43      	subs	r3, r0, #1
     27c:	4198      	sbcs	r0, r3
     27e:	0080      	lsls	r0, r0, #2
	}

	if (config->count_direction) {
     280:	4643      	mov	r3, r8
     282:	7b9b      	ldrb	r3, [r3, #14]
     284:	2b00      	cmp	r3, #0
     286:	d001      	beq.n	28c <tc_init+0x140>
		ctrlbset_tmp |= TC_CTRLBSET_DIR;
     288:	2301      	movs	r3, #1
     28a:	4318      	orrs	r0, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     28c:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     28e:	227f      	movs	r2, #127	; 0x7f
     290:	7bcb      	ldrb	r3, [r1, #15]
	}

	/* Clear old ctrlb configuration */
	while (tc_is_syncing(module_inst)) {
     292:	4393      	bics	r3, r2
     294:	d1fc      	bne.n	290 <tc_init+0x144>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLBCLR.reg = 0xFF;
     296:	33ff      	adds	r3, #255	; 0xff
     298:	7133      	strb	r3, [r6, #4]

	/* Check if we actually need to go into a wait state. */
	if (ctrlbset_tmp) {
     29a:	2800      	cmp	r0, #0
     29c:	d005      	beq.n	2aa <tc_init+0x15e>
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     29e:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     2a0:	227f      	movs	r2, #127	; 0x7f
     2a2:	7bcb      	ldrb	r3, [r1, #15]
		while (tc_is_syncing(module_inst)) {
     2a4:	4393      	bics	r3, r2
     2a6:	d1fc      	bne.n	2a2 <tc_init+0x156>
			/* Wait for sync */
		}
		/* Write configuration to register */
		hw->COUNT8.CTRLBSET.reg = ctrlbset_tmp;
     2a8:	7170      	strb	r0, [r6, #5]
	}

	/* Set ctrlc register*/
	ctrlc_tmp = config->waveform_invert_output;
     2aa:	4643      	mov	r3, r8
     2ac:	7a98      	ldrb	r0, [r3, #10]
	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_channel[i] == true) {
     2ae:	7adb      	ldrb	r3, [r3, #11]
     2b0:	2b00      	cmp	r3, #0
     2b2:	d001      	beq.n	2b8 <tc_init+0x16c>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
     2b4:	2310      	movs	r3, #16
     2b6:	4318      	orrs	r0, r3
	}

	/* Set ctrlc register*/
	ctrlc_tmp = config->waveform_invert_output;
	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_channel[i] == true) {
     2b8:	4643      	mov	r3, r8
     2ba:	7b1b      	ldrb	r3, [r3, #12]
     2bc:	2b00      	cmp	r3, #0
     2be:	d001      	beq.n	2c4 <tc_init+0x178>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
     2c0:	2320      	movs	r3, #32
     2c2:	4318      	orrs	r0, r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     2c4:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     2c6:	227f      	movs	r2, #127	; 0x7f
     2c8:	7bcb      	ldrb	r3, [r1, #15]
		}
	}

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
     2ca:	4393      	bics	r3, r2
     2cc:	d1fc      	bne.n	2c8 <tc_init+0x17c>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLC.reg = ctrlc_tmp;
     2ce:	71b0      	strb	r0, [r6, #6]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     2d0:	6822      	ldr	r2, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     2d2:	217f      	movs	r1, #127	; 0x7f
     2d4:	7bd3      	ldrb	r3, [r2, #15]

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
     2d6:	438b      	bics	r3, r1
     2d8:	d1fc      	bne.n	2d4 <tc_init+0x188>
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
     2da:	7923      	ldrb	r3, [r4, #4]
     2dc:	2b04      	cmp	r3, #4
     2de:	d005      	beq.n	2ec <tc_init+0x1a0>
     2e0:	2b08      	cmp	r3, #8
     2e2:	d041      	beq.n	368 <tc_init+0x21c>

			return STATUS_OK;
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
     2e4:	2017      	movs	r0, #23
	while (tc_is_syncing(module_inst)) {
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
     2e6:	2b00      	cmp	r3, #0
     2e8:	d157      	bne.n	39a <tc_init+0x24e>
     2ea:	e024      	b.n	336 <tc_init+0x1ea>
     2ec:	217f      	movs	r1, #127	; 0x7f
     2ee:	7bd3      	ldrb	r3, [r2, #15]
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
     2f0:	438b      	bics	r3, r1
     2f2:	d1fc      	bne.n	2ee <tc_init+0x1a2>
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
					config->counter_8_bit.value;
     2f4:	3328      	adds	r3, #40	; 0x28
     2f6:	4642      	mov	r2, r8
     2f8:	5cd3      	ldrb	r3, [r2, r3]
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
     2fa:	7433      	strb	r3, [r6, #16]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     2fc:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     2fe:	227f      	movs	r2, #127	; 0x7f
     300:	7bcb      	ldrb	r3, [r1, #15]
					config->counter_8_bit.value;


			while (tc_is_syncing(module_inst)) {
     302:	4393      	bics	r3, r2
     304:	d1fc      	bne.n	300 <tc_init+0x1b4>
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
					config->counter_8_bit.period;
     306:	3329      	adds	r3, #41	; 0x29
     308:	4642      	mov	r2, r8
     30a:	5cd3      	ldrb	r3, [r2, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
     30c:	7533      	strb	r3, [r6, #20]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     30e:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     310:	227f      	movs	r2, #127	; 0x7f
     312:	7bcb      	ldrb	r3, [r1, #15]
					config->counter_8_bit.period;

			while (tc_is_syncing(module_inst)) {
     314:	4393      	bics	r3, r2
     316:	d1fc      	bne.n	312 <tc_init+0x1c6>
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
					config->counter_8_bit.compare_capture_channel[0];
     318:	332a      	adds	r3, #42	; 0x2a
     31a:	4642      	mov	r2, r8
     31c:	5cd3      	ldrb	r3, [r2, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
     31e:	7633      	strb	r3, [r6, #24]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     320:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     322:	227f      	movs	r2, #127	; 0x7f
     324:	7bcb      	ldrb	r3, [r1, #15]
					config->counter_8_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
     326:	4393      	bics	r3, r2
     328:	d1fc      	bne.n	324 <tc_init+0x1d8>
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
					config->counter_8_bit.compare_capture_channel[1];
     32a:	332b      	adds	r3, #43	; 0x2b
     32c:	4642      	mov	r2, r8
     32e:	5cd3      	ldrb	r3, [r2, r3]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
     330:	7673      	strb	r3, [r6, #25]
					config->counter_8_bit.compare_capture_channel[1];

			return STATUS_OK;
     332:	2000      	movs	r0, #0
     334:	e031      	b.n	39a <tc_init+0x24e>
     336:	217f      	movs	r1, #127	; 0x7f
     338:	7bd3      	ldrb	r3, [r2, #15]

		case TC_COUNTER_SIZE_16BIT:
			while (tc_is_syncing(module_inst)) {
     33a:	438b      	bics	r3, r1
     33c:	d1fc      	bne.n	338 <tc_init+0x1ec>
				/* Wait for sync */
			}

			hw->COUNT16.COUNT.reg
				= config->counter_16_bit.value;
     33e:	4643      	mov	r3, r8
     340:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
     342:	8233      	strh	r3, [r6, #16]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     344:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     346:	227f      	movs	r2, #127	; 0x7f
     348:	7bcb      	ldrb	r3, [r1, #15]

			while (tc_is_syncing(module_inst)) {
     34a:	4393      	bics	r3, r2
     34c:	d1fc      	bne.n	348 <tc_init+0x1fc>
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
					config->counter_16_bit.compare_capture_channel[0];
     34e:	4643      	mov	r3, r8
     350:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
     352:	8333      	strh	r3, [r6, #24]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     354:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     356:	227f      	movs	r2, #127	; 0x7f
     358:	7bcb      	ldrb	r3, [r1, #15]
					config->counter_16_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
     35a:	4393      	bics	r3, r2
     35c:	d1fc      	bne.n	358 <tc_init+0x20c>
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
					config->counter_16_bit.compare_capture_channel[1];
     35e:	4643      	mov	r3, r8
     360:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
     362:	8373      	strh	r3, [r6, #26]
					config->counter_16_bit.compare_capture_channel[1];

			return STATUS_OK;
     364:	2000      	movs	r0, #0
     366:	e018      	b.n	39a <tc_init+0x24e>
     368:	217f      	movs	r1, #127	; 0x7f
     36a:	7bd3      	ldrb	r3, [r2, #15]

		case TC_COUNTER_SIZE_32BIT:
			while (tc_is_syncing(module_inst)) {
     36c:	438b      	bics	r3, r1
     36e:	d1fc      	bne.n	36a <tc_init+0x21e>
				/* Wait for sync */
			}

			hw->COUNT32.COUNT.reg
				= config->counter_32_bit.value;
     370:	4643      	mov	r3, r8
     372:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     374:	6133      	str	r3, [r6, #16]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     376:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     378:	227f      	movs	r2, #127	; 0x7f
     37a:	7bcb      	ldrb	r3, [r1, #15]

			while (tc_is_syncing(module_inst)) {
     37c:	4393      	bics	r3, r2
     37e:	d1fc      	bne.n	37a <tc_init+0x22e>
				/* Wait for sync */
			}

			hw->COUNT32.CC[0].reg =
     380:	4643      	mov	r3, r8
     382:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     384:	61b3      	str	r3, [r6, #24]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
     386:	6821      	ldr	r1, [r4, #0]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
     388:	227f      	movs	r2, #127	; 0x7f
     38a:	7bcb      	ldrb	r3, [r1, #15]
					config->counter_32_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
     38c:	4393      	bics	r3, r2
     38e:	d1fc      	bne.n	38a <tc_init+0x23e>
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
					config->counter_32_bit.compare_capture_channel[1];
     390:	4643      	mov	r3, r8
     392:	6b1b      	ldr	r3, [r3, #48]	; 0x30

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
     394:	61f3      	str	r3, [r6, #28]
					config->counter_32_bit.compare_capture_channel[1];

			return STATUS_OK;
     396:	2000      	movs	r0, #0
     398:	e7ff      	b.n	39a <tc_init+0x24e>
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
}
     39a:	b007      	add	sp, #28
     39c:	bc0c      	pop	{r2, r3}
     39e:	4690      	mov	r8, r2
     3a0:	4699      	mov	r9, r3
     3a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     3a4:	00000115 	.word	0x00000115
     3a8:	0000e858 	.word	0x0000e858
     3ac:	0000d7eb 	.word	0x0000d7eb
     3b0:	200015c4 	.word	0x200015c4
     3b4:	00005b25 	.word	0x00005b25
     3b8:	40000400 	.word	0x40000400
     3bc:	00005a2d 	.word	0x00005a2d
     3c0:	000059a1 	.word	0x000059a1

000003c4 <tc_set_count_value>:
 * \retval STATUS_ERR_INVALID_ARG  An invalid timer counter size was specified
 */
enum status_code tc_set_count_value(
		const struct tc_module *const module_inst,
		const uint32_t count)
{
     3c4:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance*/
	Tc *const tc_module = module_inst->hw;
     3c6:	6802      	ldr	r2, [r0, #0]
     3c8:	247f      	movs	r4, #127	; 0x7f
     3ca:	7bd3      	ldrb	r3, [r2, #15]

	while (tc_is_syncing(module_inst)) {
     3cc:	43a3      	bics	r3, r4
     3ce:	d1fc      	bne.n	3ca <tc_set_count_value+0x6>
		/* Wait for sync */
	}

	/* Write to based on the TC counter_size */
	switch (module_inst->counter_size) {
     3d0:	7903      	ldrb	r3, [r0, #4]
     3d2:	2b04      	cmp	r3, #4
     3d4:	d005      	beq.n	3e2 <tc_set_count_value+0x1e>
     3d6:	2b08      	cmp	r3, #8
     3d8:	d00b      	beq.n	3f2 <tc_set_count_value+0x2e>
		case TC_COUNTER_SIZE_32BIT:
			tc_module->COUNT32.COUNT.reg = (uint32_t)count;
			return STATUS_OK;

		default:
			return STATUS_ERR_INVALID_ARG;
     3da:	2017      	movs	r0, #23
	while (tc_is_syncing(module_inst)) {
		/* Wait for sync */
	}

	/* Write to based on the TC counter_size */
	switch (module_inst->counter_size) {
     3dc:	2b00      	cmp	r3, #0
     3de:	d10b      	bne.n	3f8 <tc_set_count_value+0x34>
     3e0:	e003      	b.n	3ea <tc_set_count_value+0x26>
		case TC_COUNTER_SIZE_8BIT:
			tc_module->COUNT8.COUNT.reg  = (uint8_t)count;
     3e2:	b2c9      	uxtb	r1, r1
     3e4:	7411      	strb	r1, [r2, #16]
			return STATUS_OK;
     3e6:	2000      	movs	r0, #0
     3e8:	e006      	b.n	3f8 <tc_set_count_value+0x34>

		case TC_COUNTER_SIZE_16BIT:
			tc_module->COUNT16.COUNT.reg = (uint16_t)count;
     3ea:	b289      	uxth	r1, r1
     3ec:	8211      	strh	r1, [r2, #16]
			return STATUS_OK;
     3ee:	2000      	movs	r0, #0
     3f0:	e002      	b.n	3f8 <tc_set_count_value+0x34>

		case TC_COUNTER_SIZE_32BIT:
			tc_module->COUNT32.COUNT.reg = (uint32_t)count;
     3f2:	6111      	str	r1, [r2, #16]
			return STATUS_OK;
     3f4:	2000      	movs	r0, #0
     3f6:	e7ff      	b.n	3f8 <tc_set_count_value+0x34>

		default:
			return STATUS_ERR_INVALID_ARG;
	}
}
     3f8:	bd10      	pop	{r4, pc}
     3fa:	46c0      	nop			; (mov r8, r8)

000003fc <ble_undefined_event_handler>:
at_ble_status_t ble_undefined_event_handler(void *params)
{
	DBG_LOG_DEV("Undefined Event Received");
    ALL_UNUSED(params);
	return AT_BLE_SUCCESS;
}
     3fc:	2000      	movs	r0, #0
     3fe:	4770      	bx	lr

00000400 <ble_scan_report_handler>:
/** @brief function handles scan report */
at_ble_status_t ble_scan_report_handler(void *params)
{
	at_ble_scan_report_t *scan_report;
	scan_report = (at_ble_scan_report_t *)params;
	if (scan_report->status == AT_BLE_SUCCESS)
     400:	7800      	ldrb	r0, [r0, #0]
     402:	2800      	cmp	r0, #0
     404:	d000      	beq.n	408 <ble_scan_report_handler+0x8>
	}
	else
	{
		DBG_LOG("Scanning  failed");
	}
	return AT_BLE_FAILURE;
     406:	20e2      	movs	r0, #226	; 0xe2
}
     408:	4770      	bx	lr
     40a:	46c0      	nop			; (mov r8, r8)

0000040c <ble_mtu_changed_indication_handler>:
	mtu_changed_ind = (at_ble_mtu_changed_ind_t *)params;
	DBG_LOG_DEV("BLE-MTU Changed, Connection Handle: %d, New Value: %d", 
										mtu_changed_ind->conhdl, 
										mtu_changed_ind->mtu_value);
	return AT_BLE_SUCCESS;
}
     40c:	2000      	movs	r0, #0
     40e:	4770      	bx	lr

00000410 <ble_mtu_changed_cmd_complete_handler>:
at_ble_status_t ble_mtu_changed_cmd_complete_handler(void *params)
{
	at_ble_cmd_complete_event_t *cmd_complete_event;
	cmd_complete_event = (at_ble_cmd_complete_event_t *)params;
	
	if (cmd_complete_event->status == AT_BLE_SUCCESS)
     410:	78c0      	ldrb	r0, [r0, #3]
     412:	2800      	cmp	r0, #0
     414:	d000      	beq.n	418 <ble_mtu_changed_cmd_complete_handler+0x8>
	{
		DBG_LOG("MTU Change Failed, Connection Handle:%d, Operation:%d",
		cmd_complete_event->conn_handle,
		cmd_complete_event->operation);
	}
	return AT_BLE_FAILURE;
     416:	20e2      	movs	r0, #226	; 0xe2
}
     418:	4770      	bx	lr
     41a:	46c0      	nop			; (mov r8, r8)

0000041c <ble_characteristic_write_cmd_complete_handler>:

at_ble_status_t ble_characteristic_write_cmd_complete_handler(void *params)
{
	at_ble_cmd_complete_event_t *cmd_complete_event;
	cmd_complete_event = (at_ble_cmd_complete_event_t *)params;
	if (cmd_complete_event->status == AT_BLE_SUCCESS)
     41c:	78c0      	ldrb	r0, [r0, #3]
     41e:	2800      	cmp	r0, #0
     420:	d000      	beq.n	424 <ble_characteristic_write_cmd_complete_handler+0x8>
	{
		DBG_LOG_DEV("Char Write Cmd Failed, Connection Handle:%d, Operation:%d",
		cmd_complete_event->conn_handle,
		cmd_complete_event->operation);
	}
	return AT_BLE_FAILURE;
     422:	20e2      	movs	r0, #226	; 0xe2
}
     424:	4770      	bx	lr
     426:	46c0      	nop			; (mov r8, r8)

00000428 <ble_disconnected_state_handler>:

/** @brief function handles disconnection event received from stack */
at_ble_status_t ble_disconnected_state_handler(void *params)
{
     428:	b5f0      	push	{r4, r5, r6, r7, lr}
     42a:	4b16      	ldr	r3, [pc, #88]	; (484 <ble_disconnected_state_handler+0x5c>)
     42c:	1c1d      	adds	r5, r3, #0
     42e:	35e1      	adds	r5, #225	; 0xe1
     430:	35ff      	adds	r5, #255	; 0xff
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == disconnect->handle) && 
		((ble_dev_info[idx].conn_state == BLE_DEVICE_PAIRED) || (ble_dev_info[idx].conn_state == BLE_DEVICE_ENCRYPTION_COMPLETED)))
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_DISCONNECTED;
     432:	2701      	movs	r7, #1
				case BLE_DEVICE_DISCONNECTED:
				break;
				
				default:
				DBG_LOG_DEV("State Not Handled %d", ble_dev_info[idx].conn_state);
				ble_dev_info[idx].conn_state = BLE_DEVICE_DEFAULT_IDLE;
     434:	2600      	movs	r6, #0
     436:	1c1c      	adds	r4, r3, #0
     438:	1c1a      	adds	r2, r3, #0
     43a:	3a56      	subs	r2, #86	; 0x56
	uint8_t idx;
	disconnect = (at_ble_disconnected_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == disconnect->handle) && 
     43c:	8811      	ldrh	r1, [r2, #0]
     43e:	8802      	ldrh	r2, [r0, #0]
     440:	4291      	cmp	r1, r2
     442:	d119      	bne.n	478 <ble_disconnected_state_handler+0x50>
		((ble_dev_info[idx].conn_state == BLE_DEVICE_PAIRED) || (ble_dev_info[idx].conn_state == BLE_DEVICE_ENCRYPTION_COMPLETED)))
     444:	781a      	ldrb	r2, [r3, #0]
	uint8_t idx;
	disconnect = (at_ble_disconnected_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == disconnect->handle) && 
     446:	2a05      	cmp	r2, #5
     448:	d001      	beq.n	44e <ble_disconnected_state_handler+0x26>
		((ble_dev_info[idx].conn_state == BLE_DEVICE_PAIRED) || (ble_dev_info[idx].conn_state == BLE_DEVICE_ENCRYPTION_COMPLETED)))
     44a:	2a08      	cmp	r2, #8
     44c:	d101      	bne.n	452 <ble_disconnected_state_handler+0x2a>
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_DISCONNECTED;
     44e:	7027      	strb	r7, [r4, #0]
     450:	e012      	b.n	478 <ble_disconnected_state_handler+0x50>
		}		
		else if(ble_dev_info[idx].conn_info.handle == disconnect->handle)
		{
			switch (ble_dev_info[idx].conn_state)
     452:	2a07      	cmp	r2, #7
     454:	d80f      	bhi.n	476 <ble_disconnected_state_handler+0x4e>
     456:	0092      	lsls	r2, r2, #2
     458:	490b      	ldr	r1, [pc, #44]	; (488 <ble_disconnected_state_handler+0x60>)
     45a:	588a      	ldr	r2, [r1, r2]
     45c:	4697      	mov	pc, r2
				case BLE_DEVICE_PAIRING_FAILED:
				case BLE_DEVICE_ENCRYPTION_STATE:
				case BLE_DEVICE_ENCRYPTION_FAILED:
				{
					/* Device is not paired so remove the device information */
					ble_dev_info[idx].conn_state = BLE_DEVICE_DEFAULT_IDLE;
     45e:	701e      	strb	r6, [r3, #0]
					if (ble_device_count > 0)
     460:	4a0a      	ldr	r2, [pc, #40]	; (48c <ble_disconnected_state_handler+0x64>)
     462:	7812      	ldrb	r2, [r2, #0]
     464:	2a00      	cmp	r2, #0
     466:	d007      	beq.n	478 <ble_disconnected_state_handler+0x50>
					{
						ble_device_count--;
     468:	4a08      	ldr	r2, [pc, #32]	; (48c <ble_disconnected_state_handler+0x64>)
     46a:	7812      	ldrb	r2, [r2, #0]
     46c:	3a01      	subs	r2, #1
     46e:	b2d2      	uxtb	r2, r2
     470:	4906      	ldr	r1, [pc, #24]	; (48c <ble_disconnected_state_handler+0x64>)
     472:	700a      	strb	r2, [r1, #0]
     474:	e000      	b.n	478 <ble_disconnected_state_handler+0x50>
				case BLE_DEVICE_DISCONNECTED:
				break;
				
				default:
				DBG_LOG_DEV("State Not Handled %d", ble_dev_info[idx].conn_state);
				ble_dev_info[idx].conn_state = BLE_DEVICE_DEFAULT_IDLE;
     476:	7026      	strb	r6, [r4, #0]
     478:	3360      	adds	r3, #96	; 0x60
{
	at_ble_disconnected_t *disconnect;
	uint8_t idx;
	disconnect = (at_ble_disconnected_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     47a:	42ab      	cmp	r3, r5
     47c:	d1db      	bne.n	436 <ble_disconnected_state_handler+0xe>
		} 
	}
	
	DBG_LOG("Device disconnected Reason:0x%02x Handle=0x%x", disconnect->reason, disconnect->handle);
	return AT_BLE_SUCCESS;
}
     47e:	2000      	movs	r0, #0
     480:	bdf0      	pop	{r4, r5, r6, r7, pc}
     482:	46c0      	nop			; (mov r8, r8)
     484:	2000073a 	.word	0x2000073a
     488:	0000e870 	.word	0x0000e870
     48c:	200008bc 	.word	0x200008bc

00000490 <ble_conn_param_update>:
	at_ble_conn_param_update_done_t * conn_param_update;
	conn_param_update = (at_ble_conn_param_update_done_t *)params;
	DBG_LOG_DEV("AT_BLE_CONN_PARAM_UPDATE ");
	ALL_UNUSED(conn_param_update);  //To avoid compiler warning
	return AT_BLE_SUCCESS;
}
     490:	2000      	movs	r0, #0
     492:	4770      	bx	lr

00000494 <ble_encryption_status_change_handler>:
	return AT_BLE_SUCCESS;
}

/** @brief function handles encryption status change */
at_ble_status_t ble_encryption_status_change_handler(void *params)
{
     494:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	enc_status = (at_ble_encryption_status_changed_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == enc_status->handle) && (ble_dev_info[idx].conn_state == BLE_DEVICE_ENCRYPTION_STATE))
     496:	8804      	ldrh	r4, [r0, #0]
     498:	4a1a      	ldr	r2, [pc, #104]	; (504 <ble_encryption_status_change_handler+0x70>)
	uint8_t idx;
	bool device_found = false;
	
	enc_status = (at_ble_encryption_status_changed_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     49a:	2300      	movs	r3, #0
	{
		if((ble_dev_info[idx].conn_info.handle == enc_status->handle) && (ble_dev_info[idx].conn_state == BLE_DEVICE_ENCRYPTION_STATE))
     49c:	8911      	ldrh	r1, [r2, #8]
     49e:	42a1      	cmp	r1, r4
     4a0:	d104      	bne.n	4ac <ble_encryption_status_change_handler+0x18>
     4a2:	1c11      	adds	r1, r2, #0
     4a4:	315e      	adds	r1, #94	; 0x5e
     4a6:	7809      	ldrb	r1, [r1, #0]
     4a8:	2906      	cmp	r1, #6
     4aa:	d021      	beq.n	4f0 <ble_encryption_status_change_handler+0x5c>
	uint8_t idx;
	bool device_found = false;
	
	enc_status = (at_ble_encryption_status_changed_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     4ac:	3301      	adds	r3, #1
     4ae:	b2db      	uxtb	r3, r3
     4b0:	3260      	adds	r2, #96	; 0x60
     4b2:	2b05      	cmp	r3, #5
     4b4:	d1f2      	bne.n	49c <ble_encryption_status_change_handler+0x8>
     4b6:	e01f      	b.n	4f8 <ble_encryption_status_change_handler+0x64>
	if(enc_status->status == AT_BLE_SUCCESS)
	{
		DBG_LOG("Encryption completed successfully");
		if (device_found)
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_ENCRYPTION_COMPLETED;
     4b8:	4d12      	ldr	r5, [pc, #72]	; (504 <ble_encryption_status_change_handler+0x70>)
     4ba:	005a      	lsls	r2, r3, #1
     4bc:	18d4      	adds	r4, r2, r3
     4be:	0164      	lsls	r4, r4, #5
     4c0:	192c      	adds	r4, r5, r4
     4c2:	1c26      	adds	r6, r4, #0
     4c4:	3658      	adds	r6, #88	; 0x58
     4c6:	2708      	movs	r7, #8
     4c8:	71b7      	strb	r7, [r6, #6]
			ble_dev_info[idx].bond_info.auth = enc_status->authen;
     4ca:	78c6      	ldrb	r6, [r0, #3]
     4cc:	7526      	strb	r6, [r4, #20]
			ble_dev_info[idx].bond_info.status = enc_status->status;
     4ce:	7880      	ldrb	r0, [r0, #2]
     4d0:	7620      	strb	r0, [r4, #24]
		ble_dev_info[idx].bond_info.status = enc_status->status;
		ble_dev_info[idx].conn_state = BLE_DEVICE_ENCRYPTION_FAILED;
		DBG_LOG("Encryption failed");
		return AT_BLE_FAILURE;
	}
	return AT_BLE_SUCCESS;
     4d2:	e015      	b.n	500 <ble_encryption_status_change_handler+0x6c>
			return AT_BLE_FAILURE;
		}
	}
	else
	{
		ble_dev_info[idx].bond_info.status = enc_status->status;
     4d4:	4c0b      	ldr	r4, [pc, #44]	; (504 <ble_encryption_status_change_handler+0x70>)
     4d6:	005a      	lsls	r2, r3, #1
     4d8:	18d0      	adds	r0, r2, r3
     4da:	0140      	lsls	r0, r0, #5
     4dc:	1820      	adds	r0, r4, r0
     4de:	7601      	strb	r1, [r0, #24]
		ble_dev_info[idx].conn_state = BLE_DEVICE_ENCRYPTION_FAILED;
     4e0:	1c03      	adds	r3, r0, #0
     4e2:	3358      	adds	r3, #88	; 0x58
     4e4:	2207      	movs	r2, #7
     4e6:	719a      	strb	r2, [r3, #6]
		DBG_LOG("Encryption failed");
		return AT_BLE_FAILURE;
     4e8:	21e2      	movs	r1, #226	; 0xe2
     4ea:	e009      	b.n	500 <ble_encryption_status_change_handler+0x6c>
			ble_dev_info[idx].bond_info.status = enc_status->status;
		}
		else
		{
			DBG_LOG("BLE Device not found encryption info");
			return AT_BLE_FAILURE;
     4ec:	21e2      	movs	r1, #226	; 0xe2
     4ee:	e007      	b.n	500 <ble_encryption_status_change_handler+0x6c>
			device_found = true;
			break;
		}
	}
	
	if(enc_status->status == AT_BLE_SUCCESS)
     4f0:	7881      	ldrb	r1, [r0, #2]
     4f2:	2900      	cmp	r1, #0
     4f4:	d1ee      	bne.n	4d4 <ble_encryption_status_change_handler+0x40>
     4f6:	e7df      	b.n	4b8 <ble_encryption_status_change_handler+0x24>
     4f8:	7881      	ldrb	r1, [r0, #2]
     4fa:	2900      	cmp	r1, #0
     4fc:	d1ea      	bne.n	4d4 <ble_encryption_status_change_handler+0x40>
     4fe:	e7f5      	b.n	4ec <ble_encryption_status_change_handler+0x58>
		ble_dev_info[idx].conn_state = BLE_DEVICE_ENCRYPTION_FAILED;
		DBG_LOG("Encryption failed");
		return AT_BLE_FAILURE;
	}
	return AT_BLE_SUCCESS;
}
     500:	1c08      	adds	r0, r1, #0
     502:	bdf0      	pop	{r4, r5, r6, r7, pc}
     504:	200006dc 	.word	0x200006dc

00000508 <ble_scan_info_handler>:
	return(at_ble_scan_start(SCAN_INTERVAL, SCAN_WINDOW, SCAN_TIMEOUT, SCAN_TYPE, AT_BLE_SCAN_GEN_DISCOVERY, false,true)) ;
}

/** @brief function handling scaned information */
at_ble_status_t ble_scan_info_handler(void *params)
{
     508:	b510      	push	{r4, lr}
     50a:	1c01      	adds	r1, r0, #0
	at_ble_scan_info_t *scan_param;
	scan_param = (at_ble_scan_info_t *)params;
	if(scan_response_count < MAX_SCAN_DEVICE)
     50c:	4b0d      	ldr	r3, [pc, #52]	; (544 <ble_scan_info_handler+0x3c>)
     50e:	781b      	ldrb	r3, [r3, #0]
     510:	b2db      	uxtb	r3, r3
     512:	2b13      	cmp	r3, #19
     514:	d812      	bhi.n	53c <ble_scan_info_handler+0x34>
	{
		// store the advertising report data into scan_info[]
		memcpy((uint8_t *)&scan_info[scan_response_count], scan_param, sizeof(at_ble_scan_info_t));
     516:	4c0b      	ldr	r4, [pc, #44]	; (544 <ble_scan_info_handler+0x3c>)
     518:	7823      	ldrb	r3, [r4, #0]
     51a:	b2db      	uxtb	r3, r3
     51c:	0098      	lsls	r0, r3, #2
     51e:	18c0      	adds	r0, r0, r3
     520:	00c0      	lsls	r0, r0, #3
     522:	18c3      	adds	r3, r0, r3
     524:	4808      	ldr	r0, [pc, #32]	; (548 <ble_scan_info_handler+0x40>)
     526:	18c0      	adds	r0, r0, r3
     528:	2229      	movs	r2, #41	; 0x29
     52a:	4b08      	ldr	r3, [pc, #32]	; (54c <ble_scan_info_handler+0x44>)
     52c:	4798      	blx	r3
		DBG_LOG_DEV("Info:Device found address [%d]  0x%02X%02X%02X%02X%02X%02X ",
     52e:	7823      	ldrb	r3, [r4, #0]
		scan_param->dev_addr.addr[4],
		scan_param->dev_addr.addr[3],
		scan_param->dev_addr.addr[2],
		scan_param->dev_addr.addr[1],
		scan_param->dev_addr.addr[0]);
		scan_response_count++;
     530:	7823      	ldrb	r3, [r4, #0]
     532:	3301      	adds	r3, #1
     534:	b2db      	uxtb	r3, r3
     536:	7023      	strb	r3, [r4, #0]
		return AT_BLE_SUCCESS;
     538:	2000      	movs	r0, #0
     53a:	e002      	b.n	542 <ble_scan_info_handler+0x3a>
	}
	else
	{
		DBG_LOG("Info:maximum no.of scan device reached...Stopping Scan");
		if(at_ble_scan_stop() != AT_BLE_SUCCESS)
     53c:	4b04      	ldr	r3, [pc, #16]	; (550 <ble_scan_info_handler+0x48>)
     53e:	4798      	blx	r3
		{
			DBG_LOG("Failed to stop scanning");
		}
		
		return AT_BLE_FAILURE;
     540:	20e2      	movs	r0, #226	; 0xe2
	}
}
     542:	bd10      	pop	{r4, pc}
     544:	200000bc 	.word	0x200000bc
     548:	20000914 	.word	0x20000914
     54c:	0000d7eb 	.word	0x0000d7eb
     550:	00007735 	.word	0x00007735

00000554 <ble_pair_done_handler>:
	return AT_BLE_SUCCESS;	
}

/** @brief function handles pair done event */
at_ble_status_t ble_pair_done_handler(void *params)
{
     554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     556:	464f      	mov	r7, r9
     558:	4646      	mov	r6, r8
     55a:	b4c0      	push	{r6, r7}
     55c:	1c06      	adds	r6, r0, #0
	bool device_found = false;
	pairing_params = (at_ble_pair_done_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == pairing_params->handle) && (ble_dev_info[idx].conn_state == BLE_DEVICE_PAIRING))
     55e:	8841      	ldrh	r1, [r0, #2]
     560:	4a25      	ldr	r2, [pc, #148]	; (5f8 <ble_pair_done_handler+0xa4>)
     562:	2300      	movs	r3, #0
     564:	b2dc      	uxtb	r4, r3
     566:	1c1d      	adds	r5, r3, #0
     568:	8910      	ldrh	r0, [r2, #8]
     56a:	4288      	cmp	r0, r1
     56c:	d110      	bne.n	590 <ble_pair_done_handler+0x3c>
     56e:	1c10      	adds	r0, r2, #0
     570:	305e      	adds	r0, #94	; 0x5e
     572:	7800      	ldrb	r0, [r0, #0]
     574:	2803      	cmp	r0, #3
     576:	d10b      	bne.n	590 <ble_pair_done_handler+0x3c>
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_PAIRED;
     578:	005b      	lsls	r3, r3, #1
     57a:	195b      	adds	r3, r3, r5
     57c:	015d      	lsls	r5, r3, #5
     57e:	4b1e      	ldr	r3, [pc, #120]	; (5f8 <ble_pair_done_handler+0xa4>)
     580:	195b      	adds	r3, r3, r5
     582:	3358      	adds	r3, #88	; 0x58
     584:	2205      	movs	r2, #5
     586:	719a      	strb	r2, [r3, #6]
			device_found = true;
			break;
		}
	}
	
	if(pairing_params->status == AT_BLE_SUCCESS)
     588:	7935      	ldrb	r5, [r6, #4]
     58a:	2d00      	cmp	r5, #0
     58c:	d005      	beq.n	59a <ble_pair_done_handler+0x46>
     58e:	e022      	b.n	5d6 <ble_pair_done_handler+0x82>
     590:	3301      	adds	r3, #1
     592:	3260      	adds	r2, #96	; 0x60
	at_ble_pair_done_t *pairing_params;
	uint8_t idx;
	bool device_found = false;
	pairing_params = (at_ble_pair_done_t *)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     594:	2b05      	cmp	r3, #5
     596:	d1e5      	bne.n	564 <ble_pair_done_handler+0x10>
     598:	e025      	b.n	5e6 <ble_pair_done_handler+0x92>
	if(pairing_params->status == AT_BLE_SUCCESS)
	{
		DBG_LOG("Pairing procedure completed successfully");
		if (device_found)
		{
			ble_dev_info[idx].bond_info.auth = pairing_params->auth;
     59a:	7832      	ldrb	r2, [r6, #0]
     59c:	4f16      	ldr	r7, [pc, #88]	; (5f8 <ble_pair_done_handler+0xa4>)
     59e:	0063      	lsls	r3, r4, #1
     5a0:	4699      	mov	r9, r3
     5a2:	1918      	adds	r0, r3, r4
     5a4:	0140      	lsls	r0, r0, #5
     5a6:	1838      	adds	r0, r7, r0
     5a8:	7502      	strb	r2, [r0, #20]
			ble_dev_info[idx].bond_info.status = pairing_params->status;
     5aa:	7932      	ldrb	r2, [r6, #4]
     5ac:	7602      	strb	r2, [r0, #24]
			memcpy((uint8_t *)&ble_dev_info[idx].bond_info.peer_csrk, (uint8_t *)&pairing_params->peer_csrk, sizeof(at_ble_CSRK_t));
     5ae:	3036      	adds	r0, #54	; 0x36
     5b0:	1c31      	adds	r1, r6, #0
     5b2:	3122      	adds	r1, #34	; 0x22
     5b4:	2210      	movs	r2, #16
     5b6:	4b11      	ldr	r3, [pc, #68]	; (5fc <ble_pair_done_handler+0xa8>)
     5b8:	4698      	mov	r8, r3
     5ba:	4798      	blx	r3
			memcpy((uint8_t *)&ble_dev_info[idx].bond_info.peer_irk, (uint8_t *)&pairing_params->peer_irk, sizeof(at_ble_IRK_t));
     5bc:	1c20      	adds	r0, r4, #0
     5be:	4448      	add	r0, r9
     5c0:	0140      	lsls	r0, r0, #5
     5c2:	1838      	adds	r0, r7, r0
     5c4:	3046      	adds	r0, #70	; 0x46
     5c6:	1c31      	adds	r1, r6, #0
     5c8:	3132      	adds	r1, #50	; 0x32
     5ca:	2217      	movs	r2, #23
     5cc:	47c0      	blx	r8
			ble_dev_info->conn_state = BLE_DEVICE_PAIRED;
     5ce:	2205      	movs	r2, #5
     5d0:	235e      	movs	r3, #94	; 0x5e
     5d2:	54fa      	strb	r2, [r7, r3]
     5d4:	e00b      	b.n	5ee <ble_pair_done_handler+0x9a>
		}		
	}
	else
	{
		DBG_LOG("Pairing failed...Disconnecting");
		if(!(at_ble_disconnect(pairing_params->handle, AT_BLE_TERMINATED_BY_USER) == AT_BLE_SUCCESS))
     5d6:	8870      	ldrh	r0, [r6, #2]
     5d8:	2113      	movs	r1, #19
     5da:	4b09      	ldr	r3, [pc, #36]	; (600 <ble_pair_done_handler+0xac>)
     5dc:	4798      	blx	r3
     5de:	1e05      	subs	r5, r0, #0
     5e0:	d005      	beq.n	5ee <ble_pair_done_handler+0x9a>
		{
			DBG_LOG("Disconnect Request Failed");
			return AT_BLE_FAILURE;
     5e2:	25e2      	movs	r5, #226	; 0xe2
     5e4:	e003      	b.n	5ee <ble_pair_done_handler+0x9a>
			device_found = true;
			break;
		}
	}
	
	if(pairing_params->status == AT_BLE_SUCCESS)
     5e6:	7933      	ldrb	r3, [r6, #4]
			}
		}
		else
		{
			DBG_LOG("BLE Device not found to store the pairing info");
			return AT_BLE_FAILURE;
     5e8:	25e2      	movs	r5, #226	; 0xe2
			device_found = true;
			break;
		}
	}
	
	if(pairing_params->status == AT_BLE_SUCCESS)
     5ea:	2b00      	cmp	r3, #0
     5ec:	d1f3      	bne.n	5d6 <ble_pair_done_handler+0x82>
			DBG_LOG("Disconnect Request Failed");
			return AT_BLE_FAILURE;
		}
	}
	return AT_BLE_SUCCESS;
}
     5ee:	1c28      	adds	r0, r5, #0
     5f0:	bc0c      	pop	{r2, r3}
     5f2:	4690      	mov	r8, r2
     5f4:	4699      	mov	r9, r3
     5f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     5f8:	200006dc 	.word	0x200006dc
     5fc:	0000d7eb 	.word	0x0000d7eb
     600:	00007755 	.word	0x00007755

00000604 <ble_conn_param_update_req>:
	ALL_UNUSED(conn_param_update);  //To avoid compiler warning
	return AT_BLE_SUCCESS;
}

at_ble_status_t ble_conn_param_update_req(void *params)
{
     604:	b510      	push	{r4, lr}
	at_ble_conn_param_update_request_t * conn_param_req;
	conn_param_req = (at_ble_conn_param_update_request_t *)params;
	at_ble_conn_update_reply(conn_param_req->handle, true, 1, 120);
     606:	8800      	ldrh	r0, [r0, #0]
     608:	2101      	movs	r1, #1
     60a:	2201      	movs	r2, #1
     60c:	2378      	movs	r3, #120	; 0x78
     60e:	4c02      	ldr	r4, [pc, #8]	; (618 <ble_conn_param_update_req+0x14>)
     610:	47a0      	blx	r4
	return AT_BLE_SUCCESS;
}
     612:	2000      	movs	r0, #0
     614:	bd10      	pop	{r4, pc}
     616:	46c0      	nop			; (mov r8, r8)
     618:	00007775 	.word	0x00007775

0000061c <ble_slave_security_request_handler>:

at_ble_status_t ble_slave_security_request_handler(void* params)
{
     61c:	b5f0      	push	{r4, r5, r6, r7, lr}
     61e:	4657      	mov	r7, sl
     620:	464e      	mov	r6, r9
     622:	4645      	mov	r5, r8
     624:	b4e0      	push	{r5, r6, r7}
     626:	b084      	sub	sp, #16
     628:	1c04      	adds	r4, r0, #0
		//@Todo Status is not handled in the Library
	//}

	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == slave_sec_req->handle) && (ble_dev_info[idx].conn_state == BLE_DEVICE_CONNECTED))
     62a:	8806      	ldrh	r6, [r0, #0]
     62c:	4962      	ldr	r1, [pc, #392]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     62e:	1c0a      	adds	r2, r1, #0
     630:	2300      	movs	r3, #0
     632:	b2dd      	uxtb	r5, r3
     634:	1c1f      	adds	r7, r3, #0
     636:	8910      	ldrh	r0, [r2, #8]
     638:	42b0      	cmp	r0, r6
     63a:	d114      	bne.n	666 <ble_slave_security_request_handler+0x4a>
     63c:	1c10      	adds	r0, r2, #0
     63e:	305e      	adds	r0, #94	; 0x5e
     640:	7800      	ldrb	r0, [r0, #0]
     642:	2802      	cmp	r0, #2
     644:	d10f      	bne.n	666 <ble_slave_security_request_handler+0x4a>
		{
			device_found = true;
			ble_dev_info[idx].conn_state = BLE_DEVICE_ENCRYPTION_STATE;
     646:	4a5c      	ldr	r2, [pc, #368]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     648:	005b      	lsls	r3, r3, #1
     64a:	19db      	adds	r3, r3, r7
     64c:	015b      	lsls	r3, r3, #5
     64e:	18d3      	adds	r3, r2, r3
     650:	3358      	adds	r3, #88	; 0x58
     652:	3004      	adds	r0, #4
     654:	7198      	strb	r0, [r3, #6]
		}
	}
	
	if (device_found)
	{
		if((ble_dev_info[idx].bond_info.auth & AT_BLE_AUTH_NO_MITM_BOND) && (slave_sec_req->bond == true))
     656:	006b      	lsls	r3, r5, #1
     658:	195b      	adds	r3, r3, r5
     65a:	015b      	lsls	r3, r3, #5
     65c:	18d3      	adds	r3, r2, r3
     65e:	7d1a      	ldrb	r2, [r3, #20]
     660:	07d3      	lsls	r3, r2, #31
     662:	d405      	bmi.n	670 <ble_slave_security_request_handler+0x54>
     664:	e015      	b.n	692 <ble_slave_security_request_handler+0x76>
     666:	3301      	adds	r3, #1
     668:	3260      	adds	r2, #96	; 0x60
		//at_ble_disconnect(slave_sec_req->handle, AT_BLE_AUTH_FAILURE);		
		//return AT_BLE_FAILURE;
		//@Todo Status is not handled in the Library
	//}

	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     66a:	2b05      	cmp	r3, #5
     66c:	d1e1      	bne.n	632 <ble_slave_security_request_handler+0x16>
     66e:	e018      	b.n	6a2 <ble_slave_security_request_handler+0x86>
		}
	}
	
	if (device_found)
	{
		if((ble_dev_info[idx].bond_info.auth & AT_BLE_AUTH_NO_MITM_BOND) && (slave_sec_req->bond == true))
     670:	78e3      	ldrb	r3, [r4, #3]
     672:	2b00      	cmp	r3, #0
     674:	d00d      	beq.n	692 <ble_slave_security_request_handler+0x76>
		{
			if(at_ble_encryption_start(slave_sec_req->handle, &ble_dev_info[idx].bond_info.peer_ltk, ble_dev_info[idx].bond_info.auth) == AT_BLE_SUCCESS)
     676:	8820      	ldrh	r0, [r4, #0]
     678:	0069      	lsls	r1, r5, #1
     67a:	1949      	adds	r1, r1, r5
     67c:	014d      	lsls	r5, r1, #5
     67e:	494e      	ldr	r1, [pc, #312]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     680:	1949      	adds	r1, r1, r5
     682:	311a      	adds	r1, #26
     684:	4b4d      	ldr	r3, [pc, #308]	; (7bc <ble_slave_security_request_handler+0x1a0>)
     686:	4798      	blx	r3
     688:	2800      	cmp	r0, #0
     68a:	d100      	bne.n	68e <ble_slave_security_request_handler+0x72>
     68c:	e08e      	b.n	7ac <ble_slave_security_request_handler+0x190>
				return  AT_BLE_SUCCESS;
			}
			else
			{
				DBG_LOG("Encryption Not started");
				return AT_BLE_FAILURE;
     68e:	20e2      	movs	r0, #226	; 0xe2
     690:	e08c      	b.n	7ac <ble_slave_security_request_handler+0x190>
			}			
		}
		else
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_CONNECTED;
     692:	006b      	lsls	r3, r5, #1
     694:	195d      	adds	r5, r3, r5
     696:	016d      	lsls	r5, r5, #5
     698:	4b47      	ldr	r3, [pc, #284]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     69a:	195d      	adds	r5, r3, r5
     69c:	3558      	adds	r5, #88	; 0x58
     69e:	2302      	movs	r3, #2
     6a0:	71ab      	strb	r3, [r5, #6]
		}
	}
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == slave_sec_req->handle) && (ble_dev_info[idx].conn_state == BLE_DEVICE_CONNECTED))
     6a2:	8825      	ldrh	r5, [r4, #0]
     6a4:	2200      	movs	r2, #0
     6a6:	b2d3      	uxtb	r3, r2
     6a8:	1c16      	adds	r6, r2, #0
     6aa:	8908      	ldrh	r0, [r1, #8]
     6ac:	42a8      	cmp	r0, r5
     6ae:	d10d      	bne.n	6cc <ble_slave_security_request_handler+0xb0>
     6b0:	1c08      	adds	r0, r1, #0
     6b2:	305e      	adds	r0, #94	; 0x5e
     6b4:	7800      	ldrb	r0, [r0, #0]
     6b6:	2802      	cmp	r0, #2
     6b8:	d108      	bne.n	6cc <ble_slave_security_request_handler+0xb0>
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_PAIRING;
     6ba:	0052      	lsls	r2, r2, #1
     6bc:	1992      	adds	r2, r2, r6
     6be:	0156      	lsls	r6, r2, #5
     6c0:	4a3d      	ldr	r2, [pc, #244]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     6c2:	1992      	adds	r2, r2, r6
     6c4:	3258      	adds	r2, #88	; 0x58
     6c6:	2103      	movs	r1, #3
     6c8:	7191      	strb	r1, [r2, #6]
			break;
     6ca:	e005      	b.n	6d8 <ble_slave_security_request_handler+0xbc>
     6cc:	3301      	adds	r3, #1
     6ce:	b2db      	uxtb	r3, r3
     6d0:	3201      	adds	r2, #1
     6d2:	3160      	adds	r1, #96	; 0x60
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_CONNECTED;
		}
	}
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     6d4:	2a05      	cmp	r2, #5
     6d6:	d1e6      	bne.n	6a6 <ble_slave_security_request_handler+0x8a>
			ble_dev_info[idx].conn_state = BLE_DEVICE_PAIRING;
			break;
		}
	}
	
	features.desired_auth =  BLE_AUTHENTICATION_LEVEL; 
     6d8:	aa01      	add	r2, sp, #4
     6da:	2102      	movs	r1, #2
     6dc:	7211      	strb	r1, [r2, #8]
	features.bond = slave_sec_req->bond;
     6de:	78e1      	ldrb	r1, [r4, #3]
     6e0:	7091      	strb	r1, [r2, #2]
	features.mitm_protection = slave_sec_req->mitm_protection;
     6e2:	7921      	ldrb	r1, [r4, #4]
     6e4:	7051      	strb	r1, [r2, #1]
	/* Device capabilities is display only , key will be generated
	and displayed */
	features.io_cababilities = AT_BLE_IO_CAP_KB_DISPLAY;
     6e6:	2104      	movs	r1, #4
     6e8:	7011      	strb	r1, [r2, #0]

	features.oob_avaiable = false;
     6ea:	2100      	movs	r1, #0
     6ec:	70d1      	strb	r1, [r2, #3]
			
	/* Distribution of LTK is required */
	if (ble_dev_info[idx].conn_info.peer_addr.type == AT_BLE_ADDRESS_RANDOM_PRIVATE_RESOLVABLE)
     6ee:	4698      	mov	r8, r3
     6f0:	005a      	lsls	r2, r3, #1
     6f2:	18d2      	adds	r2, r2, r3
     6f4:	0152      	lsls	r2, r2, #5
     6f6:	4930      	ldr	r1, [pc, #192]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     6f8:	5c52      	ldrb	r2, [r2, r1]
     6fa:	2a02      	cmp	r2, #2
     6fc:	d104      	bne.n	708 <ble_slave_security_request_handler+0xec>
	{
		features.initiator_keys =   (at_ble_key_dis_t)(AT_BLE_KEY_DIST_ENC | AT_BLE_KEY_DIST_ID);
     6fe:	aa01      	add	r2, sp, #4
     700:	2103      	movs	r1, #3
     702:	7191      	strb	r1, [r2, #6]
		features.responder_keys =   (at_ble_key_dis_t)(AT_BLE_KEY_DIST_ENC | AT_BLE_KEY_DIST_ID);
     704:	71d1      	strb	r1, [r2, #7]
     706:	e036      	b.n	776 <ble_slave_security_request_handler+0x15a>
	}
	else
	{
		features.initiator_keys =   AT_BLE_KEY_DIST_ENC;
     708:	aa01      	add	r2, sp, #4
     70a:	2101      	movs	r1, #1
     70c:	7191      	strb	r1, [r2, #6]
		features.responder_keys =   AT_BLE_KEY_DIST_ENC;
     70e:	71d1      	strb	r1, [r2, #7]
     710:	e031      	b.n	776 <ble_slave_security_request_handler+0x15a>
	if (ble_dev_info[idx].bond_info.status == AT_BLE_GAP_INVALID_PARAM)
	{
		/* Generate LTK */
		for(i=0; i<8; i++)
		{			
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
     712:	47d0      	blx	sl
     714:	4028      	ands	r0, r5
     716:	7038      	strb	r0, [r7, #0]
			ble_dev_info[idx].bond_info.peer_ltk.nb[i] = rand()&0x0f;
     718:	47d0      	blx	sl
     71a:	4028      	ands	r0, r5
     71c:	74b8      	strb	r0, [r7, #18]
     71e:	3701      	adds	r7, #1
	
	/* Check if fresh pairing requested */
	if (ble_dev_info[idx].bond_info.status == AT_BLE_GAP_INVALID_PARAM)
	{
		/* Generate LTK */
		for(i=0; i<8; i++)
     720:	42b7      	cmp	r7, r6
     722:	d1f6      	bne.n	712 <ble_slave_security_request_handler+0xf6>
     724:	464b      	mov	r3, r9
     726:	332a      	adds	r3, #42	; 0x2a
     728:	4a23      	ldr	r2, [pc, #140]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     72a:	189d      	adds	r5, r3, r2
			ble_dev_info[idx].bond_info.peer_ltk.nb[i] = rand()&0x0f;
		}
				
		for(i=8 ; i<16 ;i++)
		{
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
     72c:	4b24      	ldr	r3, [pc, #144]	; (7c0 <ble_slave_security_request_handler+0x1a4>)
     72e:	4699      	mov	r9, r3
     730:	270f      	movs	r7, #15
     732:	47c8      	blx	r9
     734:	4038      	ands	r0, r7
     736:	7030      	strb	r0, [r6, #0]
     738:	3601      	adds	r6, #1
		{			
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
			ble_dev_info[idx].bond_info.peer_ltk.nb[i] = rand()&0x0f;
		}
				
		for(i=8 ; i<16 ;i++)
     73a:	42ae      	cmp	r6, r5
     73c:	d1f9      	bne.n	732 <ble_slave_security_request_handler+0x116>
		{
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
		}
		
		ble_dev_info[idx].bond_info.peer_ltk.ediv = rand()&0xffff;
     73e:	4b20      	ldr	r3, [pc, #128]	; (7c0 <ble_slave_security_request_handler+0x1a4>)
     740:	4798      	blx	r3
     742:	4643      	mov	r3, r8
     744:	005b      	lsls	r3, r3, #1
     746:	4443      	add	r3, r8
     748:	015b      	lsls	r3, r3, #5
     74a:	4a1b      	ldr	r2, [pc, #108]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     74c:	18d3      	adds	r3, r2, r3
     74e:	8558      	strh	r0, [r3, #42]	; 0x2a
		ble_dev_info[idx].bond_info.peer_ltk.key_size = 16;
     750:	3328      	adds	r3, #40	; 0x28
     752:	2210      	movs	r2, #16
     754:	731a      	strb	r2, [r3, #12]
	{
		/* Bonding information already exists */
		
	}

	if(at_ble_authenticate(slave_sec_req->handle, &features, &ble_dev_info[idx].bond_info.peer_ltk, NULL) != AT_BLE_SUCCESS)
     756:	8820      	ldrh	r0, [r4, #0]
     758:	4643      	mov	r3, r8
     75a:	005a      	lsls	r2, r3, #1
     75c:	4442      	add	r2, r8
     75e:	0152      	lsls	r2, r2, #5
     760:	4b15      	ldr	r3, [pc, #84]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     762:	189a      	adds	r2, r3, r2
     764:	321a      	adds	r2, #26
     766:	a901      	add	r1, sp, #4
     768:	2300      	movs	r3, #0
     76a:	4c16      	ldr	r4, [pc, #88]	; (7c4 <ble_slave_security_request_handler+0x1a8>)
     76c:	47a0      	blx	r4
     76e:	2800      	cmp	r0, #0
     770:	d01c      	beq.n	7ac <ble_slave_security_request_handler+0x190>
	{
		features.bond = false;
		features.mitm_protection = false;
		DBG_LOG("Slave Security Req - Authentication Failed");
		return AT_BLE_FAILURE;
     772:	20e2      	movs	r0, #226	; 0xe2
     774:	e01a      	b.n	7ac <ble_slave_security_request_handler+0x190>
	else
	{
		features.initiator_keys =   AT_BLE_KEY_DIST_ENC;
		features.responder_keys =   AT_BLE_KEY_DIST_ENC;
	}
	features.max_key_size = 16;
     776:	aa01      	add	r2, sp, #4
     778:	2110      	movs	r1, #16
     77a:	7151      	strb	r1, [r2, #5]
	features.min_key_size = 16;
     77c:	7111      	strb	r1, [r2, #4]
	
	/* Check if fresh pairing requested */
	if (ble_dev_info[idx].bond_info.status == AT_BLE_GAP_INVALID_PARAM)
     77e:	4642      	mov	r2, r8
     780:	0052      	lsls	r2, r2, #1
     782:	4442      	add	r2, r8
     784:	0152      	lsls	r2, r2, #5
     786:	490c      	ldr	r1, [pc, #48]	; (7b8 <ble_slave_security_request_handler+0x19c>)
     788:	188a      	adds	r2, r1, r2
     78a:	7e12      	ldrb	r2, [r2, #24]
     78c:	2a40      	cmp	r2, #64	; 0x40
     78e:	d1e2      	bne.n	756 <ble_slave_security_request_handler+0x13a>
     790:	005a      	lsls	r2, r3, #1
     792:	18d3      	adds	r3, r2, r3
     794:	015b      	lsls	r3, r3, #5
     796:	4699      	mov	r9, r3
     798:	1c1f      	adds	r7, r3, #0
     79a:	371a      	adds	r7, #26
     79c:	187f      	adds	r7, r7, r1
     79e:	464e      	mov	r6, r9
     7a0:	3622      	adds	r6, #34	; 0x22
     7a2:	1876      	adds	r6, r6, r1
	{
		/* Generate LTK */
		for(i=0; i<8; i++)
		{			
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
     7a4:	4b06      	ldr	r3, [pc, #24]	; (7c0 <ble_slave_security_request_handler+0x1a4>)
     7a6:	469a      	mov	sl, r3
     7a8:	250f      	movs	r5, #15
     7aa:	e7b2      	b.n	712 <ble_slave_security_request_handler+0xf6>
		features.mitm_protection = false;
		DBG_LOG("Slave Security Req - Authentication Failed");
		return AT_BLE_FAILURE;
	}
	return AT_BLE_SUCCESS;
}
     7ac:	b004      	add	sp, #16
     7ae:	bc1c      	pop	{r2, r3, r4}
     7b0:	4690      	mov	r8, r2
     7b2:	4699      	mov	r9, r3
     7b4:	46a2      	mov	sl, r4
     7b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     7b8:	200006dc 	.word	0x200006dc
     7bc:	00008515 	.word	0x00008515
     7c0:	0000d999 	.word	0x0000d999
     7c4:	000081dd 	.word	0x000081dd

000007c8 <ble_pair_request_handler>:

/** @brief function handles pair request */
at_ble_status_t ble_pair_request_handler(void *params)
{
     7c8:	b5f0      	push	{r4, r5, r6, r7, lr}
     7ca:	4657      	mov	r7, sl
     7cc:	464e      	mov	r6, r9
     7ce:	4645      	mov	r5, r8
     7d0:	b4e0      	push	{r5, r6, r7}
     7d2:	b084      	sub	sp, #16
     7d4:	4682      	mov	sl, r0
	at_ble_pair_request_t* pair_req;
	pair_req = (at_ble_pair_request_t*)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == pair_req->handle) && (ble_dev_info[idx].conn_state == BLE_DEVICE_CONNECTED))
     7d6:	8804      	ldrh	r4, [r0, #0]
     7d8:	4943      	ldr	r1, [pc, #268]	; (8e8 <ble_pair_request_handler+0x120>)
     7da:	2200      	movs	r2, #0
     7dc:	b2d3      	uxtb	r3, r2
     7de:	1c16      	adds	r6, r2, #0
     7e0:	8908      	ldrh	r0, [r1, #8]
     7e2:	42a0      	cmp	r0, r4
     7e4:	d10d      	bne.n	802 <ble_pair_request_handler+0x3a>
     7e6:	1c08      	adds	r0, r1, #0
     7e8:	305e      	adds	r0, #94	; 0x5e
     7ea:	7800      	ldrb	r0, [r0, #0]
     7ec:	2802      	cmp	r0, #2
     7ee:	d108      	bne.n	802 <ble_pair_request_handler+0x3a>
		{
			ble_dev_info[idx].conn_state = BLE_DEVICE_PAIRING;
     7f0:	0052      	lsls	r2, r2, #1
     7f2:	1992      	adds	r2, r2, r6
     7f4:	0156      	lsls	r6, r2, #5
     7f6:	4a3c      	ldr	r2, [pc, #240]	; (8e8 <ble_pair_request_handler+0x120>)
     7f8:	1992      	adds	r2, r2, r6
     7fa:	3258      	adds	r2, #88	; 0x58
     7fc:	2103      	movs	r1, #3
     7fe:	7191      	strb	r1, [r2, #6]
			break;
     800:	e005      	b.n	80e <ble_pair_request_handler+0x46>
     802:	3301      	adds	r3, #1
     804:	b2db      	uxtb	r3, r3
     806:	3201      	adds	r2, #1
     808:	3160      	adds	r1, #96	; 0x60
	at_ble_pair_features_t features;
	uint8_t i = 0, idx;
	at_ble_pair_request_t* pair_req;
	pair_req = (at_ble_pair_request_t*)params;
	
	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     80a:	2a05      	cmp	r2, #5
     80c:	d1e6      	bne.n	7dc <ble_pair_request_handler+0x14>
			ble_dev_info[idx].conn_state = BLE_DEVICE_PAIRING;
			break;
		}
	}
	
	features.desired_auth =  BLE_AUTHENTICATION_LEVEL; 
     80e:	aa01      	add	r2, sp, #4
     810:	2102      	movs	r1, #2
     812:	7211      	strb	r1, [r2, #8]
	features.bond = BLE_BOND_REQ;
     814:	3901      	subs	r1, #1
     816:	7091      	strb	r1, [r2, #2]
	features.mitm_protection = BLE_MITM_REQ;
     818:	7051      	strb	r1, [r2, #1]
	/* Device capabilities is display only , key will be generated
	and displayed */
	features.io_cababilities = BLE_IO_CAPABALITIES;
     81a:	2100      	movs	r1, #0
     81c:	7011      	strb	r1, [r2, #0]
	features.oob_avaiable = BLE_OOB_REQ;
     81e:	70d1      	strb	r1, [r2, #3]
	
	/* Distribution of LTK is required */
	if (ble_dev_info[idx].conn_info.peer_addr.type == AT_BLE_ADDRESS_RANDOM_PRIVATE_RESOLVABLE)
     820:	4698      	mov	r8, r3
     822:	005a      	lsls	r2, r3, #1
     824:	18d2      	adds	r2, r2, r3
     826:	0152      	lsls	r2, r2, #5
     828:	492f      	ldr	r1, [pc, #188]	; (8e8 <ble_pair_request_handler+0x120>)
     82a:	5c52      	ldrb	r2, [r2, r1]
     82c:	2a02      	cmp	r2, #2
     82e:	d104      	bne.n	83a <ble_pair_request_handler+0x72>
	{
		/* Distribution of IRK is required */
		features.initiator_keys =   (at_ble_key_dis_t)(AT_BLE_KEY_DIST_ENC | AT_BLE_KEY_DIST_ID);
     830:	aa01      	add	r2, sp, #4
     832:	2103      	movs	r1, #3
     834:	7191      	strb	r1, [r2, #6]
		features.responder_keys =   (at_ble_key_dis_t)(AT_BLE_KEY_DIST_ENC | AT_BLE_KEY_DIST_ID);
     836:	71d1      	strb	r1, [r2, #7]
     838:	e036      	b.n	8a8 <ble_pair_request_handler+0xe0>
	}
	else
	{
		features.initiator_keys =   AT_BLE_KEY_DIST_ENC;
     83a:	aa01      	add	r2, sp, #4
     83c:	2101      	movs	r1, #1
     83e:	7191      	strb	r1, [r2, #6]
		features.responder_keys =   AT_BLE_KEY_DIST_ENC;
     840:	71d1      	strb	r1, [r2, #7]
     842:	e031      	b.n	8a8 <ble_pair_request_handler+0xe0>
	if (ble_dev_info[idx].bond_info.status == AT_BLE_GAP_INVALID_PARAM)
	{
		/* Generate LTK */
		for(i=0; i<8; i++)
		{						
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
     844:	47a8      	blx	r5
     846:	4020      	ands	r0, r4
     848:	7038      	strb	r0, [r7, #0]
			ble_dev_info[idx].bond_info.peer_ltk.nb[i] = rand()&0x0f;
     84a:	47a8      	blx	r5
     84c:	4020      	ands	r0, r4
     84e:	74b8      	strb	r0, [r7, #18]
     850:	3701      	adds	r7, #1
	
	/* Check if fresh pairing requested */
	if (ble_dev_info[idx].bond_info.status == AT_BLE_GAP_INVALID_PARAM)
	{
		/* Generate LTK */
		for(i=0; i<8; i++)
     852:	42b7      	cmp	r7, r6
     854:	d1f6      	bne.n	844 <ble_pair_request_handler+0x7c>
     856:	464b      	mov	r3, r9
     858:	332a      	adds	r3, #42	; 0x2a
     85a:	4a23      	ldr	r2, [pc, #140]	; (8e8 <ble_pair_request_handler+0x120>)
     85c:	189c      	adds	r4, r3, r2
			ble_dev_info[idx].bond_info.peer_ltk.nb[i] = rand()&0x0f;
		}
				
		for(i=8 ; i<16 ;i++)
		{
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
     85e:	4d23      	ldr	r5, [pc, #140]	; (8ec <ble_pair_request_handler+0x124>)
     860:	270f      	movs	r7, #15
     862:	47a8      	blx	r5
     864:	4038      	ands	r0, r7
     866:	7030      	strb	r0, [r6, #0]
     868:	3601      	adds	r6, #1
		{						
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
			ble_dev_info[idx].bond_info.peer_ltk.nb[i] = rand()&0x0f;
		}
				
		for(i=8 ; i<16 ;i++)
     86a:	42a6      	cmp	r6, r4
     86c:	d1f9      	bne.n	862 <ble_pair_request_handler+0x9a>
		for (i = 0; i < 16; i++)
		{
			DBG_LOG_CONT_DEV("0x%02X ", ble_dev_info[idx].bond_info.peer_ltk.key[i]);
		}
		
		ble_dev_info[idx].bond_info.peer_ltk.ediv = rand()&0xffff;
     86e:	4b1f      	ldr	r3, [pc, #124]	; (8ec <ble_pair_request_handler+0x124>)
     870:	4798      	blx	r3
     872:	4643      	mov	r3, r8
     874:	005b      	lsls	r3, r3, #1
     876:	4443      	add	r3, r8
     878:	015b      	lsls	r3, r3, #5
     87a:	4a1b      	ldr	r2, [pc, #108]	; (8e8 <ble_pair_request_handler+0x120>)
     87c:	18d3      	adds	r3, r2, r3
     87e:	8558      	strh	r0, [r3, #42]	; 0x2a
		ble_dev_info[idx].bond_info.peer_ltk.key_size = 16;
     880:	3328      	adds	r3, #40	; 0x28
     882:	2210      	movs	r2, #16
     884:	731a      	strb	r2, [r3, #12]
	}

	/* Send pairing response */
	DBG_LOG("Sending pairing response");

	if(at_ble_authenticate(pair_req->handle, &features, &ble_dev_info[idx].bond_info.peer_ltk, NULL) != AT_BLE_SUCCESS)
     886:	4653      	mov	r3, sl
     888:	8818      	ldrh	r0, [r3, #0]
     88a:	4643      	mov	r3, r8
     88c:	005a      	lsls	r2, r3, #1
     88e:	4442      	add	r2, r8
     890:	0152      	lsls	r2, r2, #5
     892:	4b15      	ldr	r3, [pc, #84]	; (8e8 <ble_pair_request_handler+0x120>)
     894:	189a      	adds	r2, r3, r2
     896:	321a      	adds	r2, #26
     898:	a901      	add	r1, sp, #4
     89a:	2300      	movs	r3, #0
     89c:	4c14      	ldr	r4, [pc, #80]	; (8f0 <ble_pair_request_handler+0x128>)
     89e:	47a0      	blx	r4
     8a0:	2800      	cmp	r0, #0
     8a2:	d01b      	beq.n	8dc <ble_pair_request_handler+0x114>
	{
		features.bond = false;
		features.mitm_protection = false;
		DBG_LOG("Pair Request - Authentication Failed");
		return AT_BLE_FAILURE;
     8a4:	20e2      	movs	r0, #226	; 0xe2
     8a6:	e019      	b.n	8dc <ble_pair_request_handler+0x114>
	{
		features.initiator_keys =   AT_BLE_KEY_DIST_ENC;
		features.responder_keys =   AT_BLE_KEY_DIST_ENC;
	}
			
	features.max_key_size = 16;
     8a8:	aa01      	add	r2, sp, #4
     8aa:	2110      	movs	r1, #16
     8ac:	7151      	strb	r1, [r2, #5]
	features.min_key_size = 16;
     8ae:	7111      	strb	r1, [r2, #4]
	
	/* Check if fresh pairing requested */
	if (ble_dev_info[idx].bond_info.status == AT_BLE_GAP_INVALID_PARAM)
     8b0:	4642      	mov	r2, r8
     8b2:	0052      	lsls	r2, r2, #1
     8b4:	4442      	add	r2, r8
     8b6:	0152      	lsls	r2, r2, #5
     8b8:	490b      	ldr	r1, [pc, #44]	; (8e8 <ble_pair_request_handler+0x120>)
     8ba:	188a      	adds	r2, r1, r2
     8bc:	7e12      	ldrb	r2, [r2, #24]
     8be:	2a40      	cmp	r2, #64	; 0x40
     8c0:	d1e1      	bne.n	886 <ble_pair_request_handler+0xbe>
     8c2:	005a      	lsls	r2, r3, #1
     8c4:	18d3      	adds	r3, r2, r3
     8c6:	015b      	lsls	r3, r3, #5
     8c8:	4699      	mov	r9, r3
     8ca:	1c1f      	adds	r7, r3, #0
     8cc:	371a      	adds	r7, #26
     8ce:	187f      	adds	r7, r7, r1
     8d0:	464e      	mov	r6, r9
     8d2:	3622      	adds	r6, #34	; 0x22
     8d4:	1876      	adds	r6, r6, r1
	{
		/* Generate LTK */
		for(i=0; i<8; i++)
		{						
			ble_dev_info[idx].bond_info.peer_ltk.key[i] = rand()&0x0f;
     8d6:	4d05      	ldr	r5, [pc, #20]	; (8ec <ble_pair_request_handler+0x124>)
     8d8:	240f      	movs	r4, #15
     8da:	e7b3      	b.n	844 <ble_pair_request_handler+0x7c>
		features.mitm_protection = false;
		DBG_LOG("Pair Request - Authentication Failed");
		return AT_BLE_FAILURE;
	}
	return AT_BLE_SUCCESS;
}
     8dc:	b004      	add	sp, #16
     8de:	bc1c      	pop	{r2, r3, r4}
     8e0:	4690      	mov	r8, r2
     8e2:	4699      	mov	r9, r3
     8e4:	46a2      	mov	sl, r4
     8e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     8e8:	200006dc 	.word	0x200006dc
     8ec:	0000d999 	.word	0x0000d999
     8f0:	000081dd 	.word	0x000081dd

000008f4 <ble_pair_key_request_handler>:

/** @brief function handles pair key request */
at_ble_status_t ble_pair_key_request_handler (void *params)
{
     8f4:	b5f0      	push	{r4, r5, r6, r7, lr}
     8f6:	b085      	sub	sp, #20
     8f8:	1c05      	adds	r5, r0, #0
	at_ble_pair_key_request_t *pair_key;
	pair_key = (at_ble_pair_key_request_t *)params;
	/* Passkey has fixed value in this example MSB */
	uint8_t passkey[6]={'1','2','3','4','5','6'};
     8fa:	a802      	add	r0, sp, #8
     8fc:	4920      	ldr	r1, [pc, #128]	; (980 <ble_pair_key_request_handler+0x8c>)
     8fe:	2206      	movs	r2, #6
     900:	4e20      	ldr	r6, [pc, #128]	; (984 <ble_pair_key_request_handler+0x90>)
     902:	47b0      	blx	r6
	uint8_t idx = 0;
        uint8_t pin;
        
	at_ble_pair_key_request_t pair_key_request;
        
	memcpy((uint8_t *)&pair_key_request, pair_key, sizeof(at_ble_pair_key_request_t));
     904:	ac01      	add	r4, sp, #4
     906:	1c20      	adds	r0, r4, #0
     908:	1c29      	adds	r1, r5, #0
     90a:	2204      	movs	r2, #4
     90c:	47b0      	blx	r6
	
	if (pair_key_request.passkey_type == AT_BLE_PAIR_PASSKEY_ENTRY) {
     90e:	78e3      	ldrb	r3, [r4, #3]
     910:	2b00      	cmp	r3, #0
     912:	d12b      	bne.n	96c <ble_pair_key_request_handler+0x78>
     914:	2400      	movs	r4, #0
	  DBG_LOG("Enter the Passkey(6-Digit) in Terminal:");
	  for (idx = 0; idx < 6;) {          
		pin = getchar_timeout(PIN_TIMEOUT);
     916:	4e1c      	ldr	r6, [pc, #112]	; (988 <ble_pair_key_request_handler+0x94>)
        
	memcpy((uint8_t *)&pair_key_request, pair_key, sizeof(at_ble_pair_key_request_t));
	
	if (pair_key_request.passkey_type == AT_BLE_PAIR_PASSKEY_ENTRY) {
	  DBG_LOG("Enter the Passkey(6-Digit) in Terminal:");
	  for (idx = 0; idx < 6;) {          
     918:	b2e7      	uxtb	r7, r4
		pin = getchar_timeout(PIN_TIMEOUT);
     91a:	481c      	ldr	r0, [pc, #112]	; (98c <ble_pair_key_request_handler+0x98>)
     91c:	47b0      	blx	r6
     91e:	1e02      	subs	r2, r0, #0
		if (!pin) {
     920:	d105      	bne.n	92e <ble_pair_key_request_handler+0x3a>
			DBG_LOG("Pin Timeout");
			DBG_LOG("Disconnecting ...");
			if (!(at_ble_disconnect(pair_key->handle,
     922:	8828      	ldrh	r0, [r5, #0]
     924:	2113      	movs	r1, #19
     926:	4b1a      	ldr	r3, [pc, #104]	; (990 <ble_pair_key_request_handler+0x9c>)
     928:	4798      	blx	r3
						AT_BLE_TERMINATED_BY_USER) == AT_BLE_SUCCESS)) {
				DBG_LOG("Disconnect Request Failed");
			}
			return AT_BLE_FAILURE;
     92a:	20e2      	movs	r0, #226	; 0xe2
     92c:	e025      	b.n	97a <ble_pair_key_request_handler+0x86>
		}
		if ((pin >= '0') && ( pin <= '9')) {
     92e:	3830      	subs	r0, #48	; 0x30
     930:	b2c3      	uxtb	r3, r0
     932:	2b09      	cmp	r3, #9
     934:	d808      	bhi.n	948 <ble_pair_key_request_handler+0x54>
		  passkey[idx++] = pin;
     936:	ab02      	add	r3, sp, #8
     938:	54e2      	strb	r2, [r4, r3]
		  DBG_LOG_CONT("%c", pin);
     93a:	1c10      	adds	r0, r2, #0
     93c:	4b15      	ldr	r3, [pc, #84]	; (994 <ble_pair_key_request_handler+0xa0>)
     93e:	4798      	blx	r3
     940:	3401      	adds	r4, #1
        
	memcpy((uint8_t *)&pair_key_request, pair_key, sizeof(at_ble_pair_key_request_t));
	
	if (pair_key_request.passkey_type == AT_BLE_PAIR_PASSKEY_ENTRY) {
	  DBG_LOG("Enter the Passkey(6-Digit) in Terminal:");
	  for (idx = 0; idx < 6;) {          
     942:	2c06      	cmp	r4, #6
     944:	d002      	beq.n	94c <ble_pair_key_request_handler+0x58>
     946:	e7e7      	b.n	918 <ble_pair_key_request_handler+0x24>
     948:	2f05      	cmp	r7, #5
     94a:	d9e6      	bls.n	91a <ble_pair_key_request_handler+0x26>
     94c:	2400      	movs	r4, #0
          
          /* Convert passkey to ASCII format */
          for(idx=0; idx<AT_BLE_PASSKEY_LEN; idx++)
          {
                  passkey[idx] = (passkey[idx]);
                  DBG_LOG_CONT("%c",passkey[idx]);
     94e:	4e11      	ldr	r6, [pc, #68]	; (994 <ble_pair_key_request_handler+0xa0>)
          }
          
          /* Convert passkey to ASCII format */
          for(idx=0; idx<AT_BLE_PASSKEY_LEN; idx++)
          {
                  passkey[idx] = (passkey[idx]);
     950:	ab02      	add	r3, sp, #8
                  DBG_LOG_CONT("%c",passkey[idx]);
     952:	5ce0      	ldrb	r0, [r4, r3]
     954:	47b0      	blx	r6
     956:	3401      	adds	r4, #1
          {
            DBG_LOG("Please Enter the following Pass-code(on other Device):");
          }
          
          /* Convert passkey to ASCII format */
          for(idx=0; idx<AT_BLE_PASSKEY_LEN; idx++)
     958:	2c06      	cmp	r4, #6
     95a:	d1f9      	bne.n	950 <ble_pair_key_request_handler+0x5c>
          {
                  passkey[idx] = (passkey[idx]);
                  DBG_LOG_CONT("%c",passkey[idx]);
          }		
          
          if(!(at_ble_pair_key_reply(pair_key->handle, pair_key_request.type, passkey)) == AT_BLE_SUCCESS)
     95c:	8828      	ldrh	r0, [r5, #0]
     95e:	ab01      	add	r3, sp, #4
     960:	7899      	ldrb	r1, [r3, #2]
     962:	aa02      	add	r2, sp, #8
     964:	4b0c      	ldr	r3, [pc, #48]	; (998 <ble_pair_key_request_handler+0xa4>)
     966:	4798      	blx	r3
		if(pair_key_request.type == AT_BLE_PAIR_OOB)
		{
			DBG_LOG("OOB Feature Not supported");
		}
	}
	return AT_BLE_SUCCESS;	
     968:	2000      	movs	r0, #0
     96a:	e006      	b.n	97a <ble_pair_key_request_handler+0x86>
		} 
	  }
	}	
	
	/* Display passkey */
	if(((pair_key_request.passkey_type == AT_BLE_PAIR_PASSKEY_DISPLAY) &&
     96c:	ab01      	add	r3, sp, #4
     96e:	885a      	ldrh	r2, [r3, #2]
     970:	2380      	movs	r3, #128	; 0x80
     972:	005b      	lsls	r3, r3, #1
     974:	429a      	cmp	r2, r3
     976:	d0e9      	beq.n	94c <ble_pair_key_request_handler+0x58>
		if(pair_key_request.type == AT_BLE_PAIR_OOB)
		{
			DBG_LOG("OOB Feature Not supported");
		}
	}
	return AT_BLE_SUCCESS;	
     978:	2000      	movs	r0, #0
}
     97a:	b005      	add	sp, #20
     97c:	bdf0      	pop	{r4, r5, r6, r7, pc}
     97e:	46c0      	nop			; (mov r8, r8)
     980:	0000e998 	.word	0x0000e998
     984:	0000d7eb 	.word	0x0000d7eb
     988:	00001ba1 	.word	0x00001ba1
     98c:	00007530 	.word	0x00007530
     990:	00007755 	.word	0x00007755
     994:	0000d971 	.word	0x0000d971
     998:	000083e9 	.word	0x000083e9

0000099c <ble_encryption_request_handler>:
	return AT_BLE_SUCCESS;
}

/** @brief function handles encryption requests */
at_ble_status_t ble_encryption_request_handler(void *params)
{
     99c:	b570      	push	{r4, r5, r6, lr}
     99e:	1c06      	adds	r6, r0, #0
	uint8_t idx;
	enc_req = (at_ble_encryption_request_t *)params;

	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
	{
		if((ble_dev_info[idx].conn_info.handle == enc_req->handle) && (ble_dev_info[idx].conn_state != BLE_DEVICE_DISCONNECTED) &&
     9a0:	8801      	ldrh	r1, [r0, #0]
     9a2:	4b26      	ldr	r3, [pc, #152]	; (a3c <ble_encryption_request_handler+0xa0>)
     9a4:	2500      	movs	r5, #0
     9a6:	b2ec      	uxtb	r4, r5
     9a8:	891a      	ldrh	r2, [r3, #8]
     9aa:	428a      	cmp	r2, r1
     9ac:	d115      	bne.n	9da <ble_encryption_request_handler+0x3e>
     9ae:	1c1a      	adds	r2, r3, #0
     9b0:	325e      	adds	r2, #94	; 0x5e
     9b2:	7812      	ldrb	r2, [r2, #0]
     9b4:	2a01      	cmp	r2, #1
     9b6:	d910      	bls.n	9da <ble_encryption_request_handler+0x3e>
		(ble_dev_info[idx].conn_state != BLE_DEVICE_DEFAULT_IDLE))
		{
			device_found = true;
			ble_dev_info[idx].conn_state = BLE_DEVICE_ENCRYPTION_STATE;
     9b8:	4a20      	ldr	r2, [pc, #128]	; (a3c <ble_encryption_request_handler+0xa0>)
     9ba:	006b      	lsls	r3, r5, #1
     9bc:	195b      	adds	r3, r3, r5
     9be:	015b      	lsls	r3, r3, #5
     9c0:	18d3      	adds	r3, r2, r3
     9c2:	3358      	adds	r3, #88	; 0x58
     9c4:	2106      	movs	r1, #6
     9c6:	7199      	strb	r1, [r3, #6]
		}
	}
	
	if (device_found)
	{
		if((ble_dev_info[idx].bond_info.peer_ltk.ediv == enc_req->ediv)
     9c8:	0063      	lsls	r3, r4, #1
     9ca:	191b      	adds	r3, r3, r4
     9cc:	015b      	lsls	r3, r3, #5
     9ce:	18d3      	adds	r3, r2, r3
     9d0:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
     9d2:	8873      	ldrh	r3, [r6, #2]
     9d4:	429a      	cmp	r2, r3
     9d6:	d113      	bne.n	a00 <ble_encryption_request_handler+0x64>
     9d8:	e006      	b.n	9e8 <ble_encryption_request_handler+0x4c>
     9da:	3401      	adds	r4, #1
     9dc:	b2e4      	uxtb	r4, r4
     9de:	3501      	adds	r5, #1
     9e0:	3360      	adds	r3, #96	; 0x60
	bool key_found = false;
	bool device_found = false;
	uint8_t idx;
	enc_req = (at_ble_encryption_request_t *)params;

	for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     9e2:	2d05      	cmp	r5, #5
     9e4:	d1df      	bne.n	9a6 <ble_encryption_request_handler+0xa>
     9e6:	e00b      	b.n	a00 <ble_encryption_request_handler+0x64>
	}
	
	if (device_found)
	{
		if((ble_dev_info[idx].bond_info.peer_ltk.ediv == enc_req->ediv)
		&& !memcmp(&enc_req->nb[0],&ble_dev_info[idx].bond_info.peer_ltk.nb[0],8))
     9e8:	1d30      	adds	r0, r6, #4
     9ea:	0061      	lsls	r1, r4, #1
     9ec:	1909      	adds	r1, r1, r4
     9ee:	0149      	lsls	r1, r1, #5
     9f0:	4b12      	ldr	r3, [pc, #72]	; (a3c <ble_encryption_request_handler+0xa0>)
     9f2:	1859      	adds	r1, r3, r1
     9f4:	312c      	adds	r1, #44	; 0x2c
     9f6:	2208      	movs	r2, #8
     9f8:	4b11      	ldr	r3, [pc, #68]	; (a40 <ble_encryption_request_handler+0xa4>)
     9fa:	4798      	blx	r3
			DBG_LOG_DEV("ENC-Req: Key Found");
		}
	}
	
	
    if(key_found == false)
     9fc:	2800      	cmp	r0, #0
     9fe:	d00a      	beq.n	a16 <ble_encryption_request_handler+0x7a>
    {
	    DBG_LOG("Pairing information of peer device is not available.");
	    DBG_LOG("Please unpair the device from peer device(mobile) settings menu and start pairing again");
		at_ble_disconnect(ble_dev_info[idx].conn_info.handle, AT_BLE_AUTH_FAILURE);
     a00:	0063      	lsls	r3, r4, #1
     a02:	191c      	adds	r4, r3, r4
     a04:	0164      	lsls	r4, r4, #5
     a06:	4b0d      	ldr	r3, [pc, #52]	; (a3c <ble_encryption_request_handler+0xa0>)
     a08:	191c      	adds	r4, r3, r4
     a0a:	8920      	ldrh	r0, [r4, #8]
     a0c:	2105      	movs	r1, #5
     a0e:	4b0d      	ldr	r3, [pc, #52]	; (a44 <ble_encryption_request_handler+0xa8>)
     a10:	4798      	blx	r3
		return AT_BLE_FAILURE;
     a12:	20e2      	movs	r0, #226	; 0xe2
     a14:	e010      	b.n	a38 <ble_encryption_request_handler+0x9c>
     a16:	22ff      	movs	r2, #255	; 0xff
     a18:	402a      	ands	r2, r5
    }

	if(!(at_ble_encryption_request_reply(enc_req->handle, ble_dev_info[idx].bond_info.auth, key_found, &ble_dev_info[idx].bond_info.peer_ltk) == AT_BLE_SUCCESS))
     a1a:	8830      	ldrh	r0, [r6, #0]
     a1c:	4c07      	ldr	r4, [pc, #28]	; (a3c <ble_encryption_request_handler+0xa0>)
     a1e:	0053      	lsls	r3, r2, #1
     a20:	1899      	adds	r1, r3, r2
     a22:	0149      	lsls	r1, r1, #5
     a24:	1861      	adds	r1, r4, r1
     a26:	7d09      	ldrb	r1, [r1, #20]
     a28:	189b      	adds	r3, r3, r2
     a2a:	015a      	lsls	r2, r3, #5
     a2c:	18a3      	adds	r3, r4, r2
     a2e:	331a      	adds	r3, #26
     a30:	2201      	movs	r2, #1
     a32:	4c05      	ldr	r4, [pc, #20]	; (a48 <ble_encryption_request_handler+0xac>)
     a34:	47a0      	blx	r4
	}
	else
	{      
		DBG_LOG_DEV("Encryption Request Reply");
	}
	return AT_BLE_SUCCESS;
     a36:	2000      	movs	r0, #0
}
     a38:	bd70      	pop	{r4, r5, r6, pc}
     a3a:	46c0      	nop			; (mov r8, r8)
     a3c:	200006dc 	.word	0x200006dc
     a40:	0000d7cd 	.word	0x0000d7cd
     a44:	00007755 	.word	0x00007755
     a48:	000085d9 	.word	0x000085d9

00000a4c <ble_set_device_name>:
	}
}

/** @brief set device name to BLE Device*/
at_ble_status_t ble_set_device_name(uint8_t *name, uint8_t name_len)
{
     a4c:	b508      	push	{r3, lr}
	if ((name == NULL) || (name_len < 1))
     a4e:	2800      	cmp	r0, #0
     a50:	d006      	beq.n	a60 <ble_set_device_name+0x14>
	{
		return AT_BLE_INVALID_PARAM;
     a52:	23cf      	movs	r3, #207	; 0xcf
}

/** @brief set device name to BLE Device*/
at_ble_status_t ble_set_device_name(uint8_t *name, uint8_t name_len)
{
	if ((name == NULL) || (name_len < 1))
     a54:	2900      	cmp	r1, #0
     a56:	d004      	beq.n	a62 <ble_set_device_name+0x16>
	{
		return AT_BLE_INVALID_PARAM;
	}
	return at_ble_device_name_set(name, name_len);
     a58:	4b03      	ldr	r3, [pc, #12]	; (a68 <ble_set_device_name+0x1c>)
     a5a:	4798      	blx	r3
     a5c:	1c03      	adds	r3, r0, #0
     a5e:	e000      	b.n	a62 <ble_set_device_name+0x16>
/** @brief set device name to BLE Device*/
at_ble_status_t ble_set_device_name(uint8_t *name, uint8_t name_len)
{
	if ((name == NULL) || (name_len < 1))
	{
		return AT_BLE_INVALID_PARAM;
     a60:	23cf      	movs	r3, #207	; 0xcf
	}
	return at_ble_device_name_set(name, name_len);
}
     a62:	1c18      	adds	r0, r3, #0
     a64:	bd08      	pop	{r3, pc}
     a66:	46c0      	nop			; (mov r8, r8)
     a68:	00007239 	.word	0x00007239

00000a6c <ble_mgr_events_callback_handler>:
}

bool ble_mgr_events_callback_handler(ble_mgr_event_cb_t event_cb_type, 
									ble_mgr_event_t event_type,
									const ble_event_callback_t *ble_event_handler)
{
     a6c:	b530      	push	{r4, r5, lr}
	uint8_t idx;
	uint8_t max_event_handler = 0;
	bool status = true;
	const ble_event_callback_t **ble_event_cb_ptr = NULL;
	if (ble_event_handler != NULL)
     a6e:	2a00      	cmp	r2, #0
     a70:	d047      	beq.n	b02 <ble_mgr_events_callback_handler+0x96>
	{
		switch(event_type)
     a72:	2906      	cmp	r1, #6
     a74:	d847      	bhi.n	b06 <ble_mgr_events_callback_handler+0x9a>
     a76:	0089      	lsls	r1, r1, #2
     a78:	4b28      	ldr	r3, [pc, #160]	; (b1c <ble_mgr_events_callback_handler+0xb0>)
     a7a:	585b      	ldr	r3, [r3, r1]
     a7c:	469f      	mov	pc, r3
			}
			break;
			
			case BLE_GATT_SERVER_EVENT_TYPE:
			{
				ble_event_cb_ptr = ble_mgr_gatt_server_event_cb;
     a7e:	4b28      	ldr	r3, [pc, #160]	; (b20 <ble_mgr_events_callback_handler+0xb4>)
				max_event_handler = MAX_GATT_SERVER_SUBSCRIBERS;
     a80:	2405      	movs	r4, #5
     a82:	e00a      	b.n	a9a <ble_mgr_events_callback_handler+0x2e>
			}
			break;
			
			case BLE_GATT_HTPT_EVENT_TYPE:
			{
				ble_event_cb_ptr = ble_mgr_htpt_event_cb;
     a84:	4b27      	ldr	r3, [pc, #156]	; (b24 <ble_mgr_events_callback_handler+0xb8>)
				max_event_handler = MAX_HTPT_EVENT_SUBSCRIBERS;
     a86:	2401      	movs	r4, #1
			}
			break;
     a88:	e007      	b.n	a9a <ble_mgr_events_callback_handler+0x2e>
			
			case BLE_DTM_EVENT_TYPE:
			{
				ble_event_cb_ptr = ble_mgr_dtm_event_cb;
     a8a:	4b27      	ldr	r3, [pc, #156]	; (b28 <ble_mgr_events_callback_handler+0xbc>)
				max_event_handler = MAX_DTM_EVENT_SUBSCRIBERS;
     a8c:	2405      	movs	r4, #5
			}
			break;
     a8e:	e004      	b.n	a9a <ble_mgr_events_callback_handler+0x2e>
			
			case BLE_CUSTOM_EVENT_TYPE:
			{
				ble_event_cb_ptr = ble_mgr_custom_event_cb;
     a90:	4b26      	ldr	r3, [pc, #152]	; (b2c <ble_mgr_events_callback_handler+0xc0>)
				max_event_handler = MAX_CUSTOM_EVENT_SUBSCRIBERS;
     a92:	2401      	movs	r4, #1
			}
			break;
     a94:	e001      	b.n	a9a <ble_mgr_events_callback_handler+0x2e>
	{
		switch(event_type)
		{
			case BLE_GAP_EVENT_TYPE:
			{
				ble_event_cb_ptr = ble_mgr_gap_event_cb;
     a96:	4b26      	ldr	r3, [pc, #152]	; (b30 <ble_mgr_events_callback_handler+0xc4>)
				max_event_handler = MAX_GAP_EVENT_SUBSCRIBERS;
     a98:	2405      	movs	r4, #5
		}
		
		if (status)
		{
			status = false; //Defaults to Failure[No Space to register, Not Found, Invalid Type]scenario
			if (event_cb_type == REGISTER_CALL_BACK)
     a9a:	2800      	cmp	r0, #0
     a9c:	d116      	bne.n	acc <ble_mgr_events_callback_handler+0x60>
			{
				for (idx = 0; idx < max_event_handler; idx++)
				{
					if(ble_event_cb_ptr[idx] == NULL)
     a9e:	6819      	ldr	r1, [r3, #0]
     aa0:	2900      	cmp	r1, #0
     aa2:	d10b      	bne.n	abc <ble_mgr_events_callback_handler+0x50>
     aa4:	e006      	b.n	ab4 <ble_mgr_events_callback_handler+0x48>
     aa6:	1c1d      	adds	r5, r3, #0
     aa8:	3304      	adds	r3, #4
     aaa:	1f18      	subs	r0, r3, #4
     aac:	6800      	ldr	r0, [r0, #0]
     aae:	2800      	cmp	r0, #0
     ab0:	d106      	bne.n	ac0 <ble_mgr_events_callback_handler+0x54>
     ab2:	e000      	b.n	ab6 <ble_mgr_events_callback_handler+0x4a>
     ab4:	1c1d      	adds	r5, r3, #0
					{
						ble_event_cb_ptr[idx] = ble_event_handler;
     ab6:	602a      	str	r2, [r5, #0]
						status = true; //Successfully registered to table
     ab8:	2101      	movs	r1, #1
						break;
     aba:	e02c      	b.n	b16 <ble_mgr_events_callback_handler+0xaa>
     abc:	3304      	adds	r3, #4
			status = false; //Defaults to Failure[No Space to register, Not Found, Invalid Type]scenario
			if (event_cb_type == REGISTER_CALL_BACK)
			{
				for (idx = 0; idx < max_event_handler; idx++)
				{
					if(ble_event_cb_ptr[idx] == NULL)
     abe:	2100      	movs	r1, #0
		if (status)
		{
			status = false; //Defaults to Failure[No Space to register, Not Found, Invalid Type]scenario
			if (event_cb_type == REGISTER_CALL_BACK)
			{
				for (idx = 0; idx < max_event_handler; idx++)
     ac0:	3101      	adds	r1, #1
     ac2:	b2c9      	uxtb	r1, r1
     ac4:	42a1      	cmp	r1, r4
     ac6:	d3ee      	bcc.n	aa6 <ble_mgr_events_callback_handler+0x3a>
			break;
		}
		
		if (status)
		{
			status = false; //Defaults to Failure[No Space to register, Not Found, Invalid Type]scenario
     ac8:	2100      	movs	r1, #0
     aca:	e024      	b.n	b16 <ble_mgr_events_callback_handler+0xaa>
     acc:	2100      	movs	r1, #0
						status = true; //Successfully registered to table
						break;
					}
				}
			}
			else if(event_cb_type == UNREGISTER_CALL_BACK)
     ace:	2801      	cmp	r0, #1
     ad0:	d121      	bne.n	b16 <ble_mgr_events_callback_handler+0xaa>
			{
				for (idx = 0; idx < max_event_handler; idx++)
				{
					if(ble_event_cb_ptr[idx] == ble_event_handler)
     ad2:	6819      	ldr	r1, [r3, #0]
     ad4:	4291      	cmp	r1, r2
     ad6:	d10c      	bne.n	af2 <ble_mgr_events_callback_handler+0x86>
     ad8:	e006      	b.n	ae8 <ble_mgr_events_callback_handler+0x7c>
     ada:	1c1d      	adds	r5, r3, #0
     adc:	3304      	adds	r3, #4
     ade:	1f18      	subs	r0, r3, #4
     ae0:	6800      	ldr	r0, [r0, #0]
     ae2:	4290      	cmp	r0, r2
     ae4:	d107      	bne.n	af6 <ble_mgr_events_callback_handler+0x8a>
     ae6:	e000      	b.n	aea <ble_mgr_events_callback_handler+0x7e>
     ae8:	1c1d      	adds	r5, r3, #0
					{
						ble_event_cb_ptr[idx] = NULL;
     aea:	2300      	movs	r3, #0
     aec:	602b      	str	r3, [r5, #0]
						status = true;//Successfully unregistered from table
     aee:	2101      	movs	r1, #1
						break;
     af0:	e011      	b.n	b16 <ble_mgr_events_callback_handler+0xaa>
     af2:	3304      	adds	r3, #4
			}
			else if(event_cb_type == UNREGISTER_CALL_BACK)
			{
				for (idx = 0; idx < max_event_handler; idx++)
				{
					if(ble_event_cb_ptr[idx] == ble_event_handler)
     af4:	2100      	movs	r1, #0
					}
				}
			}
			else if(event_cb_type == UNREGISTER_CALL_BACK)
			{
				for (idx = 0; idx < max_event_handler; idx++)
     af6:	3101      	adds	r1, #1
     af8:	b2c9      	uxtb	r1, r1
     afa:	42a1      	cmp	r1, r4
     afc:	d3ed      	bcc.n	ada <ble_mgr_events_callback_handler+0x6e>
			break;
		}
		
		if (status)
		{
			status = false; //Defaults to Failure[No Space to register, Not Found, Invalid Type]scenario
     afe:	2100      	movs	r1, #0
     b00:	e009      	b.n	b16 <ble_mgr_events_callback_handler+0xaa>
			}			
		}
	}
	else
	{
		status = false; //Invalid parameter
     b02:	2100      	movs	r1, #0
     b04:	e007      	b.n	b16 <ble_mgr_events_callback_handler+0xaa>
	uint8_t max_event_handler = 0;
	bool status = true;
	const ble_event_callback_t **ble_event_cb_ptr = NULL;
	if (ble_event_handler != NULL)
	{
		switch(event_type)
     b06:	2100      	movs	r1, #0
     b08:	e005      	b.n	b16 <ble_mgr_events_callback_handler+0xaa>
			}
			break;
			
			case BLE_GATT_CLIENT_EVENT_TYPE:
			{
				ble_event_cb_ptr = ble_mgr_gatt_client_event_cb;
     b0a:	4b0a      	ldr	r3, [pc, #40]	; (b34 <ble_mgr_events_callback_handler+0xc8>)
				max_event_handler = MAX_GATT_CLIENT_SUBSCRIBERS;
     b0c:	2405      	movs	r4, #5
     b0e:	e7c4      	b.n	a9a <ble_mgr_events_callback_handler+0x2e>
			}
			break;
			
			case BLE_L2CAP_EVENT_TYPE:
			{
				ble_event_cb_ptr = ble_mgr_l2cap_event_cb;
     b10:	4b09      	ldr	r3, [pc, #36]	; (b38 <ble_mgr_events_callback_handler+0xcc>)
				max_event_handler = MAX_L2CAP_EVENT_SUBSCRIBERS;
     b12:	2401      	movs	r4, #1
     b14:	e7c1      	b.n	a9a <ble_mgr_events_callback_handler+0x2e>
	else
	{
		status = false; //Invalid parameter
	}
	return status;
}
     b16:	1c08      	adds	r0, r1, #0
     b18:	bd30      	pop	{r4, r5, pc}
     b1a:	46c0      	nop			; (mov r8, r8)
     b1c:	0000e890 	.word	0x0000e890
     b20:	200006c8 	.word	0x200006c8
     b24:	200006c4 	.word	0x200006c4
     b28:	200008c0 	.word	0x200008c0
     b2c:	20001334 	.word	0x20001334
     b30:	200008d4 	.word	0x200008d4
     b34:	200008e8 	.word	0x200008e8
     b38:	20000910 	.word	0x20000910

00000b3c <ble_device_init>:
    return AT_BLE_FAILURE;
}

/** @brief BLE device initialization */
void ble_device_init(at_ble_addr_t *addr)
{
     b3c:	b5f0      	push	{r4, r5, r6, r7, lr}
     b3e:	4647      	mov	r7, r8
     b40:	b480      	push	{r7}
     b42:	b090      	sub	sp, #64	; 0x40
     b44:	1c05      	adds	r5, r0, #0
	char *dev_name = NULL;

	/* Initialize the BLE Event callbacks */
	for (idx = 0; idx < MAX_GAP_EVENT_SUBSCRIBERS; idx++)
	{
		ble_mgr_gap_event_cb[idx] = NULL;
     b46:	4a3d      	ldr	r2, [pc, #244]	; (c3c <ble_device_init+0x100>)
     b48:	2300      	movs	r3, #0
     b4a:	6013      	str	r3, [r2, #0]
     b4c:	6053      	str	r3, [r2, #4]
     b4e:	6093      	str	r3, [r2, #8]
     b50:	60d3      	str	r3, [r2, #12]
     b52:	6113      	str	r3, [r2, #16]
	}
	
	for (idx = 0; idx < MAX_GATT_CLIENT_SUBSCRIBERS; idx++)
	{
		ble_mgr_gatt_client_event_cb[idx] = NULL;
     b54:	4a3a      	ldr	r2, [pc, #232]	; (c40 <ble_device_init+0x104>)
     b56:	6013      	str	r3, [r2, #0]
     b58:	6053      	str	r3, [r2, #4]
     b5a:	6093      	str	r3, [r2, #8]
     b5c:	60d3      	str	r3, [r2, #12]
     b5e:	6113      	str	r3, [r2, #16]
	}
	
	for (idx = 0; idx < MAX_GATT_SERVER_SUBSCRIBERS; idx++)
	{
		ble_mgr_gatt_server_event_cb[idx] = NULL;
     b60:	4a38      	ldr	r2, [pc, #224]	; (c44 <ble_device_init+0x108>)
     b62:	6013      	str	r3, [r2, #0]
     b64:	6053      	str	r3, [r2, #4]
     b66:	6093      	str	r3, [r2, #8]
     b68:	60d3      	str	r3, [r2, #12]
     b6a:	6113      	str	r3, [r2, #16]
	}
	
	for (idx = 0; idx < MAX_L2CAP_EVENT_SUBSCRIBERS; idx++)
	{
		ble_mgr_l2cap_event_cb[idx] = NULL;
     b6c:	4a36      	ldr	r2, [pc, #216]	; (c48 <ble_device_init+0x10c>)
     b6e:	6013      	str	r3, [r2, #0]
	}
	
	for (idx = 0; idx < MAX_HTPT_EVENT_SUBSCRIBERS; idx++)
	{
		ble_mgr_htpt_event_cb[idx] = NULL;
     b70:	4a36      	ldr	r2, [pc, #216]	; (c4c <ble_device_init+0x110>)
     b72:	6013      	str	r3, [r2, #0]
	}
	
	for (idx = 0; idx < MAX_DTM_EVENT_SUBSCRIBERS; idx++)
	{
		ble_mgr_dtm_event_cb[idx] = NULL;
     b74:	4a36      	ldr	r2, [pc, #216]	; (c50 <ble_device_init+0x114>)
     b76:	6013      	str	r3, [r2, #0]
     b78:	6053      	str	r3, [r2, #4]
     b7a:	6093      	str	r3, [r2, #8]
     b7c:	60d3      	str	r3, [r2, #12]
     b7e:	6113      	str	r3, [r2, #16]
	}
	
	for (idx = 0; idx < MAX_CUSTOM_EVENT_SUBSCRIBERS; idx++)
	{
		ble_mgr_custom_event_cb[idx] = NULL;
     b80:	4a34      	ldr	r2, [pc, #208]	; (c54 <ble_device_init+0x118>)
     b82:	6013      	str	r3, [r2, #0]
     b84:	4c34      	ldr	r4, [pc, #208]	; (c58 <ble_device_init+0x11c>)
     b86:	33e1      	adds	r3, #225	; 0xe1
     b88:	33ff      	adds	r3, #255	; 0xff
     b8a:	4698      	mov	r8, r3
     b8c:	44a0      	add	r8, r4
	}
        
    /* Set the BLE Device connection state */
    for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
    {
        memset(&ble_dev_info[idx], 0, sizeof(ble_connected_dev_info_t));
     b8e:	4f33      	ldr	r7, [pc, #204]	; (c5c <ble_device_init+0x120>)
		ble_dev_info[idx].conn_state = BLE_DEVICE_DEFAULT_IDLE;
		/* Set Invalid to Bonding information */
		ble_dev_info[idx].bond_info.status = AT_BLE_GAP_INVALID_PARAM;
     b90:	2640      	movs	r6, #64	; 0x40
	}
        
    /* Set the BLE Device connection state */
    for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
    {
        memset(&ble_dev_info[idx], 0, sizeof(ble_connected_dev_info_t));
     b92:	1c20      	adds	r0, r4, #0
     b94:	2100      	movs	r1, #0
     b96:	2260      	movs	r2, #96	; 0x60
     b98:	47b8      	blx	r7
     b9a:	1c23      	adds	r3, r4, #0
     b9c:	335e      	adds	r3, #94	; 0x5e
		ble_dev_info[idx].conn_state = BLE_DEVICE_DEFAULT_IDLE;
     b9e:	2200      	movs	r2, #0
     ba0:	701a      	strb	r2, [r3, #0]
		/* Set Invalid to Bonding information */
		ble_dev_info[idx].bond_info.status = AT_BLE_GAP_INVALID_PARAM;
     ba2:	7626      	strb	r6, [r4, #24]
     ba4:	3460      	adds	r4, #96	; 0x60
	{
		ble_mgr_custom_event_cb[idx] = NULL;
	}
        
    /* Set the BLE Device connection state */
    for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     ba6:	4544      	cmp	r4, r8
     ba8:	d1f3      	bne.n	b92 <ble_device_init+0x56>
		ble_dev_info[idx].conn_state = BLE_DEVICE_DEFAULT_IDLE;
		/* Set Invalid to Bonding information */
		ble_dev_info[idx].bond_info.status = AT_BLE_GAP_INVALID_PARAM;
    }
	/* Need to reset the count to 0 for storing it only in SRAM */
	ble_device_count = 0; 
     baa:	4b2d      	ldr	r3, [pc, #180]	; (c60 <ble_device_init+0x124>)
     bac:	701a      	strb	r2, [r3, #0]
	
	
#if defined ATT_DB_MEMORY
	pf_cfg.memPool.memSize = BLE_ATT_DB_MEMORY_SIZE;
     bae:	4b2d      	ldr	r3, [pc, #180]	; (c64 <ble_device_init+0x128>)
     bb0:	930e      	str	r3, [sp, #56]	; 0x38
	pf_cfg.memPool.memStartAdd = (uint8_t *)&att_db_data;
     bb2:	4b2d      	ldr	r3, [pc, #180]	; (c68 <ble_device_init+0x12c>)
     bb4:	930d      	str	r3, [sp, #52]	; 0x34
#else
	pf_cfg.memPool.memSize = 0;
	pf_cfg.memPool.memStartAdd = NULL;
#endif
	/*Bus configuration*/
	busConfig.bus_type = AT_BLE_UART;
     bb6:	ab0c      	add	r3, sp, #48	; 0x30
     bb8:	2101      	movs	r1, #1
     bba:	7019      	strb	r1, [r3, #0]
	busConfig.bus_info = 0; /* Bus Info Not used */
     bbc:	705a      	strb	r2, [r3, #1]
	pf_cfg.plf_config = &busConfig;	
     bbe:	930f      	str	r3, [sp, #60]	; 0x3c
{
	/* Initialize the platform */
	DBG_LOG("Initializing BTLC1000");
	
	/* Init BLE device */
	if(at_ble_init(args) != AT_BLE_SUCCESS)
     bc0:	a80d      	add	r0, sp, #52	; 0x34
     bc2:	4b2a      	ldr	r3, [pc, #168]	; (c6c <ble_device_init+0x130>)
     bc4:	4798      	blx	r3
     bc6:	2800      	cmp	r0, #0
     bc8:	d000      	beq.n	bcc <ble_device_init+0x90>
     bca:	e7fe      	b.n	bca <ble_device_init+0x8e>
	busConfig.bus_info = 0; /* Bus Info Not used */
	pf_cfg.plf_config = &busConfig;	
	
	ble_init(&pf_cfg);
	
	init_done = true;
     bcc:	2201      	movs	r2, #1
     bce:	4b28      	ldr	r3, [pc, #160]	; (c70 <ble_device_init+0x134>)
     bd0:	701a      	strb	r2, [r3, #0]
	
	/* Register it in first index of callback handler */
	ble_mgr_events_callback_handler(REGISTER_CALL_BACK, 
     bd2:	2000      	movs	r0, #0
     bd4:	2100      	movs	r1, #0
     bd6:	4a27      	ldr	r2, [pc, #156]	; (c74 <ble_device_init+0x138>)
     bd8:	4c27      	ldr	r4, [pc, #156]	; (c78 <ble_device_init+0x13c>)
     bda:	47a0      	blx	r4
									BLE_GAP_EVENT_TYPE, 
									ble_mgr_gap_handle);
	ble_mgr_events_callback_handler(REGISTER_CALL_BACK,
     bdc:	2000      	movs	r0, #0
     bde:	2102      	movs	r1, #2
     be0:	4a26      	ldr	r2, [pc, #152]	; (c7c <ble_device_init+0x140>)
     be2:	47a0      	blx	r4

/* Set BLE Address, If address is NULL then it will use BD public address */
static void ble_set_address(at_ble_addr_t *addr)
{
	at_ble_dev_config_t stDevConfig;
	at_ble_addr_t address = {AT_BLE_ADDRESS_PUBLIC, {0xAB, 0xCD, 0xEF, 0xAB, 0xCD, 0xEF}};
     be4:	4668      	mov	r0, sp
     be6:	4926      	ldr	r1, [pc, #152]	; (c80 <ble_device_init+0x144>)
     be8:	3108      	adds	r1, #8
     bea:	2207      	movs	r2, #7
     bec:	4b25      	ldr	r3, [pc, #148]	; (c84 <ble_device_init+0x148>)
     bee:	4798      	blx	r3
	
	if (addr == NULL)
     bf0:	2d00      	cmp	r5, #0
     bf2:	d103      	bne.n	bfc <ble_device_init+0xc0>
	{		
		/* get BD address from BLE device */
		if(at_ble_addr_get(&address) != AT_BLE_SUCCESS)
     bf4:	4668      	mov	r0, sp
     bf6:	4b24      	ldr	r3, [pc, #144]	; (c88 <ble_device_init+0x14c>)
     bf8:	4798      	blx	r3
		{
			DBG_LOG("BD address get failed");
		}
		
		/* Copy the BD address into address pointer */
		addr = &address;
     bfa:	466d      	mov	r5, sp
	addr->addr[1],
	addr->addr[0], addr->type);
	
	/* Set device configuration */
	/* Device role */
	stDevConfig.role = (at_ble_dev_role_t)BLE_DEVICE_ROLE;
     bfc:	ac02      	add	r4, sp, #8
     bfe:	230a      	movs	r3, #10
     c00:	7023      	strb	r3, [r4, #0]
	/* device renew duration */
	stDevConfig.renew_dur = AT_RENEW_DUR_VAL_MIN;
     c02:	4b22      	ldr	r3, [pc, #136]	; (c8c <ble_device_init+0x150>)
     c04:	8063      	strh	r3, [r4, #2]
	/* device address type */
	memcpy((uint8_t *)&stDevConfig.address, (uint8_t *)addr, sizeof(at_ble_addr_t));
     c06:	a803      	add	r0, sp, #12
     c08:	1c29      	adds	r1, r5, #0
     c0a:	2207      	movs	r2, #7
     c0c:	4b1d      	ldr	r3, [pc, #116]	; (c84 <ble_device_init+0x148>)
     c0e:	4798      	blx	r3
	/* Attributes */
	stDevConfig.att_cfg.b2NamePerm = AT_BLE_WRITE_DISABLE;
     c10:	2300      	movs	r3, #0
     c12:	76e3      	strb	r3, [r4, #27]
	stDevConfig.att_cfg.b2AppearancePerm = AT_BLE_WRITE_DISABLE;
     c14:	7723      	strb	r3, [r4, #28]
	stDevConfig.att_cfg.b1EnableSpcs = 0;
     c16:	7763      	strb	r3, [r4, #29]
	stDevConfig.att_cfg.b1EnableServiceChanged = 0;
     c18:	77a3      	strb	r3, [r4, #30]
	stDevConfig.att_cfg.b2Rfu = AT_BLE_WRITE_DISABLE;
     c1a:	77e3      	strb	r3, [r4, #31]
	/* Handles */
	stDevConfig.gap_start_hdl = AT_BLE_AUTO_ALLOC_HANDLE;
     c1c:	8423      	strh	r3, [r4, #32]
	stDevConfig.gatt_start_hdl = AT_BLE_AUTO_ALLOC_HANDLE;
     c1e:	8463      	strh	r3, [r4, #34]	; 0x22
	/* MTU */
	stDevConfig.max_mtu = AT_MTU_VAL_RECOMMENDED;
     c20:	339e      	adds	r3, #158	; 0x9e
     c22:	84a3      	strh	r3, [r4, #36]	; 0x24
	
	if(at_ble_set_dev_config(&stDevConfig) != AT_BLE_SUCCESS)
     c24:	1c20      	adds	r0, r4, #0
     c26:	4b1a      	ldr	r3, [pc, #104]	; (c90 <ble_device_init+0x154>)
     c28:	4798      	blx	r3
									
	
	ble_set_address(addr);
	
	dev_name = (char *)BLE_DEVICE_NAME;
	if (ble_set_device_name((uint8_t *)dev_name, strlen(dev_name)) != AT_BLE_SUCCESS)
     c2a:	481a      	ldr	r0, [pc, #104]	; (c94 <ble_device_init+0x158>)
     c2c:	2109      	movs	r1, #9
     c2e:	4b1a      	ldr	r3, [pc, #104]	; (c98 <ble_device_init+0x15c>)
     c30:	4798      	blx	r3
	{
		DBG_LOG("Device name set failed");
	}
}
     c32:	b010      	add	sp, #64	; 0x40
     c34:	bc04      	pop	{r2}
     c36:	4690      	mov	r8, r2
     c38:	bdf0      	pop	{r4, r5, r6, r7, pc}
     c3a:	46c0      	nop			; (mov r8, r8)
     c3c:	200008d4 	.word	0x200008d4
     c40:	200008e8 	.word	0x200008e8
     c44:	200006c8 	.word	0x200006c8
     c48:	20000910 	.word	0x20000910
     c4c:	200006c4 	.word	0x200006c4
     c50:	200008c0 	.word	0x200008c0
     c54:	20001334 	.word	0x20001334
     c58:	200006dc 	.word	0x200006dc
     c5c:	0000d825 	.word	0x0000d825
     c60:	200008bc 	.word	0x200008bc
     c64:	000004e2 	.word	0x000004e2
     c68:	20000c48 	.word	0x20000c48
     c6c:	000073bd 	.word	0x000073bd
     c70:	200000d4 	.word	0x200000d4
     c74:	0000e9dc 	.word	0x0000e9dc
     c78:	00000a6d 	.word	0x00000a6d
     c7c:	0000e9b4 	.word	0x0000e9b4
     c80:	0000e998 	.word	0x0000e998
     c84:	0000d7eb 	.word	0x0000d7eb
     c88:	00007295 	.word	0x00007295
     c8c:	00003a98 	.word	0x00003a98
     c90:	000072b9 	.word	0x000072b9
     c94:	0000ea28 	.word	0x0000ea28
     c98:	00000a4d 	.word	0x00000a4d

00000c9c <ble_send_slave_sec_request>:
	return AT_BLE_FAILURE;
}

/** @brief function to send slave security request */
at_ble_status_t ble_send_slave_sec_request(at_ble_handle_t conn_handle)
{
     c9c:	b508      	push	{r3, lr}
	#if BLE_PAIR_ENABLE
		if (at_ble_send_slave_sec_request(conn_handle, BLE_MITM_REQ, BLE_BOND_REQ) == AT_BLE_SUCCESS)
     c9e:	2101      	movs	r1, #1
     ca0:	2201      	movs	r2, #1
     ca2:	4b03      	ldr	r3, [pc, #12]	; (cb0 <ble_send_slave_sec_request+0x14>)
     ca4:	4798      	blx	r3
     ca6:	2800      	cmp	r0, #0
     ca8:	d000      	beq.n	cac <ble_send_slave_sec_request+0x10>
		{
			DBG_LOG("Slave security request failed");
		}
	#endif
        ALL_UNUSED(conn_handle);
	return AT_BLE_FAILURE;
     caa:	20e2      	movs	r0, #226	; 0xe2
}
     cac:	bd08      	pop	{r3, pc}
     cae:	46c0      	nop			; (mov r8, r8)
     cb0:	00008491 	.word	0x00008491

00000cb4 <ble_connected_state_handler>:
	return status;
}

/** @brief function to handle connected event received from stack */
at_ble_status_t ble_connected_state_handler(void *params)
{
     cb4:	b5f0      	push	{r4, r5, r6, r7, lr}
     cb6:	4647      	mov	r7, r8
     cb8:	b480      	push	{r7}
     cba:	b098      	sub	sp, #96	; 0x60
	at_ble_connected_t *conn_params;
	uint8_t idx = 0;
	conn_params = (at_ble_connected_t *)params;
	bool peripheral_device_added = false;
	
	if (conn_params->conn_status == AT_BLE_SUCCESS)
     cbc:	7a87      	ldrb	r7, [r0, #10]
     cbe:	2f00      	cmp	r7, #0
     cc0:	d000      	beq.n	cc4 <ble_connected_state_handler+0x10>
     cc2:	e0a9      	b.n	e18 <ble_connected_state_handler+0x164>
     cc4:	1c04      	adds	r4, r0, #0
     cc6:	9002      	str	r0, [sp, #8]
		conn_params->peer_addr.addr[1],
		conn_params->peer_addr.addr[0]);
		
		DBG_LOG("Connection Handle %d", conn_params->handle);
		
		memcpy((uint8_t *)&connected_state_info, (uint8_t *)conn_params, sizeof(at_ble_connected_t));	
     cc8:	485f      	ldr	r0, [pc, #380]	; (e48 <ble_connected_state_handler+0x194>)
     cca:	1c21      	adds	r1, r4, #0
     ccc:	2212      	movs	r2, #18
     cce:	4b5f      	ldr	r3, [pc, #380]	; (e4c <ble_connected_state_handler+0x198>)
     cd0:	4798      	blx	r3
		if(memcmp((uint8_t *)&ble_peripheral_dev_address, (uint8_t *)&conn_params->peer_addr, sizeof(at_ble_addr_t)))
     cd2:	9401      	str	r4, [sp, #4]
     cd4:	485e      	ldr	r0, [pc, #376]	; (e50 <ble_connected_state_handler+0x19c>)
     cd6:	1c21      	adds	r1, r4, #0
     cd8:	2207      	movs	r2, #7
     cda:	4b5e      	ldr	r3, [pc, #376]	; (e54 <ble_connected_state_handler+0x1a0>)
     cdc:	4798      	blx	r3
     cde:	2800      	cmp	r0, #0
     ce0:	d100      	bne.n	ce4 <ble_connected_state_handler+0x30>
     ce2:	e09b      	b.n	e1c <ble_connected_state_handler+0x168>
		{
			/* Peripheral Device */
			if (conn_params->peer_addr.type == AT_BLE_ADDRESS_RANDOM_PRIVATE_RESOLVABLE) 
     ce4:	9b02      	ldr	r3, [sp, #8]
     ce6:	781b      	ldrb	r3, [r3, #0]
     ce8:	2b02      	cmp	r3, #2
     cea:	d000      	beq.n	cee <ble_connected_state_handler+0x3a>
     cec:	e096      	b.n	e1c <ble_connected_state_handler+0x168>
			{
				uint8_t idx1, idx2;
				uint16_t key_len = 0;
				uint8_t nb_keys = BLE_MAX_DEVICE_CONNECTED;
				uint8_t irk_key[BLE_MAX_DEVICE_CONNECTED * AT_BLE_MAX_KEY_LEN] = {0, };
     cee:	a804      	add	r0, sp, #16
     cf0:	2100      	movs	r1, #0
     cf2:	2250      	movs	r2, #80	; 0x50
     cf4:	4b58      	ldr	r3, [pc, #352]	; (e58 <ble_connected_state_handler+0x1a4>)
     cf6:	4798      	blx	r3
     cf8:	4e58      	ldr	r6, [pc, #352]	; (e5c <ble_connected_state_handler+0x1a8>)
		{
			/* Peripheral Device */
			if (conn_params->peer_addr.type == AT_BLE_ADDRESS_RANDOM_PRIVATE_RESOLVABLE) 
			{
				uint8_t idx1, idx2;
				uint16_t key_len = 0;
     cfa:	2300      	movs	r3, #0
     cfc:	e00b      	b.n	d16 <ble_connected_state_handler+0x62>
				uint8_t irk_key[BLE_MAX_DEVICE_CONNECTED * AT_BLE_MAX_KEY_LEN] = {0, };
				for (idx1 = 0; idx1 < BLE_MAX_DEVICE_CONNECTED; idx1++)
				{
					for (idx2 = 0; idx2 < AT_BLE_MAX_KEY_LEN; idx2++)
					{
						irk_key[key_len++] = ble_dev_info[idx1].bond_info.peer_irk.key[idx2];
     cfe:	1c59      	adds	r1, r3, #1
     d00:	7810      	ldrb	r0, [r2, #0]
     d02:	ac04      	add	r4, sp, #16
     d04:	54e0      	strb	r0, [r4, r3]
     d06:	3201      	adds	r2, #1
     d08:	b28b      	uxth	r3, r1
				uint16_t key_len = 0;
				uint8_t nb_keys = BLE_MAX_DEVICE_CONNECTED;
				uint8_t irk_key[BLE_MAX_DEVICE_CONNECTED * AT_BLE_MAX_KEY_LEN] = {0, };
				for (idx1 = 0; idx1 < BLE_MAX_DEVICE_CONNECTED; idx1++)
				{
					for (idx2 = 0; idx2 < AT_BLE_MAX_KEY_LEN; idx2++)
     d0a:	42ab      	cmp	r3, r5
     d0c:	d1f7      	bne.n	cfe <ble_connected_state_handler+0x4a>
     d0e:	3660      	adds	r6, #96	; 0x60
     d10:	1e2b      	subs	r3, r5, #0
			{
				uint8_t idx1, idx2;
				uint16_t key_len = 0;
				uint8_t nb_keys = BLE_MAX_DEVICE_CONNECTED;
				uint8_t irk_key[BLE_MAX_DEVICE_CONNECTED * AT_BLE_MAX_KEY_LEN] = {0, };
				for (idx1 = 0; idx1 < BLE_MAX_DEVICE_CONNECTED; idx1++)
     d12:	2b50      	cmp	r3, #80	; 0x50
     d14:	d004      	beq.n	d20 <ble_connected_state_handler+0x6c>
     d16:	1c1d      	adds	r5, r3, #0
     d18:	3510      	adds	r5, #16
     d1a:	b2ad      	uxth	r5, r5
	return status;
}

/** @brief function to handle connected event received from stack */
at_ble_status_t ble_connected_state_handler(void *params)
{
     d1c:	1c32      	adds	r2, r6, #0
     d1e:	e7ee      	b.n	cfe <ble_connected_state_handler+0x4a>
					}
					
				}
				if (nb_keys)
				{
					if(at_ble_random_address_resolve(BLE_MAX_DEVICE_CONNECTED, &conn_params->peer_addr, irk_key) == AT_BLE_SUCCESS)
     d20:	2005      	movs	r0, #5
     d22:	9902      	ldr	r1, [sp, #8]
     d24:	aa04      	add	r2, sp, #16
     d26:	4b4e      	ldr	r3, [pc, #312]	; (e60 <ble_connected_state_handler+0x1ac>)
     d28:	4798      	blx	r3
     d2a:	1e07      	subs	r7, r0, #0
     d2c:	d100      	bne.n	d30 <ble_connected_state_handler+0x7c>
     d2e:	e086      	b.n	e3e <ble_connected_state_handler+0x18a>
						return AT_BLE_SUCCESS;
					}
					else
					{
						DBG_LOG("Resolving Random address failed**");
						return AT_BLE_FAILURE;
     d30:	27e2      	movs	r7, #226	; 0xe2
     d32:	e084      	b.n	e3e <ble_connected_state_handler+0x18a>
     d34:	b2eb      	uxtb	r3, r5
     d36:	4698      	mov	r8, r3
		if (ble_device_count < BLE_MAX_DEVICE_CONNECTED)
		{
			bool conn_exists = false;
			for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
			{
				if(!memcmp((uint8_t *)&ble_dev_info[idx].conn_info.peer_addr, (uint8_t *)&conn_params->peer_addr, sizeof(at_ble_addr_t)))
     d38:	9503      	str	r5, [sp, #12]
     d3a:	1c20      	adds	r0, r4, #0
     d3c:	9901      	ldr	r1, [sp, #4]
     d3e:	2207      	movs	r2, #7
     d40:	47b0      	blx	r6
     d42:	2800      	cmp	r0, #0
     d44:	d10a      	bne.n	d5c <ble_connected_state_handler+0xa8>
				{
					ble_dev_info[idx].conn_state = BLE_DEVICE_CONNECTED;
     d46:	9a03      	ldr	r2, [sp, #12]
     d48:	0053      	lsls	r3, r2, #1
     d4a:	4694      	mov	ip, r2
     d4c:	4463      	add	r3, ip
     d4e:	015e      	lsls	r6, r3, #5
     d50:	4b44      	ldr	r3, [pc, #272]	; (e64 <ble_connected_state_handler+0x1b0>)
     d52:	199b      	adds	r3, r3, r6
     d54:	3358      	adds	r3, #88	; 0x58
     d56:	2202      	movs	r2, #2
     d58:	719a      	strb	r2, [r3, #6]
     d5a:	e02b      	b.n	db4 <ble_connected_state_handler+0x100>
     d5c:	3501      	adds	r5, #1
     d5e:	3460      	adds	r4, #96	; 0x60
		}
			
		if (ble_device_count < BLE_MAX_DEVICE_CONNECTED)
		{
			bool conn_exists = false;
			for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     d60:	2d05      	cmp	r5, #5
     d62:	d1e7      	bne.n	d34 <ble_connected_state_handler+0x80>
     d64:	e063      	b.n	e2e <ble_connected_state_handler+0x17a>
     d66:	b2d9      	uxtb	r1, r3
     d68:	4688      	mov	r8, r1
			
			if (!conn_exists)
			{
				for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
				{
					if(ble_dev_info[idx].conn_state == BLE_DEVICE_DEFAULT_IDLE)
     d6a:	1c1d      	adds	r5, r3, #0
     d6c:	7811      	ldrb	r1, [r2, #0]
     d6e:	2900      	cmp	r1, #0
     d70:	d118      	bne.n	da4 <ble_connected_state_handler+0xf0>
     d72:	e002      	b.n	d7a <ble_connected_state_handler+0xc6>
     d74:	2500      	movs	r5, #0
     d76:	2300      	movs	r3, #0
     d78:	4698      	mov	r8, r3
					{
						/* @Todo Need to Handle Random Address */
						memcpy(&ble_dev_info[idx].conn_info, (uint8_t *)conn_params, sizeof(at_ble_connected_t));
     d7a:	006c      	lsls	r4, r5, #1
     d7c:	1960      	adds	r0, r4, r5
     d7e:	0140      	lsls	r0, r0, #5
     d80:	4e38      	ldr	r6, [pc, #224]	; (e64 <ble_connected_state_handler+0x1b0>)
     d82:	1980      	adds	r0, r0, r6
     d84:	9902      	ldr	r1, [sp, #8]
     d86:	2212      	movs	r2, #18
     d88:	4b30      	ldr	r3, [pc, #192]	; (e4c <ble_connected_state_handler+0x198>)
     d8a:	4798      	blx	r3
						ble_device_count++;
     d8c:	4a36      	ldr	r2, [pc, #216]	; (e68 <ble_connected_state_handler+0x1b4>)
     d8e:	7813      	ldrb	r3, [r2, #0]
     d90:	3301      	adds	r3, #1
     d92:	b2db      	uxtb	r3, r3
     d94:	7013      	strb	r3, [r2, #0]
						ble_dev_info[idx].conn_state = BLE_DEVICE_CONNECTED;
     d96:	1963      	adds	r3, r4, r5
     d98:	015b      	lsls	r3, r3, #5
     d9a:	18f3      	adds	r3, r6, r3
     d9c:	3358      	adds	r3, #88	; 0x58
     d9e:	2202      	movs	r2, #2
     da0:	719a      	strb	r2, [r3, #6]
						break;
     da2:	e007      	b.n	db4 <ble_connected_state_handler+0x100>
     da4:	4641      	mov	r1, r8
     da6:	3101      	adds	r1, #1
     da8:	b2c9      	uxtb	r1, r1
     daa:	4688      	mov	r8, r1
     dac:	3301      	adds	r3, #1
     dae:	3260      	adds	r2, #96	; 0x60
				}
			}
			
			if (!conn_exists)
			{
				for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     db0:	2b05      	cmp	r3, #5
     db2:	d1d8      	bne.n	d66 <ble_connected_state_handler+0xb2>
						break;
					}
				}
			}
			
			if(!memcmp((uint8_t *)&ble_peripheral_dev_address, (uint8_t *)&conn_params->peer_addr, sizeof(at_ble_addr_t)))
     db4:	4826      	ldr	r0, [pc, #152]	; (e50 <ble_connected_state_handler+0x19c>)
     db6:	9902      	ldr	r1, [sp, #8]
     db8:	2207      	movs	r2, #7
     dba:	4b26      	ldr	r3, [pc, #152]	; (e54 <ble_connected_state_handler+0x1a0>)
     dbc:	4798      	blx	r3
     dbe:	2800      	cmp	r0, #0
     dc0:	d10d      	bne.n	dde <ble_connected_state_handler+0x12a>
			{
				ble_dev_info[idx].dev_role = AT_BLE_ROLE_CENTRAL;
     dc2:	4643      	mov	r3, r8
     dc4:	005b      	lsls	r3, r3, #1
     dc6:	4443      	add	r3, r8
     dc8:	015b      	lsls	r3, r3, #5
     dca:	4a26      	ldr	r2, [pc, #152]	; (e64 <ble_connected_state_handler+0x1b0>)
     dcc:	18d3      	adds	r3, r2, r3
     dce:	2205      	movs	r2, #5
     dd0:	749a      	strb	r2, [r3, #18]
			{
				ble_dev_info[idx].dev_role = AT_BLE_ROLE_PERIPHERAL;
				peripheral_device_added = true;
			}
			/* Reset the ble_peripheral_dev_address to identify the initiator */
			memset((uint8_t *)&ble_peripheral_dev_address, 0, sizeof(at_ble_addr_t));
     dd2:	4b1f      	ldr	r3, [pc, #124]	; (e50 <ble_connected_state_handler+0x19c>)
     dd4:	2200      	movs	r2, #0
     dd6:	601a      	str	r2, [r3, #0]
     dd8:	809a      	strh	r2, [r3, #4]
     dda:	719a      	strb	r2, [r3, #6]
     ddc:	e02f      	b.n	e3e <ble_connected_state_handler+0x18a>
			{
				ble_dev_info[idx].dev_role = AT_BLE_ROLE_CENTRAL;
			}
			else
			{
				ble_dev_info[idx].dev_role = AT_BLE_ROLE_PERIPHERAL;
     dde:	4643      	mov	r3, r8
     de0:	005b      	lsls	r3, r3, #1
     de2:	4443      	add	r3, r8
     de4:	015b      	lsls	r3, r3, #5
     de6:	4a1f      	ldr	r2, [pc, #124]	; (e64 <ble_connected_state_handler+0x1b0>)
     de8:	18d3      	adds	r3, r2, r3
     dea:	220a      	movs	r2, #10
     dec:	749a      	strb	r2, [r3, #18]
				peripheral_device_added = true;
			}
			/* Reset the ble_peripheral_dev_address to identify the initiator */
			memset((uint8_t *)&ble_peripheral_dev_address, 0, sizeof(at_ble_addr_t));
     dee:	4b18      	ldr	r3, [pc, #96]	; (e50 <ble_connected_state_handler+0x19c>)
     df0:	2100      	movs	r1, #0
     df2:	6019      	str	r1, [r3, #0]
     df4:	8099      	strh	r1, [r3, #4]
     df6:	7199      	strb	r1, [r3, #6]
			at_ble_disconnect(conn_params->handle, AT_BLE_TERMINATED_BY_USER);
		}		
		
#if ((BLE_DEVICE_ROLE == BLE_ROLE_PERIPHERAL) || (BLE_DEVICE_ROLE == BLE_ROLE_ALL))
		
        if((ble_dev_info[idx].dev_role == AT_BLE_ROLE_PERIPHERAL) && (peripheral_device_added))
     df8:	2a0a      	cmp	r2, #10
     dfa:	d120      	bne.n	e3e <ble_connected_state_handler+0x18a>
     dfc:	e007      	b.n	e0e <ble_connected_state_handler+0x15a>
			memset((uint8_t *)&ble_peripheral_dev_address, 0, sizeof(at_ble_addr_t));
					
		}
		else
		{
			DBG_LOG("Max number of connection reached: %d ===>Disconnecting...", ble_device_count);
     dfe:	4b1a      	ldr	r3, [pc, #104]	; (e68 <ble_connected_state_handler+0x1b4>)
     e00:	781b      	ldrb	r3, [r3, #0]
			at_ble_disconnect(conn_params->handle, AT_BLE_TERMINATED_BY_USER);
     e02:	9b02      	ldr	r3, [sp, #8]
     e04:	8918      	ldrh	r0, [r3, #8]
     e06:	2113      	movs	r1, #19
     e08:	4b18      	ldr	r3, [pc, #96]	; (e6c <ble_connected_state_handler+0x1b8>)
     e0a:	4798      	blx	r3
     e0c:	e017      	b.n	e3e <ble_connected_state_handler+0x18a>
		
#if ((BLE_DEVICE_ROLE == BLE_ROLE_PERIPHERAL) || (BLE_DEVICE_ROLE == BLE_ROLE_ALL))
		
        if((ble_dev_info[idx].dev_role == AT_BLE_ROLE_PERIPHERAL) && (peripheral_device_added))
        {
	 		ble_send_slave_sec_request(conn_params->handle);
     e0e:	9b02      	ldr	r3, [sp, #8]
     e10:	8918      	ldrh	r0, [r3, #8]
     e12:	4b17      	ldr	r3, [pc, #92]	; (e70 <ble_connected_state_handler+0x1bc>)
     e14:	4798      	blx	r3
     e16:	e012      	b.n	e3e <ble_connected_state_handler+0x18a>
	else
	{
		DBG_LOG("Device Connection Failed - Status: %d", conn_params->conn_status);
	}
	ALL_UNUSED(peripheral_device_added);
	return AT_BLE_SUCCESS;
     e18:	2700      	movs	r7, #0
     e1a:	e010      	b.n	e3e <ble_connected_state_handler+0x18a>
					DBG_LOG_DEV("New Connection");
				}				
			}
		}
			
		if (ble_device_count < BLE_MAX_DEVICE_CONNECTED)
     e1c:	4b12      	ldr	r3, [pc, #72]	; (e68 <ble_connected_state_handler+0x1b4>)
     e1e:	781b      	ldrb	r3, [r3, #0]
     e20:	b2db      	uxtb	r3, r3
     e22:	2b04      	cmp	r3, #4
     e24:	d8eb      	bhi.n	dfe <ble_connected_state_handler+0x14a>
     e26:	4c0f      	ldr	r4, [pc, #60]	; (e64 <ble_connected_state_handler+0x1b0>)
     e28:	2500      	movs	r5, #0
		{
			bool conn_exists = false;
			for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
			{
				if(!memcmp((uint8_t *)&ble_dev_info[idx].conn_info.peer_addr, (uint8_t *)&conn_params->peer_addr, sizeof(at_ble_addr_t)))
     e2a:	4e0a      	ldr	r6, [pc, #40]	; (e54 <ble_connected_state_handler+0x1a0>)
     e2c:	e782      	b.n	d34 <ble_connected_state_handler+0x80>
			
			if (!conn_exists)
			{
				for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
				{
					if(ble_dev_info[idx].conn_state == BLE_DEVICE_DEFAULT_IDLE)
     e2e:	235e      	movs	r3, #94	; 0x5e
     e30:	4a0c      	ldr	r2, [pc, #48]	; (e64 <ble_connected_state_handler+0x1b0>)
     e32:	5cd3      	ldrb	r3, [r2, r3]
     e34:	2b00      	cmp	r3, #0
     e36:	d09d      	beq.n	d74 <ble_connected_state_handler+0xc0>
     e38:	4a0e      	ldr	r2, [pc, #56]	; (e74 <ble_connected_state_handler+0x1c0>)
     e3a:	2301      	movs	r3, #1
     e3c:	e793      	b.n	d66 <ble_connected_state_handler+0xb2>
	{
		DBG_LOG("Device Connection Failed - Status: %d", conn_params->conn_status);
	}
	ALL_UNUSED(peripheral_device_added);
	return AT_BLE_SUCCESS;
}
     e3e:	1c38      	adds	r0, r7, #0
     e40:	b018      	add	sp, #96	; 0x60
     e42:	bc04      	pop	{r2}
     e44:	4690      	mov	r8, r2
     e46:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e48:	200008fc 	.word	0x200008fc
     e4c:	0000d7eb 	.word	0x0000d7eb
     e50:	200000c0 	.word	0x200000c0
     e54:	0000d7cd 	.word	0x0000d7cd
     e58:	0000d825 	.word	0x0000d825
     e5c:	20000722 	.word	0x20000722
     e60:	000077b5 	.word	0x000077b5
     e64:	200006dc 	.word	0x200006dc
     e68:	200008bc 	.word	0x200008bc
     e6c:	00007755 	.word	0x00007755
     e70:	00000c9d 	.word	0x00000c9d
     e74:	2000079a 	.word	0x2000079a

00000e78 <ble_resolv_rand_addr_handler>:

at_ble_status_t ble_resolv_rand_addr_handler(void *params)
{
     e78:	b5f0      	push	{r4, r5, r6, r7, lr}
     e7a:	4647      	mov	r7, r8
     e7c:	b480      	push	{r7}
	uint8_t idx;	
	bool device_found = false;
	bool peripheral_device_added = false;
	ble_resolv_rand_addr_status = (at_ble_resolv_rand_addr_status_t *)params;	
	
	if(ble_resolv_rand_addr_status->status == AT_BLE_SUCCESS)
     e7e:	7803      	ldrb	r3, [r0, #0]
     e80:	2b00      	cmp	r3, #0
     e82:	d13a      	bne.n	efa <ble_resolv_rand_addr_handler+0x82>
     e84:	4d2f      	ldr	r5, [pc, #188]	; (f44 <ble_resolv_rand_addr_handler+0xcc>)
     e86:	2400      	movs	r4, #0
	{		
		for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
		{
			/* Check the Resolved Address */
			if (!memcmp((uint8_t *)ble_resolv_rand_addr_status->irk, (uint8_t *)ble_dev_info[idx].bond_info.peer_irk.key, AT_BLE_MAX_KEY_LEN))
     e88:	1c46      	adds	r6, r0, #1
     e8a:	4f2f      	ldr	r7, [pc, #188]	; (f48 <ble_resolv_rand_addr_handler+0xd0>)
     e8c:	1c30      	adds	r0, r6, #0
     e8e:	1c29      	adds	r1, r5, #0
     e90:	2210      	movs	r2, #16
     e92:	47b8      	blx	r7
     e94:	2800      	cmp	r0, #0
     e96:	d038      	beq.n	f0a <ble_resolv_rand_addr_handler+0x92>
	bool peripheral_device_added = false;
	ble_resolv_rand_addr_status = (at_ble_resolv_rand_addr_status_t *)params;	
	
	if(ble_resolv_rand_addr_status->status == AT_BLE_SUCCESS)
	{		
		for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     e98:	3401      	adds	r4, #1
     e9a:	b2e4      	uxtb	r4, r4
     e9c:	3560      	adds	r5, #96	; 0x60
     e9e:	2c05      	cmp	r4, #5
     ea0:	d1f4      	bne.n	e8c <ble_resolv_rand_addr_handler+0x14>
     ea2:	e02a      	b.n	efa <ble_resolv_rand_addr_handler+0x82>
     ea4:	b2dc      	uxtb	r4, r3
	else
	{
		DBG_LOG_DEV("##########Device Not Found");
		for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
		{
			if(ble_dev_info[idx].conn_state == BLE_DEVICE_DEFAULT_IDLE)
     ea6:	1c1d      	adds	r5, r3, #0
     ea8:	7811      	ldrb	r1, [r2, #0]
     eaa:	2900      	cmp	r1, #0
     eac:	d11b      	bne.n	ee6 <ble_resolv_rand_addr_handler+0x6e>
     eae:	e001      	b.n	eb4 <ble_resolv_rand_addr_handler+0x3c>
     eb0:	2500      	movs	r5, #0
     eb2:	2400      	movs	r4, #0
			{
				memcpy(&ble_dev_info[idx].conn_info, (uint8_t *)&connected_state_info, sizeof(at_ble_connected_t));
     eb4:	4f25      	ldr	r7, [pc, #148]	; (f4c <ble_resolv_rand_addr_handler+0xd4>)
     eb6:	006b      	lsls	r3, r5, #1
     eb8:	4698      	mov	r8, r3
     eba:	195e      	adds	r6, r3, r5
     ebc:	0176      	lsls	r6, r6, #5
     ebe:	19be      	adds	r6, r7, r6
     ec0:	1c30      	adds	r0, r6, #0
     ec2:	4923      	ldr	r1, [pc, #140]	; (f50 <ble_resolv_rand_addr_handler+0xd8>)
     ec4:	2212      	movs	r2, #18
     ec6:	4b23      	ldr	r3, [pc, #140]	; (f54 <ble_resolv_rand_addr_handler+0xdc>)
     ec8:	4798      	blx	r3
				ble_device_count++;
     eca:	4a23      	ldr	r2, [pc, #140]	; (f58 <ble_resolv_rand_addr_handler+0xe0>)
     ecc:	7813      	ldrb	r3, [r2, #0]
     ece:	3301      	adds	r3, #1
     ed0:	b2db      	uxtb	r3, r3
     ed2:	7013      	strb	r3, [r2, #0]
				ble_dev_info[idx].conn_state = BLE_DEVICE_CONNECTED;
     ed4:	3658      	adds	r6, #88	; 0x58
     ed6:	2302      	movs	r3, #2
     ed8:	71b3      	strb	r3, [r6, #6]
				ble_dev_info[idx].dev_role = AT_BLE_ROLE_PERIPHERAL;
     eda:	4445      	add	r5, r8
     edc:	016d      	lsls	r5, r5, #5
     ede:	197d      	adds	r5, r7, r5
     ee0:	3308      	adds	r3, #8
     ee2:	74ab      	strb	r3, [r5, #18]
				peripheral_device_added = true;
				break;
     ee4:	e021      	b.n	f2a <ble_resolv_rand_addr_handler+0xb2>
     ee6:	3301      	adds	r3, #1
     ee8:	3260      	adds	r2, #96	; 0x60
		peripheral_device_added = true;
	}
	else
	{
		DBG_LOG_DEV("##########Device Not Found");
		for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
     eea:	2b05      	cmp	r3, #5
     eec:	d1da      	bne.n	ea4 <ble_resolv_rand_addr_handler+0x2c>
     eee:	e024      	b.n	f3a <ble_resolv_rand_addr_handler+0xc2>
	}
	DBG_LOG_DEV("Device idx:%d",idx);
	#if ((BLE_DEVICE_ROLE == BLE_ROLE_PERIPHERAL) || (BLE_DEVICE_ROLE == BLE_ROLE_ALL))
	if((ble_dev_info[idx].dev_role == AT_BLE_ROLE_PERIPHERAL) && (peripheral_device_added))
	{
		ble_send_slave_sec_request(connected_state_info.handle);
     ef0:	4b17      	ldr	r3, [pc, #92]	; (f50 <ble_resolv_rand_addr_handler+0xd8>)
     ef2:	8918      	ldrh	r0, [r3, #8]
     ef4:	4b19      	ldr	r3, [pc, #100]	; (f5c <ble_resolv_rand_addr_handler+0xe4>)
     ef6:	4798      	blx	r3
     ef8:	e01f      	b.n	f3a <ble_resolv_rand_addr_handler+0xc2>
	else
	{
		DBG_LOG_DEV("##########Device Not Found");
		for (idx = 0; idx < BLE_MAX_DEVICE_CONNECTED; idx++)
		{
			if(ble_dev_info[idx].conn_state == BLE_DEVICE_DEFAULT_IDLE)
     efa:	235e      	movs	r3, #94	; 0x5e
     efc:	4a13      	ldr	r2, [pc, #76]	; (f4c <ble_resolv_rand_addr_handler+0xd4>)
     efe:	5cd3      	ldrb	r3, [r2, r3]
     f00:	2b00      	cmp	r3, #0
     f02:	d0d5      	beq.n	eb0 <ble_resolv_rand_addr_handler+0x38>
     f04:	4a16      	ldr	r2, [pc, #88]	; (f60 <ble_resolv_rand_addr_handler+0xe8>)
     f06:	2301      	movs	r3, #1
     f08:	e7cc      	b.n	ea4 <ble_resolv_rand_addr_handler+0x2c>
	}
	
	if (device_found)
	{
		DBG_LOG_DEV("##########Device Found");
		ble_dev_info[idx].conn_state = BLE_DEVICE_CONNECTED;
     f0a:	4910      	ldr	r1, [pc, #64]	; (f4c <ble_resolv_rand_addr_handler+0xd4>)
     f0c:	0063      	lsls	r3, r4, #1
     f0e:	191a      	adds	r2, r3, r4
     f10:	0152      	lsls	r2, r2, #5
     f12:	188a      	adds	r2, r1, r2
     f14:	1c10      	adds	r0, r2, #0
     f16:	3058      	adds	r0, #88	; 0x58
     f18:	2502      	movs	r5, #2
     f1a:	7185      	strb	r5, [r0, #6]
		ble_dev_info[idx].dev_role = AT_BLE_ROLE_PERIPHERAL;
     f1c:	200a      	movs	r0, #10
     f1e:	7490      	strb	r0, [r2, #18]
		memcpy((uint8_t *)&ble_dev_info[idx].conn_info, (uint8_t *)&connected_state_info, sizeof(at_ble_connected_t));
     f20:	1c10      	adds	r0, r2, #0
     f22:	490b      	ldr	r1, [pc, #44]	; (f50 <ble_resolv_rand_addr_handler+0xd8>)
     f24:	2212      	movs	r2, #18
     f26:	4b0b      	ldr	r3, [pc, #44]	; (f54 <ble_resolv_rand_addr_handler+0xdc>)
     f28:	4798      	blx	r3
			}
		}
	}
	DBG_LOG_DEV("Device idx:%d",idx);
	#if ((BLE_DEVICE_ROLE == BLE_ROLE_PERIPHERAL) || (BLE_DEVICE_ROLE == BLE_ROLE_ALL))
	if((ble_dev_info[idx].dev_role == AT_BLE_ROLE_PERIPHERAL) && (peripheral_device_added))
     f2a:	0063      	lsls	r3, r4, #1
     f2c:	191c      	adds	r4, r3, r4
     f2e:	0164      	lsls	r4, r4, #5
     f30:	4b06      	ldr	r3, [pc, #24]	; (f4c <ble_resolv_rand_addr_handler+0xd4>)
     f32:	191c      	adds	r4, r3, r4
     f34:	7ca3      	ldrb	r3, [r4, #18]
     f36:	2b0a      	cmp	r3, #10
     f38:	d0da      	beq.n	ef0 <ble_resolv_rand_addr_handler+0x78>
	#endif
	ALL_UNUSED(peripheral_device_added);

	return AT_BLE_SUCCESS;
	
}
     f3a:	2000      	movs	r0, #0
     f3c:	bc04      	pop	{r2}
     f3e:	4690      	mov	r8, r2
     f40:	bdf0      	pop	{r4, r5, r6, r7, pc}
     f42:	46c0      	nop			; (mov r8, r8)
     f44:	20000722 	.word	0x20000722
     f48:	0000d7cd 	.word	0x0000d7cd
     f4c:	200006dc 	.word	0x200006dc
     f50:	200008fc 	.word	0x200008fc
     f54:	0000d7eb 	.word	0x0000d7eb
     f58:	200008bc 	.word	0x200008bc
     f5c:	00000c9d 	.word	0x00000c9d
     f60:	2000079a 	.word	0x2000079a

00000f64 <ble_event_manager>:
	}
	return AT_BLE_SUCCESS;
}

void ble_event_manager(at_ble_events_t events, void *event_params)
{
     f64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	DBG_LOG_DEV("BLE-Event:%d", events);
	switch(events)
     f66:	283a      	cmp	r0, #58	; 0x3a
     f68:	d86c      	bhi.n	1044 <ble_event_manager+0xe0>
     f6a:	1c0d      	adds	r5, r1, #0
     f6c:	0083      	lsls	r3, r0, #2
     f6e:	4a36      	ldr	r2, [pc, #216]	; (1048 <ble_event_manager+0xe4>)
     f70:	58d3      	ldr	r3, [r2, r3]
     f72:	469f      	mov	pc, r3
		for (idx = 0; idx < MAX_GAP_EVENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_gap_event_cb[idx] != NULL)
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_gap_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     f74:	0084      	lsls	r4, r0, #2
     f76:	2600      	movs	r6, #0
	case AT_BLE_CON_CHANNEL_MAP_IND:
	{
		uint8_t idx;
		for (idx = 0; idx < MAX_GAP_EVENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_gap_event_cb[idx] != NULL)
     f78:	4f34      	ldr	r7, [pc, #208]	; (104c <ble_event_manager+0xe8>)
     f7a:	59bb      	ldr	r3, [r7, r6]
     f7c:	2b00      	cmp	r3, #0
     f7e:	d004      	beq.n	f8a <ble_event_manager+0x26>
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_gap_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     f80:	591b      	ldr	r3, [r3, r4]
     f82:	2b00      	cmp	r3, #0
     f84:	d001      	beq.n	f8a <ble_event_manager+0x26>
				{
					event_cb_fn[events](event_params);
     f86:	1c28      	adds	r0, r5, #0
     f88:	4798      	blx	r3
     f8a:	3604      	adds	r6, #4
	case AT_BLE_SIGN_COUNTERS_IND:
	case AT_BLE_PEER_ATT_INFO_IND:
	case AT_BLE_CON_CHANNEL_MAP_IND:
	{
		uint8_t idx;
		for (idx = 0; idx < MAX_GAP_EVENT_SUBSCRIBERS; idx++)
     f8c:	2e14      	cmp	r6, #20
     f8e:	d1f4      	bne.n	f7a <ble_event_manager+0x16>
     f90:	e058      	b.n	1044 <ble_event_manager+0xe0>
	case AT_BLE_CHARACTERISTIC_WRITE_RESPONSE:
	case AT_BLE_NOTIFICATION_RECIEVED:
	case AT_BLE_INDICATION_RECIEVED:
	{
		uint8_t idx;
		events -= (AT_BLE_CON_CHANNEL_MAP_IND + 1);
     f92:	3813      	subs	r0, #19
		for (idx = 0; idx < MAX_GATT_CLIENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_gatt_client_event_cb[idx] != NULL)
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_gatt_client_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     f94:	b2c4      	uxtb	r4, r0
     f96:	00a4      	lsls	r4, r4, #2
     f98:	2600      	movs	r6, #0
	{
		uint8_t idx;
		events -= (AT_BLE_CON_CHANNEL_MAP_IND + 1);
		for (idx = 0; idx < MAX_GATT_CLIENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_gatt_client_event_cb[idx] != NULL)
     f9a:	4f2d      	ldr	r7, [pc, #180]	; (1050 <ble_event_manager+0xec>)
     f9c:	59bb      	ldr	r3, [r7, r6]
     f9e:	2b00      	cmp	r3, #0
     fa0:	d004      	beq.n	fac <ble_event_manager+0x48>
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_gatt_client_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     fa2:	591b      	ldr	r3, [r3, r4]
     fa4:	2b00      	cmp	r3, #0
     fa6:	d001      	beq.n	fac <ble_event_manager+0x48>
				{
					event_cb_fn[events](event_params);
     fa8:	1c28      	adds	r0, r5, #0
     faa:	4798      	blx	r3
     fac:	3604      	adds	r6, #4
	case AT_BLE_NOTIFICATION_RECIEVED:
	case AT_BLE_INDICATION_RECIEVED:
	{
		uint8_t idx;
		events -= (AT_BLE_CON_CHANNEL_MAP_IND + 1);
		for (idx = 0; idx < MAX_GATT_CLIENT_SUBSCRIBERS; idx++)
     fae:	2e14      	cmp	r6, #20
     fb0:	d1f4      	bne.n	f9c <ble_event_manager+0x38>
     fb2:	e047      	b.n	1044 <ble_event_manager+0xe0>
	case AT_BLE_MTU_CHANGED_CMD_COMPLETE:
	case AT_BLE_CHARACTERISTIC_WRITE_CMD_CMP:
	case AT_BLE_READ_AUTHORIZE_REQUEST:
	{
		uint8_t idx;
		events -= (AT_BLE_INDICATION_RECIEVED + 1);
     fb4:	381d      	subs	r0, #29
		for (idx = 0; idx < MAX_GATT_SERVER_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_gatt_server_event_cb[idx] != NULL)
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_gatt_server_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     fb6:	b2c4      	uxtb	r4, r0
     fb8:	00a4      	lsls	r4, r4, #2
     fba:	2600      	movs	r6, #0
		uint8_t idx;
		events -= (AT_BLE_INDICATION_RECIEVED + 1);
		DBG_LOG_DEV("GATT_Server Event:%d", events);
		for (idx = 0; idx < MAX_GATT_SERVER_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_gatt_server_event_cb[idx] != NULL)
     fbc:	4f25      	ldr	r7, [pc, #148]	; (1054 <ble_event_manager+0xf0>)
     fbe:	59bb      	ldr	r3, [r7, r6]
     fc0:	2b00      	cmp	r3, #0
     fc2:	d004      	beq.n	fce <ble_event_manager+0x6a>
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_gatt_server_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     fc4:	591b      	ldr	r3, [r3, r4]
     fc6:	2b00      	cmp	r3, #0
     fc8:	d001      	beq.n	fce <ble_event_manager+0x6a>
				{
					event_cb_fn[events](event_params);
     fca:	1c28      	adds	r0, r5, #0
     fcc:	4798      	blx	r3
     fce:	3604      	adds	r6, #4
	case AT_BLE_READ_AUTHORIZE_REQUEST:
	{
		uint8_t idx;
		events -= (AT_BLE_INDICATION_RECIEVED + 1);
		DBG_LOG_DEV("GATT_Server Event:%d", events);
		for (idx = 0; idx < MAX_GATT_SERVER_SUBSCRIBERS; idx++)
     fd0:	2e14      	cmp	r6, #20
     fd2:	d1f4      	bne.n	fbe <ble_event_manager+0x5a>
     fd4:	e036      	b.n	1044 <ble_event_manager+0xe0>
	case AT_BLE_LECB_ADD_CREDIT_IND:
	case AT_BLE_LECB_SEND_RESP:
	case AT_BLE_LECB_DATA_RECIEVED:
	{
		uint8_t idx;
		events -= (AT_BLE_READ_AUTHORIZE_REQUEST + 1);
     fd6:	3827      	subs	r0, #39	; 0x27
     fd8:	b2c0      	uxtb	r0, r0
		for (idx = 0; idx < MAX_L2CAP_EVENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_l2cap_event_cb[idx] != NULL)
     fda:	4b1f      	ldr	r3, [pc, #124]	; (1058 <ble_event_manager+0xf4>)
     fdc:	681b      	ldr	r3, [r3, #0]
     fde:	2b00      	cmp	r3, #0
     fe0:	d030      	beq.n	1044 <ble_event_manager+0xe0>
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_l2cap_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     fe2:	0080      	lsls	r0, r0, #2
     fe4:	58c3      	ldr	r3, [r0, r3]
     fe6:	2b00      	cmp	r3, #0
     fe8:	d02c      	beq.n	1044 <ble_event_manager+0xe0>
				{
					event_cb_fn[events](event_params);
     fea:	1c08      	adds	r0, r1, #0
     fec:	4798      	blx	r3
     fee:	e029      	b.n	1044 <ble_event_manager+0xe0>
	case AT_BLE_HTPT_ENABLE_RSP:
	case AT_BLE_HTPT_MEAS_INTV_UPD_RSP:
	case AT_BLE_HTPT_MEAS_INTV_CHG_REQ:
	{
		uint8_t idx;
		events -= (AT_BLE_LECB_DATA_RECIEVED + 1);
     ff0:	382d      	subs	r0, #45	; 0x2d
     ff2:	b2c0      	uxtb	r0, r0
		for (idx = 0; idx < MAX_HTPT_EVENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_htpt_event_cb[idx] != NULL)
     ff4:	4b19      	ldr	r3, [pc, #100]	; (105c <ble_event_manager+0xf8>)
     ff6:	681b      	ldr	r3, [r3, #0]
     ff8:	2b00      	cmp	r3, #0
     ffa:	d023      	beq.n	1044 <ble_event_manager+0xe0>
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_htpt_event_cb[idx];
				if(event_cb_fn[events] != NULL)
     ffc:	0080      	lsls	r0, r0, #2
     ffe:	58c3      	ldr	r3, [r0, r3]
    1000:	2b00      	cmp	r3, #0
    1002:	d01f      	beq.n	1044 <ble_event_manager+0xe0>
				{
					event_cb_fn[events](event_params);
    1004:	1c08      	adds	r0, r1, #0
    1006:	4798      	blx	r3
    1008:	e01c      	b.n	1044 <ble_event_manager+0xe0>
	
	case AT_BLE_LE_TEST_STATUS:
	case AT_BLE_LE_PACKET_REPORT:
	{
		uint8_t idx;
		events -= (AT_BLE_HTPT_MEAS_INTV_CHG_REQ + 1);
    100a:	3836      	subs	r0, #54	; 0x36
		for (idx = 0; idx < MAX_DTM_EVENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_dtm_event_cb[idx] != NULL)
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_dtm_event_cb[idx];
				if(event_cb_fn[events] != NULL)
    100c:	b2c4      	uxtb	r4, r0
    100e:	00a4      	lsls	r4, r4, #2
    1010:	2600      	movs	r6, #0
	{
		uint8_t idx;
		events -= (AT_BLE_HTPT_MEAS_INTV_CHG_REQ + 1);
		for (idx = 0; idx < MAX_DTM_EVENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_dtm_event_cb[idx] != NULL)
    1012:	4f13      	ldr	r7, [pc, #76]	; (1060 <ble_event_manager+0xfc>)
    1014:	59bb      	ldr	r3, [r7, r6]
    1016:	2b00      	cmp	r3, #0
    1018:	d004      	beq.n	1024 <ble_event_manager+0xc0>
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_dtm_event_cb[idx];
				if(event_cb_fn[events] != NULL)
    101a:	591b      	ldr	r3, [r3, r4]
    101c:	2b00      	cmp	r3, #0
    101e:	d001      	beq.n	1024 <ble_event_manager+0xc0>
				{
					event_cb_fn[events](event_params);
    1020:	1c28      	adds	r0, r5, #0
    1022:	4798      	blx	r3
    1024:	3604      	adds	r6, #4
	case AT_BLE_LE_TEST_STATUS:
	case AT_BLE_LE_PACKET_REPORT:
	{
		uint8_t idx;
		events -= (AT_BLE_HTPT_MEAS_INTV_CHG_REQ + 1);
		for (idx = 0; idx < MAX_DTM_EVENT_SUBSCRIBERS; idx++)
    1026:	2e14      	cmp	r6, #20
    1028:	d1f4      	bne.n	1014 <ble_event_manager+0xb0>
    102a:	e00b      	b.n	1044 <ble_event_manager+0xe0>
	case AT_BLE_CUSTOM_EVENT:
	case AT_BLE_DEVICE_READY:
	case AT_BLE_EVENT_MAX:
	{
		uint8_t idx;
		events -= (AT_BLE_LE_PACKET_REPORT + 1);
    102c:	3838      	subs	r0, #56	; 0x38
    102e:	b2c0      	uxtb	r0, r0
		for (idx = 0; idx < MAX_CUSTOM_EVENT_SUBSCRIBERS; idx++)
		{
			if (ble_mgr_custom_event_cb[idx] != NULL)
    1030:	4b0c      	ldr	r3, [pc, #48]	; (1064 <ble_event_manager+0x100>)
    1032:	681b      	ldr	r3, [r3, #0]
    1034:	2b00      	cmp	r3, #0
    1036:	d005      	beq.n	1044 <ble_event_manager+0xe0>
			{
				const ble_event_callback_t *event_cb_fn = ble_mgr_custom_event_cb[idx];
				if(event_cb_fn[events] != NULL)
    1038:	0080      	lsls	r0, r0, #2
    103a:	58c3      	ldr	r3, [r0, r3]
    103c:	2b00      	cmp	r3, #0
    103e:	d001      	beq.n	1044 <ble_event_manager+0xe0>
				{
					event_cb_fn[events](event_params);
    1040:	1c08      	adds	r0, r1, #0
    1042:	4798      	blx	r3
		DBG_LOG_DEV("BLE-Manager:Unknown Event=0x%X", events);
		DBG_LOG("\r\n");
	}
	break;		
	}
}
    1044:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1046:	46c0      	nop			; (mov r8, r8)
    1048:	0000e8ac 	.word	0x0000e8ac
    104c:	200008d4 	.word	0x200008d4
    1050:	200008e8 	.word	0x200008e8
    1054:	200006c8 	.word	0x200006c8
    1058:	20000910 	.word	0x20000910
    105c:	200006c4 	.word	0x200006c4
    1060:	200008c0 	.word	0x200008c0
    1064:	20001334 	.word	0x20001334

00001068 <ble_event_task>:
/** @brief Set BLE Address, If address is NULL then it will use BD public address */
static void ble_set_address(at_ble_addr_t *addr);

/** @brief function to get event from stack */
at_ble_status_t ble_event_task(void)
{
    1068:	b510      	push	{r4, lr}
    if (at_ble_event_get(&event, ble_event_params, BLE_EVENT_TIMEOUT) == AT_BLE_SUCCESS) 
    106a:	4808      	ldr	r0, [pc, #32]	; (108c <ble_event_task+0x24>)
    106c:	4908      	ldr	r1, [pc, #32]	; (1090 <ble_event_task+0x28>)
    106e:	2214      	movs	r2, #20
    1070:	4b08      	ldr	r3, [pc, #32]	; (1094 <ble_event_task+0x2c>)
    1072:	4798      	blx	r3
    1074:	1e04      	subs	r4, r0, #0
    1076:	d105      	bne.n	1084 <ble_event_task+0x1c>
    {
            ble_event_manager(event, ble_event_params);
    1078:	4b04      	ldr	r3, [pc, #16]	; (108c <ble_event_task+0x24>)
    107a:	7818      	ldrb	r0, [r3, #0]
    107c:	4904      	ldr	r1, [pc, #16]	; (1090 <ble_event_task+0x28>)
    107e:	4b06      	ldr	r3, [pc, #24]	; (1098 <ble_event_task+0x30>)
    1080:	4798      	blx	r3
            return AT_BLE_SUCCESS;
    1082:	e000      	b.n	1086 <ble_event_task+0x1e>
    }
    
    return AT_BLE_FAILURE;
    1084:	24e2      	movs	r4, #226	; 0xe2
}
    1086:	1c20      	adds	r0, r4, #0
    1088:	bd10      	pop	{r4, pc}
    108a:	46c0      	nop			; (mov r8, r8)
    108c:	2000090e 	.word	0x2000090e
    1090:	20001128 	.word	0x20001128
    1094:	00006b79 	.word	0x00006b79
    1098:	00000f65 	.word	0x00000f65

0000109c <ble_advertisement_data_set>:
	}
}

/* Advertisement Data will be set based on the advertisement configuration */
at_ble_status_t ble_advertisement_data_set(void)
{
    109c:	b570      	push	{r4, r5, r6, lr}
    109e:	b090      	sub	sp, #64	; 0x40
		uint8_t length_field_ind;
		uint8_t adv_element_len;
		adv_buf[adv_data_element.len] = adv_data_element.len;
		length_field_ind = adv_data_element.len;
		adv_data_element.len++;
		adv_buf[adv_data_element.len++] = COMPLETE_LIST_16BIT_SERV_UUIDS;
    10a0:	ac08      	add	r4, sp, #32
    10a2:	2303      	movs	r3, #3
    10a4:	7063      	strb	r3, [r4, #1]
		MREPEAT(SERVICE_UUID16_MAX_NUM, _CONF_SERVICE_16BIT_UUID, &adv_data_element);
    10a6:	220f      	movs	r2, #15
    10a8:	70a2      	strb	r2, [r4, #2]
    10aa:	3209      	adds	r2, #9
    10ac:	70e2      	strb	r2, [r4, #3]
		adv_element_len = adv_data_element.len - (length_field_ind + ADV_ELEMENT_SIZE);
		if(adv_element_len) 
		{			
			adv_buf[length_field_ind] = adv_element_len+ADV_TYPE_SIZE;
    10ae:	7023      	strb	r3, [r4, #0]
	#endif
	
	#if (BLE_GAP_ADV_COMPLETE_LOCAL_NAME_ENABLE && !BLE_GAP_ADV_SHORTENED_LOCAL_NAME_ENABLE)
	#if (BLE_GAP_ADV_COMPLETE_LOCAL_NAME_SCN_RSP_ENABLE != SCAN_RESPONSE_ONLY_ENABLE)
	if((adv_data_element.len) <= (AT_BLE_ADV_MAX_SIZE - (ADV_TYPE_FLAG_SIZE + ADV_ELEMENT_SIZE + BLE_GAP_ADV_DATA_COMPLETE_LOCAL_NAME_LENGTH))) {
		adv_buf[adv_data_element.len++] = BLE_GAP_ADV_DATA_COMPLETE_LOCAL_NAME_LENGTH + ADV_TYPE_SIZE;
    10b0:	3307      	adds	r3, #7
    10b2:	7123      	strb	r3, [r4, #4]
		adv_buf[adv_data_element.len++] = COMPLETE_LOCAL_NAME;
    10b4:	2609      	movs	r6, #9
    10b6:	7166      	strb	r6, [r4, #5]
		memcpy(&adv_buf[adv_data_element.len], BLE_GAP_ADV_DATA_COMPLETE_LOCAL_NAME, BLE_GAP_ADV_DATA_COMPLETE_LOCAL_NAME_LENGTH);
    10b8:	2026      	movs	r0, #38	; 0x26
    10ba:	4468      	add	r0, sp
    10bc:	490d      	ldr	r1, [pc, #52]	; (10f4 <ble_advertisement_data_set+0x58>)
    10be:	3a0f      	subs	r2, #15
    10c0:	4d0d      	ldr	r5, [pc, #52]	; (10f8 <ble_advertisement_data_set+0x5c>)
    10c2:	47a8      	blx	r5
	#endif
	#if ((BLE_GAP_ADV_SERVICE_SOLTN_128BIT_UUID_SCN_RSP_ENABLE == SCAN_RESPONSE_ENABLE) || (BLE_GAP_ADV_SERVICE_SOLTN_128BIT_UUID_SCN_RSP_ENABLE == SCAN_RESPONSE_ONLY_ENABLE))
	else if((scan_resp_data_element.len) <= (AT_BLE_ADV_MAX_SIZE - (ADV_ELEMENT_SIZE + BLE_GAP_ADV_SERVICE_128BIT_UUID_LENGTH))) {
		uint8_t length_field_ind;
		uint8_t scan_resp_element_len;
		scn_resp[scan_resp_data_element.len] = scan_resp_data_element.len;
    10c4:	2300      	movs	r3, #0
    10c6:	466a      	mov	r2, sp
    10c8:	7013      	strb	r3, [r2, #0]
		length_field_ind = scan_resp_data_element.len;
		scan_resp_data_element.len++;
		scn_resp[scan_resp_data_element.len++] = LIST_128BIT_SERV_SOLICITATION_UUIDS;
    10ca:	3315      	adds	r3, #21
    10cc:	7053      	strb	r3, [r2, #1]
	#endif
	
	#if BLE_GAP_ADV_MANUFACTURER_SPECIFIC_DATA_ENABLE
	#if (BLE_GAP_ADV_MANUFACTURER_SPECIFIC_DATA_SCN_RSP_ENABLE != SCAN_RESPONSE_ONLY_ENABLE)
	if((adv_data_element.len) <= (AT_BLE_ADV_MAX_SIZE - (ADV_TYPE_FLAG_SIZE + ADV_ELEMENT_SIZE + BLE_GAP_ADV_DATA_MANUFACTURER_SPECIFIC_DATA_SIZE))) {
		adv_buf[adv_data_element.len++] = BLE_GAP_ADV_DATA_MANUFACTURER_SPECIFIC_DATA_SIZE + ADV_TYPE_SIZE;
    10ce:	73e6      	strb	r6, [r4, #15]
		adv_buf[adv_data_element.len++] = MANUFACTURER_SPECIFIC_DATA;
    10d0:	33ea      	adds	r3, #234	; 0xea
    10d2:	7423      	strb	r3, [r4, #16]
		memcpy(&adv_buf[adv_data_element.len], BLE_GAP_ADV_DATA_MANUFACTURER_SPECIFIC_DATA, BLE_GAP_ADV_DATA_MANUFACTURER_SPECIFIC_DATA_SIZE);
    10d4:	2031      	movs	r0, #49	; 0x31
    10d6:	4468      	add	r0, sp
    10d8:	4908      	ldr	r1, [pc, #32]	; (10fc <ble_advertisement_data_set+0x60>)
    10da:	3110      	adds	r1, #16
    10dc:	2208      	movs	r2, #8
    10de:	47a8      	blx	r5
		DBG_LOG_ADV("Failed to add Manufacturer specific data");
		return AT_BLE_GAP_INVALID_PARAM;
	}
	#endif
	
	if (at_ble_adv_data_set(adv_buf, adv_data_element.len, scn_resp,
    10e0:	1c20      	adds	r0, r4, #0
    10e2:	2119      	movs	r1, #25
    10e4:	466a      	mov	r2, sp
    10e6:	2300      	movs	r3, #0
    10e8:	4c05      	ldr	r4, [pc, #20]	; (1100 <ble_advertisement_data_set+0x64>)
    10ea:	47a0      	blx	r4
		return status;
		} else {
		DBG_LOG_DEV("BLE Advertisement data set success");
		return AT_BLE_SUCCESS;
	}
}
    10ec:	2000      	movs	r0, #0
    10ee:	b010      	add	sp, #64	; 0x40
    10f0:	bd70      	pop	{r4, r5, r6, pc}
    10f2:	46c0      	nop			; (mov r8, r8)
    10f4:	0000ea28 	.word	0x0000ea28
    10f8:	0000d7eb 	.word	0x0000d7eb
    10fc:	0000e998 	.word	0x0000e998
    1100:	0000758d 	.word	0x0000758d

00001104 <serial_drv_write_cb>:
{
	return usart_read_job(&usart_instance, data);
}

static void serial_drv_write_cb(struct usart_module *const usart_module)
{
    1104:	b570      	push	{r4, r5, r6, lr}
	/* USART Tx callback */
	if(ble_txbyte_count)
    1106:	4b10      	ldr	r3, [pc, #64]	; (1148 <serial_drv_write_cb+0x44>)
    1108:	881b      	ldrh	r3, [r3, #0]
    110a:	b29b      	uxth	r3, r3
    110c:	2b00      	cmp	r3, #0
    110e:	d018      	beq.n	1142 <serial_drv_write_cb+0x3e>
	{
		g_txdata = *ble_txbuf_ptr;
    1110:	4b0e      	ldr	r3, [pc, #56]	; (114c <serial_drv_write_cb+0x48>)
    1112:	681b      	ldr	r3, [r3, #0]
    1114:	781a      	ldrb	r2, [r3, #0]
    1116:	4b0e      	ldr	r3, [pc, #56]	; (1150 <serial_drv_write_cb+0x4c>)
    1118:	801a      	strh	r2, [r3, #0]
		while(STATUS_OK != usart_write_job(&usart_instance, &g_txdata));
    111a:	4e0e      	ldr	r6, [pc, #56]	; (1154 <serial_drv_write_cb+0x50>)
    111c:	1c1d      	adds	r5, r3, #0
    111e:	4c0e      	ldr	r4, [pc, #56]	; (1158 <serial_drv_write_cb+0x54>)
    1120:	1c30      	adds	r0, r6, #0
    1122:	1c29      	adds	r1, r5, #0
    1124:	47a0      	blx	r4
    1126:	2800      	cmp	r0, #0
    1128:	d1fa      	bne.n	1120 <serial_drv_write_cb+0x1c>
		if(--ble_txbyte_count)
    112a:	4a07      	ldr	r2, [pc, #28]	; (1148 <serial_drv_write_cb+0x44>)
    112c:	8813      	ldrh	r3, [r2, #0]
    112e:	3b01      	subs	r3, #1
    1130:	b29b      	uxth	r3, r3
    1132:	8013      	strh	r3, [r2, #0]
    1134:	2b00      	cmp	r3, #0
    1136:	d006      	beq.n	1146 <serial_drv_write_cb+0x42>
		{
			++ble_txbuf_ptr;
    1138:	4a04      	ldr	r2, [pc, #16]	; (114c <serial_drv_write_cb+0x48>)
    113a:	6813      	ldr	r3, [r2, #0]
    113c:	3301      	adds	r3, #1
    113e:	6013      	str	r3, [r2, #0]
    1140:	e001      	b.n	1146 <serial_drv_write_cb+0x42>
		}
	}
	else
	{
		#if SERIAL_DRV_TX_CB_ENABLE == true
			SERIAL_DRV_TX_CB();
    1142:	4b06      	ldr	r3, [pc, #24]	; (115c <serial_drv_write_cb+0x58>)
    1144:	4798      	blx	r3
		#endif
	}		
}
    1146:	bd70      	pop	{r4, r5, r6, pc}
    1148:	200000ca 	.word	0x200000ca
    114c:	200000cc 	.word	0x200000cc
    1150:	20001378 	.word	0x20001378
    1154:	20001344 	.word	0x20001344
    1158:	000051d9 	.word	0x000051d9
    115c:	00001b79 	.word	0x00001b79

00001160 <serial_drv_send>:
	usart_configure_flowcontrol();
	#endif	
}

uint16_t serial_drv_send(uint8_t* data, uint16_t len)
{  
    1160:	b570      	push	{r4, r5, r6, lr}
    1162:	1c04      	adds	r4, r0, #0
    1164:	1c0d      	adds	r5, r1, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    1166:	4b15      	ldr	r3, [pc, #84]	; (11bc <serial_drv_send+0x5c>)
    1168:	4798      	blx	r3
  system_interrupt_enter_critical_section();
  ble_txbuf_ptr = data;
    116a:	4b15      	ldr	r3, [pc, #84]	; (11c0 <serial_drv_send+0x60>)
    116c:	601c      	str	r4, [r3, #0]
  ble_txbyte_count = len;
    116e:	4c15      	ldr	r4, [pc, #84]	; (11c4 <serial_drv_send+0x64>)
    1170:	8025      	strh	r5, [r4, #0]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    1172:	4b15      	ldr	r3, [pc, #84]	; (11c8 <serial_drv_send+0x68>)
    1174:	4798      	blx	r3
  system_interrupt_leave_critical_section();
  
  if(ble_txbyte_count)
    1176:	8823      	ldrh	r3, [r4, #0]
    1178:	b29b      	uxth	r3, r3
    117a:	2b00      	cmp	r3, #0
    117c:	d017      	beq.n	11ae <serial_drv_send+0x4e>
  {
	  g_txdata = *ble_txbuf_ptr;
    117e:	4b10      	ldr	r3, [pc, #64]	; (11c0 <serial_drv_send+0x60>)
    1180:	681b      	ldr	r3, [r3, #0]
    1182:	781a      	ldrb	r2, [r3, #0]
    1184:	4b11      	ldr	r3, [pc, #68]	; (11cc <serial_drv_send+0x6c>)
    1186:	801a      	strh	r2, [r3, #0]
	  while(STATUS_OK != usart_write_job(&usart_instance, &g_txdata));
    1188:	4e11      	ldr	r6, [pc, #68]	; (11d0 <serial_drv_send+0x70>)
    118a:	1c1d      	adds	r5, r3, #0
    118c:	4c11      	ldr	r4, [pc, #68]	; (11d4 <serial_drv_send+0x74>)
    118e:	1c30      	adds	r0, r6, #0
    1190:	1c29      	adds	r1, r5, #0
    1192:	47a0      	blx	r4
    1194:	2800      	cmp	r0, #0
    1196:	d1fa      	bne.n	118e <serial_drv_send+0x2e>
	  if(--ble_txbyte_count)
    1198:	4a0a      	ldr	r2, [pc, #40]	; (11c4 <serial_drv_send+0x64>)
    119a:	8813      	ldrh	r3, [r2, #0]
    119c:	3b01      	subs	r3, #1
    119e:	b29b      	uxth	r3, r3
    11a0:	8013      	strh	r3, [r2, #0]
    11a2:	2b00      	cmp	r3, #0
    11a4:	d003      	beq.n	11ae <serial_drv_send+0x4e>
	  {
		  ++ble_txbuf_ptr;
    11a6:	4a06      	ldr	r2, [pc, #24]	; (11c0 <serial_drv_send+0x60>)
    11a8:	6813      	ldr	r3, [r2, #0]
    11aa:	3301      	adds	r3, #1
    11ac:	6013      	str	r3, [r2, #0]
	  }
  }
  /* Wait for ongoing transmission complete */
  while(ble_txbyte_count); 
    11ae:	4a05      	ldr	r2, [pc, #20]	; (11c4 <serial_drv_send+0x64>)
    11b0:	8813      	ldrh	r3, [r2, #0]
    11b2:	b29b      	uxth	r3, r3
    11b4:	2b00      	cmp	r3, #0
    11b6:	d1fb      	bne.n	11b0 <serial_drv_send+0x50>
  return STATUS_OK;
}
    11b8:	2000      	movs	r0, #0
    11ba:	bd70      	pop	{r4, r5, r6, pc}
    11bc:	00004191 	.word	0x00004191
    11c0:	200000cc 	.word	0x200000cc
    11c4:	200000ca 	.word	0x200000ca
    11c8:	000041d1 	.word	0x000041d1
    11cc:	20001378 	.word	0x20001378
    11d0:	20001344 	.word	0x20001344
    11d4:	000051d9 	.word	0x000051d9

000011d8 <serial_read_byte>:
{
 return usart_read_buffer_job(&usart_instance, data, max_len);
}

uint8_t serial_read_byte(uint16_t* data)
{
    11d8:	b508      	push	{r3, lr}
    11da:	1c01      	adds	r1, r0, #0
	return usart_read_job(&usart_instance, data);
    11dc:	4801      	ldr	r0, [pc, #4]	; (11e4 <serial_read_byte+0xc>)
    11de:	4b02      	ldr	r3, [pc, #8]	; (11e8 <serial_read_byte+0x10>)
    11e0:	4798      	blx	r3
}
    11e2:	bd08      	pop	{r3, pc}
    11e4:	20001344 	.word	0x20001344
    11e8:	000051f5 	.word	0x000051f5

000011ec <configure_serial_drv>:
	usart_enable_callback(&usart_instance, USART_CALLBACK_BUFFER_TRANSMITTED);
	serial_read_byte(&rx_data);
}

uint8_t configure_serial_drv(void)
{
    11ec:	b570      	push	{r4, r5, r6, lr}
    11ee:	b090      	sub	sp, #64	; 0x40
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    11f0:	2380      	movs	r3, #128	; 0x80
    11f2:	05db      	lsls	r3, r3, #23
    11f4:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    11f6:	2300      	movs	r3, #0
    11f8:	9301      	str	r3, [sp, #4]
	config->parity           = USART_PARITY_NONE;
    11fa:	22ff      	movs	r2, #255	; 0xff
    11fc:	4669      	mov	r1, sp
    11fe:	810a      	strh	r2, [r1, #8]
	config->stopbits         = USART_STOPBITS_1;
    1200:	2200      	movs	r2, #0
    1202:	728b      	strb	r3, [r1, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    1204:	72cb      	strb	r3, [r1, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    1206:	2101      	movs	r1, #1
    1208:	2024      	movs	r0, #36	; 0x24
    120a:	466c      	mov	r4, sp
    120c:	5421      	strb	r1, [r4, r0]
	config->transmitter_enable = true;
    120e:	3001      	adds	r0, #1
    1210:	5421      	strb	r1, [r4, r0]
	config->clock_polarity_inverted = false;
    1212:	3125      	adds	r1, #37	; 0x25
    1214:	5463      	strb	r3, [r4, r1]
	config->use_external_clock = false;
    1216:	3101      	adds	r1, #1
    1218:	5463      	strb	r3, [r4, r1]
	config->ext_clock_freq   = 0;
    121a:	930a      	str	r3, [sp, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    121c:	3105      	adds	r1, #5
    121e:	5463      	strb	r3, [r4, r1]
	config->generator_source = GCLK_GENERATOR_0;
    1220:	3101      	adds	r1, #1
    1222:	5463      	strb	r3, [r4, r1]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    1224:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    1226:	8223      	strh	r3, [r4, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    1228:	76e3      	strb	r3, [r4, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    122a:	7622      	strb	r2, [r4, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    122c:	7722      	strb	r2, [r4, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    122e:	7662      	strb	r2, [r4, #25]
	config->receive_pulse_length                    = 19;
    1230:	2313      	movs	r3, #19
    1232:	76a3      	strb	r3, [r4, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    1234:	7762      	strb	r2, [r4, #29]
		usart_configure_flowcontrol();
		#warning "This mode works only if Flow Control Permanently Enabled in the BTLC1000"
	#else
	struct usart_config config_usart;
	usart_get_config_defaults(&config_usart);
	config_usart.baudrate = CONF_BLE_BAUDRATE;
    1236:	23e1      	movs	r3, #225	; 0xe1
    1238:	025b      	lsls	r3, r3, #9
    123a:	9308      	str	r3, [sp, #32]
	config_usart.generator_source = CONF_BLE_UART_CLOCK;
	config_usart.mux_setting = CONF_BLE_MUX_SETTING;
    123c:	23c4      	movs	r3, #196	; 0xc4
    123e:	039b      	lsls	r3, r3, #14
    1240:	9303      	str	r3, [sp, #12]
	config_usart.pinmux_pad0 = CONF_BLE_PINMUX_PAD0;
    1242:	2301      	movs	r3, #1
    1244:	425b      	negs	r3, r3
    1246:	930c      	str	r3, [sp, #48]	; 0x30
	config_usart.pinmux_pad1 = CONF_BLE_PINMUX_PAD1;
    1248:	930d      	str	r3, [sp, #52]	; 0x34
	config_usart.pinmux_pad2 = CONF_BLE_PINMUX_PAD2;
    124a:	4b1e      	ldr	r3, [pc, #120]	; (12c4 <configure_serial_drv+0xd8>)
    124c:	930e      	str	r3, [sp, #56]	; 0x38
	config_usart.pinmux_pad3 = CONF_BLE_PINMUX_PAD3;
    124e:	4b1e      	ldr	r3, [pc, #120]	; (12c8 <configure_serial_drv+0xdc>)
    1250:	930f      	str	r3, [sp, #60]	; 0x3c

	while (usart_init(&usart_instance, CONF_BLE_USART_MODULE, &config_usart) != STATUS_OK);
    1252:	4e1e      	ldr	r6, [pc, #120]	; (12cc <configure_serial_drv+0xe0>)
    1254:	4d1e      	ldr	r5, [pc, #120]	; (12d0 <configure_serial_drv+0xe4>)
    1256:	4c1f      	ldr	r4, [pc, #124]	; (12d4 <configure_serial_drv+0xe8>)
    1258:	1c30      	adds	r0, r6, #0
    125a:	1c29      	adds	r1, r5, #0
    125c:	466a      	mov	r2, sp
    125e:	47a0      	blx	r4
    1260:	2800      	cmp	r0, #0
    1262:	d1f9      	bne.n	1258 <configure_serial_drv+0x6c>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    1264:	4d19      	ldr	r5, [pc, #100]	; (12cc <configure_serial_drv+0xe0>)
    1266:	682c      	ldr	r4, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    1268:	1c20      	adds	r0, r4, #0
    126a:	4b1b      	ldr	r3, [pc, #108]	; (12d8 <configure_serial_drv+0xec>)
    126c:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    126e:	231f      	movs	r3, #31
    1270:	4018      	ands	r0, r3
    1272:	3b1e      	subs	r3, #30
    1274:	4083      	lsls	r3, r0
    1276:	1c18      	adds	r0, r3, #0
    1278:	4b18      	ldr	r3, [pc, #96]	; (12dc <configure_serial_drv+0xf0>)
    127a:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    127c:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    127e:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1280:	2b00      	cmp	r3, #0
    1282:	d1fc      	bne.n	127e <configure_serial_drv+0x92>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    1284:	6822      	ldr	r2, [r4, #0]
    1286:	3302      	adds	r3, #2
    1288:	4313      	orrs	r3, r2
    128a:	6023      	str	r3, [r4, #0]

	usart_enable(&usart_instance);
	
	ser_fifo_init(&ble_usart_rx_fifo, ble_usart_rx_buf, BLE_MAX_RX_PAYLOAD_SIZE);
    128c:	4814      	ldr	r0, [pc, #80]	; (12e0 <configure_serial_drv+0xf4>)
    128e:	4915      	ldr	r1, [pc, #84]	; (12e4 <configure_serial_drv+0xf8>)
    1290:	2280      	movs	r2, #128	; 0x80
    1292:	0092      	lsls	r2, r2, #2
    1294:	4b14      	ldr	r3, [pc, #80]	; (12e8 <configure_serial_drv+0xfc>)
    1296:	4798      	blx	r3

	/* register and enable usart callbacks */
	usart_register_callback(&usart_instance,
    1298:	4c0c      	ldr	r4, [pc, #48]	; (12cc <configure_serial_drv+0xe0>)
    129a:	1c20      	adds	r0, r4, #0
    129c:	4913      	ldr	r1, [pc, #76]	; (12ec <configure_serial_drv+0x100>)
    129e:	2201      	movs	r2, #1
    12a0:	4d13      	ldr	r5, [pc, #76]	; (12f0 <configure_serial_drv+0x104>)
    12a2:	47a8      	blx	r5
		serial_drv_read_cb, USART_CALLBACK_BUFFER_RECEIVED);
	usart_register_callback(&usart_instance,
    12a4:	1c20      	adds	r0, r4, #0
    12a6:	4913      	ldr	r1, [pc, #76]	; (12f4 <configure_serial_drv+0x108>)
    12a8:	2200      	movs	r2, #0
    12aa:	47a8      	blx	r5
{
	/* Sanity check arguments */
	Assert(module);

	/* Enable callback */
	module->callback_enable_mask |= (1 << callback_type);
    12ac:	2231      	movs	r2, #49	; 0x31
    12ae:	5ca1      	ldrb	r1, [r4, r2]
    12b0:	2303      	movs	r3, #3
    12b2:	430b      	orrs	r3, r1
    12b4:	54a3      	strb	r3, [r4, r2]
		serial_drv_write_cb, USART_CALLBACK_BUFFER_TRANSMITTED);
	usart_enable_callback(&usart_instance, USART_CALLBACK_BUFFER_RECEIVED);
	usart_enable_callback(&usart_instance, USART_CALLBACK_BUFFER_TRANSMITTED);
	serial_read_byte(&rx_data);
    12b6:	4810      	ldr	r0, [pc, #64]	; (12f8 <configure_serial_drv+0x10c>)
    12b8:	4b10      	ldr	r3, [pc, #64]	; (12fc <configure_serial_drv+0x110>)
    12ba:	4798      	blx	r3
	#endif
	
	return STATUS_OK;
}
    12bc:	2000      	movs	r0, #0
    12be:	b010      	add	sp, #64	; 0x40
    12c0:	bd70      	pop	{r4, r5, r6, pc}
    12c2:	46c0      	nop			; (mov r8, r8)
    12c4:	002a0003 	.word	0x002a0003
    12c8:	002b0003 	.word	0x002b0003
    12cc:	20001344 	.word	0x20001344
    12d0:	42001800 	.word	0x42001800
    12d4:	00004d85 	.word	0x00004d85
    12d8:	00004881 	.word	0x00004881
    12dc:	e000e100 	.word	0xe000e100
    12e0:	20001338 	.word	0x20001338
    12e4:	2000137c 	.word	0x2000137c
    12e8:	000014bd 	.word	0x000014bd
    12ec:	00001301 	.word	0x00001301
    12f0:	000051c1 	.word	0x000051c1
    12f4:	00001105 	.word	0x00001105
    12f8:	200000c8 	.word	0x200000c8
    12fc:	000011d9 	.word	0x000011d9

00001300 <serial_drv_read_cb>:
  return STATUS_OK;
}

extern void platform_process_rxdata(uint32_t t_rx_data);
static void serial_drv_read_cb(struct usart_module *const module)
{
    1300:	b570      	push	{r4, r5, r6, lr}
	 do
	 {		 
		 platform_process_rxdata((uint8_t)rx_data);
    1302:	4c06      	ldr	r4, [pc, #24]	; (131c <serial_drv_read_cb+0x1c>)
    1304:	4e06      	ldr	r6, [pc, #24]	; (1320 <serial_drv_read_cb+0x20>)
	 }while(serial_read_byte(&rx_data) == STATUS_BUSY);
    1306:	4d07      	ldr	r5, [pc, #28]	; (1324 <serial_drv_read_cb+0x24>)
extern void platform_process_rxdata(uint32_t t_rx_data);
static void serial_drv_read_cb(struct usart_module *const module)
{
	 do
	 {		 
		 platform_process_rxdata((uint8_t)rx_data);
    1308:	7820      	ldrb	r0, [r4, #0]
    130a:	47b0      	blx	r6
	 }while(serial_read_byte(&rx_data) == STATUS_BUSY);
    130c:	1c20      	adds	r0, r4, #0
    130e:	47a8      	blx	r5
    1310:	2805      	cmp	r0, #5
    1312:	d0f9      	beq.n	1308 <serial_drv_read_cb+0x8>
 
	 //call callback
	 #if SERIAL_DRV_RX_CB_ENABLE == true
		SERIAL_DRV_RX_CB();
    1314:	4b04      	ldr	r3, [pc, #16]	; (1328 <serial_drv_read_cb+0x28>)
    1316:	4798      	blx	r3
	 #endif
}
    1318:	bd70      	pop	{r4, r5, r6, pc}
    131a:	46c0      	nop			; (mov r8, r8)
    131c:	200000c8 	.word	0x200000c8
    1320:	0000199d 	.word	0x0000199d
    1324:	000011d9 	.word	0x000011d9
    1328:	00001b69 	.word	0x00001b69

0000132c <configure_usart_after_patch>:
	
	return STATUS_OK;
}

void configure_usart_after_patch(void)
{
    132c:	b570      	push	{r4, r5, r6, lr}
    132e:	b090      	sub	sp, #64	; 0x40
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    1330:	4d4b      	ldr	r5, [pc, #300]	; (1460 <configure_usart_after_patch+0x134>)
    1332:	682c      	ldr	r4, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Disable Global interrupt for module */
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    1334:	1c20      	adds	r0, r4, #0
    1336:	4b4b      	ldr	r3, [pc, #300]	; (1464 <configure_usart_after_patch+0x138>)
    1338:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    133a:	231f      	movs	r3, #31
    133c:	4018      	ands	r0, r3
    133e:	3b1e      	subs	r3, #30
    1340:	4083      	lsls	r3, r0
    1342:	1c18      	adds	r0, r3, #0
    1344:	2380      	movs	r3, #128	; 0x80
    1346:	4a48      	ldr	r2, [pc, #288]	; (1468 <configure_usart_after_patch+0x13c>)
    1348:	50d0      	str	r0, [r2, r3]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    134a:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    134c:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    134e:	2b00      	cmp	r3, #0
    1350:	d1fc      	bne.n	134c <configure_usart_after_patch+0x20>
#endif
	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Disable USART module */
	usart_hw->CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    1352:	6823      	ldr	r3, [r4, #0]
    1354:	2202      	movs	r2, #2
    1356:	4393      	bics	r3, r2
    1358:	6023      	str	r3, [r4, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    135a:	4d41      	ldr	r5, [pc, #260]	; (1460 <configure_usart_after_patch+0x134>)
    135c:	682c      	ldr	r4, [r5, #0]
	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

#if USART_CALLBACK_MODE == true
	/* Disable Global interrupt for module */
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    135e:	1c20      	adds	r0, r4, #0
    1360:	4b40      	ldr	r3, [pc, #256]	; (1464 <configure_usart_after_patch+0x138>)
    1362:	4798      	blx	r3
    1364:	231f      	movs	r3, #31
    1366:	4018      	ands	r0, r3
    1368:	3b1e      	subs	r3, #30
    136a:	4083      	lsls	r3, r0
    136c:	1c18      	adds	r0, r3, #0
    136e:	2380      	movs	r3, #128	; 0x80
    1370:	4a3d      	ldr	r2, [pc, #244]	; (1468 <configure_usart_after_patch+0x13c>)
    1372:	50d0      	str	r0, [r2, r3]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    1374:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    1376:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1378:	2b00      	cmp	r3, #0
    137a:	d1fc      	bne.n	1376 <configure_usart_after_patch+0x4a>
#endif
	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Disable USART module */
	usart_hw->CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    137c:	6823      	ldr	r3, [r4, #0]
    137e:	2202      	movs	r2, #2
    1380:	4393      	bics	r3, r2
    1382:	6023      	str	r3, [r4, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    1384:	4b36      	ldr	r3, [pc, #216]	; (1460 <configure_usart_after_patch+0x134>)
    1386:	681a      	ldr	r2, [r3, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    1388:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    138a:	2b00      	cmp	r3, #0
    138c:	d1fc      	bne.n	1388 <configure_usart_after_patch+0x5c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Reset module */
	usart_hw->CTRLA.reg = SERCOM_USART_CTRLA_SWRST;
    138e:	2101      	movs	r1, #1
    1390:	6021      	str	r1, [r4, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    1392:	2380      	movs	r3, #128	; 0x80
    1394:	05db      	lsls	r3, r3, #23
    1396:	9300      	str	r3, [sp, #0]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    1398:	2300      	movs	r3, #0
    139a:	9301      	str	r3, [sp, #4]
	config->parity           = USART_PARITY_NONE;
    139c:	22ff      	movs	r2, #255	; 0xff
    139e:	4668      	mov	r0, sp
    13a0:	8102      	strh	r2, [r0, #8]
	config->stopbits         = USART_STOPBITS_1;
    13a2:	2200      	movs	r2, #0
    13a4:	7283      	strb	r3, [r0, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    13a6:	72c3      	strb	r3, [r0, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    13a8:	2024      	movs	r0, #36	; 0x24
    13aa:	466c      	mov	r4, sp
    13ac:	5421      	strb	r1, [r4, r0]
	config->transmitter_enable = true;
    13ae:	3001      	adds	r0, #1
    13b0:	5421      	strb	r1, [r4, r0]
	config->clock_polarity_inverted = false;
    13b2:	3125      	adds	r1, #37	; 0x25
    13b4:	5463      	strb	r3, [r4, r1]
	config->use_external_clock = false;
    13b6:	3101      	adds	r1, #1
    13b8:	5463      	strb	r3, [r4, r1]
	config->ext_clock_freq   = 0;
    13ba:	930a      	str	r3, [sp, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    13bc:	3105      	adds	r1, #5
    13be:	5463      	strb	r3, [r4, r1]
	config->generator_source = GCLK_GENERATOR_0;
    13c0:	3101      	adds	r1, #1
    13c2:	5463      	strb	r3, [r4, r1]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    13c4:	9305      	str	r3, [sp, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    13c6:	8223      	strh	r3, [r4, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    13c8:	76e3      	strb	r3, [r4, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    13ca:	7622      	strb	r2, [r4, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    13cc:	7722      	strb	r2, [r4, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    13ce:	7662      	strb	r2, [r4, #25]
	config->receive_pulse_length                    = 19;
    13d0:	2313      	movs	r3, #19
    13d2:	76a3      	strb	r3, [r4, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    13d4:	7762      	strb	r2, [r4, #29]
	usart_disable(&usart_instance);
	usart_reset(&usart_instance);
#endif
	usart_get_config_defaults(&config_usart);

	config_usart.baudrate = CONF_FLCR_BLE_BAUDRATE;
    13d6:	23e1      	movs	r3, #225	; 0xe1
    13d8:	025b      	lsls	r3, r3, #9
    13da:	9308      	str	r3, [sp, #32]
	config_usart.generator_source = CONF_FLCR_BLE_UART_CLOCK;
	config_usart.mux_setting = CONF_FLCR_BLE_MUX_SETTING;
    13dc:	2390      	movs	r3, #144	; 0x90
    13de:	035b      	lsls	r3, r3, #13
    13e0:	9303      	str	r3, [sp, #12]
	config_usart.pinmux_pad0 = CONF_FLCR_BLE_PINMUX_PAD0;
    13e2:	4b22      	ldr	r3, [pc, #136]	; (146c <configure_usart_after_patch+0x140>)
    13e4:	930c      	str	r3, [sp, #48]	; 0x30
	config_usart.pinmux_pad1 = CONF_FLCR_BLE_PINMUX_PAD1;
    13e6:	4b22      	ldr	r3, [pc, #136]	; (1470 <configure_usart_after_patch+0x144>)
    13e8:	930d      	str	r3, [sp, #52]	; 0x34
	config_usart.pinmux_pad2 = CONF_FLCR_BLE_PINMUX_PAD2;
    13ea:	4b22      	ldr	r3, [pc, #136]	; (1474 <configure_usart_after_patch+0x148>)
    13ec:	930e      	str	r3, [sp, #56]	; 0x38
	config_usart.pinmux_pad3 = CONF_FLCR_BLE_PINMUX_PAD3;
    13ee:	4b22      	ldr	r3, [pc, #136]	; (1478 <configure_usart_after_patch+0x14c>)
    13f0:	930f      	str	r3, [sp, #60]	; 0x3c

	while (usart_init(&usart_instance, CONF_FLCR_BLE_USART_MODULE, &config_usart) != STATUS_OK);
    13f2:	4e1b      	ldr	r6, [pc, #108]	; (1460 <configure_usart_after_patch+0x134>)
    13f4:	4d21      	ldr	r5, [pc, #132]	; (147c <configure_usart_after_patch+0x150>)
    13f6:	4c22      	ldr	r4, [pc, #136]	; (1480 <configure_usart_after_patch+0x154>)
    13f8:	1c30      	adds	r0, r6, #0
    13fa:	1c29      	adds	r1, r5, #0
    13fc:	466a      	mov	r2, sp
    13fe:	47a0      	blx	r4
    1400:	2800      	cmp	r0, #0
    1402:	d1f9      	bne.n	13f8 <configure_usart_after_patch+0xcc>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    1404:	4d16      	ldr	r5, [pc, #88]	; (1460 <configure_usart_after_patch+0x134>)
    1406:	682c      	ldr	r4, [r5, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    1408:	1c20      	adds	r0, r4, #0
    140a:	4b16      	ldr	r3, [pc, #88]	; (1464 <configure_usart_after_patch+0x138>)
    140c:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    140e:	231f      	movs	r3, #31
    1410:	4018      	ands	r0, r3
    1412:	3b1e      	subs	r3, #30
    1414:	4083      	lsls	r3, r0
    1416:	1c18      	adds	r0, r3, #0
    1418:	4b13      	ldr	r3, [pc, #76]	; (1468 <configure_usart_after_patch+0x13c>)
    141a:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    141c:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    141e:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    1420:	2b00      	cmp	r3, #0
    1422:	d1fc      	bne.n	141e <configure_usart_after_patch+0xf2>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    1424:	6822      	ldr	r2, [r4, #0]
    1426:	3302      	adds	r3, #2
    1428:	4313      	orrs	r3, r2
    142a:	6023      	str	r3, [r4, #0]

	usart_enable(&usart_instance);
	
	ser_fifo_init(&ble_usart_rx_fifo, ble_usart_rx_buf, BLE_MAX_RX_PAYLOAD_SIZE);
    142c:	4815      	ldr	r0, [pc, #84]	; (1484 <configure_usart_after_patch+0x158>)
    142e:	4916      	ldr	r1, [pc, #88]	; (1488 <configure_usart_after_patch+0x15c>)
    1430:	2280      	movs	r2, #128	; 0x80
    1432:	0092      	lsls	r2, r2, #2
    1434:	4b15      	ldr	r3, [pc, #84]	; (148c <configure_usart_after_patch+0x160>)
    1436:	4798      	blx	r3

	/* register and enable usart callbacks */
	usart_register_callback(&usart_instance,
    1438:	4c09      	ldr	r4, [pc, #36]	; (1460 <configure_usart_after_patch+0x134>)
    143a:	1c20      	adds	r0, r4, #0
    143c:	4914      	ldr	r1, [pc, #80]	; (1490 <configure_usart_after_patch+0x164>)
    143e:	2201      	movs	r2, #1
    1440:	4d14      	ldr	r5, [pc, #80]	; (1494 <configure_usart_after_patch+0x168>)
    1442:	47a8      	blx	r5
	serial_drv_read_cb, USART_CALLBACK_BUFFER_RECEIVED);
	usart_register_callback(&usart_instance,
    1444:	1c20      	adds	r0, r4, #0
    1446:	4914      	ldr	r1, [pc, #80]	; (1498 <configure_usart_after_patch+0x16c>)
    1448:	2200      	movs	r2, #0
    144a:	47a8      	blx	r5
    144c:	2231      	movs	r2, #49	; 0x31
    144e:	5ca1      	ldrb	r1, [r4, r2]
    1450:	2303      	movs	r3, #3
    1452:	430b      	orrs	r3, r1
    1454:	54a3      	strb	r3, [r4, r2]
	serial_drv_write_cb, USART_CALLBACK_BUFFER_TRANSMITTED);
	usart_enable_callback(&usart_instance, USART_CALLBACK_BUFFER_RECEIVED);
	usart_enable_callback(&usart_instance, USART_CALLBACK_BUFFER_TRANSMITTED);
	serial_read_byte(&rx_data);
    1456:	4811      	ldr	r0, [pc, #68]	; (149c <configure_usart_after_patch+0x170>)
    1458:	4b11      	ldr	r3, [pc, #68]	; (14a0 <configure_usart_after_patch+0x174>)
    145a:	4798      	blx	r3
void configure_usart_after_patch(void)
{
	#if UART_FLOWCONTROL_6WIRE_MODE == true
	usart_configure_flowcontrol();
	#endif	
}
    145c:	b010      	add	sp, #64	; 0x40
    145e:	bd70      	pop	{r4, r5, r6, pc}
    1460:	20001344 	.word	0x20001344
    1464:	00004881 	.word	0x00004881
    1468:	e000e100 	.word	0xe000e100
    146c:	00100002 	.word	0x00100002
    1470:	00110002 	.word	0x00110002
    1474:	00120002 	.word	0x00120002
    1478:	00130002 	.word	0x00130002
    147c:	42000c00 	.word	0x42000c00
    1480:	00004d85 	.word	0x00004d85
    1484:	20001338 	.word	0x20001338
    1488:	2000137c 	.word	0x2000137c
    148c:	000014bd 	.word	0x000014bd
    1490:	00001301 	.word	0x00001301
    1494:	000051c1 	.word	0x000051c1
    1498:	00001105 	.word	0x00001105
    149c:	200000c8 	.word	0x200000c8
    14a0:	000011d9 	.word	0x000011d9

000014a4 <platform_set_serial_drv_tx_status>:
}

uint32_t platform_set_serial_drv_tx_status(void)
{
	return true;
}
    14a4:	2001      	movs	r0, #1
    14a6:	4770      	bx	lr

000014a8 <platform_serial_drv_tx_status>:

uint32_t platform_serial_drv_tx_status(void)
{
    14a8:	b508      	push	{r3, lr}
	return(usart_get_job_status(&usart_instance, USART_TRANSCEIVER_TX));
    14aa:	4802      	ldr	r0, [pc, #8]	; (14b4 <platform_serial_drv_tx_status+0xc>)
    14ac:	2101      	movs	r1, #1
    14ae:	4b02      	ldr	r3, [pc, #8]	; (14b8 <platform_serial_drv_tx_status+0x10>)
    14b0:	4798      	blx	r3
}
    14b2:	bd08      	pop	{r3, pc}
    14b4:	20001344 	.word	0x20001344
    14b8:	00005205 	.word	0x00005205

000014bc <ser_fifo_init>:
	// ... and must fit in a uint16_t. Since the read and write indexes are using a
	// double-index range implementation, the max FIFO size is thus 32768 items.
	Assert (size <= 32768);

	// Serial Fifo starts empty.
	fifo_desc->read_index  = 0;
    14bc:	2300      	movs	r3, #0
    14be:	8083      	strh	r3, [r0, #4]
	fifo_desc->write_index = 0;
    14c0:	80c3      	strh	r3, [r0, #6]

	// Save the size parameter.
	fifo_desc->size = size;
    14c2:	8102      	strh	r2, [r0, #8]

	// Create a mask to speed up the FIFO management (index swapping).
	fifo_desc->mask = (2 * (uint16_t)size) - 1;
    14c4:	0052      	lsls	r2, r2, #1
    14c6:	3a01      	subs	r2, #1
    14c8:	8142      	strh	r2, [r0, #10]

	// Save the buffer pointer.
	fifo_desc->buffer.u8ptr = buffer;
    14ca:	6001      	str	r1, [r0, #0]

	return SER_FIFO_OK;
}
    14cc:	2000      	movs	r0, #0
    14ce:	4770      	bx	lr

000014d0 <bus_tc_cc0_cb>:
{
	timer_callback = cb_ptr;
}

void bus_tc_cc0_cb(struct tc_module *const module_inst)
{
    14d0:	b508      	push	{r3, lr}
	bus_timer_callback();
    14d2:	4b02      	ldr	r3, [pc, #8]	; (14dc <bus_tc_cc0_cb+0xc>)
    14d4:	681b      	ldr	r3, [r3, #0]
    14d6:	4798      	blx	r3
}
    14d8:	bd08      	pop	{r3, pc}
    14da:	46c0      	nop			; (mov r8, r8)
    14dc:	2000157c 	.word	0x2000157c

000014e0 <tc_cc0_cb>:

void tc_cc0_cb(struct tc_module *const module_inst)
{
    14e0:	b508      	push	{r3, lr}
	static uint16_t tc_count;
	tc_set_count_value(&tc_instance, 0);
    14e2:	480b      	ldr	r0, [pc, #44]	; (1510 <tc_cc0_cb+0x30>)
    14e4:	2100      	movs	r1, #0
    14e6:	4b0b      	ldr	r3, [pc, #44]	; (1514 <tc_cc0_cb+0x34>)
    14e8:	4798      	blx	r3
	tc_count += 1;
    14ea:	4a0b      	ldr	r2, [pc, #44]	; (1518 <tc_cc0_cb+0x38>)
    14ec:	8813      	ldrh	r3, [r2, #0]
    14ee:	3301      	adds	r3, #1
    14f0:	b29b      	uxth	r3, r3
    14f2:	8013      	strh	r3, [r2, #0]
	if (tc_count >= timeout_count)
    14f4:	4a09      	ldr	r2, [pc, #36]	; (151c <tc_cc0_cb+0x3c>)
    14f6:	6812      	ldr	r2, [r2, #0]
    14f8:	4293      	cmp	r3, r2
    14fa:	d307      	bcc.n	150c <tc_cc0_cb+0x2c>
	{
		tc_count = 0;
    14fc:	2200      	movs	r2, #0
    14fe:	4b06      	ldr	r3, [pc, #24]	; (1518 <tc_cc0_cb+0x38>)
    1500:	801a      	strh	r2, [r3, #0]
		if (timer_callback != NULL)
    1502:	4b07      	ldr	r3, [pc, #28]	; (1520 <tc_cc0_cb+0x40>)
    1504:	681b      	ldr	r3, [r3, #0]
    1506:	2b00      	cmp	r3, #0
    1508:	d000      	beq.n	150c <tc_cc0_cb+0x2c>
		{
			timer_callback();
    150a:	4798      	blx	r3
		}
	}
}
    150c:	bd08      	pop	{r3, pc}
    150e:	46c0      	nop			; (mov r8, r8)
    1510:	2000158c 	.word	0x2000158c
    1514:	000003c5 	.word	0x000003c5
    1518:	200000d0 	.word	0x200000d0
    151c:	20001588 	.word	0x20001588
    1520:	20001580 	.word	0x20001580

00001524 <hw_timer_init>:

void tc_cc0_cb(struct tc_module *const module_inst);
void bus_tc_cc0_cb(struct tc_module *const module_inst);

void hw_timer_init(void)
{
    1524:	b510      	push	{r4, lr}
    1526:	b08e      	sub	sp, #56	; 0x38
{
	/* Sanity check arguments */
	Assert(config);

	/* Write default config to config struct */
	config->clock_source               = GCLK_GENERATOR_0;
    1528:	aa01      	add	r2, sp, #4
    152a:	2300      	movs	r3, #0
    152c:	2100      	movs	r1, #0
    152e:	7013      	strb	r3, [r2, #0]
	config->counter_size               = TC_COUNTER_SIZE_16BIT;
    1530:	7093      	strb	r3, [r2, #2]
	config->clock_prescaler            = TC_CLOCK_PRESCALER_DIV1;
	config->wave_generation            = TC_WAVE_GENERATION_NORMAL_FREQ;
    1532:	7193      	strb	r3, [r2, #6]
	config->reload_action              = TC_RELOAD_ACTION_GCLK;
    1534:	2000      	movs	r0, #0
    1536:	8113      	strh	r3, [r2, #8]
	config->run_in_standby             = false;
    1538:	7050      	strb	r0, [r2, #1]
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	config->on_demand                  = false;
#endif
	config->waveform_invert_output     = TC_WAVEFORM_INVERT_OUTPUT_NONE;
    153a:	7291      	strb	r1, [r2, #10]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    153c:	72d1      	strb	r1, [r2, #11]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    153e:	7311      	strb	r1, [r2, #12]
#ifdef 	FEATURE_TC_IO_CAPTURE
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
#endif

	config->count_direction            = TC_COUNT_DIRECTION_UP;
    1540:	7391      	strb	r1, [r2, #14]
	config->oneshot                    = false;
    1542:	7351      	strb	r1, [r2, #13]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].enabled = false;
    1544:	7411      	strb	r1, [r2, #16]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_out = 0;
    1546:	6153      	str	r3, [r2, #20]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_mux = 0;
    1548:	6193      	str	r3, [r2, #24]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].enabled = false;
    154a:	7711      	strb	r1, [r2, #28]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_out = 0;
    154c:	6213      	str	r3, [r2, #32]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_mux = 0;
    154e:	6253      	str	r3, [r2, #36]	; 0x24

	config->counter_16_bit.value                   = 0x0000;
    1550:	8513      	strh	r3, [r2, #40]	; 0x28

	tc_get_config_defaults(&config_tc);

	config_tc.counter_size = TC_COUNTER_SIZE_16BIT;
	config_tc.clock_source = GCLK_GENERATOR_0;
	config_tc.clock_prescaler = TC_CLOCK_PRESCALER_DIV1024;
    1552:	23e0      	movs	r3, #224	; 0xe0
    1554:	00db      	lsls	r3, r3, #3
    1556:	8093      	strh	r3, [r2, #4]
	config_tc.counter_8_bit.period = 0;
    1558:	2329      	movs	r3, #41	; 0x29
    155a:	54d0      	strb	r0, [r2, r3]
	config_tc.counter_16_bit.compare_capture_channel[0] = TC_COUNT_1SEC;
    155c:	4b0c      	ldr	r3, [pc, #48]	; (1590 <hw_timer_init+0x6c>)
    155e:	8553      	strh	r3, [r2, #42]	; 0x2a
	config_tc.counter_16_bit.compare_capture_channel[1] = 0xFFFF;
    1560:	2301      	movs	r3, #1
    1562:	425b      	negs	r3, r3
    1564:	8593      	strh	r3, [r2, #44]	; 0x2c

	tc_init(&tc_instance, CONF_TC_MODULE, &config_tc);
    1566:	4c0b      	ldr	r4, [pc, #44]	; (1594 <hw_timer_init+0x70>)
    1568:	1c20      	adds	r0, r4, #0
    156a:	490b      	ldr	r1, [pc, #44]	; (1598 <hw_timer_init+0x74>)
    156c:	4b0b      	ldr	r3, [pc, #44]	; (159c <hw_timer_init+0x78>)
    156e:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    1570:	6822      	ldr	r2, [r4, #0]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    1572:	217f      	movs	r1, #127	; 0x7f
    1574:	7bd3      	ldrb	r3, [r2, #15]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    1576:	438b      	bics	r3, r1
    1578:	d1fc      	bne.n	1574 <hw_timer_init+0x50>
		/* Wait for sync */
	}

	/* Enable TC module */
	tc_module->CTRLA.reg |= TC_CTRLA_ENABLE;
    157a:	8811      	ldrh	r1, [r2, #0]
    157c:	3302      	adds	r3, #2
    157e:	430b      	orrs	r3, r1
    1580:	8013      	strh	r3, [r2, #0]

	tc_enable(&tc_instance);
	
	tc_register_callback(&tc_instance, tc_cc0_cb,
    1582:	4804      	ldr	r0, [pc, #16]	; (1594 <hw_timer_init+0x70>)
    1584:	4906      	ldr	r1, [pc, #24]	; (15a0 <hw_timer_init+0x7c>)
    1586:	2202      	movs	r2, #2
    1588:	4b06      	ldr	r3, [pc, #24]	; (15a4 <hw_timer_init+0x80>)
    158a:	4798      	blx	r3
						TC_CALLBACK_CC_CHANNEL0);
}
    158c:	b00e      	add	sp, #56	; 0x38
    158e:	bd10      	pop	{r4, pc}
    1590:	ffffb71b 	.word	0xffffb71b
    1594:	2000158c 	.word	0x2000158c
    1598:	42002c00 	.word	0x42002c00
    159c:	0000014d 	.word	0x0000014d
    15a0:	000014e1 	.word	0x000014e1
    15a4:	00001be1 	.word	0x00001be1

000015a8 <hw_timer_register_callback>:

void hw_timer_register_callback(hw_timer_callback_t cb_ptr)
{
	timer_callback = cb_ptr;
    15a8:	4b01      	ldr	r3, [pc, #4]	; (15b0 <hw_timer_register_callback+0x8>)
    15aa:	6018      	str	r0, [r3, #0]
}
    15ac:	4770      	bx	lr
    15ae:	46c0      	nop			; (mov r8, r8)
    15b0:	20001580 	.word	0x20001580

000015b4 <hw_timer_start>:
		}
	}
}

void hw_timer_start(uint32_t timer_val)
{
    15b4:	b510      	push	{r4, lr}
	timeout_count = timer_val;
    15b6:	4b0d      	ldr	r3, [pc, #52]	; (15ec <hw_timer_start+0x38>)
    15b8:	6018      	str	r0, [r3, #0]
	tc_set_count_value(&tc_instance, 0);
    15ba:	4c0d      	ldr	r4, [pc, #52]	; (15f0 <hw_timer_start+0x3c>)
    15bc:	1c20      	adds	r0, r4, #0
    15be:	2100      	movs	r1, #0
    15c0:	4b0c      	ldr	r3, [pc, #48]	; (15f4 <hw_timer_start+0x40>)
    15c2:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module);


	/* Enable interrupts for this TC module */
	system_interrupt_enable(_tc_interrupt_get_interrupt_vector(_tc_get_inst_index(module->hw)));
    15c4:	6820      	ldr	r0, [r4, #0]
    15c6:	4b0c      	ldr	r3, [pc, #48]	; (15f8 <hw_timer_start+0x44>)
    15c8:	4798      	blx	r3
#else
			MRECURSION(TC_INST_NUM, _TC_INTERRUPT_VECT_NUM, TC_INST_MAX_ID)
#endif
		};

	return (enum system_interrupt_vector)tc_interrupt_vectors[inst_num];
    15ca:	4b0c      	ldr	r3, [pc, #48]	; (15fc <hw_timer_start+0x48>)
    15cc:	5c1b      	ldrb	r3, [r3, r0]
    15ce:	221f      	movs	r2, #31
    15d0:	4013      	ands	r3, r2
    15d2:	3a1e      	subs	r2, #30
    15d4:	409a      	lsls	r2, r3
    15d6:	1c13      	adds	r3, r2, #0
    15d8:	4a09      	ldr	r2, [pc, #36]	; (1600 <hw_timer_start+0x4c>)
    15da:	6013      	str	r3, [r2, #0]
	/* Enable interrupts for this TC module */
	system_interrupt_enable(_tc_interrupt_get_interrupt_vector(_tc_get_inst_index(module->hw)));

	/* Enable callback */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
		module->enable_callback_mask |= TC_INTFLAG_MC(1);
    15dc:	7e62      	ldrb	r2, [r4, #25]
    15de:	2310      	movs	r3, #16
    15e0:	4313      	orrs	r3, r2
    15e2:	7663      	strb	r3, [r4, #25]
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(1);
    15e4:	6823      	ldr	r3, [r4, #0]
    15e6:	2210      	movs	r2, #16
    15e8:	735a      	strb	r2, [r3, #13]
	tc_enable_callback(&tc_instance, TC_CALLBACK_CC_CHANNEL0);
}
    15ea:	bd10      	pop	{r4, pc}
    15ec:	20001588 	.word	0x20001588
    15f0:	2000158c 	.word	0x2000158c
    15f4:	000003c5 	.word	0x000003c5
    15f8:	00000115 	.word	0x00000115
    15fc:	0000ea34 	.word	0x0000ea34
    1600:	e000e100 	.word	0xe000e100

00001604 <hw_timer_stop>:
	/* Sanity check arguments */
	Assert(module);

	/* Disable callback */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
		module->hw->COUNT8.INTENCLR.reg = TC_INTFLAG_MC(1);
    1604:	4b03      	ldr	r3, [pc, #12]	; (1614 <hw_timer_stop+0x10>)
    1606:	2110      	movs	r1, #16
    1608:	681a      	ldr	r2, [r3, #0]
    160a:	7311      	strb	r1, [r2, #12]
		module->enable_callback_mask &= ~TC_INTFLAG_MC(1);
    160c:	7e5a      	ldrb	r2, [r3, #25]
    160e:	438a      	bics	r2, r1
    1610:	765a      	strb	r2, [r3, #25]

void hw_timer_stop(void)
{
	tc_disable_callback(&tc_instance, TC_CALLBACK_CC_CHANNEL0);
}
    1612:	4770      	bx	lr
    1614:	2000158c 	.word	0x2000158c

00001618 <platform_configure_timer>:

uint32_t bus_activity_timer_frequency;
void platform_configure_timer(hw_timer_callback_t bus_tc_cb_ptr)
{
    1618:	b570      	push	{r4, r5, r6, lr}
    161a:	b08e      	sub	sp, #56	; 0x38
	uint32_t prescaler;
	struct tc_config timer_config;
	bus_timer_callback = bus_tc_cb_ptr;
    161c:	4b2f      	ldr	r3, [pc, #188]	; (16dc <platform_configure_timer+0xc4>)
    161e:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Write default config to config struct */
	config->clock_source               = GCLK_GENERATOR_0;
    1620:	ac01      	add	r4, sp, #4
    1622:	2300      	movs	r3, #0
    1624:	2200      	movs	r2, #0
    1626:	7023      	strb	r3, [r4, #0]
	config->counter_size               = TC_COUNTER_SIZE_16BIT;
    1628:	70a3      	strb	r3, [r4, #2]
	config->clock_prescaler            = TC_CLOCK_PRESCALER_DIV1;
	config->wave_generation            = TC_WAVE_GENERATION_NORMAL_FREQ;
    162a:	71a3      	strb	r3, [r4, #6]
	config->reload_action              = TC_RELOAD_ACTION_GCLK;
    162c:	8123      	strh	r3, [r4, #8]
	config->run_in_standby             = false;
    162e:	2100      	movs	r1, #0
    1630:	7061      	strb	r1, [r4, #1]
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	config->on_demand                  = false;
#endif
	config->waveform_invert_output     = TC_WAVEFORM_INVERT_OUTPUT_NONE;
    1632:	72a2      	strb	r2, [r4, #10]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    1634:	72e2      	strb	r2, [r4, #11]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    1636:	7322      	strb	r2, [r4, #12]
#endif

	config->count_direction            = TC_COUNT_DIRECTION_UP;
	config->oneshot                    = false;

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].enabled = false;
    1638:	7422      	strb	r2, [r4, #16]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_out = 0;
    163a:	6163      	str	r3, [r4, #20]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_mux = 0;
    163c:	61a3      	str	r3, [r4, #24]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].enabled = false;
    163e:	7722      	strb	r2, [r4, #28]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_out = 0;
    1640:	6223      	str	r3, [r4, #32]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_mux = 0;
    1642:	6263      	str	r3, [r4, #36]	; 0x24

	config->counter_16_bit.value                   = 0x0000;
    1644:	8523      	strh	r3, [r4, #40]	; 0x28
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_0]                        = 0x0000;
    1646:	8563      	strh	r3, [r4, #42]	; 0x2a
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_1]                        = 0x0000;
    1648:	85a3      	strh	r3, [r4, #44]	; 0x2c
	tc_get_config_defaults(&timer_config);
	timer_config.clock_prescaler		= TC_CLOCK_PRESCALER_DIV4;
    164a:	2380      	movs	r3, #128	; 0x80
    164c:	009b      	lsls	r3, r3, #2
    164e:	80a3      	strh	r3, [r4, #4]
	timer_config.count_direction		= TC_COUNT_DIRECTION_UP;
	timer_config.oneshot				= true;
    1650:	2501      	movs	r5, #1
    1652:	7365      	strb	r5, [r4, #13]
	timer_config.counter_size			= TC_COUNTER_SIZE_16BIT;
	timer_config.count_direction		= TC_COUNT_DIRECTION_DOWN;
    1654:	73a5      	strb	r5, [r4, #14]
	tc_init(&bus_tc_instance, CONF_BUS_TC_MODULE, &timer_config);
    1656:	4e22      	ldr	r6, [pc, #136]	; (16e0 <platform_configure_timer+0xc8>)
    1658:	1c30      	adds	r0, r6, #0
    165a:	4922      	ldr	r1, [pc, #136]	; (16e4 <platform_configure_timer+0xcc>)
    165c:	1c22      	adds	r2, r4, #0
    165e:	4b22      	ldr	r3, [pc, #136]	; (16e8 <platform_configure_timer+0xd0>)
    1660:	4798      	blx	r3
	prescaler = 1 << (timer_config.clock_prescaler >> TC_CTRLA_PRESCALER_Pos);
    1662:	88a3      	ldrh	r3, [r4, #4]
    1664:	0a1b      	lsrs	r3, r3, #8
    1666:	409d      	lsls	r5, r3
	bus_activity_timer_frequency = (system_gclk_gen_get_hz(timer_config.clock_source) / prescaler);
    1668:	7820      	ldrb	r0, [r4, #0]
    166a:	4b20      	ldr	r3, [pc, #128]	; (16ec <platform_configure_timer+0xd4>)
    166c:	4798      	blx	r3
    166e:	1c29      	adds	r1, r5, #0
    1670:	4b1f      	ldr	r3, [pc, #124]	; (16f0 <platform_configure_timer+0xd8>)
    1672:	4798      	blx	r3
    1674:	4b1f      	ldr	r3, [pc, #124]	; (16f4 <platform_configure_timer+0xdc>)
    1676:	6018      	str	r0, [r3, #0]
	tc_set_count_value(&bus_tc_instance, 0xFFFFFFFF);
    1678:	1c30      	adds	r0, r6, #0
    167a:	2101      	movs	r1, #1
    167c:	4249      	negs	r1, r1
    167e:	4b1e      	ldr	r3, [pc, #120]	; (16f8 <platform_configure_timer+0xe0>)
    1680:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    1682:	6832      	ldr	r2, [r6, #0]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    1684:	217f      	movs	r1, #127	; 0x7f
    1686:	7bd3      	ldrb	r3, [r2, #15]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    1688:	438b      	bics	r3, r1
    168a:	d1fc      	bne.n	1686 <platform_configure_timer+0x6e>
		/* Wait for sync */
	}

	/* Enable TC module */
	tc_module->CTRLA.reg |= TC_CTRLA_ENABLE;
    168c:	8811      	ldrh	r1, [r2, #0]
    168e:	3302      	adds	r3, #2
    1690:	430b      	orrs	r3, r1
    1692:	8013      	strh	r3, [r2, #0]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    1694:	4b12      	ldr	r3, [pc, #72]	; (16e0 <platform_configure_timer+0xc8>)
    1696:	681a      	ldr	r2, [r3, #0]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    1698:	217f      	movs	r1, #127	; 0x7f
    169a:	7bd3      	ldrb	r3, [r2, #15]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    169c:	438b      	bics	r3, r1
    169e:	d1fc      	bne.n	169a <platform_configure_timer+0x82>
		/* Wait for sync */
	}

	/* Write command to execute */
	tc_module->CTRLBSET.reg = TC_CTRLBSET_CMD(TC_CTRLBSET_CMD_STOP_Val);
    16a0:	3380      	adds	r3, #128	; 0x80
    16a2:	7153      	strb	r3, [r2, #5]
	tc_enable(&bus_tc_instance);
	tc_stop_counter(&bus_tc_instance);
	tc_register_callback(&bus_tc_instance, bus_tc_cc0_cb,
    16a4:	4c0e      	ldr	r4, [pc, #56]	; (16e0 <platform_configure_timer+0xc8>)
    16a6:	1c20      	adds	r0, r4, #0
    16a8:	4914      	ldr	r1, [pc, #80]	; (16fc <platform_configure_timer+0xe4>)
    16aa:	2200      	movs	r2, #0
    16ac:	4b14      	ldr	r3, [pc, #80]	; (1700 <platform_configure_timer+0xe8>)
    16ae:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module);


	/* Enable interrupts for this TC module */
	system_interrupt_enable(_tc_interrupt_get_interrupt_vector(_tc_get_inst_index(module->hw)));
    16b0:	6820      	ldr	r0, [r4, #0]
    16b2:	4b14      	ldr	r3, [pc, #80]	; (1704 <platform_configure_timer+0xec>)
    16b4:	4798      	blx	r3
#else
			MRECURSION(TC_INST_NUM, _TC_INTERRUPT_VECT_NUM, TC_INST_MAX_ID)
#endif
		};

	return (enum system_interrupt_vector)tc_interrupt_vectors[inst_num];
    16b6:	4b14      	ldr	r3, [pc, #80]	; (1708 <platform_configure_timer+0xf0>)
    16b8:	5c1b      	ldrb	r3, [r3, r0]
    16ba:	221f      	movs	r2, #31
    16bc:	4013      	ands	r3, r2
    16be:	3a1e      	subs	r2, #30
    16c0:	1c11      	adds	r1, r2, #0
    16c2:	4099      	lsls	r1, r3
    16c4:	1c0b      	adds	r3, r1, #0
    16c6:	4911      	ldr	r1, [pc, #68]	; (170c <platform_configure_timer+0xf4>)
    16c8:	600b      	str	r3, [r1, #0]
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
		module->enable_callback_mask |= TC_INTFLAG_MC(2);
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(2);
	}
	else {
		module->enable_callback_mask |= (1 << callback_type);
    16ca:	7e61      	ldrb	r1, [r4, #25]
    16cc:	2301      	movs	r3, #1
    16ce:	430b      	orrs	r3, r1
    16d0:	7663      	strb	r3, [r4, #25]
		module->hw->COUNT8.INTENSET.reg = (1 << callback_type);
    16d2:	6823      	ldr	r3, [r4, #0]
    16d4:	735a      	strb	r2, [r3, #13]
									TC_CALLBACK_OVERFLOW);
	tc_enable_callback(&bus_tc_instance, TC_CALLBACK_OVERFLOW);
}
    16d6:	b00e      	add	sp, #56	; 0x38
    16d8:	bd70      	pop	{r4, r5, r6, pc}
    16da:	46c0      	nop			; (mov r8, r8)
    16dc:	2000157c 	.word	0x2000157c
    16e0:	200015a8 	.word	0x200015a8
    16e4:	42003000 	.word	0x42003000
    16e8:	0000014d 	.word	0x0000014d
    16ec:	00005915 	.word	0x00005915
    16f0:	0000bdad 	.word	0x0000bdad
    16f4:	20001584 	.word	0x20001584
    16f8:	000003c5 	.word	0x000003c5
    16fc:	000014d1 	.word	0x000014d1
    1700:	00001be1 	.word	0x00001be1
    1704:	00000115 	.word	0x00000115
    1708:	0000ea34 	.word	0x0000ea34
    170c:	e000e100 	.word	0xe000e100

00001710 <Platform_start_bus_timer>:


void Platform_start_bus_timer(uint32_t timeout)
{
    1710:	b538      	push	{r3, r4, r5, lr}
	uint32_t top_value;
	if (timeout == 0xFFFFFFFF)
    1712:	1c43      	adds	r3, r0, #1
    1714:	d018      	beq.n	1748 <Platform_start_bus_timer+0x38>
    1716:	1c04      	adds	r4, r0, #0
	{
		return;
	}
	top_value = (bus_activity_timer_frequency / 1000) * timeout;
	tc_set_count_value(&bus_tc_instance, top_value);
    1718:	4d0c      	ldr	r5, [pc, #48]	; (174c <Platform_start_bus_timer+0x3c>)
	uint32_t top_value;
	if (timeout == 0xFFFFFFFF)
	{
		return;
	}
	top_value = (bus_activity_timer_frequency / 1000) * timeout;
    171a:	4b0d      	ldr	r3, [pc, #52]	; (1750 <Platform_start_bus_timer+0x40>)
    171c:	6818      	ldr	r0, [r3, #0]
    171e:	21fa      	movs	r1, #250	; 0xfa
    1720:	0089      	lsls	r1, r1, #2
    1722:	4b0c      	ldr	r3, [pc, #48]	; (1754 <Platform_start_bus_timer+0x44>)
    1724:	4798      	blx	r3
    1726:	1c01      	adds	r1, r0, #0
    1728:	4361      	muls	r1, r4
	tc_set_count_value(&bus_tc_instance, top_value);
    172a:	1c28      	adds	r0, r5, #0
    172c:	4b0a      	ldr	r3, [pc, #40]	; (1758 <Platform_start_bus_timer+0x48>)
    172e:	4798      	blx	r3
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    1730:	682a      	ldr	r2, [r5, #0]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    1732:	217f      	movs	r1, #127	; 0x7f
    1734:	7bd3      	ldrb	r3, [r2, #15]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    1736:	438b      	bics	r3, r1
    1738:	d1fc      	bne.n	1734 <Platform_start_bus_timer+0x24>
		/* Wait for sync */
	}

	/* Make certain that there are no conflicting commands in the register */
	tc_module->CTRLBCLR.reg = TC_CTRLBCLR_CMD_NONE;
    173a:	7113      	strb	r3, [r2, #4]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    173c:	217f      	movs	r1, #127	; 0x7f
    173e:	7bd3      	ldrb	r3, [r2, #15]
	}

	/* Make certain that there are no conflicting commands in the register */
	tc_module->CTRLBCLR.reg = TC_CTRLBCLR_CMD_NONE;

	while (tc_is_syncing(module_inst)) {
    1740:	438b      	bics	r3, r1
    1742:	d1fc      	bne.n	173e <Platform_start_bus_timer+0x2e>
		/* Wait for sync */
	}

	/* Write command to execute */
	tc_module->CTRLBSET.reg = TC_CTRLBSET_CMD(TC_CTRLBSET_CMD_RETRIGGER_Val);
    1744:	3340      	adds	r3, #64	; 0x40
    1746:	7153      	strb	r3, [r2, #5]
	tc_start_counter(&bus_tc_instance);
}
    1748:	bd38      	pop	{r3, r4, r5, pc}
    174a:	46c0      	nop			; (mov r8, r8)
    174c:	200015a8 	.word	0x200015a8
    1750:	20001584 	.word	0x20001584
    1754:	0000bdad 	.word	0x0000bdad
    1758:	000003c5 	.word	0x000003c5

0000175c <Platform_stop_bus_timer>:
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    175c:	4b04      	ldr	r3, [pc, #16]	; (1770 <Platform_stop_bus_timer+0x14>)
    175e:	681a      	ldr	r2, [r3, #0]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    1760:	217f      	movs	r1, #127	; 0x7f
    1762:	7bd3      	ldrb	r3, [r2, #15]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    1764:	438b      	bics	r3, r1
    1766:	d1fc      	bne.n	1762 <Platform_stop_bus_timer+0x6>
		/* Wait for sync */
	}

	/* Write command to execute */
	tc_module->CTRLBSET.reg = TC_CTRLBSET_CMD(TC_CTRLBSET_CMD_STOP_Val);
    1768:	3380      	adds	r3, #128	; 0x80
    176a:	7153      	strb	r3, [r2, #5]

void Platform_stop_bus_timer(void)
{
	tc_stop_counter(&bus_tc_instance);
}
    176c:	4770      	bx	lr
    176e:	46c0      	nop			; (mov r8, r8)
    1770:	200015a8 	.word	0x200015a8

00001774 <platform_reset_bus_timer>:

void platform_reset_bus_timer(void)
{
    1774:	b508      	push	{r3, lr}
	Platform_stop_bus_timer();
    1776:	4b03      	ldr	r3, [pc, #12]	; (1784 <platform_reset_bus_timer+0x10>)
    1778:	4798      	blx	r3
	Platform_start_bus_timer(5);
    177a:	2005      	movs	r0, #5
    177c:	4b02      	ldr	r3, [pc, #8]	; (1788 <platform_reset_bus_timer+0x14>)
    177e:	4798      	blx	r3
}
    1780:	bd08      	pop	{r3, pc}
    1782:	46c0      	nop			; (mov r8, r8)
    1784:	0000175d 	.word	0x0000175d
    1788:	00001711 	.word	0x00001711

0000178c <bus_activity_timer_callback>:
#endif

void platform_process_rxdata(uint32_t t_rx_data);

void bus_activity_timer_callback(void)
{
    178c:	b508      	push	{r3, lr}
	if (bus_type == AT_BLE_UART)
    178e:	4b07      	ldr	r3, [pc, #28]	; (17ac <bus_activity_timer_callback+0x20>)
    1790:	781b      	ldrb	r3, [r3, #0]
    1792:	2b01      	cmp	r3, #1
    1794:	d109      	bne.n	17aa <bus_activity_timer_callback+0x1e>
	{
		if (platform_serial_drv_tx_status() == STATUS_OK)
    1796:	4b06      	ldr	r3, [pc, #24]	; (17b0 <bus_activity_timer_callback+0x24>)
    1798:	4798      	blx	r3
    179a:	2800      	cmp	r0, #0
    179c:	d103      	bne.n	17a6 <bus_activity_timer_callback+0x1a>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    179e:	2208      	movs	r2, #8
    17a0:	4b04      	ldr	r3, [pc, #16]	; (17b4 <bus_activity_timer_callback+0x28>)
    17a2:	615a      	str	r2, [r3, #20]
    17a4:	e001      	b.n	17aa <bus_activity_timer_callback+0x1e>
		{
			platform_set_sleep();
		}
		else
		{
			platform_reset_bus_timer();
    17a6:	4b04      	ldr	r3, [pc, #16]	; (17b8 <bus_activity_timer_callback+0x2c>)
    17a8:	4798      	blx	r3
		}
	}
}
    17aa:	bd08      	pop	{r3, pc}
    17ac:	20000005 	.word	0x20000005
    17b0:	000014a9 	.word	0x000014a9
    17b4:	41004480 	.word	0x41004480
    17b8:	00001775 	.word	0x00001775

000017bc <check_and_assert_ext_wakeup>:

void check_and_assert_ext_wakeup(uint8_t mode)
{
    17bc:	b508      	push	{r3, lr}
	if (init_done)
    17be:	4b0b      	ldr	r3, [pc, #44]	; (17ec <check_and_assert_ext_wakeup+0x30>)
    17c0:	681b      	ldr	r3, [r3, #0]
    17c2:	2b00      	cmp	r3, #0
    17c4:	d011      	beq.n	17ea <check_and_assert_ext_wakeup+0x2e>
		const uint8_t gpio_pin)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	return (port_base->OUT.reg & pin_mask);
    17c6:	4b0a      	ldr	r3, [pc, #40]	; (17f0 <check_and_assert_ext_wakeup+0x34>)
    17c8:	691b      	ldr	r3, [r3, #16]
	{
		if (!ble_wakeup_pin_level())
    17ca:	071b      	lsls	r3, r3, #28
    17cc:	d40b      	bmi.n	17e6 <check_and_assert_ext_wakeup+0x2a>
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    17ce:	2208      	movs	r2, #8
    17d0:	4b07      	ldr	r3, [pc, #28]	; (17f0 <check_and_assert_ext_wakeup+0x34>)
    17d2:	619a      	str	r2, [r3, #24]
		{
			platform_wakeup();
			if (mode == TX_MODE)
    17d4:	2801      	cmp	r0, #1
    17d6:	d102      	bne.n	17de <check_and_assert_ext_wakeup+0x22>
			{
				delay_ms(BTLC1000_WAKEUP_DELAY);
    17d8:	3004      	adds	r0, #4
    17da:	4b06      	ldr	r3, [pc, #24]	; (17f4 <check_and_assert_ext_wakeup+0x38>)
    17dc:	4798      	blx	r3
			}
			Platform_start_bus_timer(5);
    17de:	2005      	movs	r0, #5
    17e0:	4b05      	ldr	r3, [pc, #20]	; (17f8 <check_and_assert_ext_wakeup+0x3c>)
    17e2:	4798      	blx	r3
    17e4:	e001      	b.n	17ea <check_and_assert_ext_wakeup+0x2e>
		}
		else
		{						
			platform_reset_bus_timer();
    17e6:	4b05      	ldr	r3, [pc, #20]	; (17fc <check_and_assert_ext_wakeup+0x40>)
    17e8:	4798      	blx	r3
		}
	}
}
    17ea:	bd08      	pop	{r3, pc}
    17ec:	200000d4 	.word	0x200000d4
    17f0:	41004480 	.word	0x41004480
    17f4:	00001e1d 	.word	0x00001e1d
    17f8:	00001711 	.word	0x00001711
    17fc:	00001775 	.word	0x00001775

00001800 <platform_init>:

at_ble_status_t platform_init(void* platform_params)
{	
    1800:	b5f0      	push	{r4, r5, r6, r7, lr}
    1802:	4647      	mov	r7, r8
    1804:	b480      	push	{r7}
    1806:	b082      	sub	sp, #8
	platform_config	*cfg = (platform_config *)platform_params;
	
	if (cfg->bus_type == AT_BLE_UART)
    1808:	7803      	ldrb	r3, [r0, #0]
		delay_ms(BTLC1000_STARTUP_DELAY);
		
		bus_type = AT_BLE_UART;
		return AT_BLE_SUCCESS;
	}
	return AT_BLE_INVALID_PARAM;
    180a:	20cf      	movs	r0, #207	; 0xcf

at_ble_status_t platform_init(void* platform_params)
{	
	platform_config	*cfg = (platform_config *)platform_params;
	
	if (cfg->bus_type == AT_BLE_UART)
    180c:	2b01      	cmp	r3, #1
    180e:	d124      	bne.n	185a <platform_init+0x5a>
static inline void ble_configure_control_pin(void)
{
	struct port_config pin_conf;
	
	/* initialize the delay before use */
	delay_init();
    1810:	4b14      	ldr	r3, [pc, #80]	; (1864 <platform_init+0x64>)
    1812:	4798      	blx	r3
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
	config->powersave  = false;
    1814:	ac01      	add	r4, sp, #4
    1816:	2300      	movs	r3, #0
    1818:	70a3      	strb	r3, [r4, #2]
	
	/* get the default values for port pin configuration */
	port_get_config_defaults(&pin_conf);

	/* Configure control pins as output */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    181a:	2701      	movs	r7, #1
    181c:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_DOWN;
    181e:	3302      	adds	r3, #2
    1820:	7063      	strb	r3, [r4, #1]
	
	port_pin_set_config(BTLC1000_WAKEUP_PIN, &pin_conf);
    1822:	2023      	movs	r0, #35	; 0x23
    1824:	1c21      	adds	r1, r4, #0
    1826:	4b10      	ldr	r3, [pc, #64]	; (1868 <platform_init+0x68>)
    1828:	4698      	mov	r8, r3
    182a:	4798      	blx	r3
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    182c:	4d0f      	ldr	r5, [pc, #60]	; (186c <platform_init+0x6c>)
    182e:	1c2b      	adds	r3, r5, #0
    1830:	3380      	adds	r3, #128	; 0x80
    1832:	2608      	movs	r6, #8
    1834:	619e      	str	r6, [r3, #24]
	/* set wakeup pin to low */
	ble_wakeup_pin_set_high();
	
	port_pin_set_config(BTLC1000_CHIP_ENABLE_PIN, &pin_conf);
    1836:	2003      	movs	r0, #3
    1838:	1c21      	adds	r1, r4, #0
    183a:	47c0      	blx	r8
	} else {
		port_base->OUTCLR.reg = pin_mask;
    183c:	616e      	str	r6, [r5, #20]
	/* set chip enable to low */
	ble_enable_pin_set_low();
	
	/* Delay for 50ms */
	delay_ms(BTLC1000_RESET_MS);
    183e:	2032      	movs	r0, #50	; 0x32
    1840:	4c0b      	ldr	r4, [pc, #44]	; (1870 <platform_init+0x70>)
    1842:	47a0      	blx	r4
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1844:	61ae      	str	r6, [r5, #24]
	{
		
		ble_configure_control_pin();
		
		configure_serial_drv();
    1846:	4b0b      	ldr	r3, [pc, #44]	; (1874 <platform_init+0x74>)
    1848:	4798      	blx	r3
		
		platform_configure_timer(bus_activity_timer_callback);
    184a:	480b      	ldr	r0, [pc, #44]	; (1878 <platform_init+0x78>)
    184c:	4b0b      	ldr	r3, [pc, #44]	; (187c <platform_init+0x7c>)
    184e:	4798      	blx	r3
		
		delay_ms(BTLC1000_STARTUP_DELAY);
    1850:	480b      	ldr	r0, [pc, #44]	; (1880 <platform_init+0x80>)
    1852:	47a0      	blx	r4
		
		bus_type = AT_BLE_UART;
    1854:	4b0b      	ldr	r3, [pc, #44]	; (1884 <platform_init+0x84>)
    1856:	701f      	strb	r7, [r3, #0]
		return AT_BLE_SUCCESS;
    1858:	2000      	movs	r0, #0
	}
	return AT_BLE_INVALID_PARAM;
	
}
    185a:	b002      	add	sp, #8
    185c:	bc04      	pop	{r2}
    185e:	4690      	mov	r8, r2
    1860:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1862:	46c0      	nop			; (mov r8, r8)
    1864:	00001de1 	.word	0x00001de1
    1868:	0000441d 	.word	0x0000441d
    186c:	41004400 	.word	0x41004400
    1870:	00001e1d 	.word	0x00001e1d
    1874:	000011ed 	.word	0x000011ed
    1878:	0000178d 	.word	0x0000178d
    187c:	00001619 	.word	0x00001619
    1880:	00000dac 	.word	0x00000dac
    1884:	20000005 	.word	0x20000005

00001888 <platform_cmd_cmpl_signal>:
	return AT_BLE_SUCCESS;
}

void platform_cmd_cmpl_signal(void)
{
	cmd_cmpl_flag = 1;
    1888:	2201      	movs	r2, #1
    188a:	4b01      	ldr	r3, [pc, #4]	; (1890 <platform_cmd_cmpl_signal+0x8>)
    188c:	601a      	str	r2, [r3, #0]
}
    188e:	4770      	bx	lr
    1890:	200000e4 	.word	0x200000e4

00001894 <platform_interface_send_sleep>:
}

int platform_interface_send_sleep(void)
{
	return 0;
}
    1894:	2000      	movs	r0, #0
    1896:	4770      	bx	lr

00001898 <platform_interface_send_wakeup>:

int platform_interface_send_wakeup(void)
{
	return 0;
}
    1898:	2000      	movs	r0, #0
    189a:	4770      	bx	lr

0000189c <start_timer>:
uint32_t ctr48 = 615; // 1ms @ 48 MHz


/* Timeout in ms */
void start_timer(uint32_t timeout)
{
    189c:	b538      	push	{r3, r4, r5, lr}
    189e:	1c04      	adds	r4, r0, #0
#if SAMG55	
	uint32_t main_clk  = sysclk_get_cpu_hz();
#endif

#if SAMD21 || SAML21
	uint32_t main_clk  = system_gclk_gen_get_hz(0);
    18a0:	2000      	movs	r0, #0
    18a2:	4b14      	ldr	r3, [pc, #80]	; (18f4 <start_timer+0x58>)
    18a4:	4798      	blx	r3
#endif
	double ctr = 1.0;
	if (main_clk == 8000000)
    18a6:	4b14      	ldr	r3, [pc, #80]	; (18f8 <start_timer+0x5c>)
    18a8:	4298      	cmp	r0, r3
    18aa:	d105      	bne.n	18b8 <start_timer+0x1c>
		ticks = ctr8*timeout;
    18ac:	4b13      	ldr	r3, [pc, #76]	; (18fc <start_timer+0x60>)
    18ae:	6818      	ldr	r0, [r3, #0]
    18b0:	4344      	muls	r4, r0
    18b2:	4b13      	ldr	r3, [pc, #76]	; (1900 <start_timer+0x64>)
    18b4:	601c      	str	r4, [r3, #0]
    18b6:	e017      	b.n	18e8 <start_timer+0x4c>
	else if (main_clk == 48000000)
    18b8:	4b12      	ldr	r3, [pc, #72]	; (1904 <start_timer+0x68>)
    18ba:	4298      	cmp	r0, r3
    18bc:	d105      	bne.n	18ca <start_timer+0x2e>
		ticks = ctr48*timeout;
    18be:	4b12      	ldr	r3, [pc, #72]	; (1908 <start_timer+0x6c>)
    18c0:	6818      	ldr	r0, [r3, #0]
    18c2:	4344      	muls	r4, r0
    18c4:	4b0e      	ldr	r3, [pc, #56]	; (1900 <start_timer+0x64>)
    18c6:	601c      	str	r4, [r3, #0]
    18c8:	e00e      	b.n	18e8 <start_timer+0x4c>
	else
	{
		ctr = 615.0 * (double)((double)main_clk/48000000);
    18ca:	4b10      	ldr	r3, [pc, #64]	; (190c <start_timer+0x70>)
    18cc:	4798      	blx	r3
    18ce:	2200      	movs	r2, #0
    18d0:	4b0f      	ldr	r3, [pc, #60]	; (1910 <start_timer+0x74>)
    18d2:	4d10      	ldr	r5, [pc, #64]	; (1914 <start_timer+0x78>)
    18d4:	47a8      	blx	r5
    18d6:	2200      	movs	r2, #0
    18d8:	4b0f      	ldr	r3, [pc, #60]	; (1918 <start_timer+0x7c>)
    18da:	4d10      	ldr	r5, [pc, #64]	; (191c <start_timer+0x80>)
    18dc:	47a8      	blx	r5
		ticks = (uint32_t)ctr * timeout;
    18de:	4b10      	ldr	r3, [pc, #64]	; (1920 <start_timer+0x84>)
    18e0:	4798      	blx	r3
    18e2:	4344      	muls	r4, r0
    18e4:	4b06      	ldr	r3, [pc, #24]	; (1900 <start_timer+0x64>)
    18e6:	601c      	str	r4, [r3, #0]
	}
	ticks *= 2;
    18e8:	4a05      	ldr	r2, [pc, #20]	; (1900 <start_timer+0x64>)
    18ea:	6813      	ldr	r3, [r2, #0]
    18ec:	005b      	lsls	r3, r3, #1
    18ee:	6013      	str	r3, [r2, #0]
}
    18f0:	bd38      	pop	{r3, r4, r5, pc}
    18f2:	46c0      	nop			; (mov r8, r8)
    18f4:	00005915 	.word	0x00005915
    18f8:	007a1200 	.word	0x007a1200
    18fc:	20000000 	.word	0x20000000
    1900:	200000e0 	.word	0x200000e0
    1904:	02dc6c00 	.word	0x02dc6c00
    1908:	20000008 	.word	0x20000008
    190c:	0000d41d 	.word	0x0000d41d
    1910:	4186e360 	.word	0x4186e360
    1914:	0000c141 	.word	0x0000c141
    1918:	40833800 	.word	0x40833800
    191c:	0000c789 	.word	0x0000c789
    1920:	0000c105 	.word	0x0000c105

00001924 <timer_done>:


uint32_t timer_done(void)
{
	return --ticks; 
    1924:	4b02      	ldr	r3, [pc, #8]	; (1930 <timer_done+0xc>)
    1926:	681a      	ldr	r2, [r3, #0]
    1928:	1e50      	subs	r0, r2, #1
    192a:	6018      	str	r0, [r3, #0]
}
    192c:	4770      	bx	lr
    192e:	46c0      	nop			; (mov r8, r8)
    1930:	200000e0 	.word	0x200000e0

00001934 <platform_enter_critical_section>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    1934:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    1936:	f3bf 8f5f 	dmb	sy

void platform_enter_critical_section(void)
{
	Disable_global_interrupt();
    193a:	2200      	movs	r2, #0
    193c:	4b01      	ldr	r3, [pc, #4]	; (1944 <platform_enter_critical_section+0x10>)
    193e:	701a      	strb	r2, [r3, #0]
}
    1940:	4770      	bx	lr
    1942:	46c0      	nop			; (mov r8, r8)
    1944:	20000020 	.word	0x20000020

00001948 <platform_leave_critical_section>:
 
void platform_leave_critical_section(void)
{
	Enable_global_interrupt();
    1948:	2201      	movs	r2, #1
    194a:	4b03      	ldr	r3, [pc, #12]	; (1958 <platform_leave_critical_section+0x10>)
    194c:	701a      	strb	r2, [r3, #0]
    194e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    1952:	b662      	cpsie	i
}
    1954:	4770      	bx	lr
    1956:	46c0      	nop			; (mov r8, r8)
    1958:	20000020 	.word	0x20000020

0000195c <platform_interface_send>:
	return AT_BLE_INVALID_PARAM;
	
}

at_ble_status_t platform_interface_send(uint8_t if_type, uint8_t* data, uint32_t len)
{
    195c:	b538      	push	{r3, r4, r5, lr}
    195e:	1c0d      	adds	r5, r1, #0
    1960:	1c14      	adds	r4, r2, #0
	if (if_type != AT_BLE_UART)
	{
		return AT_BLE_INVALID_PARAM;
    1962:	23cf      	movs	r3, #207	; 0xcf
	
}

at_ble_status_t platform_interface_send(uint8_t if_type, uint8_t* data, uint32_t len)
{
	if (if_type != AT_BLE_UART)
    1964:	2801      	cmp	r0, #1
    1966:	d10d      	bne.n	1984 <platform_interface_send+0x28>
	{
		DBG_LOG_CONT("0x%X, ", data[i]);
		
	}
#endif
	platform_enter_critical_section();
    1968:	4b07      	ldr	r3, [pc, #28]	; (1988 <platform_interface_send+0x2c>)
    196a:	4798      	blx	r3
	platform_set_serial_drv_tx_status();
    196c:	4b07      	ldr	r3, [pc, #28]	; (198c <platform_interface_send+0x30>)
    196e:	4798      	blx	r3
	platform_leave_critical_section();
    1970:	4b07      	ldr	r3, [pc, #28]	; (1990 <platform_interface_send+0x34>)
    1972:	4798      	blx	r3
	check_and_assert_ext_wakeup(TX_MODE);
    1974:	2001      	movs	r0, #1
    1976:	4b07      	ldr	r3, [pc, #28]	; (1994 <platform_interface_send+0x38>)
    1978:	4798      	blx	r3

	serial_drv_send(data, len);
    197a:	b2a1      	uxth	r1, r4
    197c:	1c28      	adds	r0, r5, #0
    197e:	4b06      	ldr	r3, [pc, #24]	; (1998 <platform_interface_send+0x3c>)
    1980:	4798      	blx	r3
	return AT_BLE_SUCCESS;
    1982:	2300      	movs	r3, #0
}
    1984:	1c18      	adds	r0, r3, #0
    1986:	bd38      	pop	{r3, r4, r5, pc}
    1988:	00001935 	.word	0x00001935
    198c:	000014a5 	.word	0x000014a5
    1990:	00001949 	.word	0x00001949
    1994:	000017bd 	.word	0x000017bd
    1998:	00001161 	.word	0x00001161

0000199c <platform_process_rxdata>:
	Enable_global_interrupt();
}


void platform_process_rxdata(uint32_t t_rx_data)
{
    199c:	b510      	push	{r4, lr}
    199e:	b082      	sub	sp, #8
    19a0:	9001      	str	r0, [sp, #4]
	if(slave_state == PLATFORM_TRANSPORT_SLAVE_CONNECTED)
    19a2:	4b19      	ldr	r3, [pc, #100]	; (1a08 <platform_process_rxdata+0x6c>)
    19a4:	781b      	ldrb	r3, [r3, #0]
    19a6:	2b02      	cmp	r3, #2
    19a8:	d119      	bne.n	19de <platform_process_rxdata+0x42>
	{
		platform_enter_critical_section();
    19aa:	4b18      	ldr	r3, [pc, #96]	; (1a0c <platform_process_rxdata+0x70>)
    19ac:	4798      	blx	r3
		ser_fifo_push_uint8(&ble_usart_rx_fifo, (uint8_t)t_rx_data);
    19ae:	9c01      	ldr	r4, [sp, #4]
 *  \return The number of used elements.
 */
static inline uint16_t ser_fifo_get_used_size(ser_fifo_desc_t *ser_fifo_desc)
{
        uint16_t read_index;
        read_index = ser_fifo_desc->read_index;
    19b0:	4917      	ldr	r1, [pc, #92]	; (1a10 <platform_process_rxdata+0x74>)
    19b2:	8888      	ldrh	r0, [r1, #4]
	return ((ser_fifo_desc->write_index - read_index) & ser_fifo_desc->mask);
    19b4:	88cb      	ldrh	r3, [r1, #6]
    19b6:	894a      	ldrh	r2, [r1, #10]
    19b8:	1a1b      	subs	r3, r3, r0
 */
static inline int ser_fifo_push_uint8(ser_fifo_desc_t *ser_fifo_desc, uint32_t item)
{
	uint16_t write_index;

	if (ser_fifo_is_full(ser_fifo_desc)) {
    19ba:	8909      	ldrh	r1, [r1, #8]
    19bc:	4013      	ands	r3, r2
    19be:	4299      	cmp	r1, r3
    19c0:	d00a      	beq.n	19d8 <platform_process_rxdata+0x3c>
		return SER_FIFO_ERROR_OVERFLOW;
	}

	write_index = ser_fifo_desc->write_index;
    19c2:	4913      	ldr	r1, [pc, #76]	; (1a10 <platform_process_rxdata+0x74>)
    19c4:	88cb      	ldrh	r3, [r1, #6]
    19c6:	b29b      	uxth	r3, r3
	ser_fifo_desc->buffer.u8ptr[write_index & (ser_fifo_desc->mask >> 1)] = item;
    19c8:	0852      	lsrs	r2, r2, #1
    19ca:	401a      	ands	r2, r3
    19cc:	6808      	ldr	r0, [r1, #0]
    19ce:	5484      	strb	r4, [r0, r2]
	write_index = (write_index + 1) & ser_fifo_desc->mask;
    19d0:	3301      	adds	r3, #1
    19d2:	894a      	ldrh	r2, [r1, #10]
    19d4:	4013      	ands	r3, r2

	// Must be the last thing to do.
	barrier();
	ser_fifo_desc->write_index = write_index;
    19d6:	80cb      	strh	r3, [r1, #6]
		platform_leave_critical_section();
    19d8:	4b0e      	ldr	r3, [pc, #56]	; (1a14 <platform_process_rxdata+0x78>)
    19da:	4798      	blx	r3
    19dc:	e012      	b.n	1a04 <platform_process_rxdata+0x68>
	}			
	else if(slave_state == PLATFORM_TRANSPORT_SLAVE_PATCH_DOWNLOAD)
    19de:	4b0a      	ldr	r3, [pc, #40]	; (1a08 <platform_process_rxdata+0x6c>)
    19e0:	781b      	ldrb	r3, [r3, #0]
    19e2:	2b01      	cmp	r3, #1
    19e4:	d104      	bne.n	19f0 <platform_process_rxdata+0x54>
	{
		fw_patch_download_cb((uint8_t*)&t_rx_data, 1);
    19e6:	a801      	add	r0, sp, #4
    19e8:	2101      	movs	r1, #1
    19ea:	4b0b      	ldr	r3, [pc, #44]	; (1a18 <platform_process_rxdata+0x7c>)
    19ec:	4798      	blx	r3
    19ee:	e009      	b.n	1a04 <platform_process_rxdata+0x68>
	}
	else if(slave_state == PLATFORM_TRANSPORT_SLAVE_DISCONNECTED)
    19f0:	4b05      	ldr	r3, [pc, #20]	; (1a08 <platform_process_rxdata+0x6c>)
    19f2:	781b      	ldrb	r3, [r3, #0]
    19f4:	2b00      	cmp	r3, #0
    19f6:	d105      	bne.n	1a04 <platform_process_rxdata+0x68>
	{
		if(t_rx_data == GTL_EIF_CONNECT_RESP)
    19f8:	9b01      	ldr	r3, [sp, #4]
    19fa:	2b5a      	cmp	r3, #90	; 0x5a
    19fc:	d102      	bne.n	1a04 <platform_process_rxdata+0x68>
		{
			slave_state = PLATFORM_TRANSPORT_SLAVE_PATCH_DOWNLOAD;
    19fe:	2201      	movs	r2, #1
    1a00:	4b01      	ldr	r3, [pc, #4]	; (1a08 <platform_process_rxdata+0x6c>)
    1a02:	701a      	strb	r2, [r3, #0]
		}				
	}
}
    1a04:	b002      	add	sp, #8
    1a06:	bd10      	pop	{r4, pc}
    1a08:	200003a1 	.word	0x200003a1
    1a0c:	00001935 	.word	0x00001935
    1a10:	20001338 	.word	0x20001338
    1a14:	00001949 	.word	0x00001949
    1a18:	0000864d 	.word	0x0000864d

00001a1c <platform_cmd_cmpl_wait>:
		}
	}
}

void platform_cmd_cmpl_wait(bool* timeout)
{
    1a1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a1e:	4647      	mov	r7, r8
    1a20:	b480      	push	{r7}
    1a22:	b082      	sub	sp, #8
    1a24:	4680      	mov	r8, r0
	uint32_t t_rx_data;
	start_timer(PLATFORM_EVT_WAIT_TIMEOUT);
    1a26:	20fa      	movs	r0, #250	; 0xfa
    1a28:	0100      	lsls	r0, r0, #4
    1a2a:	4b1c      	ldr	r3, [pc, #112]	; (1a9c <platform_cmd_cmpl_wait+0x80>)
    1a2c:	4798      	blx	r3
	do 
	{
		platform_enter_critical_section();
    1a2e:	4e1c      	ldr	r6, [pc, #112]	; (1aa0 <platform_cmd_cmpl_wait+0x84>)
 *    \retval false when the FIFO is not empty.
 */
static inline bool ser_fifo_is_empty(ser_fifo_desc_t *ser_fifo_desc)
{
  uint16_t read_index;
  read_index = ser_fifo_desc->read_index;
    1a30:	4d1c      	ldr	r5, [pc, #112]	; (1aa4 <platform_cmd_cmpl_wait+0x88>)

	if (ser_fifo_is_empty(ser_fifo_desc)) {
		return SER_FIFO_ERROR_UNDERFLOW;
	}

	read_index = ser_fifo_desc->read_index;
    1a32:	1c2c      	adds	r4, r5, #0
    1a34:	47b0      	blx	r6
 *    \retval false when the FIFO is not empty.
 */
static inline bool ser_fifo_is_empty(ser_fifo_desc_t *ser_fifo_desc)
{
  uint16_t read_index;
  read_index = ser_fifo_desc->read_index;
    1a36:	88ab      	ldrh	r3, [r5, #4]
  if(read_index == ser_fifo_desc->write_index)
    1a38:	88ea      	ldrh	r2, [r5, #6]
    1a3a:	b29b      	uxth	r3, r3
 */
static inline int ser_fifo_pull_uint8(ser_fifo_desc_t *ser_fifo_desc, uint8_t *item)
{
	uint16_t read_index;

	if (ser_fifo_is_empty(ser_fifo_desc)) {
    1a3c:	4293      	cmp	r3, r2
    1a3e:	d011      	beq.n	1a64 <platform_cmd_cmpl_wait+0x48>
		return SER_FIFO_ERROR_UNDERFLOW;
	}

	read_index = ser_fifo_desc->read_index;
    1a40:	88a3      	ldrh	r3, [r4, #4]
    1a42:	b29b      	uxth	r3, r3
	*item = ser_fifo_desc->buffer.u8ptr[read_index & (ser_fifo_desc->mask >> 1)];
    1a44:	8961      	ldrh	r1, [r4, #10]
    1a46:	084a      	lsrs	r2, r1, #1
    1a48:	401a      	ands	r2, r3
    1a4a:	6820      	ldr	r0, [r4, #0]
    1a4c:	5c82      	ldrb	r2, [r0, r2]
    1a4e:	af01      	add	r7, sp, #4
    1a50:	703a      	strb	r2, [r7, #0]
	read_index = (read_index + 1) & ser_fifo_desc->mask;
    1a52:	3301      	adds	r3, #1
    1a54:	400b      	ands	r3, r1

	// Must be the last thing to do.
	barrier();
	ser_fifo_desc->read_index = read_index;
    1a56:	80a3      	strh	r3, [r4, #4]
		if(ser_fifo_pull_uint8(&ble_usart_rx_fifo, (uint8_t *)&t_rx_data) == SER_FIFO_OK)
		{		
			platform_leave_critical_section();	
    1a58:	4b13      	ldr	r3, [pc, #76]	; (1aa8 <platform_cmd_cmpl_wait+0x8c>)
    1a5a:	4798      	blx	r3
			platform_interface_callback((uint8_t*)&t_rx_data, 1);
    1a5c:	1c38      	adds	r0, r7, #0
    1a5e:	2101      	movs	r1, #1
    1a60:	4b12      	ldr	r3, [pc, #72]	; (1aac <platform_cmd_cmpl_wait+0x90>)
    1a62:	4798      	blx	r3
		}
		platform_leave_critical_section();
    1a64:	4b10      	ldr	r3, [pc, #64]	; (1aa8 <platform_cmd_cmpl_wait+0x8c>)
    1a66:	4798      	blx	r3
	}while((cmd_cmpl_flag != 1) && (timer_done()>0));
    1a68:	4b11      	ldr	r3, [pc, #68]	; (1ab0 <platform_cmd_cmpl_wait+0x94>)
    1a6a:	681b      	ldr	r3, [r3, #0]
    1a6c:	2b01      	cmp	r3, #1
    1a6e:	d003      	beq.n	1a78 <platform_cmd_cmpl_wait+0x5c>
    1a70:	4b10      	ldr	r3, [pc, #64]	; (1ab4 <platform_cmd_cmpl_wait+0x98>)
    1a72:	4798      	blx	r3
    1a74:	2800      	cmp	r0, #0
    1a76:	d1dd      	bne.n	1a34 <platform_cmd_cmpl_wait+0x18>

	if (cmd_cmpl_flag == 1)
    1a78:	4b0d      	ldr	r3, [pc, #52]	; (1ab0 <platform_cmd_cmpl_wait+0x94>)
    1a7a:	681b      	ldr	r3, [r3, #0]
    1a7c:	2b01      	cmp	r3, #1
    1a7e:	d105      	bne.n	1a8c <platform_cmd_cmpl_wait+0x70>
	{
	#ifdef BLE_DBG_ENABLE
		DBG_LOG_BLE("\r\nAS\n");
	#endif
		cmd_cmpl_flag = 0;
    1a80:	2300      	movs	r3, #0
    1a82:	4a0b      	ldr	r2, [pc, #44]	; (1ab0 <platform_cmd_cmpl_wait+0x94>)
    1a84:	6013      	str	r3, [r2, #0]
	 
 }
 
 void stop_timer(void)
 {
	 ticks = 0;
    1a86:	4a0c      	ldr	r2, [pc, #48]	; (1ab8 <platform_cmd_cmpl_wait+0x9c>)
    1a88:	6013      	str	r3, [r2, #0]
    1a8a:	e002      	b.n	1a92 <platform_cmd_cmpl_wait+0x76>
		cmd_cmpl_flag = 0;
		stop_timer();
	}
	else
	{
		*timeout = true;
    1a8c:	2301      	movs	r3, #1
    1a8e:	4642      	mov	r2, r8
    1a90:	7013      	strb	r3, [r2, #0]
	#ifdef BLE_DBG_ENABLE
		DBG_LOG_BLE("\r\nAF\n");
	#endif
	}
}
    1a92:	b002      	add	sp, #8
    1a94:	bc04      	pop	{r2}
    1a96:	4690      	mov	r8, r2
    1a98:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a9a:	46c0      	nop			; (mov r8, r8)
    1a9c:	0000189d 	.word	0x0000189d
    1aa0:	00001935 	.word	0x00001935
    1aa4:	20001338 	.word	0x20001338
    1aa8:	00001949 	.word	0x00001949
    1aac:	00008849 	.word	0x00008849
    1ab0:	200000e4 	.word	0x200000e4
    1ab4:	00001925 	.word	0x00001925
    1ab8:	200000e0 	.word	0x200000e0

00001abc <platform_event_signal>:

void platform_event_signal(void)
{
	event_flag = 1;
    1abc:	2201      	movs	r2, #1
    1abe:	4b01      	ldr	r3, [pc, #4]	; (1ac4 <platform_event_signal+0x8>)
    1ac0:	601a      	str	r2, [r3, #0]
}
    1ac2:	4770      	bx	lr
    1ac4:	200000dc 	.word	0x200000dc

00001ac8 <platform_event_wait>:

at_ble_status_t platform_event_wait(uint32_t timeout)
{
    1ac8:	b570      	push	{r4, r5, r6, lr}
    1aca:	b082      	sub	sp, #8
	at_ble_status_t status = AT_BLE_SUCCESS;
	uint8_t platform_buf[1];
	uint32_t t_rx_data;
	start_timer(timeout);
    1acc:	4b1a      	ldr	r3, [pc, #104]	; (1b38 <platform_event_wait+0x70>)
    1ace:	4798      	blx	r3
	do
	{
		platform_enter_critical_section();
    1ad0:	4e1a      	ldr	r6, [pc, #104]	; (1b3c <platform_event_wait+0x74>)
 *    \retval false when the FIFO is not empty.
 */
static inline bool ser_fifo_is_empty(ser_fifo_desc_t *ser_fifo_desc)
{
  uint16_t read_index;
  read_index = ser_fifo_desc->read_index;
    1ad2:	4d1b      	ldr	r5, [pc, #108]	; (1b40 <platform_event_wait+0x78>)

	if (ser_fifo_is_empty(ser_fifo_desc)) {
		return SER_FIFO_ERROR_UNDERFLOW;
	}

	read_index = ser_fifo_desc->read_index;
    1ad4:	1c2c      	adds	r4, r5, #0
    1ad6:	47b0      	blx	r6
 *    \retval false when the FIFO is not empty.
 */
static inline bool ser_fifo_is_empty(ser_fifo_desc_t *ser_fifo_desc)
{
  uint16_t read_index;
  read_index = ser_fifo_desc->read_index;
    1ad8:	88ab      	ldrh	r3, [r5, #4]
  if(read_index == ser_fifo_desc->write_index)
    1ada:	88ea      	ldrh	r2, [r5, #6]
    1adc:	b29b      	uxth	r3, r3
 */
static inline int ser_fifo_pull_uint8(ser_fifo_desc_t *ser_fifo_desc, uint8_t *item)
{
	uint16_t read_index;

	if (ser_fifo_is_empty(ser_fifo_desc)) {
    1ade:	4293      	cmp	r3, r2
    1ae0:	d013      	beq.n	1b0a <platform_event_wait+0x42>
		return SER_FIFO_ERROR_UNDERFLOW;
	}

	read_index = ser_fifo_desc->read_index;
    1ae2:	88a3      	ldrh	r3, [r4, #4]
    1ae4:	b29b      	uxth	r3, r3
	*item = ser_fifo_desc->buffer.u8ptr[read_index & (ser_fifo_desc->mask >> 1)];
    1ae6:	8961      	ldrh	r1, [r4, #10]
    1ae8:	084a      	lsrs	r2, r1, #1
    1aea:	401a      	ands	r2, r3
    1aec:	6820      	ldr	r0, [r4, #0]
    1aee:	5c82      	ldrb	r2, [r0, r2]
    1af0:	4668      	mov	r0, sp
    1af2:	7002      	strb	r2, [r0, #0]
	read_index = (read_index + 1) & ser_fifo_desc->mask;
    1af4:	3301      	adds	r3, #1
    1af6:	400b      	ands	r3, r1

	// Must be the last thing to do.
	barrier();
	ser_fifo_desc->read_index = read_index;
    1af8:	80a3      	strh	r3, [r4, #4]
		if(ser_fifo_pull_uint8(&ble_usart_rx_fifo, (uint8_t *)&t_rx_data) == SER_FIFO_OK)
		{
			platform_leave_critical_section();
    1afa:	4b12      	ldr	r3, [pc, #72]	; (1b44 <platform_event_wait+0x7c>)
    1afc:	4798      	blx	r3
			platform_buf[0] = (uint8_t)t_rx_data;
    1afe:	a801      	add	r0, sp, #4
    1b00:	9b00      	ldr	r3, [sp, #0]
    1b02:	7003      	strb	r3, [r0, #0]
			platform_interface_callback(platform_buf, 1);
    1b04:	2101      	movs	r1, #1
    1b06:	4b10      	ldr	r3, [pc, #64]	; (1b48 <platform_event_wait+0x80>)
    1b08:	4798      	blx	r3
		}
		platform_leave_critical_section();
    1b0a:	4b0e      	ldr	r3, [pc, #56]	; (1b44 <platform_event_wait+0x7c>)
    1b0c:	4798      	blx	r3
	}while((event_flag != 1) && (timer_done()>0));
    1b0e:	4b0f      	ldr	r3, [pc, #60]	; (1b4c <platform_event_wait+0x84>)
    1b10:	681b      	ldr	r3, [r3, #0]
    1b12:	2b01      	cmp	r3, #1
    1b14:	d003      	beq.n	1b1e <platform_event_wait+0x56>
    1b16:	4b0e      	ldr	r3, [pc, #56]	; (1b50 <platform_event_wait+0x88>)
    1b18:	4798      	blx	r3
    1b1a:	2800      	cmp	r0, #0
    1b1c:	d1db      	bne.n	1ad6 <platform_event_wait+0xe>
	if (event_flag == 1)
    1b1e:	4b0b      	ldr	r3, [pc, #44]	; (1b4c <platform_event_wait+0x84>)
    1b20:	681b      	ldr	r3, [r3, #0]
		#endif
		stop_timer();
	}
	else
	{
		status = AT_BLE_TIMEOUT;
    1b22:	20d0      	movs	r0, #208	; 0xd0
			platform_buf[0] = (uint8_t)t_rx_data;
			platform_interface_callback(platform_buf, 1);
		}
		platform_leave_critical_section();
	}while((event_flag != 1) && (timer_done()>0));
	if (event_flag == 1)
    1b24:	2b01      	cmp	r3, #1
    1b26:	d105      	bne.n	1b34 <platform_event_wait+0x6c>
	{
		event_flag = 0;
    1b28:	2300      	movs	r3, #0
    1b2a:	4a08      	ldr	r2, [pc, #32]	; (1b4c <platform_event_wait+0x84>)
    1b2c:	6013      	str	r3, [r2, #0]
	 
 }
 
 void stop_timer(void)
 {
	 ticks = 0;
    1b2e:	4a09      	ldr	r2, [pc, #36]	; (1b54 <platform_event_wait+0x8c>)
    1b30:	6013      	str	r3, [r2, #0]
	event_flag = 1;
}

at_ble_status_t platform_event_wait(uint32_t timeout)
{
	at_ble_status_t status = AT_BLE_SUCCESS;
    1b32:	2000      	movs	r0, #0
		#ifdef BLE_DBG_ENABLE
		DBG_LOG_BLE("\r\nSF\n");
		#endif
	}	
	return status;
}
    1b34:	b002      	add	sp, #8
    1b36:	bd70      	pop	{r4, r5, r6, pc}
    1b38:	0000189d 	.word	0x0000189d
    1b3c:	00001935 	.word	0x00001935
    1b40:	20001338 	.word	0x20001338
    1b44:	00001949 	.word	0x00001949
    1b48:	00008849 	.word	0x00008849
    1b4c:	200000dc 	.word	0x200000dc
    1b50:	00001925 	.word	0x00001925
    1b54:	200000e0 	.word	0x200000e0

00001b58 <platform_sleep>:

uint8_t platform_sleep(uint32_t sleepms)
{
    1b58:	b508      	push	{r3, lr}
	delay_ms(sleepms);
    1b5a:	4b02      	ldr	r3, [pc, #8]	; (1b64 <platform_sleep+0xc>)
    1b5c:	4798      	blx	r3
	return true;
}
    1b5e:	2001      	movs	r0, #1
    1b60:	bd08      	pop	{r3, pc}
    1b62:	46c0      	nop			; (mov r8, r8)
    1b64:	00001e1d 	.word	0x00001e1d

00001b68 <serial_rx_callback>:

void serial_rx_callback(void) 
{
    1b68:	b508      	push	{r3, lr}
	check_and_assert_ext_wakeup(RX_MODE);
    1b6a:	2002      	movs	r0, #2
    1b6c:	4b01      	ldr	r3, [pc, #4]	; (1b74 <serial_rx_callback+0xc>)
    1b6e:	4798      	blx	r3
}
    1b70:	bd08      	pop	{r3, pc}
    1b72:	46c0      	nop			; (mov r8, r8)
    1b74:	000017bd 	.word	0x000017bd

00001b78 <serial_tx_callback>:

void serial_tx_callback(void)
{
	tx_done = 1;
    1b78:	2201      	movs	r2, #1
    1b7a:	4b01      	ldr	r3, [pc, #4]	; (1b80 <serial_tx_callback+0x8>)
    1b7c:	701a      	strb	r2, [r3, #0]
}
    1b7e:	4770      	bx	lr
    1b80:	200000d8 	.word	0x200000d8

00001b84 <platform_cleanup>:
 }
 
 void platform_cleanup(void)
 {
	 
 }
    1b84:	4770      	bx	lr
    1b86:	46c0      	nop			; (mov r8, r8)

00001b88 <stop_timer>:
 
 void stop_timer(void)
 {
	 ticks = 0;
    1b88:	2200      	movs	r2, #0
    1b8a:	4b01      	ldr	r3, [pc, #4]	; (1b90 <stop_timer+0x8>)
    1b8c:	601a      	str	r2, [r3, #0]
 }
    1b8e:	4770      	bx	lr
    1b90:	200000e0 	.word	0x200000e0

00001b94 <platform_configure_hw_fc_uart>:

 void platform_configure_hw_fc_uart(void)
 {
    1b94:	b508      	push	{r3, lr}
 	configure_usart_after_patch();
    1b96:	4b01      	ldr	r3, [pc, #4]	; (1b9c <platform_configure_hw_fc_uart+0x8>)
    1b98:	4798      	blx	r3
 }
    1b9a:	bd08      	pop	{r3, pc}
    1b9c:	0000132d 	.word	0x0000132d

00001ba0 <getchar_timeout>:
	stdio_serial_init(&cdc_uart_module, CONF_STDIO_USART_MODULE, &usart_conf);
	usart_enable(&cdc_uart_module);
}

uint8_t getchar_timeout(uint32_t timeout)
{
    1ba0:	b570      	push	{r4, r5, r6, lr}
    1ba2:	b082      	sub	sp, #8
	uint16_t temp = NULL;
    1ba4:	2200      	movs	r2, #0
    1ba6:	466b      	mov	r3, sp
    1ba8:	80da      	strh	r2, [r3, #6]

	start_timer(timeout);
    1baa:	4b09      	ldr	r3, [pc, #36]	; (1bd0 <getchar_timeout+0x30>)
    1bac:	4798      	blx	r3
	while((STATUS_OK != usart_read_wait(&cdc_uart_module, &temp)) && (timer_done()>0));
    1bae:	4d09      	ldr	r5, [pc, #36]	; (1bd4 <getchar_timeout+0x34>)
    1bb0:	4c09      	ldr	r4, [pc, #36]	; (1bd8 <getchar_timeout+0x38>)
    1bb2:	4e0a      	ldr	r6, [pc, #40]	; (1bdc <getchar_timeout+0x3c>)
    1bb4:	1c28      	adds	r0, r5, #0
    1bb6:	466b      	mov	r3, sp
    1bb8:	1d99      	adds	r1, r3, #6
    1bba:	47a0      	blx	r4
    1bbc:	2800      	cmp	r0, #0
    1bbe:	d002      	beq.n	1bc6 <getchar_timeout+0x26>
    1bc0:	47b0      	blx	r6
    1bc2:	2800      	cmp	r0, #0
    1bc4:	d1f6      	bne.n	1bb4 <getchar_timeout+0x14>

	return ((uint8_t)temp);	
    1bc6:	466b      	mov	r3, sp
    1bc8:	7998      	ldrb	r0, [r3, #6]
}
    1bca:	b002      	add	sp, #8
    1bcc:	bd70      	pop	{r4, r5, r6, pc}
    1bce:	46c0      	nop			; (mov r8, r8)
    1bd0:	0000189d 	.word	0x0000189d
    1bd4:	200000e8 	.word	0x200000e8
    1bd8:	000050bd 	.word	0x000050bd
    1bdc:	00001925 	.word	0x00001925

00001be0 <tc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    1be0:	1c93      	adds	r3, r2, #2
    1be2:	009b      	lsls	r3, r3, #2
    1be4:	5019      	str	r1, [r3, r0]

	/* Set the bit corresponding to the callback_type */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
    1be6:	2a02      	cmp	r2, #2
    1be8:	d104      	bne.n	1bf4 <tc_register_callback+0x14>
		module->register_callback_mask |= TC_INTFLAG_MC(1);
    1bea:	7e02      	ldrb	r2, [r0, #24]
    1bec:	2310      	movs	r3, #16
    1bee:	4313      	orrs	r3, r2
    1bf0:	7603      	strb	r3, [r0, #24]
    1bf2:	e00c      	b.n	1c0e <tc_register_callback+0x2e>
	}
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
    1bf4:	2a03      	cmp	r2, #3
    1bf6:	d104      	bne.n	1c02 <tc_register_callback+0x22>
		module->register_callback_mask |= TC_INTFLAG_MC(2);
    1bf8:	7e02      	ldrb	r2, [r0, #24]
    1bfa:	2320      	movs	r3, #32
    1bfc:	4313      	orrs	r3, r2
    1bfe:	7603      	strb	r3, [r0, #24]
    1c00:	e005      	b.n	1c0e <tc_register_callback+0x2e>
	}
	else {
		module->register_callback_mask |= (1 << callback_type);
    1c02:	2301      	movs	r3, #1
    1c04:	4093      	lsls	r3, r2
    1c06:	1c1a      	adds	r2, r3, #0
    1c08:	7e03      	ldrb	r3, [r0, #24]
    1c0a:	431a      	orrs	r2, r3
    1c0c:	7602      	strb	r2, [r0, #24]
	}
	return STATUS_OK;
}
    1c0e:	2000      	movs	r0, #0
    1c10:	4770      	bx	lr
    1c12:	46c0      	nop			; (mov r8, r8)

00001c14 <_tc_interrupt_handler>:
 * \param[in]  instance  ID of the TC instance calling the interrupt
 *                       handler
 */
void _tc_interrupt_handler(
		uint8_t instance)
{
    1c14:	b538      	push	{r3, r4, r5, lr}
	/* Temporary variable */
	uint8_t interrupt_and_callback_status_mask;

	/* Get device instance from the look-up table */
	struct tc_module *module
    1c16:	0080      	lsls	r0, r0, #2
    1c18:	4b14      	ldr	r3, [pc, #80]	; (1c6c <_tc_interrupt_handler+0x58>)
    1c1a:	58c5      	ldr	r5, [r0, r3]
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    1c1c:	682b      	ldr	r3, [r5, #0]
    1c1e:	7b9c      	ldrb	r4, [r3, #14]
    1c20:	7e2b      	ldrb	r3, [r5, #24]
    1c22:	401c      	ands	r4, r3
    1c24:	7e6b      	ldrb	r3, [r5, #25]
    1c26:	401c      	ands	r4, r3
			module->register_callback_mask &
			module->enable_callback_mask;

	/* Check if an Overflow interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
    1c28:	07e3      	lsls	r3, r4, #31
    1c2a:	d505      	bpl.n	1c38 <_tc_interrupt_handler+0x24>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_OVERFLOW])(module);
    1c2c:	1c28      	adds	r0, r5, #0
    1c2e:	68ab      	ldr	r3, [r5, #8]
    1c30:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    1c32:	2301      	movs	r3, #1
    1c34:	682a      	ldr	r2, [r5, #0]
    1c36:	7393      	strb	r3, [r2, #14]
	}

	/* Check if an Error interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_ERR) {
    1c38:	07a3      	lsls	r3, r4, #30
    1c3a:	d505      	bpl.n	1c48 <_tc_interrupt_handler+0x34>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_ERROR])(module);
    1c3c:	1c28      	adds	r0, r5, #0
    1c3e:	68eb      	ldr	r3, [r5, #12]
    1c40:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_ERR;
    1c42:	2302      	movs	r3, #2
    1c44:	682a      	ldr	r2, [r5, #0]
    1c46:	7393      	strb	r3, [r2, #14]
	}

	/* Check if an Match/Capture Channel 0 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(1)) {
    1c48:	06e3      	lsls	r3, r4, #27
    1c4a:	d505      	bpl.n	1c58 <_tc_interrupt_handler+0x44>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL0])(module);
    1c4c:	1c28      	adds	r0, r5, #0
    1c4e:	692b      	ldr	r3, [r5, #16]
    1c50:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(1);
    1c52:	2310      	movs	r3, #16
    1c54:	682a      	ldr	r2, [r5, #0]
    1c56:	7393      	strb	r3, [r2, #14]
	}

	/* Check if an Match/Capture Channel 1 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(2)) {
    1c58:	06a3      	lsls	r3, r4, #26
    1c5a:	d505      	bpl.n	1c68 <_tc_interrupt_handler+0x54>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL1])(module);
    1c5c:	1c28      	adds	r0, r5, #0
    1c5e:	696b      	ldr	r3, [r5, #20]
    1c60:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(2);
    1c62:	682b      	ldr	r3, [r5, #0]
    1c64:	2220      	movs	r2, #32
    1c66:	739a      	strb	r2, [r3, #14]
	}
}
    1c68:	bd38      	pop	{r3, r4, r5, pc}
    1c6a:	46c0      	nop			; (mov r8, r8)
    1c6c:	200015c4 	.word	0x200015c4

00001c70 <TC3_Handler>:
#if (SAML21E) || (SAML21G)
	_TC_INTERRUPT_HANDLER(0,0)
	_TC_INTERRUPT_HANDLER(1,1)
	_TC_INTERRUPT_HANDLER(4,2)
#else
	MRECURSION(TC_INST_NUM, _TC_INTERRUPT_HANDLER, TC_INST_MAX_ID)
    1c70:	b508      	push	{r3, lr}
    1c72:	2000      	movs	r0, #0
    1c74:	4b01      	ldr	r3, [pc, #4]	; (1c7c <TC3_Handler+0xc>)
    1c76:	4798      	blx	r3
    1c78:	bd08      	pop	{r3, pc}
    1c7a:	46c0      	nop			; (mov r8, r8)
    1c7c:	00001c15 	.word	0x00001c15

00001c80 <TC4_Handler>:
    1c80:	b508      	push	{r3, lr}
    1c82:	2001      	movs	r0, #1
    1c84:	4b01      	ldr	r3, [pc, #4]	; (1c8c <TC4_Handler+0xc>)
    1c86:	4798      	blx	r3
    1c88:	bd08      	pop	{r3, pc}
    1c8a:	46c0      	nop			; (mov r8, r8)
    1c8c:	00001c15 	.word	0x00001c15

00001c90 <TC5_Handler>:
    1c90:	b508      	push	{r3, lr}
    1c92:	2002      	movs	r0, #2
    1c94:	4b01      	ldr	r3, [pc, #4]	; (1c9c <TC5_Handler+0xc>)
    1c96:	4798      	blx	r3
    1c98:	bd08      	pop	{r3, pc}
    1c9a:	46c0      	nop			; (mov r8, r8)
    1c9c:	00001c15 	.word	0x00001c15

00001ca0 <bat_init_service>:
extern ble_connected_dev_info_t ble_dev_info[BLE_MAX_DEVICE_CONNECTED];

/**@brief Initialize the service with its included service, characteristics, and descriptors
 */
void bat_init_service(bat_gatt_service_handler_t *battery_serv, uint8_t *battery_value)
{
    1ca0:	b530      	push	{r4, r5, lr}
	battery_serv->serv_handle = 0;
    1ca2:	2300      	movs	r3, #0
    1ca4:	2100      	movs	r1, #0
    1ca6:	8243      	strh	r3, [r0, #18]
	battery_serv->serv_uuid.type = AT_BLE_UUID_16;
    1ca8:	7001      	strb	r1, [r0, #0]
	battery_serv->serv_uuid.uuid[0] = (uint8_t) BAT_SERVICE_UUID;
    1caa:	220f      	movs	r2, #15
    1cac:	7042      	strb	r2, [r0, #1]
	battery_serv->serv_uuid.uuid[1] = (uint8_t) (BAT_SERVICE_UUID >> 8);
    1cae:	2418      	movs	r4, #24
    1cb0:	7084      	strb	r4, [r0, #2]
	
	//Battery service characteristic
	battery_serv->serv_chars.char_val_handle = 0;          /* handle stored here */
    1cb2:	8283      	strh	r3, [r0, #20]
	battery_serv->serv_chars.uuid.type = AT_BLE_UUID_16;
    1cb4:	7581      	strb	r1, [r0, #22]
	battery_serv->serv_chars.uuid.uuid[0] = (uint8_t) BAT_CHAR_BAT_LEVEL_UUID;          /* UUID : Manufacturer Name String */
    1cb6:	320a      	adds	r2, #10
    1cb8:	75c2      	strb	r2, [r0, #23]
	battery_serv->serv_chars.uuid.uuid[1] = (uint8_t) (BAT_CHAR_BAT_LEVEL_UUID >> 8);          /* UUID : Manufacturer Name String */
    1cba:	3211      	adds	r2, #17
    1cbc:	7602      	strb	r2, [r0, #24]
	battery_serv->serv_chars.properties = (AT_BLE_CHAR_READ | AT_BLE_CHAR_NOTIFY); /* Properties */
    1cbe:	3a18      	subs	r2, #24
    1cc0:	8502      	strh	r2, [r0, #40]	; 0x28
	battery_serv->serv_chars.init_value = &battery_init_value;             /* value */
    1cc2:	4a10      	ldr	r2, [pc, #64]	; (1d04 <bat_init_service+0x64>)
    1cc4:	62c2      	str	r2, [r0, #44]	; 0x2c
	battery_serv->serv_chars.value_init_len = sizeof(uint8_t);
    1cc6:	2201      	movs	r2, #1
    1cc8:	8602      	strh	r2, [r0, #48]	; 0x30
	battery_serv->serv_chars.value_max_len = sizeof(uint8_t);
    1cca:	8642      	strh	r2, [r0, #50]	; 0x32
#if BLE_PAIR_ENABLE
	battery_serv->serv_chars.value_permissions = (AT_BLE_ATTR_READABLE_REQ_AUTHN_NO_AUTHR |
    1ccc:	2522      	movs	r5, #34	; 0x22
    1cce:	3233      	adds	r2, #51	; 0x33
    1cd0:	5485      	strb	r5, [r0, r2]
												 AT_BLE_ATTR_WRITABLE_REQ_AUTHN_NO_AUTHR);   /* permissions */
#else
	battery_serv->serv_chars.value_permissions = (AT_BLE_ATTR_READABLE_NO_AUTHN_NO_AUTHR |
												 AT_BLE_ATTR_WRITABLE_NO_AUTHN_NO_AUTHR);   /* permissions */
#endif
	battery_serv->serv_chars.user_desc = NULL;           /* user defined name */
    1cd2:	6383      	str	r3, [r0, #56]	; 0x38
	battery_serv->serv_chars.user_desc_len = 0;
    1cd4:	8783      	strh	r3, [r0, #60]	; 0x3c
	battery_serv->serv_chars.user_desc_max_len = 0;
    1cd6:	87c3      	strh	r3, [r0, #62]	; 0x3e
	battery_serv->serv_chars.user_desc_permissions = AT_BLE_ATTR_NO_PERMISSIONS;             /*user description permissions*/
    1cd8:	3210      	adds	r2, #16
    1cda:	5481      	strb	r1, [r0, r2]
	battery_serv->serv_chars.client_config_permissions = AT_BLE_ATTR_NO_PERMISSIONS;         /*client config permissions*/
    1cdc:	3201      	adds	r2, #1
    1cde:	5481      	strb	r1, [r0, r2]
	battery_serv->serv_chars.server_config_permissions = AT_BLE_ATTR_NO_PERMISSIONS;         /*server config permissions*/
    1ce0:	3201      	adds	r2, #1
    1ce2:	5481      	strb	r1, [r0, r2]
	battery_serv->serv_chars.user_desc_handle = 0;             /*user desc handles*/
    1ce4:	3202      	adds	r2, #2
    1ce6:	5283      	strh	r3, [r0, r2]
	battery_serv->serv_chars.client_config_handle = 0;         /*client config handles*/
    1ce8:	3202      	adds	r2, #2
    1cea:	5283      	strh	r3, [r0, r2]
	battery_serv->serv_chars.server_config_handle = 0;         /*server config handles*/
    1cec:	3202      	adds	r2, #2
    1cee:	5283      	strh	r3, [r0, r2]
	
	presentation_format.format = AT_BLE_PRES_FORMAT_UINT8;
    1cf0:	4a05      	ldr	r2, [pc, #20]	; (1d08 <bat_init_service+0x68>)
    1cf2:	3d1e      	subs	r5, #30
    1cf4:	7015      	strb	r5, [r2, #0]
	presentation_format.exponent = BAT_CHAR_PRESENTATION_FORMAT_EXPONENT;
    1cf6:	7051      	strb	r1, [r2, #1]
	presentation_format.unit = (uint8_t) BAT_CHAR_PRESENTATION_FORMAT_UNIT;
	presentation_format.unit = (uint8_t) (BAT_CHAR_PRESENTATION_FORMAT_UNIT >> 8);
    1cf8:	8054      	strh	r4, [r2, #2]
	presentation_format.name_space = BAT_CHAR_PRESENTATION_FORMAT_NAMESPACE;
    1cfa:	2101      	movs	r1, #1
    1cfc:	7111      	strb	r1, [r2, #4]
	presentation_format.description = (uint8_t) BAT_CHAR_PRESENTATION_FORMAT_DESCRIPTOR;
    1cfe:	80d3      	strh	r3, [r2, #6]
	presentation_format.description = (uint8_t) (BAT_CHAR_PRESENTATION_FORMAT_DESCRIPTOR >> 8);
	
	battery_serv->serv_chars.presentation_format = &presentation_format;       /* presentation format */
    1d00:	6402      	str	r2, [r0, #64]	; 0x40
	ALL_UNUSED(battery_value);
}
    1d02:	bd30      	pop	{r4, r5, pc}
    1d04:	2000000c 	.word	0x2000000c
    1d08:	200015d0 	.word	0x200015d0

00001d0c <bat_primary_service_define>:

/**@brief defining a initialized service 
 */
at_ble_status_t bat_primary_service_define(bat_gatt_service_handler_t *battery_service)
{
    1d0c:	b510      	push	{r4, lr}
    1d0e:	b082      	sub	sp, #8
	return(at_ble_primary_service_define(&battery_service->serv_uuid,
    1d10:	1c01      	adds	r1, r0, #0
    1d12:	3112      	adds	r1, #18
    1d14:	1c03      	adds	r3, r0, #0
    1d16:	3314      	adds	r3, #20
    1d18:	9300      	str	r3, [sp, #0]
    1d1a:	2301      	movs	r3, #1
    1d1c:	9301      	str	r3, [sp, #4]
    1d1e:	2200      	movs	r2, #0
    1d20:	2300      	movs	r3, #0
    1d22:	4c02      	ldr	r4, [pc, #8]	; (1d2c <bat_primary_service_define+0x20>)
    1d24:	47a0      	blx	r4
	&battery_service->serv_handle,
	NULL, 0,
	&battery_service->serv_chars, 1));
}
    1d26:	b002      	add	sp, #8
    1d28:	bd10      	pop	{r4, pc}
    1d2a:	46c0      	nop			; (mov r8, r8)
    1d2c:	00007e91 	.word	0x00007e91

00001d30 <bat_update_char_value>:

/**@brief Function used to update characteristic value
 */
at_ble_status_t bat_update_char_value (at_ble_handle_t conn_handle, bat_gatt_service_handler_t *battery_serv , uint8_t char_data,bool volatile *flag)
{
    1d30:	b570      	push	{r4, r5, r6, lr}
    1d32:	b082      	sub	sp, #8
    1d34:	1c04      	adds	r4, r0, #0
    1d36:	1c0e      	adds	r6, r1, #0
    1d38:	1c1d      	adds	r5, r3, #0
    1d3a:	466b      	mov	r3, sp
    1d3c:	1dd9      	adds	r1, r3, #7
    1d3e:	700a      	strb	r2, [r1, #0]
	at_ble_status_t status = AT_BLE_SUCCESS;
	/* Updating the att data base */
	if ((status = at_ble_characteristic_value_set(battery_serv->serv_chars.char_val_handle, &char_data, sizeof(uint8_t))) != AT_BLE_SUCCESS){
    1d40:	8ab0      	ldrh	r0, [r6, #20]
    1d42:	2201      	movs	r2, #1
    1d44:	4b09      	ldr	r3, [pc, #36]	; (1d6c <bat_update_char_value+0x3c>)
    1d46:	4798      	blx	r3
    1d48:	1e03      	subs	r3, r0, #0
    1d4a:	d10c      	bne.n	1d66 <bat_update_char_value+0x36>
		return status;
	} else {
		DBG_LOG_DEV("updating the characteristic value is successful");
	}

	if(bat_notification_flag){
    1d4c:	4b08      	ldr	r3, [pc, #32]	; (1d70 <bat_update_char_value+0x40>)
    1d4e:	781b      	ldrb	r3, [r3, #0]
			DBG_LOG_DEV("sending notification successful");
			*flag = false;
			return status;
		}
	}
	return status;
    1d50:	2000      	movs	r0, #0
		return status;
	} else {
		DBG_LOG_DEV("updating the characteristic value is successful");
	}

	if(bat_notification_flag){
    1d52:	2b00      	cmp	r3, #0
    1d54:	d007      	beq.n	1d66 <bat_update_char_value+0x36>
		/* sending notification to the peer about change in the battery level */ 
		if((status = at_ble_notification_send(conn_handle, battery_serv->serv_chars.char_val_handle)) != AT_BLE_SUCCESS) {
    1d56:	8ab1      	ldrh	r1, [r6, #20]
    1d58:	1c20      	adds	r0, r4, #0
    1d5a:	4b06      	ldr	r3, [pc, #24]	; (1d74 <bat_update_char_value+0x44>)
    1d5c:	4798      	blx	r3
    1d5e:	1e03      	subs	r3, r0, #0
    1d60:	d101      	bne.n	1d66 <bat_update_char_value+0x36>
			DBG_LOG("sending notification failed%d",status);
			return status;
		}
		else {
			DBG_LOG_DEV("sending notification successful");
			*flag = false;
    1d62:	2200      	movs	r2, #0
    1d64:	702a      	strb	r2, [r5, #0]
			return status;
		}
	}
	return status;
}
    1d66:	b002      	add	sp, #8
    1d68:	bd70      	pop	{r4, r5, r6, pc}
    1d6a:	46c0      	nop			; (mov r8, r8)
    1d6c:	00007ec5 	.word	0x00007ec5
    1d70:	2000011c 	.word	0x2000011c
    1d74:	00008065 	.word	0x00008065

00001d78 <bat_char_changed_event>:
/**@brief function to check the client characteristic configuration value. 
 */
at_ble_status_t bat_char_changed_event(at_ble_handle_t conn_handle, bat_gatt_service_handler_t *battery_service, at_ble_characteristic_changed_t *char_handle, bool volatile *flag)
{
    1d78:	b570      	push	{r4, r5, r6, lr}
    1d7a:	4c14      	ldr	r4, [pc, #80]	; (1dcc <bat_char_changed_event+0x54>)
    1d7c:	44a5      	add	sp, r4
    1d7e:	1c05      	adds	r5, r0, #0
    1d80:	1c0c      	adds	r4, r1, #0
    1d82:	1c1e      	adds	r6, r3, #0
	at_ble_status_t status = AT_BLE_SUCCESS;
	at_ble_characteristic_changed_t change_params;
	memcpy((uint8_t *)&change_params, char_handle, sizeof(at_ble_characteristic_changed_t));
    1d84:	a801      	add	r0, sp, #4
    1d86:	1c11      	adds	r1, r2, #0
    1d88:	4a11      	ldr	r2, [pc, #68]	; (1dd0 <bat_char_changed_event+0x58>)
    1d8a:	4b12      	ldr	r3, [pc, #72]	; (1dd4 <bat_char_changed_event+0x5c>)
    1d8c:	4798      	blx	r3
	
	if(battery_service->serv_chars.client_config_handle == change_params.char_handle)
    1d8e:	234a      	movs	r3, #74	; 0x4a
    1d90:	5ae2      	ldrh	r2, [r4, r3]
    1d92:	ab01      	add	r3, sp, #4
    1d94:	885b      	ldrh	r3, [r3, #2]
		else
		{
			bat_notification_flag = false;			
		}
	}
	return status;
    1d96:	2000      	movs	r0, #0
{
	at_ble_status_t status = AT_BLE_SUCCESS;
	at_ble_characteristic_changed_t change_params;
	memcpy((uint8_t *)&change_params, char_handle, sizeof(at_ble_characteristic_changed_t));
	
	if(battery_service->serv_chars.client_config_handle == change_params.char_handle)
    1d98:	429a      	cmp	r2, r3
    1d9a:	d113      	bne.n	1dc4 <bat_char_changed_event+0x4c>
	{
		if(change_params.char_new_value[0])
    1d9c:	ab01      	add	r3, sp, #4
    1d9e:	7a1b      	ldrb	r3, [r3, #8]
    1da0:	2b00      	cmp	r3, #0
    1da2:	d00b      	beq.n	1dbc <bat_char_changed_event+0x44>
		{
			bat_notification_flag = true;
    1da4:	2201      	movs	r2, #1
    1da6:	4b0c      	ldr	r3, [pc, #48]	; (1dd8 <bat_char_changed_event+0x60>)
    1da8:	701a      	strb	r2, [r3, #0]
			/* sending notification to the peer about change in the battery level */
			if((status = at_ble_notification_send(conn_handle, battery_service->serv_chars.char_val_handle)) != AT_BLE_SUCCESS) {
    1daa:	8aa1      	ldrh	r1, [r4, #20]
    1dac:	1c28      	adds	r0, r5, #0
    1dae:	4b0b      	ldr	r3, [pc, #44]	; (1ddc <bat_char_changed_event+0x64>)
    1db0:	4798      	blx	r3
    1db2:	1e03      	subs	r3, r0, #0
    1db4:	d106      	bne.n	1dc4 <bat_char_changed_event+0x4c>
				DBG_LOG("sending notification failed%d",status);
				return status;
			}
			else {
				DBG_LOG_DEV("sending notification successful");
				*flag = false;
    1db6:	2200      	movs	r2, #0
    1db8:	7032      	strb	r2, [r6, #0]
				return status;
    1dba:	e003      	b.n	1dc4 <bat_char_changed_event+0x4c>
			}			
		}
		else
		{
			bat_notification_flag = false;			
    1dbc:	2200      	movs	r2, #0
    1dbe:	4b06      	ldr	r3, [pc, #24]	; (1dd8 <bat_char_changed_event+0x60>)
    1dc0:	701a      	strb	r2, [r3, #0]
		}
	}
	return status;
    1dc2:	2000      	movs	r0, #0
}
    1dc4:	2384      	movs	r3, #132	; 0x84
    1dc6:	009b      	lsls	r3, r3, #2
    1dc8:	449d      	add	sp, r3
    1dca:	bd70      	pop	{r4, r5, r6, pc}
    1dcc:	fffffdf0 	.word	0xfffffdf0
    1dd0:	0000020a 	.word	0x0000020a
    1dd4:	0000d7eb 	.word	0x0000d7eb
    1dd8:	2000011c 	.word	0x2000011c
    1ddc:	00008065 	.word	0x00008065

00001de0 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
    1de0:	b510      	push	{r4, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
    1de2:	2000      	movs	r0, #0
    1de4:	4b08      	ldr	r3, [pc, #32]	; (1e08 <delay_init+0x28>)
    1de6:	4798      	blx	r3
	cycles_per_ms /= 1000;
    1de8:	4c08      	ldr	r4, [pc, #32]	; (1e0c <delay_init+0x2c>)
    1dea:	21fa      	movs	r1, #250	; 0xfa
    1dec:	0089      	lsls	r1, r1, #2
    1dee:	47a0      	blx	r4
    1df0:	4b07      	ldr	r3, [pc, #28]	; (1e10 <delay_init+0x30>)
    1df2:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
    1df4:	21fa      	movs	r1, #250	; 0xfa
    1df6:	0089      	lsls	r1, r1, #2
    1df8:	47a0      	blx	r4
    1dfa:	4b06      	ldr	r3, [pc, #24]	; (1e14 <delay_init+0x34>)
    1dfc:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
    1dfe:	2205      	movs	r2, #5
    1e00:	4b05      	ldr	r3, [pc, #20]	; (1e18 <delay_init+0x38>)
    1e02:	601a      	str	r2, [r3, #0]
}
    1e04:	bd10      	pop	{r4, pc}
    1e06:	46c0      	nop			; (mov r8, r8)
    1e08:	00005915 	.word	0x00005915
    1e0c:	0000bdad 	.word	0x0000bdad
    1e10:	20000014 	.word	0x20000014
    1e14:	20000010 	.word	0x20000010
    1e18:	e000e010 	.word	0xe000e010

00001e1c <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
    1e1c:	b530      	push	{r4, r5, lr}
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
    1e1e:	4b08      	ldr	r3, [pc, #32]	; (1e40 <delay_cycles_ms+0x24>)
    1e20:	681c      	ldr	r4, [r3, #0]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
    1e22:	4a08      	ldr	r2, [pc, #32]	; (1e44 <delay_cycles_ms+0x28>)
		SysTick->VAL = 0;
    1e24:	2500      	movs	r5, #0

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    1e26:	2180      	movs	r1, #128	; 0x80
    1e28:	0249      	lsls	r1, r1, #9
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
	while (n--) {
    1e2a:	e006      	b.n	1e3a <delay_cycles_ms+0x1e>
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
    1e2c:	2c00      	cmp	r4, #0
    1e2e:	d004      	beq.n	1e3a <delay_cycles_ms+0x1e>
		SysTick->LOAD = n;
    1e30:	6054      	str	r4, [r2, #4]
		SysTick->VAL = 0;
    1e32:	6095      	str	r5, [r2, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    1e34:	6813      	ldr	r3, [r2, #0]
    1e36:	420b      	tst	r3, r1
    1e38:	d0fc      	beq.n	1e34 <delay_cycles_ms+0x18>
    1e3a:	3801      	subs	r0, #1
    1e3c:	d2f6      	bcs.n	1e2c <delay_cycles_ms+0x10>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
	}
}
    1e3e:	bd30      	pop	{r4, r5, pc}
    1e40:	20000014 	.word	0x20000014
    1e44:	e000e010 	.word	0xe000e010

00001e48 <chip_isr>:
#include "conf_winc.h"

static tpfNmBspIsr gpfIsr;

static void chip_isr(void)
{
    1e48:	b508      	push	{r3, lr}
	if (gpfIsr) {
    1e4a:	4b03      	ldr	r3, [pc, #12]	; (1e58 <chip_isr+0x10>)
    1e4c:	681b      	ldr	r3, [r3, #0]
    1e4e:	2b00      	cmp	r3, #0
    1e50:	d000      	beq.n	1e54 <chip_isr+0xc>
		gpfIsr();
    1e52:	4798      	blx	r3
	}
}
    1e54:	bd08      	pop	{r3, pc}
    1e56:	46c0      	nop			; (mov r8, r8)
    1e58:	20000120 	.word	0x20000120

00001e5c <nm_bsp_sleep>:
 *	@brief	Sleep in units of mSec
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
    1e5c:	b538      	push	{r3, r4, r5, lr}
	while (u32TimeMsec--) {
    1e5e:	2800      	cmp	r0, #0
    1e60:	d006      	beq.n	1e70 <nm_bsp_sleep+0x14>
    1e62:	1c04      	adds	r4, r0, #0
		delay_ms(1);
    1e64:	4d03      	ldr	r5, [pc, #12]	; (1e74 <nm_bsp_sleep+0x18>)
    1e66:	2001      	movs	r0, #1
    1e68:	47a8      	blx	r5
    1e6a:	3c01      	subs	r4, #1
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
	while (u32TimeMsec--) {
    1e6c:	2c00      	cmp	r4, #0
    1e6e:	d1fa      	bne.n	1e66 <nm_bsp_sleep+0xa>
		delay_ms(1);
	}
}
    1e70:	bd38      	pop	{r3, r4, r5, pc}
    1e72:	46c0      	nop			; (mov r8, r8)
    1e74:	00001e1d 	.word	0x00001e1d

00001e78 <nm_bsp_reset>:
 *	@fn		nm_bsp_reset
 *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
 *           CHIP_EN high then RESET_N high
 */
void nm_bsp_reset(void)
{
    1e78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	} else {
		port_base->OUTCLR.reg = pin_mask;
    1e7a:	4c08      	ldr	r4, [pc, #32]	; (1e9c <nm_bsp_reset+0x24>)
    1e7c:	2780      	movs	r7, #128	; 0x80
    1e7e:	057f      	lsls	r7, r7, #21
    1e80:	6167      	str	r7, [r4, #20]
    1e82:	2680      	movs	r6, #128	; 0x80
    1e84:	0536      	lsls	r6, r6, #20
    1e86:	6166      	str	r6, [r4, #20]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
	nm_bsp_sleep(100);
    1e88:	2064      	movs	r0, #100	; 0x64
    1e8a:	4d05      	ldr	r5, [pc, #20]	; (1ea0 <nm_bsp_reset+0x28>)
    1e8c:	47a8      	blx	r5
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1e8e:	61a7      	str	r7, [r4, #24]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, true);
	nm_bsp_sleep(10);
    1e90:	200a      	movs	r0, #10
    1e92:	47a8      	blx	r5
    1e94:	61a6      	str	r6, [r4, #24]
	port_pin_set_output_level(CONF_WINC_PIN_RESET, true);
	nm_bsp_sleep(10);
    1e96:	200a      	movs	r0, #10
    1e98:	47a8      	blx	r5
}
    1e9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1e9c:	41004400 	.word	0x41004400
    1ea0:	00001e5d 	.word	0x00001e5d

00001ea4 <nm_bsp_init>:
 *	@fn		nm_bsp_init
 *	@brief	Initialize BSP
 *	@return	0 in case of success and -1 in case of failure
 */
sint8 nm_bsp_init(void)
{
    1ea4:	b570      	push	{r4, r5, r6, lr}
    1ea6:	b082      	sub	sp, #8
	gpfIsr = NULL;
    1ea8:	2300      	movs	r3, #0
    1eaa:	4a13      	ldr	r2, [pc, #76]	; (1ef8 <nm_bsp_init+0x54>)
    1eac:	6013      	str	r3, [r2, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    1eae:	ac01      	add	r4, sp, #4
    1eb0:	2501      	movs	r5, #1
    1eb2:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    1eb4:	70a3      	strb	r3, [r4, #2]
	struct port_config pin_conf;

	port_get_config_defaults(&pin_conf);

	/* Configure control pins as output. */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    1eb6:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
    1eb8:	201b      	movs	r0, #27
    1eba:	1c21      	adds	r1, r4, #0
    1ebc:	4e0f      	ldr	r6, [pc, #60]	; (1efc <nm_bsp_init+0x58>)
    1ebe:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
    1ec0:	201c      	movs	r0, #28
    1ec2:	1c21      	adds	r1, r4, #0
    1ec4:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
    1ec6:	2028      	movs	r0, #40	; 0x28
    1ec8:	1c21      	adds	r1, r4, #0
    1eca:	47b0      	blx	r6

	/* Initialize chip IOs. */
	init_chip_pins();

    /* Make sure a 1ms Systick is configured. */
    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
    1ecc:	4b0c      	ldr	r3, [pc, #48]	; (1f00 <nm_bsp_init+0x5c>)
    1ece:	681b      	ldr	r3, [r3, #0]
    1ed0:	421d      	tst	r5, r3
    1ed2:	d003      	beq.n	1edc <nm_bsp_init+0x38>
    1ed4:	4b0a      	ldr	r3, [pc, #40]	; (1f00 <nm_bsp_init+0x5c>)
    1ed6:	681b      	ldr	r3, [r3, #0]
    1ed8:	079b      	lsls	r3, r3, #30
    1eda:	d401      	bmi.n	1ee0 <nm_bsp_init+0x3c>
	    delay_init();
    1edc:	4b09      	ldr	r3, [pc, #36]	; (1f04 <nm_bsp_init+0x60>)
    1ede:	4798      	blx	r3
    }

	/* Perform chip reset. */
	nm_bsp_reset();
    1ee0:	4b09      	ldr	r3, [pc, #36]	; (1f08 <nm_bsp_init+0x64>)
    1ee2:	4798      	blx	r3
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
	cpu_irq_enable();
    1ee4:	2201      	movs	r2, #1
    1ee6:	4b09      	ldr	r3, [pc, #36]	; (1f0c <nm_bsp_init+0x68>)
    1ee8:	701a      	strb	r2, [r3, #0]
    1eea:	f3bf 8f5f 	dmb	sy
    1eee:	b662      	cpsie	i

	system_interrupt_enable_global();

	return M2M_SUCCESS;
}
    1ef0:	2000      	movs	r0, #0
    1ef2:	b002      	add	sp, #8
    1ef4:	bd70      	pop	{r4, r5, r6, pc}
    1ef6:	46c0      	nop			; (mov r8, r8)
    1ef8:	20000120 	.word	0x20000120
    1efc:	0000441d 	.word	0x0000441d
    1f00:	e000e010 	.word	0xe000e010
    1f04:	00001de1 	.word	0x00001de1
    1f08:	00001e79 	.word	0x00001e79
    1f0c:	20000020 	.word	0x20000020

00001f10 <nm_bsp_register_isr>:
 *	@brief	Register interrupt service routine
 *	@param[IN]	pfIsr
 *				Pointer to ISR handler
 */
void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
{
    1f10:	b510      	push	{r4, lr}
    1f12:	b084      	sub	sp, #16
	struct extint_chan_conf config_extint_chan;

	gpfIsr = pfIsr;
    1f14:	4b0e      	ldr	r3, [pc, #56]	; (1f50 <nm_bsp_register_isr+0x40>)
    1f16:	6018      	str	r0, [r3, #0]

	extint_chan_get_config_defaults(&config_extint_chan);
    1f18:	ac01      	add	r4, sp, #4
    1f1a:	1c20      	adds	r0, r4, #0
    1f1c:	4b0d      	ldr	r3, [pc, #52]	; (1f54 <nm_bsp_register_isr+0x44>)
    1f1e:	4798      	blx	r3
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
    1f20:	2329      	movs	r3, #41	; 0x29
    1f22:	9301      	str	r3, [sp, #4]
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
    1f24:	2300      	movs	r3, #0
    1f26:	6063      	str	r3, [r4, #4]
	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
    1f28:	3301      	adds	r3, #1
    1f2a:	7223      	strb	r3, [r4, #8]
	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
    1f2c:	3301      	adds	r3, #1
    1f2e:	72e3      	strb	r3, [r4, #11]

	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
    1f30:	2009      	movs	r0, #9
    1f32:	1c21      	adds	r1, r4, #0
    1f34:	4b08      	ldr	r3, [pc, #32]	; (1f58 <nm_bsp_register_isr+0x48>)
    1f36:	4798      	blx	r3
	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
    1f38:	4808      	ldr	r0, [pc, #32]	; (1f5c <nm_bsp_register_isr+0x4c>)
    1f3a:	2109      	movs	r1, #9
    1f3c:	2200      	movs	r2, #0
    1f3e:	4b08      	ldr	r3, [pc, #32]	; (1f60 <nm_bsp_register_isr+0x50>)
    1f40:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    1f42:	2009      	movs	r0, #9
    1f44:	2100      	movs	r1, #0
    1f46:	4b07      	ldr	r3, [pc, #28]	; (1f64 <nm_bsp_register_isr+0x54>)
    1f48:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
    1f4a:	b004      	add	sp, #16
    1f4c:	bd10      	pop	{r4, pc}
    1f4e:	46c0      	nop			; (mov r8, r8)
    1f50:	20000120 	.word	0x20000120
    1f54:	00004391 	.word	0x00004391
    1f58:	000043a5 	.word	0x000043a5
    1f5c:	00001e49 	.word	0x00001e49
    1f60:	00004239 	.word	0x00004239
    1f64:	00004265 	.word	0x00004265

00001f68 <nm_bsp_interrupt_ctrl>:
 *	@brief	Enable/Disable interrupts
 *	@param[IN]	u8Enable
 *				'0' disable interrupts. '1' enable interrupts
 */
void nm_bsp_interrupt_ctrl(uint8 u8Enable)
{
    1f68:	b508      	push	{r3, lr}
	if (u8Enable) {
    1f6a:	2800      	cmp	r0, #0
    1f6c:	d004      	beq.n	1f78 <nm_bsp_interrupt_ctrl+0x10>
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    1f6e:	2009      	movs	r0, #9
    1f70:	2100      	movs	r1, #0
    1f72:	4b04      	ldr	r3, [pc, #16]	; (1f84 <nm_bsp_interrupt_ctrl+0x1c>)
    1f74:	4798      	blx	r3
    1f76:	e003      	b.n	1f80 <nm_bsp_interrupt_ctrl+0x18>
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
    1f78:	2009      	movs	r0, #9
    1f7a:	2100      	movs	r1, #0
    1f7c:	4b02      	ldr	r3, [pc, #8]	; (1f88 <nm_bsp_interrupt_ctrl+0x20>)
    1f7e:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
    1f80:	bd08      	pop	{r3, pc}
    1f82:	46c0      	nop			; (mov r8, r8)
    1f84:	00004265 	.word	0x00004265
    1f88:	00004285 	.word	0x00004285

00001f8c <nm_bus_init>:
*	@fn		nm_bus_init
*	@brief	Initialize the bus wrapper
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*/
sint8 nm_bus_init(void *pvinit)
{
    1f8c:	b530      	push	{r4, r5, lr}
    1f8e:	b091      	sub	sp, #68	; 0x44
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
    1f90:	4c2f      	ldr	r4, [pc, #188]	; (2050 <STACK_SIZE+0x50>)
    1f92:	230e      	movs	r3, #14
    1f94:	7023      	strb	r3, [r4, #0]
	slave->address_enabled = config->address_enabled;
    1f96:	2300      	movs	r3, #0
    1f98:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
    1f9a:	70a3      	strb	r3, [r4, #2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    1f9c:	a901      	add	r1, sp, #4
    1f9e:	2201      	movs	r2, #1
    1fa0:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
    1fa2:	708b      	strb	r3, [r1, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
    1fa4:	700a      	strb	r2, [r1, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    1fa6:	200e      	movs	r0, #14
    1fa8:	4b2a      	ldr	r3, [pc, #168]	; (2054 <STACK_SIZE+0x54>)
    1faa:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
    1fac:	7823      	ldrb	r3, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1fae:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    1fb0:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1fb2:	2900      	cmp	r1, #0
    1fb4:	d104      	bne.n	1fc0 <nm_bus_init+0x34>
		return &(ports[port_index]->Group[group_index]);
    1fb6:	095a      	lsrs	r2, r3, #5
    1fb8:	01d2      	lsls	r2, r2, #7
    1fba:	4927      	ldr	r1, [pc, #156]	; (2058 <STACK_SIZE+0x58>)
    1fbc:	468c      	mov	ip, r1
    1fbe:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1fc0:	211f      	movs	r1, #31
    1fc2:	400b      	ands	r3, r1
    1fc4:	391e      	subs	r1, #30
    1fc6:	1c08      	adds	r0, r1, #0
    1fc8:	4098      	lsls	r0, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1fca:	6190      	str	r0, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    1fcc:	aa02      	add	r2, sp, #8
    1fce:	7011      	strb	r1, [r2, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
    1fd0:	2300      	movs	r3, #0
    1fd2:	6053      	str	r3, [r2, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    1fd4:	6093      	str	r3, [r2, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
    1fd6:	20c0      	movs	r0, #192	; 0xc0
    1fd8:	0380      	lsls	r0, r0, #14
    1fda:	60d0      	str	r0, [r2, #12]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    1fdc:	7413      	strb	r3, [r2, #16]
	config->run_in_standby   = false;
    1fde:	7453      	strb	r3, [r2, #17]
	config->receiver_enable  = true;
    1fe0:	7491      	strb	r1, [r2, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
    1fe2:	74d1      	strb	r1, [r2, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
    1fe4:	7513      	strb	r3, [r2, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    1fe6:	3123      	adds	r1, #35	; 0x23
    1fe8:	5453      	strb	r3, [r2, r1]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    1fea:	9309      	str	r3, [sp, #36]	; 0x24
    1fec:	930a      	str	r3, [sp, #40]	; 0x28
	spi_attach_slave(&slave_inst, &slave_config);

	/* Configure the SPI master. */
	spi_get_config_defaults(&config);
	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
    1fee:	4b1b      	ldr	r3, [pc, #108]	; (205c <STACK_SIZE+0x5c>)
    1ff0:	6293      	str	r3, [r2, #40]	; 0x28
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
    1ff2:	4b1b      	ldr	r3, [pc, #108]	; (2060 <STACK_SIZE+0x60>)
    1ff4:	62d3      	str	r3, [r2, #44]	; 0x2c
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
    1ff6:	2301      	movs	r3, #1
    1ff8:	425b      	negs	r3, r3
    1ffa:	6313      	str	r3, [r2, #48]	; 0x30
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
    1ffc:	4b19      	ldr	r3, [pc, #100]	; (2064 <STACK_SIZE+0x64>)
    1ffe:	6353      	str	r3, [r2, #52]	; 0x34
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
    2000:	4b19      	ldr	r3, [pc, #100]	; (2068 <STACK_SIZE+0x68>)
    2002:	6193      	str	r3, [r2, #24]
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
    2004:	4819      	ldr	r0, [pc, #100]	; (206c <STACK_SIZE+0x6c>)
    2006:	491a      	ldr	r1, [pc, #104]	; (2070 <STACK_SIZE+0x70>)
    2008:	4b1a      	ldr	r3, [pc, #104]	; (2074 <STACK_SIZE+0x74>)
    200a:	4798      	blx	r3
    200c:	2800      	cmp	r0, #0
    200e:	d11a      	bne.n	2046 <STACK_SIZE+0x46>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    2010:	4d16      	ldr	r5, [pc, #88]	; (206c <STACK_SIZE+0x6c>)
    2012:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    2014:	1c20      	adds	r0, r4, #0
    2016:	4b18      	ldr	r3, [pc, #96]	; (2078 <STACK_SIZE+0x78>)
    2018:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    201a:	231f      	movs	r3, #31
    201c:	4018      	ands	r0, r3
    201e:	3b1e      	subs	r3, #30
    2020:	4083      	lsls	r3, r0
    2022:	1c18      	adds	r0, r3, #0
    2024:	4b15      	ldr	r3, [pc, #84]	; (207c <STACK_SIZE+0x7c>)
    2026:	6018      	str	r0, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    2028:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    202a:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    202c:	2b00      	cmp	r3, #0
    202e:	d1fc      	bne.n	202a <STACK_SIZE+0x2a>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    2030:	6822      	ldr	r2, [r4, #0]
    2032:	3302      	adds	r3, #2
    2034:	4313      	orrs	r3, r2
    2036:	6023      	str	r3, [r4, #0]
	}

	/* Enable the SPI master. */
	spi_enable(&master);

	nm_bsp_reset();
    2038:	4b11      	ldr	r3, [pc, #68]	; (2080 <STACK_SIZE+0x80>)
    203a:	4798      	blx	r3
	nm_bsp_sleep(1);
    203c:	2001      	movs	r0, #1
    203e:	4b11      	ldr	r3, [pc, #68]	; (2084 <STACK_SIZE+0x84>)
    2040:	4798      	blx	r3
#endif
	return result;
    2042:	2000      	movs	r0, #0
    2044:	e000      	b.n	2048 <STACK_SIZE+0x48>
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
	config.master_slave_select_enable = false;

	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
		return M2M_ERR_BUS_FAIL;
    2046:	20fa      	movs	r0, #250	; 0xfa
    2048:	b240      	sxtb	r0, r0

	nm_bsp_reset();
	nm_bsp_sleep(1);
#endif
	return result;
}
    204a:	b011      	add	sp, #68	; 0x44
    204c:	bd30      	pop	{r4, r5, pc}
    204e:	46c0      	nop			; (mov r8, r8)
    2050:	200015d8 	.word	0x200015d8
    2054:	0000441d 	.word	0x0000441d
    2058:	41004400 	.word	0x41004400
    205c:	000c0002 	.word	0x000c0002
    2060:	000d0002 	.word	0x000d0002
    2064:	000f0002 	.word	0x000f0002
    2068:	00b71b00 	.word	0x00b71b00
    206c:	200015dc 	.word	0x200015dc
    2070:	42001000 	.word	0x42001000
    2074:	0000490d 	.word	0x0000490d
    2078:	00004881 	.word	0x00004881
    207c:	e000e100 	.word	0xe000e100
    2080:	00001e79 	.word	0x00001e79
    2084:	00001e5d 	.word	0x00001e5d

00002088 <nm_bus_ioctl>:
*					Arbitrary parameter depenging on IOCTL
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@note	For SPI only, it's important to be able to send/receive at the same time
*/
sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
{
    2088:	b5f0      	push	{r4, r5, r6, r7, lr}
    208a:	465f      	mov	r7, fp
    208c:	4656      	mov	r6, sl
    208e:	464d      	mov	r5, r9
    2090:	4644      	mov	r4, r8
    2092:	b4f0      	push	{r4, r5, r6, r7}
    2094:	b085      	sub	sp, #20
	sint8 s8Ret = 0;
	switch(u8Cmd)
    2096:	2803      	cmp	r0, #3
    2098:	d169      	bne.n	216e <nm_bus_ioctl+0xe6>
		}
		break;
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
    209a:	680e      	ldr	r6, [r1, #0]
    209c:	684d      	ldr	r5, [r1, #4]
    209e:	890c      	ldrh	r4, [r1, #8]
struct spi_module master;
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
    20a0:	2200      	movs	r2, #0
    20a2:	ab02      	add	r3, sp, #8
    20a4:	71da      	strb	r2, [r3, #7]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if (!pu8Mosi) {
    20a6:	2e00      	cmp	r6, #0
    20a8:	d008      	beq.n	20bc <nm_bus_ioctl+0x34>
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	else if(!pu8Miso) {
    20aa:	2d00      	cmp	r5, #0
    20ac:	d15d      	bne.n	216a <nm_bus_ioctl+0xe2>
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
    20ae:	2301      	movs	r3, #1
    20b0:	4699      	mov	r9, r3
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    20b2:	2300      	movs	r3, #0
    20b4:	9301      	str	r3, [sp, #4]
	if (!pu8Mosi) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	else if(!pu8Miso) {
		pu8Miso = &u8Dummy;
    20b6:	ab02      	add	r3, sp, #8
    20b8:	1ddd      	adds	r5, r3, #7
    20ba:	e005      	b.n	20c8 <nm_bus_ioctl+0x40>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    20bc:	2300      	movs	r3, #0
    20be:	4699      	mov	r9, r3
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if (!pu8Mosi) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
    20c0:	3301      	adds	r3, #1
    20c2:	9301      	str	r3, [sp, #4]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if (!pu8Mosi) {
		pu8Mosi = &u8Dummy;
    20c4:	ab02      	add	r3, sp, #8
    20c6:	1dde      	adds	r6, r3, #7
	}
	else {
		return M2M_ERR_BUS_FAIL;
	}

	spi_select_slave(&master, &slave_inst, true);
    20c8:	482d      	ldr	r0, [pc, #180]	; (2180 <nm_bus_ioctl+0xf8>)
    20ca:	492e      	ldr	r1, [pc, #184]	; (2184 <nm_bus_ioctl+0xfc>)
    20cc:	2201      	movs	r2, #1
    20ce:	4b2e      	ldr	r3, [pc, #184]	; (2188 <nm_bus_ioctl+0x100>)
    20d0:	4798      	blx	r3

	while (u16Sz) {
    20d2:	2c00      	cmp	r4, #0
    20d4:	d03c      	beq.n	2150 <nm_bus_ioctl+0xc8>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    20d6:	4b2a      	ldr	r3, [pc, #168]	; (2180 <nm_bus_ioctl+0xf8>)
    20d8:	469b      	mov	fp, r3

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    20da:	2701      	movs	r7, #1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    20dc:	2204      	movs	r2, #4
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    20de:	469a      	mov	sl, r3

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    20e0:	2304      	movs	r3, #4
    20e2:	4698      	mov	r8, r3
			;
		*pu8Miso = rxd_data;

		u16Sz--;
		if (!u8SkipMiso)
			pu8Miso++;
    20e4:	4649      	mov	r1, r9
    20e6:	424b      	negs	r3, r1
    20e8:	4159      	adcs	r1, r3
    20ea:	4689      	mov	r9, r1
	}

	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
		txd_data = *pu8Mosi;
    20ec:	7830      	ldrb	r0, [r6, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    20ee:	465b      	mov	r3, fp
    20f0:	681b      	ldr	r3, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    20f2:	7e19      	ldrb	r1, [r3, #24]
		while (!spi_is_ready_to_write(&master))
    20f4:	4239      	tst	r1, r7
    20f6:	d0fc      	beq.n	20f2 <nm_bus_ioctl+0x6a>
    20f8:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    20fa:	4239      	tst	r1, r7
    20fc:	d0fc      	beq.n	20f8 <nm_bus_ioctl+0x70>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    20fe:	6298      	str	r0, [r3, #40]	; 0x28
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    2100:	7e19      	ldrb	r1, [r3, #24]
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
    2102:	4211      	tst	r1, r2
    2104:	d0fc      	beq.n	2100 <nm_bus_ioctl+0x78>
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    2106:	4651      	mov	r1, sl
    2108:	7989      	ldrb	r1, [r1, #6]
    210a:	468c      	mov	ip, r1
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    210c:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    210e:	4211      	tst	r1, r2
    2110:	d0fc      	beq.n	210c <nm_bus_ioctl+0x84>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    2112:	8b59      	ldrh	r1, [r3, #26]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    2114:	2000      	movs	r0, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    2116:	4211      	tst	r1, r2
    2118:	d005      	beq.n	2126 <nm_bus_ioctl+0x9e>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    211a:	8b59      	ldrh	r1, [r3, #26]
    211c:	4640      	mov	r0, r8
    211e:	4301      	orrs	r1, r0
    2120:	b289      	uxth	r1, r1
    2122:	8359      	strh	r1, [r3, #26]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
    2124:	201e      	movs	r0, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    2126:	4661      	mov	r1, ip
    2128:	2901      	cmp	r1, #1
    212a:	d103      	bne.n	2134 <nm_bus_ioctl+0xac>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    212c:	6a99      	ldr	r1, [r3, #40]	; 0x28
    212e:	05c9      	lsls	r1, r1, #23
    2130:	0dc9      	lsrs	r1, r1, #23
    2132:	e001      	b.n	2138 <nm_bus_ioctl+0xb0>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    2134:	6a99      	ldr	r1, [r3, #40]	; 0x28
    2136:	b2c9      	uxtb	r1, r1
			;
		while (spi_read(&master, &rxd_data) != STATUS_OK)
    2138:	2800      	cmp	r0, #0
    213a:	d1e7      	bne.n	210c <nm_bus_ioctl+0x84>
			;
		*pu8Miso = rxd_data;
    213c:	7029      	strb	r1, [r5, #0]

		u16Sz--;
    213e:	3c01      	subs	r4, #1
    2140:	b2a4      	uxth	r4, r4
		if (!u8SkipMiso)
			pu8Miso++;
    2142:	444d      	add	r5, r9
		if (!u8SkipMosi)
			pu8Mosi++;
    2144:	9b01      	ldr	r3, [sp, #4]
    2146:	4259      	negs	r1, r3
    2148:	414b      	adcs	r3, r1
    214a:	18f6      	adds	r6, r6, r3
		return M2M_ERR_BUS_FAIL;
	}

	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
    214c:	2c00      	cmp	r4, #0
    214e:	d1cd      	bne.n	20ec <nm_bus_ioctl+0x64>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    2150:	4b0b      	ldr	r3, [pc, #44]	; (2180 <nm_bus_ioctl+0xf8>)
    2152:	6819      	ldr	r1, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    2154:	2202      	movs	r2, #2
    2156:	7e0b      	ldrb	r3, [r1, #24]
			pu8Miso++;
		if (!u8SkipMosi)
			pu8Mosi++;
	}

	while (!spi_is_write_complete(&master))
    2158:	4213      	tst	r3, r2
    215a:	d0fc      	beq.n	2156 <nm_bus_ioctl+0xce>
		;

	spi_select_slave(&master, &slave_inst, false);
    215c:	4808      	ldr	r0, [pc, #32]	; (2180 <nm_bus_ioctl+0xf8>)
    215e:	4909      	ldr	r1, [pc, #36]	; (2184 <nm_bus_ioctl+0xfc>)
    2160:	2200      	movs	r2, #0
    2162:	4b09      	ldr	r3, [pc, #36]	; (2188 <nm_bus_ioctl+0x100>)
    2164:	4798      	blx	r3

	return M2M_SUCCESS;
    2166:	2000      	movs	r0, #0
    2168:	e002      	b.n	2170 <nm_bus_ioctl+0xe8>
	else if(!pu8Miso) {
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
	}
	else {
		return M2M_ERR_BUS_FAIL;
    216a:	20fa      	movs	r0, #250	; 0xfa
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
    216c:	e000      	b.n	2170 <nm_bus_ioctl+0xe8>
#endif
		default:
			s8Ret = -1;
    216e:	20ff      	movs	r0, #255	; 0xff
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
    2170:	b240      	sxtb	r0, r0
}
    2172:	b005      	add	sp, #20
    2174:	bc3c      	pop	{r2, r3, r4, r5}
    2176:	4690      	mov	r8, r2
    2178:	4699      	mov	r9, r3
    217a:	46a2      	mov	sl, r4
    217c:	46ab      	mov	fp, r5
    217e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2180:	200015dc 	.word	0x200015dc
    2184:	200015d8 	.word	0x200015d8
    2188:	00004ae1 	.word	0x00004ae1

0000218c <nm_bus_deinit>:
/*
*	@fn		nm_bus_deinit
*	@brief	De-initialize the bus wrapper
*/
sint8 nm_bus_deinit(void)
{
    218c:	b538      	push	{r3, r4, r5, lr}
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    218e:	4d0b      	ldr	r5, [pc, #44]	; (21bc <nm_bus_deinit+0x30>)
    2190:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    2192:	1c20      	adds	r0, r4, #0
    2194:	4b0a      	ldr	r3, [pc, #40]	; (21c0 <nm_bus_deinit+0x34>)
    2196:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    2198:	231f      	movs	r3, #31
    219a:	4018      	ands	r0, r3
    219c:	3b1e      	subs	r3, #30
    219e:	4083      	lsls	r3, r0
    21a0:	1c18      	adds	r0, r3, #0
    21a2:	2380      	movs	r3, #128	; 0x80
    21a4:	4a07      	ldr	r2, [pc, #28]	; (21c4 <nm_bus_deinit+0x38>)
    21a6:	50d0      	str	r0, [r2, r3]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    21a8:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    21aa:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    21ac:	2b00      	cmp	r3, #0
    21ae:	d1fc      	bne.n	21aa <nm_bus_deinit+0x1e>
		/* Wait until the synchronization is complete */
	}

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    21b0:	6823      	ldr	r3, [r4, #0]
    21b2:	2202      	movs	r2, #2
    21b4:	4393      	bics	r3, r2
    21b6:	6023      	str	r3, [r4, #0]
#ifdef CONF_WINC_USE_SPI
	spi_disable(&master);	

#endif /* CONF_WINC_USE_SPI */
	return result;
}
    21b8:	2000      	movs	r0, #0
    21ba:	bd38      	pop	{r3, r4, r5, pc}
    21bc:	200015dc 	.word	0x200015dc
    21c0:	00004881 	.word	0x00004881
    21c4:	e000e100 	.word	0xe000e100

000021c8 <m2m_memcpy>:
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
	if(sz == 0) return;
    21c8:	2a00      	cmp	r2, #0
    21ca:	d006      	beq.n	21da <m2m_memcpy+0x12>
    21cc:	1882      	adds	r2, r0, r2
	do
	{
		*pDst = *pSrc;
    21ce:	780b      	ldrb	r3, [r1, #0]
    21d0:	7003      	strb	r3, [r0, #0]
		pDst++;
    21d2:	3001      	adds	r0, #1
		pSrc++;
    21d4:	3101      	adds	r1, #1
	}while(--sz);
    21d6:	4290      	cmp	r0, r2
    21d8:	d1f9      	bne.n	21ce <m2m_memcpy+0x6>
}
    21da:	4770      	bx	lr

000021dc <m2m_memset>:
	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
	if(sz == 0) return;
    21dc:	2a00      	cmp	r2, #0
    21de:	d004      	beq.n	21ea <m2m_memset+0xe>
    21e0:	1882      	adds	r2, r0, r2
	do
	{
		*pBuf = val;
    21e2:	7001      	strb	r1, [r0, #0]
		pBuf++;
    21e4:	3001      	adds	r0, #1
	}while(--sz);
    21e6:	4290      	cmp	r0, r2
    21e8:	d1fb      	bne.n	21e2 <m2m_memset+0x6>
}
    21ea:	4770      	bx	lr

000021ec <m2m_strlen>:

uint16 m2m_strlen(uint8 * pcStr)
{
    21ec:	1c03      	adds	r3, r0, #0
	uint16	u16StrLen = 0;
	while(*pcStr)
    21ee:	7802      	ldrb	r2, [r0, #0]
    21f0:	2a00      	cmp	r2, #0
    21f2:	d007      	beq.n	2204 <m2m_strlen+0x18>
    21f4:	2000      	movs	r0, #0
	{
		u16StrLen ++;
    21f6:	3001      	adds	r0, #1
    21f8:	b280      	uxth	r0, r0
		pcStr++;
    21fa:	3301      	adds	r3, #1
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
	while(*pcStr)
    21fc:	781a      	ldrb	r2, [r3, #0]
    21fe:	2a00      	cmp	r2, #0
    2200:	d1f9      	bne.n	21f6 <m2m_strlen+0xa>
    2202:	e000      	b.n	2206 <m2m_strlen+0x1a>
	}while(--sz);
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
    2204:	2000      	movs	r0, #0
	{
		u16StrLen ++;
		pcStr++;
	}
	return u16StrLen;
}
    2206:	4770      	bx	lr

00002208 <isr>:
tpfHifCallBack pfHifCb = NULL;
tpfHifCallBack pfCryptoCb = NULL;

static void isr(void)
{
	gu8Interrupt++;
    2208:	4a02      	ldr	r2, [pc, #8]	; (2214 <isr+0xc>)
    220a:	7813      	ldrb	r3, [r2, #0]
    220c:	3301      	adds	r3, #1
    220e:	b2db      	uxtb	r3, r3
    2210:	7013      	strb	r3, [r2, #0]
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
    2212:	4770      	bx	lr
    2214:	2000012c 	.word	0x2000012c

00002218 <m2m_hif_cb>:
*/
static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{


}
    2218:	4770      	bx	lr
    221a:	46c0      	nop			; (mov r8, r8)

0000221c <hif_set_rx_done>:
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
static sint8 hif_set_rx_done(void)
{
    221c:	b500      	push	{lr}
    221e:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
#ifdef NM_EDGE_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
    2220:	2001      	movs	r0, #1
    2222:	4b09      	ldr	r3, [pc, #36]	; (2248 <hif_set_rx_done+0x2c>)
    2224:	4798      	blx	r3
#endif

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
    2226:	4809      	ldr	r0, [pc, #36]	; (224c <hif_set_rx_done+0x30>)
    2228:	a901      	add	r1, sp, #4
    222a:	4b09      	ldr	r3, [pc, #36]	; (2250 <hif_set_rx_done+0x34>)
    222c:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    222e:	2800      	cmp	r0, #0
    2230:	d106      	bne.n	2240 <hif_set_rx_done+0x24>
	//reg &= ~(1<<0);

	/* Set RX Done */
	reg |= (1<<1);
    2232:	2102      	movs	r1, #2
    2234:	9b01      	ldr	r3, [sp, #4]
    2236:	4319      	orrs	r1, r3
    2238:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    223a:	4804      	ldr	r0, [pc, #16]	; (224c <hif_set_rx_done+0x30>)
    223c:	4b05      	ldr	r3, [pc, #20]	; (2254 <hif_set_rx_done+0x38>)
    223e:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
#endif
ERR1:
	return ret;
    2240:	b240      	sxtb	r0, r0

}
    2242:	b003      	add	sp, #12
    2244:	bd00      	pop	{pc}
    2246:	46c0      	nop			; (mov r8, r8)
    2248:	00001f69 	.word	0x00001f69
    224c:	00001070 	.word	0x00001070
    2250:	000030bd 	.word	0x000030bd
    2254:	000030c9 	.word	0x000030c9

00002258 <hif_chip_wake>:
*	@brief	To Wakeup the chip.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_wake(void)
{
    2258:	b508      	push	{r3, lr}
	sint8 ret = M2M_SUCCESS;
	if(gu8ChipSleep == 0)
    225a:	4b0f      	ldr	r3, [pc, #60]	; (2298 <hif_chip_wake+0x40>)
    225c:	781b      	ldrb	r3, [r3, #0]
    225e:	2b00      	cmp	r3, #0
    2260:	d111      	bne.n	2286 <hif_chip_wake+0x2e>
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
    2262:	4b0e      	ldr	r3, [pc, #56]	; (229c <hif_chip_wake+0x44>)
    2264:	781b      	ldrb	r3, [r3, #0]
    2266:	2b03      	cmp	r3, #3
    2268:	d003      	beq.n	2272 <hif_chip_wake+0x1a>
    226a:	4b0c      	ldr	r3, [pc, #48]	; (229c <hif_chip_wake+0x44>)
    226c:	781b      	ldrb	r3, [r3, #0]
    226e:	2b04      	cmp	r3, #4
    2270:	d109      	bne.n	2286 <hif_chip_wake+0x2e>
		{
			ret = nm_clkless_wake();
    2272:	4b0b      	ldr	r3, [pc, #44]	; (22a0 <hif_chip_wake+0x48>)
    2274:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
    2276:	2800      	cmp	r0, #0
    2278:	d10b      	bne.n	2292 <hif_chip_wake+0x3a>
			ret = nm_write_reg(WAKE_REG, WAKE_VALUE);
    227a:	480a      	ldr	r0, [pc, #40]	; (22a4 <hif_chip_wake+0x4c>)
    227c:	490a      	ldr	r1, [pc, #40]	; (22a8 <hif_chip_wake+0x50>)
    227e:	4b0b      	ldr	r3, [pc, #44]	; (22ac <hif_chip_wake+0x54>)
    2280:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
    2282:	2800      	cmp	r0, #0
    2284:	d105      	bne.n	2292 <hif_chip_wake+0x3a>
		}
		else
		{
		}
	}
	gu8ChipSleep++;
    2286:	4a04      	ldr	r2, [pc, #16]	; (2298 <hif_chip_wake+0x40>)
    2288:	7813      	ldrb	r3, [r2, #0]
    228a:	3301      	adds	r3, #1
    228c:	b2db      	uxtb	r3, r3
    228e:	7013      	strb	r3, [r2, #0]
    2290:	2000      	movs	r0, #0
ERR1:
	return ret;
    2292:	b240      	sxtb	r0, r0
}
    2294:	bd08      	pop	{r3, pc}
    2296:	46c0      	nop			; (mov r8, r8)
    2298:	20000148 	.word	0x20000148
    229c:	20000138 	.word	0x20000138
    22a0:	00002cad 	.word	0x00002cad
    22a4:	00001074 	.word	0x00001074
    22a8:	00005678 	.word	0x00005678
    22ac:	000030c9 	.word	0x000030c9

000022b0 <hif_chip_sleep>:
*	@brief	To make the chip sleep.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
    22b0:	b500      	push	{lr}
    22b2:	b083      	sub	sp, #12
	sint8 ret = M2M_SUCCESS;

	if(gu8ChipSleep >= 1)
    22b4:	4b17      	ldr	r3, [pc, #92]	; (2314 <hif_chip_sleep+0x64>)
    22b6:	781b      	ldrb	r3, [r3, #0]
    22b8:	2b00      	cmp	r3, #0
    22ba:	d004      	beq.n	22c6 <hif_chip_sleep+0x16>
	{
		gu8ChipSleep--;
    22bc:	4a15      	ldr	r2, [pc, #84]	; (2314 <hif_chip_sleep+0x64>)
    22be:	7813      	ldrb	r3, [r2, #0]
    22c0:	3b01      	subs	r3, #1
    22c2:	b2db      	uxtb	r3, r3
    22c4:	7013      	strb	r3, [r2, #0]
	}
	
	if(gu8ChipSleep == 0)
    22c6:	4b13      	ldr	r3, [pc, #76]	; (2314 <hif_chip_sleep+0x64>)
    22c8:	781b      	ldrb	r3, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
	sint8 ret = M2M_SUCCESS;
    22ca:	2000      	movs	r0, #0
	if(gu8ChipSleep >= 1)
	{
		gu8ChipSleep--;
	}
	
	if(gu8ChipSleep == 0)
    22cc:	2b00      	cmp	r3, #0
    22ce:	d11e      	bne.n	230e <hif_chip_sleep+0x5e>
	{
		if((gu8ChipMode == M2M_PS_DEEP_AUTOMATIC)||(gu8ChipMode == M2M_PS_MANUAL))
    22d0:	4b11      	ldr	r3, [pc, #68]	; (2318 <hif_chip_sleep+0x68>)
    22d2:	781b      	ldrb	r3, [r3, #0]
    22d4:	2b03      	cmp	r3, #3
    22d6:	d003      	beq.n	22e0 <hif_chip_sleep+0x30>
    22d8:	4b0f      	ldr	r3, [pc, #60]	; (2318 <hif_chip_sleep+0x68>)
    22da:	781b      	ldrb	r3, [r3, #0]
    22dc:	2b04      	cmp	r3, #4
    22de:	d116      	bne.n	230e <hif_chip_sleep+0x5e>
		{
			uint32 reg = 0;
    22e0:	2300      	movs	r3, #0
    22e2:	9301      	str	r3, [sp, #4]
			ret = nm_write_reg(WAKE_REG, SLEEP_VALUE);
    22e4:	480d      	ldr	r0, [pc, #52]	; (231c <hif_chip_sleep+0x6c>)
    22e6:	490e      	ldr	r1, [pc, #56]	; (2320 <hif_chip_sleep+0x70>)
    22e8:	4b0e      	ldr	r3, [pc, #56]	; (2324 <hif_chip_sleep+0x74>)
    22ea:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
    22ec:	2800      	cmp	r0, #0
    22ee:	d10e      	bne.n	230e <hif_chip_sleep+0x5e>
			/* Clear bit 1 */
			ret = nm_read_reg_with_ret(0x1, &reg);
    22f0:	3001      	adds	r0, #1
    22f2:	a901      	add	r1, sp, #4
    22f4:	4b0c      	ldr	r3, [pc, #48]	; (2328 <hif_chip_sleep+0x78>)
    22f6:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
    22f8:	2800      	cmp	r0, #0
    22fa:	d108      	bne.n	230e <hif_chip_sleep+0x5e>
			if(reg&0x2)
    22fc:	9901      	ldr	r1, [sp, #4]
    22fe:	078b      	lsls	r3, r1, #30
    2300:	d505      	bpl.n	230e <hif_chip_sleep+0x5e>
			{
				reg &=~(1 << 1);
    2302:	2302      	movs	r3, #2
    2304:	4399      	bics	r1, r3
    2306:	9101      	str	r1, [sp, #4]
				ret = nm_write_reg(0x1, reg);
    2308:	3001      	adds	r0, #1
    230a:	4b06      	ldr	r3, [pc, #24]	; (2324 <hif_chip_sleep+0x74>)
    230c:	4798      	blx	r3
		else
		{
		}
	}
ERR1:
	return ret;
    230e:	b240      	sxtb	r0, r0
}
    2310:	b003      	add	sp, #12
    2312:	bd00      	pop	{pc}
    2314:	20000148 	.word	0x20000148
    2318:	20000138 	.word	0x20000138
    231c:	00001074 	.word	0x00001074
    2320:	00004321 	.word	0x00004321
    2324:	000030c9 	.word	0x000030c9
    2328:	000030bd 	.word	0x000030bd

0000232c <hif_init>:
*				Pointer to the arguments.
*   @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_init(void * arg)
{
    232c:	b508      	push	{r3, lr}
	pfWifiCb = NULL;
    232e:	2300      	movs	r3, #0
    2330:	4a08      	ldr	r2, [pc, #32]	; (2354 <hif_init+0x28>)
    2332:	6013      	str	r3, [r2, #0]
	pfIpCb = NULL;
    2334:	4a08      	ldr	r2, [pc, #32]	; (2358 <hif_init+0x2c>)
    2336:	6013      	str	r3, [r2, #0]

	gu8ChipSleep = 0;
    2338:	4a08      	ldr	r2, [pc, #32]	; (235c <hif_init+0x30>)
    233a:	7013      	strb	r3, [r2, #0]
	gu8ChipMode = M2M_NO_PS;
    233c:	4a08      	ldr	r2, [pc, #32]	; (2360 <hif_init+0x34>)
    233e:	7013      	strb	r3, [r2, #0]

	gu8Interrupt = 0;
    2340:	4a08      	ldr	r2, [pc, #32]	; (2364 <hif_init+0x38>)
    2342:	7013      	strb	r3, [r2, #0]
	nm_bsp_register_isr(isr);
    2344:	4808      	ldr	r0, [pc, #32]	; (2368 <hif_init+0x3c>)
    2346:	4b09      	ldr	r3, [pc, #36]	; (236c <hif_init+0x40>)
    2348:	4798      	blx	r3
			break;
		case M2M_REQ_GROUP_OTA:
			pfOtaCb = fn;
			break;
		case M2M_REQ_GROUP_HIF:
			pfHifCb = fn;
    234a:	4a09      	ldr	r2, [pc, #36]	; (2370 <hif_init+0x44>)
    234c:	4b09      	ldr	r3, [pc, #36]	; (2374 <hif_init+0x48>)
    234e:	601a      	str	r2, [r3, #0]
	nm_bsp_register_isr(isr);

	hif_register_cb(M2M_REQ_GROUP_HIF,m2m_hif_cb);

	return M2M_SUCCESS;
}
    2350:	2000      	movs	r0, #0
    2352:	bd08      	pop	{r3, pc}
    2354:	20000128 	.word	0x20000128
    2358:	2000013c 	.word	0x2000013c
    235c:	20000148 	.word	0x20000148
    2360:	20000138 	.word	0x20000138
    2364:	2000012c 	.word	0x2000012c
    2368:	00002209 	.word	0x00002209
    236c:	00001f11 	.word	0x00001f11
    2370:	00002219 	.word	0x00002219
    2374:	20000130 	.word	0x20000130

00002378 <hif_send>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
{
    2378:	b5f0      	push	{r4, r5, r6, r7, lr}
    237a:	4657      	mov	r7, sl
    237c:	b480      	push	{r7}
    237e:	b088      	sub	sp, #32
    2380:	4682      	mov	sl, r0
    2382:	1c0c      	adds	r4, r1, #0
    2384:	9201      	str	r2, [sp, #4]
    2386:	9300      	str	r3, [sp, #0]
    2388:	ab0e      	add	r3, sp, #56	; 0x38
    238a:	cb80      	ldmia	r3!, {r7}
    238c:	881e      	ldrh	r6, [r3, #0]
    238e:	ab10      	add	r3, sp, #64	; 0x40
    2390:	881d      	ldrh	r5, [r3, #0]
	sint8		ret = M2M_ERR_SEND;
	volatile tstrHifHdr	strHif;

	strHif.u8Opcode		= u8Opcode&(~NBIT7);
    2392:	227f      	movs	r2, #127	; 0x7f
    2394:	400a      	ands	r2, r1
    2396:	ab07      	add	r3, sp, #28
    2398:	705a      	strb	r2, [r3, #1]
	strHif.u8Gid		= u8Gid;
    239a:	7018      	strb	r0, [r3, #0]
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
    239c:	2208      	movs	r2, #8
    239e:	805a      	strh	r2, [r3, #2]
	if(pu8DataBuf != NULL)
    23a0:	2f00      	cmp	r7, #0
    23a2:	d005      	beq.n	23b0 <hif_send+0x38>
	{
		strHif.u16Length += u16DataOffset + u16DataSize;
    23a4:	885a      	ldrh	r2, [r3, #2]
    23a6:	1992      	adds	r2, r2, r6
    23a8:	18aa      	adds	r2, r5, r2
    23aa:	b292      	uxth	r2, r2
    23ac:	805a      	strh	r2, [r3, #2]
    23ae:	e006      	b.n	23be <hif_send+0x46>
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
    23b0:	ab07      	add	r3, sp, #28
    23b2:	885a      	ldrh	r2, [r3, #2]
    23b4:	9900      	ldr	r1, [sp, #0]
    23b6:	468c      	mov	ip, r1
    23b8:	4462      	add	r2, ip
    23ba:	b292      	uxth	r2, r2
    23bc:	805a      	strh	r2, [r3, #2]
	}
	ret = hif_chip_wake();
    23be:	4b4c      	ldr	r3, [pc, #304]	; (24f0 <hif_send+0x178>)
    23c0:	4798      	blx	r3
	if(ret == M2M_SUCCESS)
    23c2:	2800      	cmp	r0, #0
    23c4:	d000      	beq.n	23c8 <hif_send+0x50>
    23c6:	e08e      	b.n	24e6 <hif_send+0x16e>
	{
		volatile uint32 reg, dma_addr = 0;
    23c8:	2300      	movs	r3, #0
    23ca:	9305      	str	r3, [sp, #20]
		volatile uint16 cnt = 0;
    23cc:	aa02      	add	r2, sp, #8
    23ce:	80d3      	strh	r3, [r2, #6]

		reg = 0UL;
    23d0:	9304      	str	r3, [sp, #16]
		reg |= (uint32)u8Gid;
    23d2:	9b04      	ldr	r3, [sp, #16]
    23d4:	4652      	mov	r2, sl
    23d6:	431a      	orrs	r2, r3
    23d8:	9204      	str	r2, [sp, #16]
		reg |= ((uint32)u8Opcode<<8);
    23da:	9b04      	ldr	r3, [sp, #16]
    23dc:	0224      	lsls	r4, r4, #8
    23de:	431c      	orrs	r4, r3
    23e0:	9404      	str	r4, [sp, #16]
		reg |= ((uint32)strHif.u16Length<<16);
    23e2:	ab07      	add	r3, sp, #28
    23e4:	885b      	ldrh	r3, [r3, #2]
    23e6:	9a04      	ldr	r2, [sp, #16]
    23e8:	041b      	lsls	r3, r3, #16
    23ea:	4313      	orrs	r3, r2
    23ec:	9304      	str	r3, [sp, #16]
		ret = nm_write_reg(NMI_STATE_REG,reg);
    23ee:	9904      	ldr	r1, [sp, #16]
    23f0:	4840      	ldr	r0, [pc, #256]	; (24f4 <hif_send+0x17c>)
    23f2:	4b41      	ldr	r3, [pc, #260]	; (24f8 <hif_send+0x180>)
    23f4:	4798      	blx	r3
		if(M2M_SUCCESS != ret) goto ERR1;
    23f6:	2800      	cmp	r0, #0
    23f8:	d175      	bne.n	24e6 <hif_send+0x16e>


		reg = 0;
    23fa:	2300      	movs	r3, #0
    23fc:	9304      	str	r3, [sp, #16]
		reg |= (1<<1);
    23fe:	9a04      	ldr	r2, [sp, #16]
    2400:	3302      	adds	r3, #2
    2402:	4313      	orrs	r3, r2
    2404:	9304      	str	r3, [sp, #16]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
    2406:	9904      	ldr	r1, [sp, #16]
    2408:	483c      	ldr	r0, [pc, #240]	; (24fc <hif_send+0x184>)
    240a:	4b3b      	ldr	r3, [pc, #236]	; (24f8 <hif_send+0x180>)
    240c:	4798      	blx	r3
		if(M2M_SUCCESS != ret) goto ERR1;
    240e:	2800      	cmp	r0, #0
    2410:	d169      	bne.n	24e6 <hif_send+0x16e>
		dma_addr = 0;
    2412:	2200      	movs	r2, #0
    2414:	9205      	str	r2, [sp, #20]

		//nm_bsp_interrupt_ctrl(0);

		for(cnt = 0; cnt < 1000; cnt ++)
    2416:	ab02      	add	r3, sp, #8
    2418:	80da      	strh	r2, [r3, #6]
    241a:	3306      	adds	r3, #6
    241c:	881b      	ldrh	r3, [r3, #0]
    241e:	b29b      	uxth	r3, r3
    2420:	4a37      	ldr	r2, [pc, #220]	; (2500 <hif_send+0x188>)
    2422:	4293      	cmp	r3, r2
    2424:	d81c      	bhi.n	2460 <hif_send+0xe8>
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
    2426:	4c37      	ldr	r4, [pc, #220]	; (2504 <hif_send+0x18c>)
    2428:	4834      	ldr	r0, [pc, #208]	; (24fc <hif_send+0x184>)
    242a:	a904      	add	r1, sp, #16
    242c:	47a0      	blx	r4
			if(ret != M2M_SUCCESS) break;
    242e:	2800      	cmp	r0, #0
    2430:	d116      	bne.n	2460 <hif_send+0xe8>
			if (!(reg & 0x2))
    2432:	9b04      	ldr	r3, [sp, #16]
    2434:	079b      	lsls	r3, r3, #30
    2436:	d408      	bmi.n	244a <hif_send+0xd2>
			{
				ret = nm_read_reg_with_ret(0x150400,(uint32 *)&dma_addr);
    2438:	4833      	ldr	r0, [pc, #204]	; (2508 <hif_send+0x190>)
    243a:	a905      	add	r1, sp, #20
    243c:	4b31      	ldr	r3, [pc, #196]	; (2504 <hif_send+0x18c>)
    243e:	4798      	blx	r3
				if(ret != M2M_SUCCESS) {
    2440:	2800      	cmp	r0, #0
    2442:	d00d      	beq.n	2460 <hif_send+0xe8>
					/*in case of read error clear the dma address and return error*/
					dma_addr = 0;
    2444:	2300      	movs	r3, #0
    2446:	9305      	str	r3, [sp, #20]
    2448:	e00a      	b.n	2460 <hif_send+0xe8>
		if(M2M_SUCCESS != ret) goto ERR1;
		dma_addr = 0;

		//nm_bsp_interrupt_ctrl(0);

		for(cnt = 0; cnt < 1000; cnt ++)
    244a:	ab02      	add	r3, sp, #8
    244c:	88da      	ldrh	r2, [r3, #6]
    244e:	3201      	adds	r2, #1
    2450:	b292      	uxth	r2, r2
    2452:	80da      	strh	r2, [r3, #6]
    2454:	3306      	adds	r3, #6
    2456:	881b      	ldrh	r3, [r3, #0]
    2458:	b29b      	uxth	r3, r3
    245a:	4a29      	ldr	r2, [pc, #164]	; (2500 <hif_send+0x188>)
    245c:	4293      	cmp	r3, r2
    245e:	d9e3      	bls.n	2428 <hif_send+0xb0>
				break;
			}
		}
		//nm_bsp_interrupt_ctrl(1);

		if (dma_addr != 0)
    2460:	9b05      	ldr	r3, [sp, #20]
    2462:	2b00      	cmp	r3, #0
    2464:	d03e      	beq.n	24e4 <hif_send+0x16c>
		{
			volatile uint32	u32CurrAddr;
			u32CurrAddr = dma_addr;
    2466:	9b05      	ldr	r3, [sp, #20]
    2468:	9306      	str	r3, [sp, #24]
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
    246a:	a907      	add	r1, sp, #28
    246c:	884b      	ldrh	r3, [r1, #2]
    246e:	b29b      	uxth	r3, r3
    2470:	804b      	strh	r3, [r1, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
    2472:	9806      	ldr	r0, [sp, #24]
    2474:	2208      	movs	r2, #8
    2476:	4b25      	ldr	r3, [pc, #148]	; (250c <hif_send+0x194>)
    2478:	4798      	blx	r3
		#ifdef CONF_WINC_USE_I2C
			nm_bsp_sleep(1);
		#endif
			if(M2M_SUCCESS != ret) goto ERR1;
    247a:	2800      	cmp	r0, #0
    247c:	d133      	bne.n	24e6 <hif_send+0x16e>
			u32CurrAddr += M2M_HIF_HDR_OFFSET;
    247e:	9b06      	ldr	r3, [sp, #24]
    2480:	3308      	adds	r3, #8
    2482:	9306      	str	r3, [sp, #24]
			if(pu8CtrlBuf != NULL)
    2484:	9b01      	ldr	r3, [sp, #4]
    2486:	2b00      	cmp	r3, #0
    2488:	d00b      	beq.n	24a2 <hif_send+0x12a>
			{
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
    248a:	9806      	ldr	r0, [sp, #24]
    248c:	1c19      	adds	r1, r3, #0
    248e:	9c00      	ldr	r4, [sp, #0]
    2490:	1c22      	adds	r2, r4, #0
    2492:	4b1e      	ldr	r3, [pc, #120]	; (250c <hif_send+0x194>)
    2494:	4798      	blx	r3
			#ifdef CONF_WINC_USE_I2C
				nm_bsp_sleep(1);
			#endif
				if(M2M_SUCCESS != ret) goto ERR1;
    2496:	2800      	cmp	r0, #0
    2498:	d125      	bne.n	24e6 <hif_send+0x16e>
				u32CurrAddr += u16CtrlBufSize;
    249a:	9b06      	ldr	r3, [sp, #24]
    249c:	46a4      	mov	ip, r4
    249e:	4463      	add	r3, ip
    24a0:	9306      	str	r3, [sp, #24]
			}
			if(pu8DataBuf != NULL)
    24a2:	2f00      	cmp	r7, #0
    24a4:	d00e      	beq.n	24c4 <hif_send+0x14c>
			{
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
    24a6:	9b06      	ldr	r3, [sp, #24]
    24a8:	9a00      	ldr	r2, [sp, #0]
    24aa:	1aad      	subs	r5, r5, r2
    24ac:	18ed      	adds	r5, r5, r3
    24ae:	9506      	str	r5, [sp, #24]
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
    24b0:	9806      	ldr	r0, [sp, #24]
    24b2:	1c39      	adds	r1, r7, #0
    24b4:	1c32      	adds	r2, r6, #0
    24b6:	4b15      	ldr	r3, [pc, #84]	; (250c <hif_send+0x194>)
    24b8:	4798      	blx	r3
			#ifdef CONF_WINC_USE_I2C	
				nm_bsp_sleep(1);
			#endif
				if(M2M_SUCCESS != ret) goto ERR1;
    24ba:	2800      	cmp	r0, #0
    24bc:	d113      	bne.n	24e6 <hif_send+0x16e>
				u32CurrAddr += u16DataSize;
    24be:	9b06      	ldr	r3, [sp, #24]
    24c0:	18f3      	adds	r3, r6, r3
    24c2:	9306      	str	r3, [sp, #24]
			}

			reg = dma_addr << 2;
    24c4:	9b05      	ldr	r3, [sp, #20]
    24c6:	009b      	lsls	r3, r3, #2
    24c8:	9304      	str	r3, [sp, #16]
			reg |= (1 << 1);
    24ca:	9a04      	ldr	r2, [sp, #16]
    24cc:	2302      	movs	r3, #2
    24ce:	4313      	orrs	r3, r2
    24d0:	9304      	str	r3, [sp, #16]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
    24d2:	9904      	ldr	r1, [sp, #16]
    24d4:	480e      	ldr	r0, [pc, #56]	; (2510 <hif_send+0x198>)
    24d6:	4b08      	ldr	r3, [pc, #32]	; (24f8 <hif_send+0x180>)
    24d8:	4798      	blx	r3
			if(M2M_SUCCESS != ret) goto ERR1;
    24da:	2800      	cmp	r0, #0
    24dc:	d103      	bne.n	24e6 <hif_send+0x16e>
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
		goto ERR1;
	}
	ret = hif_chip_sleep();
    24de:	4b0d      	ldr	r3, [pc, #52]	; (2514 <hif_send+0x19c>)
    24e0:	4798      	blx	r3
    24e2:	e000      	b.n	24e6 <hif_send+0x16e>
			if(M2M_SUCCESS != ret) goto ERR1;
		}
		else
		{
			M2M_DBG("Failed to alloc rx size\r");
			ret =  M2M_ERR_MEM_ALLOC;
    24e4:	20fd      	movs	r0, #253	; 0xfd
		goto ERR1;
	}
	ret = hif_chip_sleep();

ERR1:
	return ret;
    24e6:	b240      	sxtb	r0, r0
}
    24e8:	b008      	add	sp, #32
    24ea:	bc04      	pop	{r2}
    24ec:	4692      	mov	sl, r2
    24ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    24f0:	00002259 	.word	0x00002259
    24f4:	0000108c 	.word	0x0000108c
    24f8:	000030c9 	.word	0x000030c9
    24fc:	00001078 	.word	0x00001078
    2500:	000003e7 	.word	0x000003e7
    2504:	000030bd 	.word	0x000030bd
    2508:	00150400 	.word	0x00150400
    250c:	00003141 	.word	0x00003141
    2510:	0000106c 	.word	0x0000106c
    2514:	000022b1 	.word	0x000022b1

00002518 <hif_handle_isr>:
*	@brief	Handle interrupt received from NMC1500 firmware.
*   @return     The function SHALL return 0 for success and a negative value otherwise.
*/

sint8 hif_handle_isr(void)
{
    2518:	b5f0      	push	{r4, r5, r6, r7, lr}
    251a:	4657      	mov	r7, sl
    251c:	464e      	mov	r6, r9
    251e:	4645      	mov	r5, r8
    2520:	b4e0      	push	{r5, r6, r7}
    2522:	b084      	sub	sp, #16
	sint8 ret = M2M_SUCCESS;

	while (gu8Interrupt) {
    2524:	4b64      	ldr	r3, [pc, #400]	; (26b8 <hif_handle_isr+0x1a0>)
    2526:	4699      	mov	r9, r3
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gu8Interrupt--;
    2528:	4698      	mov	r8, r3
{
	sint8 ret = M2M_ERR_BUS_FAIL;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = hif_chip_wake();
    252a:	4d64      	ldr	r5, [pc, #400]	; (26bc <hif_handle_isr+0x1a4>)

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;

	while (gu8Interrupt) {
    252c:	e0b7      	b.n	269e <hif_handle_isr+0x186>
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gu8Interrupt--;
    252e:	4643      	mov	r3, r8
    2530:	781b      	ldrb	r3, [r3, #0]
    2532:	3b01      	subs	r3, #1
    2534:	b2db      	uxtb	r3, r3
    2536:	4642      	mov	r2, r8
    2538:	7013      	strb	r3, [r2, #0]
	volatile tstrHifHdr strHif;

	ret = hif_chip_wake();
	if(ret == M2M_SUCCESS)
	{
		ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
    253a:	4e61      	ldr	r6, [pc, #388]	; (26c0 <hif_handle_isr+0x1a8>)
{
	sint8 ret = M2M_ERR_BUS_FAIL;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = hif_chip_wake();
    253c:	47a8      	blx	r5
	if(ret == M2M_SUCCESS)
    253e:	2800      	cmp	r0, #0
    2540:	d1fc      	bne.n	253c <hif_handle_isr+0x24>
	{
		ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
    2542:	4860      	ldr	r0, [pc, #384]	; (26c4 <hif_handle_isr+0x1ac>)
    2544:	a901      	add	r1, sp, #4
    2546:	47b0      	blx	r6
		if(M2M_SUCCESS == ret)
    2548:	2800      	cmp	r0, #0
    254a:	d1f7      	bne.n	253c <hif_handle_isr+0x24>
		{
			if(reg & 0x1)	/* New interrupt has been received */
    254c:	9b01      	ldr	r3, [sp, #4]
    254e:	07db      	lsls	r3, r3, #31
    2550:	d400      	bmi.n	2554 <hif_handle_isr+0x3c>
    2552:	e09e      	b.n	2692 <hif_handle_isr+0x17a>
			{
				uint16 size;

				nm_bsp_interrupt_ctrl(0);
    2554:	4b5c      	ldr	r3, [pc, #368]	; (26c8 <hif_handle_isr+0x1b0>)
    2556:	4798      	blx	r3
				/*Clearing RX interrupt*/
				reg &= ~(1<<0);
    2558:	2301      	movs	r3, #1
    255a:	9901      	ldr	r1, [sp, #4]
    255c:	4399      	bics	r1, r3
    255e:	9101      	str	r1, [sp, #4]
				ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    2560:	4858      	ldr	r0, [pc, #352]	; (26c4 <hif_handle_isr+0x1ac>)
    2562:	4b5a      	ldr	r3, [pc, #360]	; (26cc <hif_handle_isr+0x1b4>)
    2564:	4798      	blx	r3
				if(ret != M2M_SUCCESS)goto ERR1;
    2566:	2800      	cmp	r0, #0
    2568:	d1e8      	bne.n	253c <hif_handle_isr+0x24>
				gu8HifSizeDone = 0;
    256a:	2200      	movs	r2, #0
    256c:	4b58      	ldr	r3, [pc, #352]	; (26d0 <hif_handle_isr+0x1b8>)
    256e:	701a      	strb	r2, [r3, #0]
				size = (uint16)((reg >> 2) & 0xfff);
    2570:	9b01      	ldr	r3, [sp, #4]
    2572:	049b      	lsls	r3, r3, #18
    2574:	0d1b      	lsrs	r3, r3, #20
    2576:	469a      	mov	sl, r3
				if (size > 0) {
    2578:	d0e0      	beq.n	253c <hif_handle_isr+0x24>
					uint32 address = 0;
    257a:	2300      	movs	r3, #0
    257c:	9303      	str	r3, [sp, #12]
					/**
					start bus transfer
					**/
					ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
    257e:	4855      	ldr	r0, [pc, #340]	; (26d4 <hif_handle_isr+0x1bc>)
    2580:	a903      	add	r1, sp, #12
    2582:	4b4f      	ldr	r3, [pc, #316]	; (26c0 <hif_handle_isr+0x1a8>)
    2584:	4798      	blx	r3
    2586:	1e04      	subs	r4, r0, #0
					if(M2M_SUCCESS != ret)
    2588:	d003      	beq.n	2592 <hif_handle_isr+0x7a>
					{
						M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
						nm_bsp_interrupt_ctrl(1);
    258a:	2001      	movs	r0, #1
    258c:	4b4e      	ldr	r3, [pc, #312]	; (26c8 <hif_handle_isr+0x1b0>)
    258e:	4798      	blx	r3
    2590:	e082      	b.n	2698 <hif_handle_isr+0x180>
						goto ERR1;
					}
					ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
    2592:	af02      	add	r7, sp, #8
    2594:	9803      	ldr	r0, [sp, #12]
    2596:	1c39      	adds	r1, r7, #0
    2598:	2204      	movs	r2, #4
    259a:	4b4f      	ldr	r3, [pc, #316]	; (26d8 <hif_handle_isr+0x1c0>)
    259c:	4798      	blx	r3
    259e:	1c04      	adds	r4, r0, #0
					strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
    25a0:	887b      	ldrh	r3, [r7, #2]
    25a2:	b29b      	uxth	r3, r3
    25a4:	807b      	strh	r3, [r7, #2]
					if(M2M_SUCCESS != ret)
    25a6:	2800      	cmp	r0, #0
    25a8:	d003      	beq.n	25b2 <hif_handle_isr+0x9a>
					{
						M2M_ERR("(hif) address bus fail\n");
						nm_bsp_interrupt_ctrl(1);
    25aa:	2001      	movs	r0, #1
    25ac:	4b46      	ldr	r3, [pc, #280]	; (26c8 <hif_handle_isr+0x1b0>)
    25ae:	4798      	blx	r3
    25b0:	e072      	b.n	2698 <hif_handle_isr+0x180>
						goto ERR1;
					}
					if(strHif.u16Length != size)
    25b2:	ab02      	add	r3, sp, #8
    25b4:	885b      	ldrh	r3, [r3, #2]
    25b6:	b29b      	uxth	r3, r3
    25b8:	459a      	cmp	sl, r3
    25ba:	d00a      	beq.n	25d2 <hif_handle_isr+0xba>
					{
						if((size - strHif.u16Length) > 4)
    25bc:	ab02      	add	r3, sp, #8
    25be:	885b      	ldrh	r3, [r3, #2]
    25c0:	4652      	mov	r2, sl
    25c2:	1ad3      	subs	r3, r2, r3
    25c4:	2b04      	cmp	r3, #4
    25c6:	dd04      	ble.n	25d2 <hif_handle_isr+0xba>
						{
							M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
								size, strHif.u16Length, strHif.u8Gid, strHif.u8Opcode);
							nm_bsp_interrupt_ctrl(1);
    25c8:	2001      	movs	r0, #1
    25ca:	4b3f      	ldr	r3, [pc, #252]	; (26c8 <hif_handle_isr+0x1b0>)
    25cc:	4798      	blx	r3
							ret = M2M_ERR_BUS_FAIL;
    25ce:	24fa      	movs	r4, #250	; 0xfa
    25d0:	e062      	b.n	2698 <hif_handle_isr+0x180>
							goto ERR1;
						}
					}

					if(M2M_REQ_GROUP_WIFI == strHif.u8Gid)
    25d2:	ab02      	add	r3, sp, #8
    25d4:	781b      	ldrb	r3, [r3, #0]
    25d6:	2b01      	cmp	r3, #1
    25d8:	d10d      	bne.n	25f6 <hif_handle_isr+0xde>
					{
						if(pfWifiCb)
    25da:	4b40      	ldr	r3, [pc, #256]	; (26dc <hif_handle_isr+0x1c4>)
    25dc:	681b      	ldr	r3, [r3, #0]
    25de:	2b00      	cmp	r3, #0
    25e0:	d051      	beq.n	2686 <hif_handle_isr+0x16e>
							pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    25e2:	aa02      	add	r2, sp, #8
    25e4:	7850      	ldrb	r0, [r2, #1]
    25e6:	b2c0      	uxtb	r0, r0
    25e8:	8851      	ldrh	r1, [r2, #2]
    25ea:	3908      	subs	r1, #8
    25ec:	b289      	uxth	r1, r1
    25ee:	9a03      	ldr	r2, [sp, #12]
    25f0:	3208      	adds	r2, #8
    25f2:	4798      	blx	r3
    25f4:	e047      	b.n	2686 <hif_handle_isr+0x16e>

					}
					else if(M2M_REQ_GROUP_IP == strHif.u8Gid)
    25f6:	ab02      	add	r3, sp, #8
    25f8:	781b      	ldrb	r3, [r3, #0]
    25fa:	2b02      	cmp	r3, #2
    25fc:	d10d      	bne.n	261a <hif_handle_isr+0x102>
					{
						if(pfIpCb)
    25fe:	4b38      	ldr	r3, [pc, #224]	; (26e0 <hif_handle_isr+0x1c8>)
    2600:	681b      	ldr	r3, [r3, #0]
    2602:	2b00      	cmp	r3, #0
    2604:	d03f      	beq.n	2686 <hif_handle_isr+0x16e>
							pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    2606:	aa02      	add	r2, sp, #8
    2608:	7850      	ldrb	r0, [r2, #1]
    260a:	b2c0      	uxtb	r0, r0
    260c:	8851      	ldrh	r1, [r2, #2]
    260e:	3908      	subs	r1, #8
    2610:	b289      	uxth	r1, r1
    2612:	9a03      	ldr	r2, [sp, #12]
    2614:	3208      	adds	r2, #8
    2616:	4798      	blx	r3
    2618:	e035      	b.n	2686 <hif_handle_isr+0x16e>
					}
					else if(M2M_REQ_GROUP_OTA == strHif.u8Gid)
    261a:	ab02      	add	r3, sp, #8
    261c:	781b      	ldrb	r3, [r3, #0]
    261e:	2b04      	cmp	r3, #4
    2620:	d10d      	bne.n	263e <hif_handle_isr+0x126>
					{
						if(pfOtaCb)
    2622:	4b30      	ldr	r3, [pc, #192]	; (26e4 <hif_handle_isr+0x1cc>)
    2624:	681b      	ldr	r3, [r3, #0]
    2626:	2b00      	cmp	r3, #0
    2628:	d02d      	beq.n	2686 <hif_handle_isr+0x16e>
							pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    262a:	aa02      	add	r2, sp, #8
    262c:	7850      	ldrb	r0, [r2, #1]
    262e:	b2c0      	uxtb	r0, r0
    2630:	8851      	ldrh	r1, [r2, #2]
    2632:	3908      	subs	r1, #8
    2634:	b289      	uxth	r1, r1
    2636:	9a03      	ldr	r2, [sp, #12]
    2638:	3208      	adds	r2, #8
    263a:	4798      	blx	r3
    263c:	e023      	b.n	2686 <hif_handle_isr+0x16e>
					}
					else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
    263e:	ab02      	add	r3, sp, #8
    2640:	781b      	ldrb	r3, [r3, #0]
    2642:	2b06      	cmp	r3, #6
    2644:	d10d      	bne.n	2662 <hif_handle_isr+0x14a>
					{
						if(pfCryptoCb)
    2646:	4b28      	ldr	r3, [pc, #160]	; (26e8 <hif_handle_isr+0x1d0>)
    2648:	681b      	ldr	r3, [r3, #0]
    264a:	2b00      	cmp	r3, #0
    264c:	d01b      	beq.n	2686 <hif_handle_isr+0x16e>
							pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    264e:	aa02      	add	r2, sp, #8
    2650:	7850      	ldrb	r0, [r2, #1]
    2652:	b2c0      	uxtb	r0, r0
    2654:	8851      	ldrh	r1, [r2, #2]
    2656:	3908      	subs	r1, #8
    2658:	b289      	uxth	r1, r1
    265a:	9a03      	ldr	r2, [sp, #12]
    265c:	3208      	adds	r2, #8
    265e:	4798      	blx	r3
    2660:	e011      	b.n	2686 <hif_handle_isr+0x16e>
					}
					else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
    2662:	ab02      	add	r3, sp, #8
    2664:	781b      	ldrb	r3, [r3, #0]
							pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
					}
					else
					{
						M2M_ERR("(hif) invalid group ID\n");
						ret = M2M_ERR_BUS_FAIL;
    2666:	24fa      	movs	r4, #250	; 0xfa
					else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
					{
						if(pfCryptoCb)
							pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
					}
					else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
    2668:	2b07      	cmp	r3, #7
    266a:	d115      	bne.n	2698 <hif_handle_isr+0x180>
					{
						if(pfSigmaCb)
    266c:	4b1f      	ldr	r3, [pc, #124]	; (26ec <hif_handle_isr+0x1d4>)
    266e:	681b      	ldr	r3, [r3, #0]
    2670:	2b00      	cmp	r3, #0
    2672:	d008      	beq.n	2686 <hif_handle_isr+0x16e>
							pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    2674:	aa02      	add	r2, sp, #8
    2676:	7850      	ldrb	r0, [r2, #1]
    2678:	b2c0      	uxtb	r0, r0
    267a:	8851      	ldrh	r1, [r2, #2]
    267c:	3908      	subs	r1, #8
    267e:	b289      	uxth	r1, r1
    2680:	9a03      	ldr	r2, [sp, #12]
    2682:	3208      	adds	r2, #8
    2684:	4798      	blx	r3
						M2M_ERR("(hif) invalid group ID\n");
						ret = M2M_ERR_BUS_FAIL;
						goto ERR1;
					}
					#ifndef ENABLE_UNO_BOARD
					if(!gu8HifSizeDone)
    2686:	4b12      	ldr	r3, [pc, #72]	; (26d0 <hif_handle_isr+0x1b8>)
    2688:	781b      	ldrb	r3, [r3, #0]
    268a:	2b00      	cmp	r3, #0
    268c:	d101      	bne.n	2692 <hif_handle_isr+0x17a>
					{
						M2M_ERR("(hif) host app didn't set RX Done\n");
						ret = hif_set_rx_done();
    268e:	4b18      	ldr	r3, [pc, #96]	; (26f0 <hif_handle_isr+0x1d8>)
    2690:	4798      	blx	r3
	{
		M2M_ERR("(hif) FAIL to wakeup the chip\n");
		goto ERR1;
	}

	ret = hif_chip_sleep();
    2692:	4b18      	ldr	r3, [pc, #96]	; (26f4 <hif_handle_isr+0x1dc>)
    2694:	4798      	blx	r3
    2696:	1c04      	adds	r4, r0, #0
		/*when the interrupt enabled*/
		gu8Interrupt--;
		while(1)
		{
			ret = hif_isr();
			if(ret == M2M_SUCCESS) {
    2698:	2c00      	cmp	r4, #0
    269a:	d000      	beq.n	269e <hif_handle_isr+0x186>
    269c:	e74e      	b.n	253c <hif_handle_isr+0x24>

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;

	while (gu8Interrupt) {
    269e:	464b      	mov	r3, r9
    26a0:	781b      	ldrb	r3, [r3, #0]
    26a2:	2b00      	cmp	r3, #0
    26a4:	d000      	beq.n	26a8 <hif_handle_isr+0x190>
    26a6:	e742      	b.n	252e <hif_handle_isr+0x16>
			}
		}
	}

	return ret;
}
    26a8:	2000      	movs	r0, #0
    26aa:	b004      	add	sp, #16
    26ac:	bc1c      	pop	{r2, r3, r4}
    26ae:	4690      	mov	r8, r2
    26b0:	4699      	mov	r9, r3
    26b2:	46a2      	mov	sl, r4
    26b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    26b6:	46c0      	nop			; (mov r8, r8)
    26b8:	2000012c 	.word	0x2000012c
    26bc:	00002259 	.word	0x00002259
    26c0:	000030bd 	.word	0x000030bd
    26c4:	00001070 	.word	0x00001070
    26c8:	00001f69 	.word	0x00001f69
    26cc:	000030c9 	.word	0x000030c9
    26d0:	20000140 	.word	0x20000140
    26d4:	00001084 	.word	0x00001084
    26d8:	000030d5 	.word	0x000030d5
    26dc:	20000128 	.word	0x20000128
    26e0:	2000013c 	.word	0x2000013c
    26e4:	20000144 	.word	0x20000144
    26e8:	20000124 	.word	0x20000124
    26ec:	20000134 	.word	0x20000134
    26f0:	0000221d 	.word	0x0000221d
    26f4:	000022b1 	.word	0x000022b1

000026f8 <hif_receive>:
*	@param [in]	isDone
*				If you don't need any more packets send True otherwise send false
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/
sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
{
    26f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    26fa:	464f      	mov	r7, r9
    26fc:	4646      	mov	r6, r8
    26fe:	b4c0      	push	{r6, r7}
    2700:	b083      	sub	sp, #12
    2702:	1c06      	adds	r6, r0, #0
    2704:	1c0c      	adds	r4, r1, #0
    2706:	1c15      	adds	r5, r2, #0
    2708:	1c1f      	adds	r7, r3, #0
	uint32 address, reg;
	uint16 size;
	sint8 ret = M2M_SUCCESS;

	if(u32Addr == 0 ||pu8Buf == NULL || u16Sz == 0)
    270a:	2800      	cmp	r0, #0
    270c:	d003      	beq.n	2716 <hif_receive+0x1e>
    270e:	2900      	cmp	r1, #0
    2710:	d001      	beq.n	2716 <hif_receive+0x1e>
    2712:	2a00      	cmp	r2, #0
    2714:	d107      	bne.n	2726 <hif_receive+0x2e>
	{
		if(isDone)
    2716:	2f00      	cmp	r7, #0
    2718:	d034      	beq.n	2784 <hif_receive+0x8c>
		{
			gu8HifSizeDone = 1;
    271a:	2201      	movs	r2, #1
    271c:	4b20      	ldr	r3, [pc, #128]	; (27a0 <hif_receive+0xa8>)
    271e:	701a      	strb	r2, [r3, #0]
			
			/* set RX done */
			ret = hif_set_rx_done();
    2720:	4b20      	ldr	r3, [pc, #128]	; (27a4 <hif_receive+0xac>)
    2722:	4798      	blx	r3
    2724:	e035      	b.n	2792 <hif_receive+0x9a>
			M2M_ERR(" hif_receive: Invalid argument\n");
		}
		goto ERR1;
	}

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
    2726:	4820      	ldr	r0, [pc, #128]	; (27a8 <hif_receive+0xb0>)
    2728:	4669      	mov	r1, sp
    272a:	4b20      	ldr	r3, [pc, #128]	; (27ac <hif_receive+0xb4>)
    272c:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    272e:	2800      	cmp	r0, #0
    2730:	d12f      	bne.n	2792 <hif_receive+0x9a>


	size = (uint16)((reg >> 2) & 0xfff);
    2732:	9b00      	ldr	r3, [sp, #0]
    2734:	4698      	mov	r8, r3
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1,&address);
    2736:	481e      	ldr	r0, [pc, #120]	; (27b0 <hif_receive+0xb8>)
    2738:	a901      	add	r1, sp, #4
    273a:	4b1c      	ldr	r3, [pc, #112]	; (27ac <hif_receive+0xb4>)
    273c:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    273e:	2800      	cmp	r0, #0
    2740:	d127      	bne.n	2792 <hif_receive+0x9a>

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
	if(ret != M2M_SUCCESS)goto ERR1;


	size = (uint16)((reg >> 2) & 0xfff);
    2742:	4643      	mov	r3, r8
    2744:	049b      	lsls	r3, r3, #18
    2746:	0d1b      	lsrs	r3, r3, #20
    2748:	4698      	mov	r8, r3
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1,&address);
	if(ret != M2M_SUCCESS)goto ERR1;


	if(u16Sz > size)
    274a:	429d      	cmp	r5, r3
    274c:	d81c      	bhi.n	2788 <hif_receive+0x90>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%d><%d>\n",u16Sz, size);
		goto ERR1;
	}
	if((u32Addr < address)||((u32Addr + u16Sz)>(address+size)))
    274e:	9b01      	ldr	r3, [sp, #4]
    2750:	429e      	cmp	r6, r3
    2752:	d31b      	bcc.n	278c <hif_receive+0x94>
    2754:	1972      	adds	r2, r6, r5
    2756:	4691      	mov	r9, r2
    2758:	4443      	add	r3, r8
    275a:	429a      	cmp	r2, r3
    275c:	d818      	bhi.n	2790 <hif_receive+0x98>
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
		goto ERR1;
	}
	
	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
    275e:	1c30      	adds	r0, r6, #0
    2760:	1c21      	adds	r1, r4, #0
    2762:	1c2a      	adds	r2, r5, #0
    2764:	4b13      	ldr	r3, [pc, #76]	; (27b4 <hif_receive+0xbc>)
    2766:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    2768:	2800      	cmp	r0, #0
    276a:	d112      	bne.n	2792 <hif_receive+0x9a>

	/* check if this is the last packet */
	if((((address + size) - (u32Addr + u16Sz)) <= 0) || isDone)
    276c:	9b01      	ldr	r3, [sp, #4]
    276e:	4443      	add	r3, r8
    2770:	4599      	cmp	r9, r3
    2772:	d001      	beq.n	2778 <hif_receive+0x80>
    2774:	2f00      	cmp	r7, #0
    2776:	d00c      	beq.n	2792 <hif_receive+0x9a>
	{
		gu8HifSizeDone = 1;
    2778:	2201      	movs	r2, #1
    277a:	4b09      	ldr	r3, [pc, #36]	; (27a0 <hif_receive+0xa8>)
    277c:	701a      	strb	r2, [r3, #0]

		/* set RX done */
		ret = hif_set_rx_done();
    277e:	4b09      	ldr	r3, [pc, #36]	; (27a4 <hif_receive+0xac>)
    2780:	4798      	blx	r3
    2782:	e006      	b.n	2792 <hif_receive+0x9a>
			/* set RX done */
			ret = hif_set_rx_done();
		}
		else
		{
			ret = M2M_ERR_FAIL;
    2784:	20f4      	movs	r0, #244	; 0xf4
    2786:	e004      	b.n	2792 <hif_receive+0x9a>
	if(ret != M2M_SUCCESS)goto ERR1;


	if(u16Sz > size)
	{
		ret = M2M_ERR_FAIL;
    2788:	20f4      	movs	r0, #244	; 0xf4
    278a:	e002      	b.n	2792 <hif_receive+0x9a>
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%d><%d>\n",u16Sz, size);
		goto ERR1;
	}
	if((u32Addr < address)||((u32Addr + u16Sz)>(address+size)))
	{
		ret = M2M_ERR_FAIL;
    278c:	20f4      	movs	r0, #244	; 0xf4
    278e:	e000      	b.n	2792 <hif_receive+0x9a>
    2790:	20f4      	movs	r0, #244	; 0xf4
	}



ERR1:
	return ret;
    2792:	b240      	sxtb	r0, r0
}
    2794:	b003      	add	sp, #12
    2796:	bc0c      	pop	{r2, r3}
    2798:	4690      	mov	r8, r2
    279a:	4699      	mov	r9, r3
    279c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    279e:	46c0      	nop			; (mov r8, r8)
    27a0:	20000140 	.word	0x20000140
    27a4:	0000221d 	.word	0x0000221d
    27a8:	00001070 	.word	0x00001070
    27ac:	000030bd 	.word	0x000030bd
    27b0:	00001084 	.word	0x00001084
    27b4:	000030d5 	.word	0x000030d5

000027b8 <hif_register_cb>:
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
	switch(u8Grp)
    27b8:	2807      	cmp	r0, #7
    27ba:	d81b      	bhi.n	27f4 <hif_register_cb+0x3c>
    27bc:	0080      	lsls	r0, r0, #2
    27be:	4b0f      	ldr	r3, [pc, #60]	; (27fc <hif_register_cb+0x44>)
    27c0:	581b      	ldr	r3, [r3, r0]
    27c2:	469f      	mov	pc, r3
	{
		case M2M_REQ_GROUP_IP:
			pfIpCb = fn;
    27c4:	4b0e      	ldr	r3, [pc, #56]	; (2800 <hif_register_cb+0x48>)
    27c6:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    27c8:	2000      	movs	r0, #0
	switch(u8Grp)
	{
		case M2M_REQ_GROUP_IP:
			pfIpCb = fn;
			break;
    27ca:	e014      	b.n	27f6 <hif_register_cb+0x3e>
		case M2M_REQ_GROUP_WIFI:
			pfWifiCb = fn;
    27cc:	4b0d      	ldr	r3, [pc, #52]	; (2804 <hif_register_cb+0x4c>)
    27ce:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    27d0:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_IP:
			pfIpCb = fn;
			break;
		case M2M_REQ_GROUP_WIFI:
			pfWifiCb = fn;
			break;
    27d2:	e010      	b.n	27f6 <hif_register_cb+0x3e>
		case M2M_REQ_GROUP_OTA:
			pfOtaCb = fn;
    27d4:	4b0c      	ldr	r3, [pc, #48]	; (2808 <hif_register_cb+0x50>)
    27d6:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    27d8:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_WIFI:
			pfWifiCb = fn;
			break;
		case M2M_REQ_GROUP_OTA:
			pfOtaCb = fn;
			break;
    27da:	e00c      	b.n	27f6 <hif_register_cb+0x3e>
		case M2M_REQ_GROUP_HIF:
			pfHifCb = fn;
    27dc:	4b0b      	ldr	r3, [pc, #44]	; (280c <hif_register_cb+0x54>)
    27de:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    27e0:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_OTA:
			pfOtaCb = fn;
			break;
		case M2M_REQ_GROUP_HIF:
			pfHifCb = fn;
			break;
    27e2:	e008      	b.n	27f6 <hif_register_cb+0x3e>
		case M2M_REQ_GROUP_CRYPTO:
			pfCryptoCb = fn;
    27e4:	4b0a      	ldr	r3, [pc, #40]	; (2810 <hif_register_cb+0x58>)
    27e6:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    27e8:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_HIF:
			pfHifCb = fn;
			break;
		case M2M_REQ_GROUP_CRYPTO:
			pfCryptoCb = fn;
			break;
    27ea:	e004      	b.n	27f6 <hif_register_cb+0x3e>
		case M2M_REQ_GROUP_SIGMA:
			pfSigmaCb = fn;
    27ec:	4b09      	ldr	r3, [pc, #36]	; (2814 <hif_register_cb+0x5c>)
    27ee:	6019      	str	r1, [r3, #0]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    27f0:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_CRYPTO:
			pfCryptoCb = fn;
			break;
		case M2M_REQ_GROUP_SIGMA:
			pfSigmaCb = fn;
			break;
    27f2:	e000      	b.n	27f6 <hif_register_cb+0x3e>
		default:
			M2M_ERR("GRp ? %d\n",u8Grp);
			ret = M2M_ERR_FAIL;
    27f4:	20f4      	movs	r0, #244	; 0xf4
			break;
	}
	return ret;
    27f6:	b240      	sxtb	r0, r0
}
    27f8:	4770      	bx	lr
    27fa:	46c0      	nop			; (mov r8, r8)
    27fc:	0000ea38 	.word	0x0000ea38
    2800:	2000013c 	.word	0x2000013c
    2804:	20000128 	.word	0x20000128
    2808:	20000144 	.word	0x20000144
    280c:	20000130 	.word	0x20000130
    2810:	20000124 	.word	0x20000124
    2814:	20000134 	.word	0x20000134

00002818 <m2m_wifi_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
    2818:	b530      	push	{r4, r5, lr}
    281a:	b09d      	sub	sp, #116	; 0x74
    281c:	1c14      	adds	r4, r2, #0
	uint8 rx_buf[8];
	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
    281e:	282c      	cmp	r0, #44	; 0x2c
    2820:	d111      	bne.n	2846 <m2m_wifi_cb+0x2e>
	{
		tstrM2mWifiStateChanged strState;
		if (hif_receive(u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
    2822:	1c10      	adds	r0, r2, #0
    2824:	a901      	add	r1, sp, #4
    2826:	2204      	movs	r2, #4
    2828:	2300      	movs	r3, #0
    282a:	4c85      	ldr	r4, [pc, #532]	; (2a40 <m2m_wifi_cb+0x228>)
    282c:	47a0      	blx	r4
    282e:	2800      	cmp	r0, #0
    2830:	d000      	beq.n	2834 <m2m_wifi_cb+0x1c>
    2832:	e103      	b.n	2a3c <m2m_wifi_cb+0x224>
		{
			if (gpfAppWifiCb)
    2834:	4b83      	ldr	r3, [pc, #524]	; (2a44 <m2m_wifi_cb+0x22c>)
    2836:	681b      	ldr	r3, [r3, #0]
    2838:	2b00      	cmp	r3, #0
    283a:	d100      	bne.n	283e <m2m_wifi_cb+0x26>
    283c:	e0fe      	b.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
    283e:	302c      	adds	r0, #44	; 0x2c
    2840:	a901      	add	r1, sp, #4
    2842:	4798      	blx	r3
    2844:	e0fa      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
    2846:	281b      	cmp	r0, #27
    2848:	d111      	bne.n	286e <m2m_wifi_cb+0x56>
	{
		tstrSystemTime strSysTime;
		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
    284a:	1c10      	adds	r0, r2, #0
    284c:	a901      	add	r1, sp, #4
    284e:	2208      	movs	r2, #8
    2850:	2300      	movs	r3, #0
    2852:	4c7b      	ldr	r4, [pc, #492]	; (2a40 <m2m_wifi_cb+0x228>)
    2854:	47a0      	blx	r4
    2856:	2800      	cmp	r0, #0
    2858:	d000      	beq.n	285c <m2m_wifi_cb+0x44>
    285a:	e0ef      	b.n	2a3c <m2m_wifi_cb+0x224>
		{
			if (gpfAppWifiCb)
    285c:	4b79      	ldr	r3, [pc, #484]	; (2a44 <m2m_wifi_cb+0x22c>)
    285e:	681b      	ldr	r3, [r3, #0]
    2860:	2b00      	cmp	r3, #0
    2862:	d100      	bne.n	2866 <m2m_wifi_cb+0x4e>
    2864:	e0ea      	b.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
    2866:	301b      	adds	r0, #27
    2868:	a901      	add	r1, sp, #4
    286a:	4798      	blx	r3
    286c:	e0e6      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
    286e:	2806      	cmp	r0, #6
    2870:	d111      	bne.n	2896 <m2m_wifi_cb+0x7e>
	{
		tstrM2MConnInfo		strConnInfo;
		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
    2872:	1c10      	adds	r0, r2, #0
    2874:	a901      	add	r1, sp, #4
    2876:	2230      	movs	r2, #48	; 0x30
    2878:	2301      	movs	r3, #1
    287a:	4c71      	ldr	r4, [pc, #452]	; (2a40 <m2m_wifi_cb+0x228>)
    287c:	47a0      	blx	r4
    287e:	2800      	cmp	r0, #0
    2880:	d000      	beq.n	2884 <m2m_wifi_cb+0x6c>
    2882:	e0db      	b.n	2a3c <m2m_wifi_cb+0x224>
		{
			if(gpfAppWifiCb)
    2884:	4b6f      	ldr	r3, [pc, #444]	; (2a44 <m2m_wifi_cb+0x22c>)
    2886:	681b      	ldr	r3, [r3, #0]
    2888:	2b00      	cmp	r3, #0
    288a:	d100      	bne.n	288e <m2m_wifi_cb+0x76>
    288c:	e0d6      	b.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
    288e:	3006      	adds	r0, #6
    2890:	a901      	add	r1, sp, #4
    2892:	4798      	blx	r3
    2894:	e0d2      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
    2896:	280e      	cmp	r0, #14
    2898:	d100      	bne.n	289c <m2m_wifi_cb+0x84>
    289a:	e0cf      	b.n	2a3c <m2m_wifi_cb+0x224>
			if (app_wifi_recover_cb)
				app_wifi_recover_cb(strState.u8CurrState);
		}
#endif
	}
	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
    289c:	2832      	cmp	r0, #50	; 0x32
    289e:	d111      	bne.n	28c4 <m2m_wifi_cb+0xac>
	{
		tstrM2MIPConfig strIpConfig;
		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
    28a0:	1c10      	adds	r0, r2, #0
    28a2:	a901      	add	r1, sp, #4
    28a4:	2210      	movs	r2, #16
    28a6:	2300      	movs	r3, #0
    28a8:	4c65      	ldr	r4, [pc, #404]	; (2a40 <m2m_wifi_cb+0x228>)
    28aa:	47a0      	blx	r4
    28ac:	2800      	cmp	r0, #0
    28ae:	d000      	beq.n	28b2 <m2m_wifi_cb+0x9a>
    28b0:	e0c4      	b.n	2a3c <m2m_wifi_cb+0x224>
		{
			if (gpfAppWifiCb)
    28b2:	4b64      	ldr	r3, [pc, #400]	; (2a44 <m2m_wifi_cb+0x22c>)
    28b4:	681b      	ldr	r3, [r3, #0]
    28b6:	2b00      	cmp	r3, #0
    28b8:	d100      	bne.n	28bc <m2m_wifi_cb+0xa4>
    28ba:	e0bf      	b.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
    28bc:	3032      	adds	r0, #50	; 0x32
    28be:	a901      	add	r1, sp, #4
    28c0:	4798      	blx	r3
    28c2:	e0bb      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if (u8OpCode == M2M_WIFI_REQ_WPS)
    28c4:	282f      	cmp	r0, #47	; 0x2f
    28c6:	d116      	bne.n	28f6 <m2m_wifi_cb+0xde>
	{
		tstrM2MWPSInfo strWps;
		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
    28c8:	a801      	add	r0, sp, #4
    28ca:	2100      	movs	r1, #0
    28cc:	2264      	movs	r2, #100	; 0x64
    28ce:	4b5e      	ldr	r3, [pc, #376]	; (2a48 <m2m_wifi_cb+0x230>)
    28d0:	4798      	blx	r3
		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
    28d2:	1c20      	adds	r0, r4, #0
    28d4:	a901      	add	r1, sp, #4
    28d6:	2264      	movs	r2, #100	; 0x64
    28d8:	2300      	movs	r3, #0
    28da:	4c59      	ldr	r4, [pc, #356]	; (2a40 <m2m_wifi_cb+0x228>)
    28dc:	47a0      	blx	r4
    28de:	2800      	cmp	r0, #0
    28e0:	d000      	beq.n	28e4 <m2m_wifi_cb+0xcc>
    28e2:	e0ab      	b.n	2a3c <m2m_wifi_cb+0x224>
		{
			if (gpfAppWifiCb)
    28e4:	4b57      	ldr	r3, [pc, #348]	; (2a44 <m2m_wifi_cb+0x22c>)
    28e6:	681b      	ldr	r3, [r3, #0]
    28e8:	2b00      	cmp	r3, #0
    28ea:	d100      	bne.n	28ee <m2m_wifi_cb+0xd6>
    28ec:	e0a6      	b.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
    28ee:	302f      	adds	r0, #47	; 0x2f
    28f0:	a901      	add	r1, sp, #4
    28f2:	4798      	blx	r3
    28f4:	e0a2      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
    28f6:	2834      	cmp	r0, #52	; 0x34
    28f8:	d111      	bne.n	291e <m2m_wifi_cb+0x106>
	{
		uint32  u32ConflictedIP;
		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
    28fa:	1c10      	adds	r0, r2, #0
    28fc:	a901      	add	r1, sp, #4
    28fe:	2204      	movs	r2, #4
    2900:	2300      	movs	r3, #0
    2902:	4c4f      	ldr	r4, [pc, #316]	; (2a40 <m2m_wifi_cb+0x228>)
    2904:	47a0      	blx	r4
    2906:	2800      	cmp	r0, #0
    2908:	d000      	beq.n	290c <m2m_wifi_cb+0xf4>
    290a:	e097      	b.n	2a3c <m2m_wifi_cb+0x224>
		{
			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n", 
				BYTE_0(u32ConflictedIP),BYTE_1(u32ConflictedIP),BYTE_2(u32ConflictedIP),BYTE_3(u32ConflictedIP));
			if (gpfAppWifiCb)
    290c:	4b4d      	ldr	r3, [pc, #308]	; (2a44 <m2m_wifi_cb+0x22c>)
    290e:	681b      	ldr	r3, [r3, #0]
    2910:	2b00      	cmp	r3, #0
    2912:	d100      	bne.n	2916 <m2m_wifi_cb+0xfe>
    2914:	e092      	b.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);
    2916:	3034      	adds	r0, #52	; 0x34
    2918:	2100      	movs	r1, #0
    291a:	4798      	blx	r3
    291c:	e08e      	b.n	2a3c <m2m_wifi_cb+0x224>

		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_DONE)
    291e:	2811      	cmp	r0, #17
    2920:	d117      	bne.n	2952 <m2m_wifi_cb+0x13a>
	{
		tstrM2mScanDone strState;
		gu8scanInProgress = 0;
    2922:	2200      	movs	r2, #0
    2924:	4b49      	ldr	r3, [pc, #292]	; (2a4c <m2m_wifi_cb+0x234>)
    2926:	701a      	strb	r2, [r3, #0]
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
    2928:	1c20      	adds	r0, r4, #0
    292a:	a901      	add	r1, sp, #4
    292c:	3204      	adds	r2, #4
    292e:	2300      	movs	r3, #0
    2930:	4c43      	ldr	r4, [pc, #268]	; (2a40 <m2m_wifi_cb+0x228>)
    2932:	47a0      	blx	r4
    2934:	2800      	cmp	r0, #0
    2936:	d000      	beq.n	293a <m2m_wifi_cb+0x122>
    2938:	e080      	b.n	2a3c <m2m_wifi_cb+0x224>
		{
			gu8ChNum = strState.u8NumofCh;
    293a:	ab01      	add	r3, sp, #4
    293c:	781a      	ldrb	r2, [r3, #0]
    293e:	4b44      	ldr	r3, [pc, #272]	; (2a50 <m2m_wifi_cb+0x238>)
    2940:	701a      	strb	r2, [r3, #0]
			if (gpfAppWifiCb)
    2942:	4b40      	ldr	r3, [pc, #256]	; (2a44 <m2m_wifi_cb+0x22c>)
    2944:	681b      	ldr	r3, [r3, #0]
    2946:	2b00      	cmp	r3, #0
    2948:	d078      	beq.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
    294a:	3011      	adds	r0, #17
    294c:	a901      	add	r1, sp, #4
    294e:	4798      	blx	r3
    2950:	e074      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
    2952:	2813      	cmp	r0, #19
    2954:	d10f      	bne.n	2976 <m2m_wifi_cb+0x15e>
	{
		tstrM2mWifiscanResult strScanResult;
		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
    2956:	1c10      	adds	r0, r2, #0
    2958:	a901      	add	r1, sp, #4
    295a:	222c      	movs	r2, #44	; 0x2c
    295c:	2300      	movs	r3, #0
    295e:	4c38      	ldr	r4, [pc, #224]	; (2a40 <m2m_wifi_cb+0x228>)
    2960:	47a0      	blx	r4
    2962:	2800      	cmp	r0, #0
    2964:	d16a      	bne.n	2a3c <m2m_wifi_cb+0x224>
		{
			if (gpfAppWifiCb)
    2966:	4b37      	ldr	r3, [pc, #220]	; (2a44 <m2m_wifi_cb+0x22c>)
    2968:	681b      	ldr	r3, [r3, #0]
    296a:	2b00      	cmp	r3, #0
    296c:	d066      	beq.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
    296e:	3013      	adds	r0, #19
    2970:	a901      	add	r1, sp, #4
    2972:	4798      	blx	r3
    2974:	e062      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
    2976:	2804      	cmp	r0, #4
    2978:	d10f      	bne.n	299a <m2m_wifi_cb+0x182>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    297a:	1c10      	adds	r0, r2, #0
    297c:	a91a      	add	r1, sp, #104	; 0x68
    297e:	2204      	movs	r2, #4
    2980:	2300      	movs	r3, #0
    2982:	4c2f      	ldr	r4, [pc, #188]	; (2a40 <m2m_wifi_cb+0x228>)
    2984:	47a0      	blx	r4
    2986:	2800      	cmp	r0, #0
    2988:	d158      	bne.n	2a3c <m2m_wifi_cb+0x224>
		{
			if (gpfAppWifiCb)
    298a:	4b2e      	ldr	r3, [pc, #184]	; (2a44 <m2m_wifi_cb+0x22c>)
    298c:	681b      	ldr	r3, [r3, #0]
    298e:	2b00      	cmp	r3, #0
    2990:	d054      	beq.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
    2992:	3004      	adds	r0, #4
    2994:	a91a      	add	r1, sp, #104	; 0x68
    2996:	4798      	blx	r3
    2998:	e050      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
    299a:	2865      	cmp	r0, #101	; 0x65
    299c:	d10f      	bne.n	29be <m2m_wifi_cb+0x1a6>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    299e:	1c10      	adds	r0, r2, #0
    29a0:	a91a      	add	r1, sp, #104	; 0x68
    29a2:	2204      	movs	r2, #4
    29a4:	2300      	movs	r3, #0
    29a6:	4c26      	ldr	r4, [pc, #152]	; (2a40 <m2m_wifi_cb+0x228>)
    29a8:	47a0      	blx	r4
    29aa:	2800      	cmp	r0, #0
    29ac:	d146      	bne.n	2a3c <m2m_wifi_cb+0x224>
		{
			if (gpfAppWifiCb)
    29ae:	4b25      	ldr	r3, [pc, #148]	; (2a44 <m2m_wifi_cb+0x22c>)
    29b0:	681b      	ldr	r3, [r3, #0]
    29b2:	2b00      	cmp	r3, #0
    29b4:	d042      	beq.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
    29b6:	3065      	adds	r0, #101	; 0x65
    29b8:	a91a      	add	r1, sp, #104	; 0x68
    29ba:	4798      	blx	r3
    29bc:	e03e      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
    29be:	2809      	cmp	r0, #9
    29c0:	d10f      	bne.n	29e2 <m2m_wifi_cb+0x1ca>
	{
		tstrM2MProvisionInfo	strProvInfo;
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
    29c2:	1c10      	adds	r0, r2, #0
    29c4:	a901      	add	r1, sp, #4
    29c6:	2264      	movs	r2, #100	; 0x64
    29c8:	2301      	movs	r3, #1
    29ca:	4c1d      	ldr	r4, [pc, #116]	; (2a40 <m2m_wifi_cb+0x228>)
    29cc:	47a0      	blx	r4
    29ce:	2800      	cmp	r0, #0
    29d0:	d134      	bne.n	2a3c <m2m_wifi_cb+0x224>
		{
			if(gpfAppWifiCb)
    29d2:	4b1c      	ldr	r3, [pc, #112]	; (2a44 <m2m_wifi_cb+0x22c>)
    29d4:	681b      	ldr	r3, [r3, #0]
    29d6:	2b00      	cmp	r3, #0
    29d8:	d030      	beq.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
    29da:	3009      	adds	r0, #9
    29dc:	a901      	add	r1, sp, #4
    29de:	4798      	blx	r3
    29e0:	e02c      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
    29e2:	282a      	cmp	r0, #42	; 0x2a
    29e4:	d10f      	bne.n	2a06 <m2m_wifi_cb+0x1ee>
	{
		tstrM2MDefaultConnResp	strResp;
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
    29e6:	1c10      	adds	r0, r2, #0
    29e8:	a901      	add	r1, sp, #4
    29ea:	2204      	movs	r2, #4
    29ec:	2301      	movs	r3, #1
    29ee:	4c14      	ldr	r4, [pc, #80]	; (2a40 <m2m_wifi_cb+0x228>)
    29f0:	47a0      	blx	r4
    29f2:	2800      	cmp	r0, #0
    29f4:	d122      	bne.n	2a3c <m2m_wifi_cb+0x224>
		{
			if(gpfAppWifiCb)
    29f6:	4b13      	ldr	r3, [pc, #76]	; (2a44 <m2m_wifi_cb+0x22c>)
    29f8:	681b      	ldr	r3, [r3, #0]
    29fa:	2b00      	cmp	r3, #0
    29fc:	d01e      	beq.n	2a3c <m2m_wifi_cb+0x224>
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
    29fe:	302a      	adds	r0, #42	; 0x2a
    2a00:	a901      	add	r1, sp, #4
    2a02:	4798      	blx	r3
    2a04:	e01a      	b.n	2a3c <m2m_wifi_cb+0x224>
		}
	}
	
	else if(u8OpCode == M2M_WIFI_RESP_GET_PRNG)
    2a06:	2820      	cmp	r0, #32
    2a08:	d118      	bne.n	2a3c <m2m_wifi_cb+0x224>
	{
		tstrPrng strPrng;
		if(hif_receive(u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
    2a0a:	1c10      	adds	r0, r2, #0
    2a0c:	a901      	add	r1, sp, #4
    2a0e:	2208      	movs	r2, #8
    2a10:	2300      	movs	r3, #0
    2a12:	4d0b      	ldr	r5, [pc, #44]	; (2a40 <m2m_wifi_cb+0x228>)
    2a14:	47a8      	blx	r5
    2a16:	2800      	cmp	r0, #0
    2a18:	d110      	bne.n	2a3c <m2m_wifi_cb+0x224>
		{
			if(hif_receive(u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
    2a1a:	1c20      	adds	r0, r4, #0
    2a1c:	3008      	adds	r0, #8
    2a1e:	ab01      	add	r3, sp, #4
    2a20:	889a      	ldrh	r2, [r3, #4]
    2a22:	9901      	ldr	r1, [sp, #4]
    2a24:	2301      	movs	r3, #1
    2a26:	4c06      	ldr	r4, [pc, #24]	; (2a40 <m2m_wifi_cb+0x228>)
    2a28:	47a0      	blx	r4
    2a2a:	2800      	cmp	r0, #0
    2a2c:	d106      	bne.n	2a3c <m2m_wifi_cb+0x224>
			{
				if(gpfAppWifiCb)
    2a2e:	4b05      	ldr	r3, [pc, #20]	; (2a44 <m2m_wifi_cb+0x22c>)
    2a30:	681b      	ldr	r3, [r3, #0]
    2a32:	2b00      	cmp	r3, #0
    2a34:	d002      	beq.n	2a3c <m2m_wifi_cb+0x224>
					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
    2a36:	3020      	adds	r0, #32
    2a38:	a901      	add	r1, sp, #4
    2a3a:	4798      	blx	r3
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
	}
}
    2a3c:	b01d      	add	sp, #116	; 0x74
    2a3e:	bd30      	pop	{r4, r5, pc}
    2a40:	000026f9 	.word	0x000026f9
    2a44:	2000014c 	.word	0x2000014c
    2a48:	000021dd 	.word	0x000021dd
    2a4c:	20000150 	.word	0x20000150
    2a50:	20000151 	.word	0x20000151

00002a54 <m2m_wifi_init>:
	}	
	return s8Ret;
}

sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
    2a54:	b510      	push	{r4, lr}
    2a56:	b08a      	sub	sp, #40	; 0x28
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
    2a58:	2201      	movs	r2, #1
    2a5a:	466b      	mov	r3, sp
    2a5c:	71da      	strb	r2, [r3, #7]
	
	if(param == NULL) {
    2a5e:	2800      	cmp	r0, #0
    2a60:	d01d      	beq.n	2a9e <m2m_wifi_init+0x4a>
		ret = M2M_ERR_FAIL;
		goto _EXIT0;
	}
	
	gpfAppWifiCb = param->pfAppWifiCb;
    2a62:	6802      	ldr	r2, [r0, #0]
    2a64:	4b10      	ldr	r3, [pc, #64]	; (2aa8 <m2m_wifi_init+0x54>)
    2a66:	601a      	str	r2, [r3, #0]
#endif /* ETH_MODE */

#ifdef CONF_MGMT
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
    2a68:	2200      	movs	r2, #0
    2a6a:	4b10      	ldr	r3, [pc, #64]	; (2aac <m2m_wifi_init+0x58>)
    2a6c:	701a      	strb	r2, [r3, #0]
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
    2a6e:	466b      	mov	r3, sp
    2a70:	1dd8      	adds	r0, r3, #7
    2a72:	4b0f      	ldr	r3, [pc, #60]	; (2ab0 <m2m_wifi_init+0x5c>)
    2a74:	4798      	blx	r3
    2a76:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
    2a78:	d112      	bne.n	2aa0 <m2m_wifi_init+0x4c>
	/* Initialize host interface module */
	ret = hif_init(NULL);
    2a7a:	2000      	movs	r0, #0
    2a7c:	4b0d      	ldr	r3, [pc, #52]	; (2ab4 <m2m_wifi_init+0x60>)
    2a7e:	4798      	blx	r3
    2a80:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
    2a82:	d108      	bne.n	2a96 <m2m_wifi_init+0x42>

	hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb);
    2a84:	2001      	movs	r0, #1
    2a86:	490c      	ldr	r1, [pc, #48]	; (2ab8 <m2m_wifi_init+0x64>)
    2a88:	4b0c      	ldr	r3, [pc, #48]	; (2abc <m2m_wifi_init+0x68>)
    2a8a:	4798      	blx	r3

	ret = nm_get_firmware_info(&strtmp);
    2a8c:	a802      	add	r0, sp, #8
    2a8e:	4b0c      	ldr	r3, [pc, #48]	; (2ac0 <m2m_wifi_init+0x6c>)
    2a90:	4798      	blx	r3
    2a92:	1c04      	adds	r4, r0, #0
	if(M2M_ERR_FW_VER_MISMATCH == ret)
	{
		M2M_ERR("Mismatch Firmawre Version\n");
	}

	goto _EXIT0;
    2a94:	e004      	b.n	2aa0 <m2m_wifi_init+0x4c>

_EXIT1:
	nm_drv_deinit(NULL);
    2a96:	2000      	movs	r0, #0
    2a98:	4b0a      	ldr	r3, [pc, #40]	; (2ac4 <m2m_wifi_init+0x70>)
    2a9a:	4798      	blx	r3
    2a9c:	e000      	b.n	2aa0 <m2m_wifi_init+0x4c>
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
	
	if(param == NULL) {
		ret = M2M_ERR_FAIL;
    2a9e:	24f4      	movs	r4, #244	; 0xf4
	goto _EXIT0;

_EXIT1:
	nm_drv_deinit(NULL);
_EXIT0:
	return ret;
    2aa0:	b260      	sxtb	r0, r4
}
    2aa2:	b00a      	add	sp, #40	; 0x28
    2aa4:	bd10      	pop	{r4, pc}
    2aa6:	46c0      	nop			; (mov r8, r8)
    2aa8:	2000014c 	.word	0x2000014c
    2aac:	20000150 	.word	0x20000150
    2ab0:	00003259 	.word	0x00003259
    2ab4:	0000232d 	.word	0x0000232d
    2ab8:	00002819 	.word	0x00002819
    2abc:	000027b9 	.word	0x000027b9
    2ac0:	000031ad 	.word	0x000031ad
    2ac4:	000032bd 	.word	0x000032bd

00002ac8 <m2m_wifi_handle_events>:
	return M2M_SUCCESS;
}


sint8 m2m_wifi_handle_events(void * arg)
{
    2ac8:	b508      	push	{r3, lr}
	return hif_handle_isr();
    2aca:	4b01      	ldr	r3, [pc, #4]	; (2ad0 <m2m_wifi_handle_events+0x8>)
    2acc:	4798      	blx	r3
}
    2ace:	bd08      	pop	{r3, pc}
    2ad0:	00002519 	.word	0x00002519

00002ad4 <m2m_wifi_connect_sc>:
sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
}
sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
{
    2ad4:	b5f0      	push	{r4, r5, r6, r7, lr}
    2ad6:	464f      	mov	r7, r9
    2ad8:	4646      	mov	r6, r8
    2ada:	b4c0      	push	{r6, r7}
    2adc:	b0a3      	sub	sp, #140	; 0x8c
    2ade:	9005      	str	r0, [sp, #20]
    2ae0:	1c0c      	adds	r4, r1, #0
    2ae2:	1c15      	adds	r5, r2, #0
    2ae4:	1c1f      	adds	r7, r3, #0
    2ae6:	ab2a      	add	r3, sp, #168	; 0xa8
    2ae8:	881b      	ldrh	r3, [r3, #0]
    2aea:	4699      	mov	r9, r3
    2aec:	ab2b      	add	r3, sp, #172	; 0xac
    2aee:	781b      	ldrb	r3, [r3, #0]
    2af0:	4698      	mov	r8, r3
	sint8				ret = M2M_SUCCESS;
	tstrM2mWifiConnect	strConnect;
	tstrM2MWifiSecInfo	*pstrAuthInfo;

	if(u8SecType != M2M_WIFI_SEC_OPEN)
    2af2:	2a01      	cmp	r2, #1
    2af4:	d025      	beq.n	2b42 <m2m_wifi_connect_sc+0x6e>
	{
		if(pvAuthInfo == NULL)
    2af6:	2f00      	cmp	r7, #0
    2af8:	d100      	bne.n	2afc <m2m_wifi_connect_sc+0x28>
    2afa:	e086      	b.n	2c0a <m2m_wifi_connect_sc+0x136>
		{
			M2M_ERR("Key is not valid\n");
			ret = M2M_ERR_FAIL;
			goto ERR1;
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
    2afc:	2a02      	cmp	r2, #2
    2afe:	d120      	bne.n	2b42 <m2m_wifi_connect_sc+0x6e>
    2b00:	1c38      	adds	r0, r7, #0
    2b02:	4b50      	ldr	r3, [pc, #320]	; (2c44 <m2m_wifi_connect_sc+0x170>)
    2b04:	4798      	blx	r3
    2b06:	2840      	cmp	r0, #64	; 0x40
    2b08:	d11b      	bne.n	2b42 <m2m_wifi_connect_sc+0x6e>
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
			{
				if(pu8Psk[i]<'0' || (pu8Psk[i]>'9' && pu8Psk[i] < 'A')|| (pu8Psk[i]>'F' && pu8Psk[i] < 'a') || pu8Psk[i] > 'f')
    2b0a:	783b      	ldrb	r3, [r7, #0]
    2b0c:	1c1a      	adds	r2, r3, #0
    2b0e:	3a30      	subs	r2, #48	; 0x30
    2b10:	2a36      	cmp	r2, #54	; 0x36
    2b12:	d87c      	bhi.n	2c0e <m2m_wifi_connect_sc+0x13a>
    2b14:	3a0a      	subs	r2, #10
    2b16:	2a06      	cmp	r2, #6
    2b18:	d97b      	bls.n	2c12 <m2m_wifi_connect_sc+0x13e>
    2b1a:	3b47      	subs	r3, #71	; 0x47
    2b1c:	2b19      	cmp	r3, #25
    2b1e:	d97a      	bls.n	2c16 <m2m_wifi_connect_sc+0x142>
    2b20:	1c7a      	adds	r2, r7, #1
    2b22:	1c38      	adds	r0, r7, #0
    2b24:	3040      	adds	r0, #64	; 0x40
    2b26:	7813      	ldrb	r3, [r2, #0]
    2b28:	1c19      	adds	r1, r3, #0
    2b2a:	3930      	subs	r1, #48	; 0x30
    2b2c:	2936      	cmp	r1, #54	; 0x36
    2b2e:	d874      	bhi.n	2c1a <m2m_wifi_connect_sc+0x146>
    2b30:	390a      	subs	r1, #10
    2b32:	2906      	cmp	r1, #6
    2b34:	d973      	bls.n	2c1e <m2m_wifi_connect_sc+0x14a>
    2b36:	3b47      	subs	r3, #71	; 0x47
    2b38:	2b19      	cmp	r3, #25
    2b3a:	d972      	bls.n	2c22 <m2m_wifi_connect_sc+0x14e>
    2b3c:	3201      	adds	r2, #1
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
    2b3e:	4282      	cmp	r2, r0
    2b40:	d1f1      	bne.n	2b26 <m2m_wifi_connect_sc+0x52>
				}
				i++;
			}
		}
	}
	if((u8SsidLen<=0)||(u8SsidLen>=M2M_MAX_SSID_LEN))
    2b42:	1e63      	subs	r3, r4, #1
    2b44:	2b1f      	cmp	r3, #31
    2b46:	d86e      	bhi.n	2c26 <m2m_wifi_connect_sc+0x152>
		M2M_ERR("SSID LEN INVALID\n");
		ret = M2M_ERR_FAIL;
		goto ERR1;
	}

	if(u16Ch>M2M_WIFI_CH_14)
    2b48:	464b      	mov	r3, r9
    2b4a:	2b0d      	cmp	r3, #13
    2b4c:	d901      	bls.n	2b52 <m2m_wifi_connect_sc+0x7e>
	{
		if(u16Ch!=M2M_WIFI_CH_ALL)
    2b4e:	2bff      	cmp	r3, #255	; 0xff
    2b50:	d16b      	bne.n	2c2a <m2m_wifi_connect_sc+0x156>
			goto ERR1;
		}
	}


	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
    2b52:	ae07      	add	r6, sp, #28
    2b54:	205a      	movs	r0, #90	; 0x5a
    2b56:	ab02      	add	r3, sp, #8
    2b58:	469c      	mov	ip, r3
    2b5a:	4460      	add	r0, ip
    2b5c:	9905      	ldr	r1, [sp, #20]
    2b5e:	1c22      	adds	r2, r4, #0
    2b60:	4b39      	ldr	r3, [pc, #228]	; (2c48 <m2m_wifi_connect_sc+0x174>)
    2b62:	4798      	blx	r3
	strConnect.au8SSID[u8SsidLen]	= 0;
    2b64:	1934      	adds	r4, r6, r4
    2b66:	3440      	adds	r4, #64	; 0x40
    2b68:	2300      	movs	r3, #0
    2b6a:	71a3      	strb	r3, [r4, #6]
	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
    2b6c:	3344      	adds	r3, #68	; 0x44
    2b6e:	464a      	mov	r2, r9
    2b70:	52f2      	strh	r2, [r6, r3]
	/* Credentials will be Not be saved if u8NoSaveCred is set */ 
	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
    2b72:	4643      	mov	r3, r8
    2b74:	1e5a      	subs	r2, r3, #1
    2b76:	4193      	sbcs	r3, r2
    2b78:	2267      	movs	r2, #103	; 0x67
    2b7a:	54b3      	strb	r3, [r6, r2]
	pstrAuthInfo = &strConnect.strSec;
	pstrAuthInfo->u8SecType		= u8SecType;
    2b7c:	2341      	movs	r3, #65	; 0x41
    2b7e:	54f5      	strb	r5, [r6, r3]

	if(u8SecType == M2M_WIFI_SEC_WEP)
    2b80:	2d03      	cmp	r5, #3
    2b82:	d11e      	bne.n	2bc2 <m2m_wifi_connect_sc+0xee>
	{
		tstrM2mWifiWepParams	* pstrWepParams = (tstrM2mWifiWepParams*)pvAuthInfo;
		tstrM2mWifiWepParams	*pstrWep = &pstrAuthInfo->uniAuth.strWepInfo;
		pstrWep->u8KeyIndx =pstrWepParams->u8KeyIndx-1;
    2b84:	783b      	ldrb	r3, [r7, #0]
    2b86:	3b01      	subs	r3, #1
    2b88:	b2db      	uxtb	r3, r3
    2b8a:	aa07      	add	r2, sp, #28
    2b8c:	7013      	strb	r3, [r2, #0]

		if(pstrWep->u8KeyIndx >= WEP_KEY_MAX_INDEX)
    2b8e:	2b03      	cmp	r3, #3
    2b90:	d84d      	bhi.n	2c2e <m2m_wifi_connect_sc+0x15a>
		{
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
			ret = M2M_ERR_FAIL;
			goto ERR1;
		}
		pstrWep->u8KeySz = pstrWepParams->u8KeySz-1;
    2b92:	787a      	ldrb	r2, [r7, #1]
    2b94:	1e51      	subs	r1, r2, #1
    2b96:	ab07      	add	r3, sp, #28
    2b98:	7059      	strb	r1, [r3, #1]
		if ((pstrWep->u8KeySz != WEP_40_KEY_STRING_SIZE)&& (pstrWep->u8KeySz != WEP_104_KEY_STRING_SIZE))
    2b9a:	2310      	movs	r3, #16
    2b9c:	1c11      	adds	r1, r2, #0
    2b9e:	4399      	bics	r1, r3
		{
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
			ret = M2M_ERR_FAIL;
    2ba0:	20f4      	movs	r0, #244	; 0xf4
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
			ret = M2M_ERR_FAIL;
			goto ERR1;
		}
		pstrWep->u8KeySz = pstrWepParams->u8KeySz-1;
		if ((pstrWep->u8KeySz != WEP_40_KEY_STRING_SIZE)&& (pstrWep->u8KeySz != WEP_104_KEY_STRING_SIZE))
    2ba2:	290b      	cmp	r1, #11
    2ba4:	d148      	bne.n	2c38 <m2m_wifi_connect_sc+0x164>
		{
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
			ret = M2M_ERR_FAIL;
			goto ERR1;
		}
		m2m_memcpy((uint8*)pstrWep->au8WepKey,(uint8*)pstrWepParams->au8WepKey, pstrWepParams->u8KeySz);
    2ba6:	1cb9      	adds	r1, r7, #2
    2ba8:	38de      	subs	r0, #222	; 0xde
    2baa:	ab02      	add	r3, sp, #8
    2bac:	469c      	mov	ip, r3
    2bae:	4460      	add	r0, ip
    2bb0:	4b25      	ldr	r3, [pc, #148]	; (2c48 <m2m_wifi_connect_sc+0x174>)
    2bb2:	4798      	blx	r3
		pstrWep->au8WepKey[pstrWepParams->u8KeySz] = 0;
    2bb4:	787b      	ldrb	r3, [r7, #1]
    2bb6:	aa07      	add	r2, sp, #28
    2bb8:	4694      	mov	ip, r2
    2bba:	4463      	add	r3, ip
    2bbc:	2200      	movs	r2, #0
    2bbe:	709a      	strb	r2, [r3, #2]
    2bc0:	e018      	b.n	2bf4 <m2m_wifi_connect_sc+0x120>

	}


	else if(u8SecType == M2M_WIFI_SEC_WPA_PSK)
    2bc2:	2d02      	cmp	r5, #2
    2bc4:	d10c      	bne.n	2be0 <m2m_wifi_connect_sc+0x10c>
	{
		uint16	u16KeyLen = m2m_strlen((uint8*)pvAuthInfo);
    2bc6:	1c38      	adds	r0, r7, #0
    2bc8:	4b1e      	ldr	r3, [pc, #120]	; (2c44 <m2m_wifi_connect_sc+0x170>)
    2bca:	4798      	blx	r3
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
    2bcc:	1e43      	subs	r3, r0, #1
    2bce:	b29b      	uxth	r3, r3
    2bd0:	2b3f      	cmp	r3, #63	; 0x3f
    2bd2:	d82e      	bhi.n	2c32 <m2m_wifi_connect_sc+0x15e>
		{
			M2M_ERR("Incorrect PSK key length\n");
			ret = M2M_ERR_FAIL;
			goto ERR1;
		}
		m2m_memcpy(pstrAuthInfo->uniAuth.au8PSK, (uint8*)pvAuthInfo, u16KeyLen + 1);
    2bd4:	1c42      	adds	r2, r0, #1
    2bd6:	a807      	add	r0, sp, #28
    2bd8:	1c39      	adds	r1, r7, #0
    2bda:	4b1b      	ldr	r3, [pc, #108]	; (2c48 <m2m_wifi_connect_sc+0x174>)
    2bdc:	4798      	blx	r3
    2bde:	e009      	b.n	2bf4 <m2m_wifi_connect_sc+0x120>
	}
	else if(u8SecType == M2M_WIFI_SEC_802_1X)
    2be0:	2d04      	cmp	r5, #4
    2be2:	d105      	bne.n	2bf0 <m2m_wifi_connect_sc+0x11c>
	{
		m2m_memcpy((uint8*)&pstrAuthInfo->uniAuth.strCred1x, (uint8*)pvAuthInfo, sizeof(tstr1xAuthCredentials));
    2be4:	a807      	add	r0, sp, #28
    2be6:	1c39      	adds	r1, r7, #0
    2be8:	223e      	movs	r2, #62	; 0x3e
    2bea:	4b17      	ldr	r3, [pc, #92]	; (2c48 <m2m_wifi_connect_sc+0x174>)
    2bec:	4798      	blx	r3
    2bee:	e001      	b.n	2bf4 <m2m_wifi_connect_sc+0x120>
	}
	else if(u8SecType == M2M_WIFI_SEC_OPEN)
    2bf0:	2d01      	cmp	r5, #1
    2bf2:	d120      	bne.n	2c36 <m2m_wifi_connect_sc+0x162>
		M2M_ERR("undefined sec type\n");
		ret = M2M_ERR_FAIL;
		goto ERR1;
	}

	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
    2bf4:	2300      	movs	r3, #0
    2bf6:	9300      	str	r3, [sp, #0]
    2bf8:	9301      	str	r3, [sp, #4]
    2bfa:	9302      	str	r3, [sp, #8]
    2bfc:	2001      	movs	r0, #1
    2bfe:	2128      	movs	r1, #40	; 0x28
    2c00:	aa07      	add	r2, sp, #28
    2c02:	336c      	adds	r3, #108	; 0x6c
    2c04:	4c11      	ldr	r4, [pc, #68]	; (2c4c <m2m_wifi_connect_sc+0x178>)
    2c06:	47a0      	blx	r4
    2c08:	e016      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
	if(u8SecType != M2M_WIFI_SEC_OPEN)
	{
		if(pvAuthInfo == NULL)
		{
			M2M_ERR("Key is not valid\n");
			ret = M2M_ERR_FAIL;
    2c0a:	20f4      	movs	r0, #244	; 0xf4
    2c0c:	e014      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
			while(i < (M2M_MAX_PSK_LEN-1))
			{
				if(pu8Psk[i]<'0' || (pu8Psk[i]>'9' && pu8Psk[i] < 'A')|| (pu8Psk[i]>'F' && pu8Psk[i] < 'a') || pu8Psk[i] > 'f')
				{
					M2M_ERR("Invalid Key\n");
					ret = M2M_ERR_FAIL;
    2c0e:	20f4      	movs	r0, #244	; 0xf4
    2c10:	e012      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
    2c12:	20f4      	movs	r0, #244	; 0xf4
    2c14:	e010      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
    2c16:	20f4      	movs	r0, #244	; 0xf4
    2c18:	e00e      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
    2c1a:	20f4      	movs	r0, #244	; 0xf4
    2c1c:	e00c      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
    2c1e:	20f4      	movs	r0, #244	; 0xf4
    2c20:	e00a      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
    2c22:	20f4      	movs	r0, #244	; 0xf4
    2c24:	e008      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
		}
	}
	if((u8SsidLen<=0)||(u8SsidLen>=M2M_MAX_SSID_LEN))
	{
		M2M_ERR("SSID LEN INVALID\n");
		ret = M2M_ERR_FAIL;
    2c26:	20f4      	movs	r0, #244	; 0xf4
    2c28:	e006      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
	if(u16Ch>M2M_WIFI_CH_14)
	{
		if(u16Ch!=M2M_WIFI_CH_ALL)
		{
			M2M_ERR("CH INVALID\n");
			ret = M2M_ERR_FAIL;
    2c2a:	20f4      	movs	r0, #244	; 0xf4
    2c2c:	e004      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
		pstrWep->u8KeyIndx =pstrWepParams->u8KeyIndx-1;

		if(pstrWep->u8KeyIndx >= WEP_KEY_MAX_INDEX)
		{
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
			ret = M2M_ERR_FAIL;
    2c2e:	20f4      	movs	r0, #244	; 0xf4
    2c30:	e002      	b.n	2c38 <m2m_wifi_connect_sc+0x164>
	{
		uint16	u16KeyLen = m2m_strlen((uint8*)pvAuthInfo);
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
		{
			M2M_ERR("Incorrect PSK key length\n");
			ret = M2M_ERR_FAIL;
    2c32:	20f4      	movs	r0, #244	; 0xf4
    2c34:	e000      	b.n	2c38 <m2m_wifi_connect_sc+0x164>

	}
	else
	{
		M2M_ERR("undefined sec type\n");
		ret = M2M_ERR_FAIL;
    2c36:	20f4      	movs	r0, #244	; 0xf4
	}

	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);

ERR1:
	return ret;
    2c38:	b240      	sxtb	r0, r0
}
    2c3a:	b023      	add	sp, #140	; 0x8c
    2c3c:	bc0c      	pop	{r2, r3}
    2c3e:	4690      	mov	r8, r2
    2c40:	4699      	mov	r9, r3
    2c42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2c44:	000021ed 	.word	0x000021ed
    2c48:	000021c9 	.word	0x000021c9
    2c4c:	00002379 	.word	0x00002379

00002c50 <m2m_wifi_connect>:
{
	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);
}

sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
    2c50:	b510      	push	{r4, lr}
    2c52:	b082      	sub	sp, #8
    2c54:	ac04      	add	r4, sp, #16
    2c56:	8824      	ldrh	r4, [r4, #0]
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
    2c58:	9400      	str	r4, [sp, #0]
    2c5a:	2400      	movs	r4, #0
    2c5c:	9401      	str	r4, [sp, #4]
    2c5e:	4c02      	ldr	r4, [pc, #8]	; (2c68 <m2m_wifi_connect+0x18>)
    2c60:	47a0      	blx	r4
}
    2c62:	b002      	add	sp, #8
    2c64:	bd10      	pop	{r4, pc}
    2c66:	46c0      	nop			; (mov r8, r8)
    2c68:	00002ad5 	.word	0x00002ad5

00002c6c <m2m_wifi_request_dhcp_client>:

sint8 m2m_wifi_request_dhcp_client(void)
{
	/*legacy API should be removed */
	return 0;
}
    2c6c:	2000      	movs	r0, #0
    2c6e:	4770      	bx	lr

00002c70 <chip_apply_conf>:
#define M2M_DISABLE_PS				(0xd0ul)

static uint32 clk_status_reg_adr = 0xf; /* Assume initially it is B0 chip */

sint8 chip_apply_conf(uint32 u32Conf)
{
    2c70:	b5f0      	push	{r4, r5, r6, r7, lr}
    2c72:	b083      	sub	sp, #12
    2c74:	1c04      	adds	r4, r0, #0
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    2c76:	25a5      	movs	r5, #165	; 0xa5
    2c78:	016d      	lsls	r5, r5, #5
    2c7a:	4e0a      	ldr	r6, [pc, #40]	; (2ca4 <chip_apply_conf+0x34>)
		if(val32 != 0) {		
			uint32 reg = 0;
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    2c7c:	4f0a      	ldr	r7, [pc, #40]	; (2ca8 <chip_apply_conf+0x38>)
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    2c7e:	1c28      	adds	r0, r5, #0
    2c80:	1c21      	adds	r1, r4, #0
    2c82:	47b0      	blx	r6
		if(val32 != 0) {		
    2c84:	2c00      	cmp	r4, #0
    2c86:	d009      	beq.n	2c9c <chip_apply_conf+0x2c>
			uint32 reg = 0;
    2c88:	2300      	movs	r3, #0
    2c8a:	9301      	str	r3, [sp, #4]
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    2c8c:	1c28      	adds	r0, r5, #0
    2c8e:	a901      	add	r1, sp, #4
    2c90:	47b8      	blx	r7
			if(ret == M2M_SUCCESS) {
    2c92:	2800      	cmp	r0, #0
    2c94:	d1f3      	bne.n	2c7e <chip_apply_conf+0xe>
				if(reg == val32)
    2c96:	9b01      	ldr	r3, [sp, #4]
    2c98:	429c      	cmp	r4, r3
    2c9a:	d1f0      	bne.n	2c7e <chip_apply_conf+0xe>
			break;
		}
	} while(1);

	return M2M_SUCCESS;
}
    2c9c:	2000      	movs	r0, #0
    2c9e:	b003      	add	sp, #12
    2ca0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2ca2:	46c0      	nop			; (mov r8, r8)
    2ca4:	000030c9 	.word	0x000030c9
    2ca8:	000030bd 	.word	0x000030bd

00002cac <nm_clkless_wake>:
*	@author	Samer Sarhan
*	@date	06 June 2014
*	@version	1.0
*/
sint8 nm_clkless_wake(void)
{
    2cac:	b5f0      	push	{r4, r5, r6, r7, lr}
    2cae:	465f      	mov	r7, fp
    2cb0:	4656      	mov	r6, sl
    2cb2:	4645      	mov	r5, r8
    2cb4:	b4e0      	push	{r5, r6, r7}
    2cb6:	b084      	sub	sp, #16
	sint8 ret = M2M_SUCCESS;
	uint32 reg, clk_status_reg,trials = 0;
	/* wait 1ms, spi data read */
	nm_bsp_sleep(1);
    2cb8:	2001      	movs	r0, #1
    2cba:	4b38      	ldr	r3, [pc, #224]	; (2d9c <nm_clkless_wake+0xf0>)
    2cbc:	4798      	blx	r3
	ret = nm_read_reg_with_ret(0x1, &reg);
    2cbe:	2001      	movs	r0, #1
    2cc0:	a903      	add	r1, sp, #12
    2cc2:	4b37      	ldr	r3, [pc, #220]	; (2da0 <nm_clkless_wake+0xf4>)
    2cc4:	4798      	blx	r3
    2cc6:	9001      	str	r0, [sp, #4]
	if(ret != M2M_SUCCESS) {
    2cc8:	2800      	cmp	r0, #0
    2cca:	d15e      	bne.n	2d8a <nm_clkless_wake+0xde>
    2ccc:	2400      	movs	r4, #0
	 * If A0, then clks_enabled bit exists in register 0xe
	 */
	do
	{
		/* Set bit 1 */
		nm_write_reg(0x1, reg | (1 << 1));
    2cce:	4b35      	ldr	r3, [pc, #212]	; (2da4 <nm_clkless_wake+0xf8>)
    2cd0:	469b      	mov	fp, r3
		/* wait 1ms, spi data read */
		nm_bsp_sleep(1);
    2cd2:	4b32      	ldr	r3, [pc, #200]	; (2d9c <nm_clkless_wake+0xf0>)
    2cd4:	469a      	mov	sl, r3
		// Check the clock status
		ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    2cd6:	4b34      	ldr	r3, [pc, #208]	; (2da8 <nm_clkless_wake+0xfc>)
    2cd8:	4698      	mov	r8, r3
	 * If A0, then clks_enabled bit exists in register 0xe
	 */
	do
	{
		/* Set bit 1 */
		nm_write_reg(0x1, reg | (1 << 1));
    2cda:	2102      	movs	r1, #2
    2cdc:	9b03      	ldr	r3, [sp, #12]
    2cde:	4319      	orrs	r1, r3
    2ce0:	2001      	movs	r0, #1
    2ce2:	47d8      	blx	fp
		/* wait 1ms, spi data read */
		nm_bsp_sleep(1);
    2ce4:	2001      	movs	r0, #1
    2ce6:	47d0      	blx	sl
		// Check the clock status
		ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    2ce8:	4643      	mov	r3, r8
    2cea:	6818      	ldr	r0, [r3, #0]
    2cec:	a902      	add	r1, sp, #8
    2cee:	4b2c      	ldr	r3, [pc, #176]	; (2da0 <nm_clkless_wake+0xf4>)
    2cf0:	4798      	blx	r3
		if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
    2cf2:	2800      	cmp	r0, #0
    2cf4:	d102      	bne.n	2cfc <nm_clkless_wake+0x50>
    2cf6:	9b02      	ldr	r3, [sp, #8]
    2cf8:	2b00      	cmp	r3, #0
    2cfa:	d10e      	bne.n	2d1a <nm_clkless_wake+0x6e>
			/* Register 0xf did not exist in A0.
			 * If register 0xf fails to read or if it reads 0,
			 * then the chip is A0.
			 */
			clk_status_reg_adr = 0xe;
    2cfc:	4d2a      	ldr	r5, [pc, #168]	; (2da8 <nm_clkless_wake+0xfc>)
    2cfe:	230e      	movs	r3, #14
    2d00:	602b      	str	r3, [r5, #0]
			/* wait 1ms, spi data read */
			nm_bsp_sleep(1);
    2d02:	2001      	movs	r0, #1
    2d04:	4b25      	ldr	r3, [pc, #148]	; (2d9c <nm_clkless_wake+0xf0>)
    2d06:	4798      	blx	r3
			ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    2d08:	6828      	ldr	r0, [r5, #0]
    2d0a:	a902      	add	r1, sp, #8
    2d0c:	4b24      	ldr	r3, [pc, #144]	; (2da0 <nm_clkless_wake+0xf4>)
    2d0e:	4798      	blx	r3
			
			/* Aelmeleh 24-08-2015*/
			/* Check for C3000 rev. D0 value */
			if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
    2d10:	2800      	cmp	r0, #0
    2d12:	d10d      	bne.n	2d30 <nm_clkless_wake+0x84>
    2d14:	9b02      	ldr	r3, [sp, #8]
    2d16:	2b00      	cmp	r3, #0
    2d18:	d00a      	beq.n	2d30 <nm_clkless_wake+0x84>
		}

		// in case of clocks off, wait 2ms, and check it again.
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
    2d1a:	9b02      	ldr	r3, [sp, #8]
    2d1c:	075b      	lsls	r3, r3, #29
    2d1e:	d427      	bmi.n	2d70 <nm_clkless_wake+0xc4>
    2d20:	3401      	adds	r4, #1
    2d22:	1c20      	adds	r0, r4, #0
    2d24:	2103      	movs	r1, #3
    2d26:	4b21      	ldr	r3, [pc, #132]	; (2dac <nm_clkless_wake+0x100>)
    2d28:	4798      	blx	r3
    2d2a:	2900      	cmp	r1, #0
    2d2c:	d00d      	beq.n	2d4a <nm_clkless_wake+0x9e>
    2d2e:	e025      	b.n	2d7c <nm_clkless_wake+0xd0>
			
			/* Aelmeleh 24-08-2015*/
			/* Check for C3000 rev. D0 value */
			if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
				 
				clk_status_reg_adr = 0x13;
    2d30:	4d1d      	ldr	r5, [pc, #116]	; (2da8 <nm_clkless_wake+0xfc>)
    2d32:	2313      	movs	r3, #19
    2d34:	602b      	str	r3, [r5, #0]
				/* wait 1ms, spi data read */
				nm_bsp_sleep(1);
    2d36:	2001      	movs	r0, #1
    2d38:	4b18      	ldr	r3, [pc, #96]	; (2d9c <nm_clkless_wake+0xf0>)
    2d3a:	4798      	blx	r3
				ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    2d3c:	6828      	ldr	r0, [r5, #0]
    2d3e:	a902      	add	r1, sp, #8
    2d40:	4b17      	ldr	r3, [pc, #92]	; (2da0 <nm_clkless_wake+0xf4>)
    2d42:	4798      	blx	r3
			
				if(ret != M2M_SUCCESS) {
    2d44:	2800      	cmp	r0, #0
    2d46:	d0e8      	beq.n	2d1a <nm_clkless_wake+0x6e>
    2d48:	e016      	b.n	2d78 <nm_clkless_wake+0xcc>
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
		{
			/* Wait for the chip to stabilize*/
			nm_bsp_sleep(2);
    2d4a:	4f14      	ldr	r7, [pc, #80]	; (2d9c <nm_clkless_wake+0xf0>)

			// Make sure chip is awake. This is an extra step that can be removed
			// later to avoid the bus access overhead
			nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    2d4c:	4e16      	ldr	r6, [pc, #88]	; (2da8 <nm_clkless_wake+0xfc>)
    2d4e:	4d14      	ldr	r5, [pc, #80]	; (2da0 <nm_clkless_wake+0xf4>)
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
		{
			/* Wait for the chip to stabilize*/
			nm_bsp_sleep(2);
    2d50:	2002      	movs	r0, #2
    2d52:	47b8      	blx	r7

			// Make sure chip is awake. This is an extra step that can be removed
			// later to avoid the bus access overhead
			nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    2d54:	6830      	ldr	r0, [r6, #0]
    2d56:	a902      	add	r1, sp, #8
    2d58:	47a8      	blx	r5
		}

		// in case of clocks off, wait 2ms, and check it again.
		// if still off, wait for another 2ms, for a total wait of 6ms.
		// If still off, redo the wake up sequence
		while( ((clk_status_reg & 0x4) == 0) && (((++trials) %3) == 0))
    2d5a:	9b02      	ldr	r3, [sp, #8]
    2d5c:	075b      	lsls	r3, r3, #29
    2d5e:	d407      	bmi.n	2d70 <nm_clkless_wake+0xc4>
    2d60:	3401      	adds	r4, #1
    2d62:	1c20      	adds	r0, r4, #0
    2d64:	2103      	movs	r1, #3
    2d66:	4b11      	ldr	r3, [pc, #68]	; (2dac <nm_clkless_wake+0x100>)
    2d68:	4798      	blx	r3
    2d6a:	2900      	cmp	r1, #0
    2d6c:	d0f0      	beq.n	2d50 <nm_clkless_wake+0xa4>
    2d6e:	e005      	b.n	2d7c <nm_clkless_wake+0xd0>
		if((clk_status_reg & 0x4) == 0)
		{
			// Reset bit 0
			nm_write_reg(0x1, reg | (1 << 1));
		}
	} while((clk_status_reg & 0x4) == 0);
    2d70:	9b02      	ldr	r3, [sp, #8]
    2d72:	075b      	lsls	r3, r3, #29
    2d74:	d5b1      	bpl.n	2cda <nm_clkless_wake+0x2e>
    2d76:	e008      	b.n	2d8a <nm_clkless_wake+0xde>
			if( (ret != M2M_SUCCESS) || ((ret == M2M_SUCCESS) && (clk_status_reg == 0)) ) {
				 
				clk_status_reg_adr = 0x13;
				/* wait 1ms, spi data read */
				nm_bsp_sleep(1);
				ret = nm_read_reg_with_ret(clk_status_reg_adr, &clk_status_reg);
    2d78:	9001      	str	r0, [sp, #4]
    2d7a:	e006      	b.n	2d8a <nm_clkless_wake+0xde>
		}
		// in case of failure, Reset the wakeup bit to introduce a new edge on the next loop
		if((clk_status_reg & 0x4) == 0)
		{
			// Reset bit 0
			nm_write_reg(0x1, reg | (1 << 1));
    2d7c:	2102      	movs	r1, #2
    2d7e:	9b03      	ldr	r3, [sp, #12]
    2d80:	4319      	orrs	r1, r3
    2d82:	2001      	movs	r0, #1
    2d84:	4b07      	ldr	r3, [pc, #28]	; (2da4 <nm_clkless_wake+0xf8>)
    2d86:	4798      	blx	r3
    2d88:	e7f2      	b.n	2d70 <nm_clkless_wake+0xc4>
		}
	} while((clk_status_reg & 0x4) == 0);

_WAKE_EXIT:
	return ret;
    2d8a:	466b      	mov	r3, sp
    2d8c:	2004      	movs	r0, #4
    2d8e:	5618      	ldrsb	r0, [r3, r0]
}
    2d90:	b004      	add	sp, #16
    2d92:	bc1c      	pop	{r2, r3, r4}
    2d94:	4690      	mov	r8, r2
    2d96:	469a      	mov	sl, r3
    2d98:	46a3      	mov	fp, r4
    2d9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2d9c:	00001e5d 	.word	0x00001e5d
    2da0:	000030bd 	.word	0x000030bd
    2da4:	000030c9 	.word	0x000030c9
    2da8:	2000001c 	.word	0x2000001c
    2dac:	0000beb9 	.word	0x0000beb9

00002db0 <enable_interrupts>:
	nm_write_reg(0x6, 0x0);
	nm_write_reg(0x7, 0x0);
}

sint8 enable_interrupts(void)
{
    2db0:	b500      	push	{lr}
    2db2:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret;
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
    2db4:	4816      	ldr	r0, [pc, #88]	; (2e10 <enable_interrupts+0x60>)
    2db6:	a901      	add	r1, sp, #4
    2db8:	4b16      	ldr	r3, [pc, #88]	; (2e14 <enable_interrupts+0x64>)
    2dba:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
    2dbc:	2800      	cmp	r0, #0
    2dbe:	d11c      	bne.n	2dfa <enable_interrupts+0x4a>
		return M2M_ERR_BUS_FAIL;
	}
	reg |= ((uint32) 1 << 8);
    2dc0:	2180      	movs	r1, #128	; 0x80
    2dc2:	0049      	lsls	r1, r1, #1
    2dc4:	9b01      	ldr	r3, [sp, #4]
    2dc6:	4319      	orrs	r1, r3
    2dc8:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
    2dca:	4811      	ldr	r0, [pc, #68]	; (2e10 <enable_interrupts+0x60>)
    2dcc:	4b12      	ldr	r3, [pc, #72]	; (2e18 <enable_interrupts+0x68>)
    2dce:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
    2dd0:	2800      	cmp	r0, #0
    2dd2:	d114      	bne.n	2dfe <enable_interrupts+0x4e>
		return M2M_ERR_BUS_FAIL;
	}
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
    2dd4:	20d0      	movs	r0, #208	; 0xd0
    2dd6:	0140      	lsls	r0, r0, #5
    2dd8:	a901      	add	r1, sp, #4
    2dda:	4b0e      	ldr	r3, [pc, #56]	; (2e14 <enable_interrupts+0x64>)
    2ddc:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
    2dde:	2800      	cmp	r0, #0
    2de0:	d10f      	bne.n	2e02 <enable_interrupts+0x52>
		return M2M_ERR_BUS_FAIL;
	}
	reg |= ((uint32) 1 << 16);
    2de2:	2180      	movs	r1, #128	; 0x80
    2de4:	0249      	lsls	r1, r1, #9
    2de6:	9b01      	ldr	r3, [sp, #4]
    2de8:	4319      	orrs	r1, r3
    2dea:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
    2dec:	20d0      	movs	r0, #208	; 0xd0
    2dee:	0140      	lsls	r0, r0, #5
    2df0:	4b09      	ldr	r3, [pc, #36]	; (2e18 <enable_interrupts+0x68>)
    2df2:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
    2df4:	2800      	cmp	r0, #0
    2df6:	d106      	bne.n	2e06 <enable_interrupts+0x56>
    2df8:	e006      	b.n	2e08 <enable_interrupts+0x58>
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
    2dfa:	20fa      	movs	r0, #250	; 0xfa
    2dfc:	e004      	b.n	2e08 <enable_interrupts+0x58>
	}
	reg |= ((uint32) 1 << 8);
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
    2dfe:	20fa      	movs	r0, #250	; 0xfa
    2e00:	e002      	b.n	2e08 <enable_interrupts+0x58>
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
    2e02:	20fa      	movs	r0, #250	; 0xfa
    2e04:	e000      	b.n	2e08 <enable_interrupts+0x58>
	}
	reg |= ((uint32) 1 << 16);
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
	if (M2M_SUCCESS != ret) {
		return M2M_ERR_BUS_FAIL;
    2e06:	20fa      	movs	r0, #250	; 0xfa
    2e08:	b240      	sxtb	r0, r0
	}
	return M2M_SUCCESS;
}
    2e0a:	b003      	add	sp, #12
    2e0c:	bd00      	pop	{pc}
    2e0e:	46c0      	nop			; (mov r8, r8)
    2e10:	00001408 	.word	0x00001408
    2e14:	000030bd 	.word	0x000030bd
    2e18:	000030c9 	.word	0x000030c9

00002e1c <nmi_get_chipid>:
	nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
	return ret;
}

uint32 nmi_get_chipid(void)
{
    2e1c:	b510      	push	{r4, lr}
    2e1e:	b082      	sub	sp, #8
	static uint32 chipid = 0;

	if (chipid == 0) {
    2e20:	4b27      	ldr	r3, [pc, #156]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e22:	681c      	ldr	r4, [r3, #0]
    2e24:	2c00      	cmp	r4, #0
    2e26:	d146      	bne.n	2eb6 <nmi_get_chipid+0x9a>
		uint32 rfrevid;

		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
    2e28:	2080      	movs	r0, #128	; 0x80
    2e2a:	0140      	lsls	r0, r0, #5
    2e2c:	1c19      	adds	r1, r3, #0
    2e2e:	4b25      	ldr	r3, [pc, #148]	; (2ec4 <nmi_get_chipid+0xa8>)
    2e30:	4798      	blx	r3
    2e32:	2800      	cmp	r0, #0
    2e34:	d003      	beq.n	2e3e <nmi_get_chipid+0x22>
			chipid = 0;
    2e36:	2200      	movs	r2, #0
    2e38:	4b21      	ldr	r3, [pc, #132]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e3a:	601a      	str	r2, [r3, #0]
			return 0;
    2e3c:	e03d      	b.n	2eba <nmi_get_chipid+0x9e>
		}
		//if((ret = nm_read_reg_with_ret(0x11fc, &revid)) != M2M_SUCCESS) {
		//	return 0;
		//}
		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
    2e3e:	4822      	ldr	r0, [pc, #136]	; (2ec8 <nmi_get_chipid+0xac>)
    2e40:	a901      	add	r1, sp, #4
    2e42:	4b20      	ldr	r3, [pc, #128]	; (2ec4 <nmi_get_chipid+0xa8>)
    2e44:	4798      	blx	r3
    2e46:	2800      	cmp	r0, #0
    2e48:	d003      	beq.n	2e52 <nmi_get_chipid+0x36>
			chipid = 0;
    2e4a:	2200      	movs	r2, #0
    2e4c:	4b1c      	ldr	r3, [pc, #112]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e4e:	601a      	str	r2, [r3, #0]
			return 0;
    2e50:	e033      	b.n	2eba <nmi_get_chipid+0x9e>
		}

		if (chipid == 0x1002a0)  {
    2e52:	4b1b      	ldr	r3, [pc, #108]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e54:	681b      	ldr	r3, [r3, #0]
    2e56:	4a1d      	ldr	r2, [pc, #116]	; (2ecc <nmi_get_chipid+0xb0>)
    2e58:	4293      	cmp	r3, r2
    2e5a:	d106      	bne.n	2e6a <nmi_get_chipid+0x4e>
			if (rfrevid == 0x1) { /* 1002A0 */
    2e5c:	9b01      	ldr	r3, [sp, #4]
    2e5e:	2b01      	cmp	r3, #1
    2e60:	d021      	beq.n	2ea6 <nmi_get_chipid+0x8a>
			} else /* if (rfrevid == 0x2) */ { /* 1002A1 */
				chipid = 0x1002a1;
    2e62:	4a1b      	ldr	r2, [pc, #108]	; (2ed0 <nmi_get_chipid+0xb4>)
    2e64:	4b16      	ldr	r3, [pc, #88]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e66:	601a      	str	r2, [r3, #0]
    2e68:	e01d      	b.n	2ea6 <nmi_get_chipid+0x8a>
			}
		} else if(chipid == 0x1002b0) {
    2e6a:	4a1a      	ldr	r2, [pc, #104]	; (2ed4 <nmi_get_chipid+0xb8>)
    2e6c:	4293      	cmp	r3, r2
    2e6e:	d10c      	bne.n	2e8a <nmi_get_chipid+0x6e>
			if(rfrevid == 3) { /* 1002B0 */
    2e70:	9b01      	ldr	r3, [sp, #4]
    2e72:	2b03      	cmp	r3, #3
    2e74:	d017      	beq.n	2ea6 <nmi_get_chipid+0x8a>
			} else if(rfrevid == 4) { /* 1002B1 */
    2e76:	2b04      	cmp	r3, #4
    2e78:	d103      	bne.n	2e82 <nmi_get_chipid+0x66>
				chipid = 0x1002b1;
    2e7a:	4a17      	ldr	r2, [pc, #92]	; (2ed8 <nmi_get_chipid+0xbc>)
    2e7c:	4b10      	ldr	r3, [pc, #64]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e7e:	601a      	str	r2, [r3, #0]
    2e80:	e011      	b.n	2ea6 <nmi_get_chipid+0x8a>
			} else /* if(rfrevid == 5) */ { /* 1002B2 */
				chipid = 0x1002b2;
    2e82:	4a16      	ldr	r2, [pc, #88]	; (2edc <nmi_get_chipid+0xc0>)
    2e84:	4b0e      	ldr	r3, [pc, #56]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e86:	601a      	str	r2, [r3, #0]
    2e88:	e00d      	b.n	2ea6 <nmi_get_chipid+0x8a>
			}
		} else if(chipid == 0x1000F0) { 
    2e8a:	4a15      	ldr	r2, [pc, #84]	; (2ee0 <nmi_get_chipid+0xc4>)
    2e8c:	4293      	cmp	r3, r2
    2e8e:	d10a      	bne.n	2ea6 <nmi_get_chipid+0x8a>
			if((nm_read_reg_with_ret(0x3B0000, &chipid)) != M2M_SUCCESS) {
    2e90:	20ec      	movs	r0, #236	; 0xec
    2e92:	0380      	lsls	r0, r0, #14
    2e94:	490a      	ldr	r1, [pc, #40]	; (2ec0 <nmi_get_chipid+0xa4>)
    2e96:	4b0b      	ldr	r3, [pc, #44]	; (2ec4 <nmi_get_chipid+0xa8>)
    2e98:	4798      	blx	r3
    2e9a:	2800      	cmp	r0, #0
    2e9c:	d003      	beq.n	2ea6 <nmi_get_chipid+0x8a>
			chipid = 0;
    2e9e:	2200      	movs	r2, #0
    2ea0:	4b07      	ldr	r3, [pc, #28]	; (2ec0 <nmi_get_chipid+0xa4>)
    2ea2:	601a      	str	r2, [r3, #0]
			return 0;
    2ea4:	e009      	b.n	2eba <nmi_get_chipid+0x9e>
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
		chipid |= 0x050000;
    2ea6:	4a06      	ldr	r2, [pc, #24]	; (2ec0 <nmi_get_chipid+0xa4>)
				chipid |= 0x050000;
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
    2ea8:	4b0e      	ldr	r3, [pc, #56]	; (2ee4 <nmi_get_chipid+0xc8>)
    2eaa:	6811      	ldr	r1, [r2, #0]
    2eac:	400b      	ands	r3, r1
		chipid |= 0x050000;
    2eae:	21a0      	movs	r1, #160	; 0xa0
    2eb0:	02c9      	lsls	r1, r1, #11
    2eb2:	430b      	orrs	r3, r1
    2eb4:	6013      	str	r3, [r2, #0]
#endif /* PROBE_FLASH */
	}
	return chipid;
    2eb6:	4b02      	ldr	r3, [pc, #8]	; (2ec0 <nmi_get_chipid+0xa4>)
    2eb8:	681c      	ldr	r4, [r3, #0]
}
    2eba:	1c20      	adds	r0, r4, #0
    2ebc:	b002      	add	sp, #8
    2ebe:	bd10      	pop	{r4, pc}
    2ec0:	20000154 	.word	0x20000154
    2ec4:	000030bd 	.word	0x000030bd
    2ec8:	000013f4 	.word	0x000013f4
    2ecc:	001002a0 	.word	0x001002a0
    2ed0:	001002a1 	.word	0x001002a1
    2ed4:	001002b0 	.word	0x001002b0
    2ed8:	001002b1 	.word	0x001002b1
    2edc:	001002b2 	.word	0x001002b2
    2ee0:	001000f0 	.word	0x001000f0
    2ee4:	fff0ffff 	.word	0xfff0ffff

00002ee8 <wait_for_bootrom>:
#endif
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
    2ee8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2eea:	1c07      	adds	r7, r0, #0
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;

	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    2eec:	4d24      	ldr	r5, [pc, #144]	; (2f80 <wait_for_bootrom+0x98>)
    2eee:	4c25      	ldr	r4, [pc, #148]	; (2f84 <wait_for_bootrom+0x9c>)
		if (reg & 0x80000000) {
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    2ef0:	4e25      	ldr	r6, [pc, #148]	; (2f88 <wait_for_bootrom+0xa0>)
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;

	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    2ef2:	1c28      	adds	r0, r5, #0
    2ef4:	47a0      	blx	r4
		if (reg & 0x80000000) {
    2ef6:	2800      	cmp	r0, #0
    2ef8:	db02      	blt.n	2f00 <wait_for_bootrom+0x18>
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    2efa:	2001      	movs	r0, #1
    2efc:	47b0      	blx	r6
	}
    2efe:	e7f8      	b.n	2ef2 <wait_for_bootrom+0xa>
	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
    2f00:	4822      	ldr	r0, [pc, #136]	; (2f8c <wait_for_bootrom+0xa4>)
    2f02:	4b20      	ldr	r3, [pc, #128]	; (2f84 <wait_for_bootrom+0x9c>)
    2f04:	4798      	blx	r3
	reg &= 0x1;

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
    2f06:	07c3      	lsls	r3, r0, #31
    2f08:	d409      	bmi.n	2f1e <wait_for_bootrom+0x36>
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    2f0a:	4e1f      	ldr	r6, [pc, #124]	; (2f88 <wait_for_bootrom+0xa0>)
			reg = nm_read_reg(BOOTROM_REG);
    2f0c:	4c20      	ldr	r4, [pc, #128]	; (2f90 <wait_for_bootrom+0xa8>)
    2f0e:	4d1d      	ldr	r5, [pc, #116]	; (2f84 <wait_for_bootrom+0x9c>)
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    2f10:	2001      	movs	r0, #1
    2f12:	47b0      	blx	r6
			reg = nm_read_reg(BOOTROM_REG);
    2f14:	1c20      	adds	r0, r4, #0
    2f16:	47a8      	blx	r5

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
    2f18:	4b1e      	ldr	r3, [pc, #120]	; (2f94 <wait_for_bootrom+0xac>)
    2f1a:	4298      	cmp	r0, r3
    2f1c:	d1f8      	bne.n	2f10 <wait_for_bootrom+0x28>
				goto ERR2;
			}
		}
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
    2f1e:	2f02      	cmp	r7, #2
    2f20:	d109      	bne.n	2f36 <wait_for_bootrom+0x4e>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    2f22:	481d      	ldr	r0, [pc, #116]	; (2f98 <wait_for_bootrom+0xb0>)
    2f24:	491d      	ldr	r1, [pc, #116]	; (2f9c <wait_for_bootrom+0xb4>)
    2f26:	4c1e      	ldr	r4, [pc, #120]	; (2fa0 <wait_for_bootrom+0xb8>)
    2f28:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, NBIT20);
    2f2a:	481e      	ldr	r0, [pc, #120]	; (2fa4 <wait_for_bootrom+0xbc>)
    2f2c:	2180      	movs	r1, #128	; 0x80
    2f2e:	0349      	lsls	r1, r1, #13
    2f30:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    2f32:	2700      	movs	r7, #0
    2f34:	e00e      	b.n	2f54 <wait_for_bootrom+0x6c>
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
    2f36:	2f03      	cmp	r7, #3
    2f38:	d108      	bne.n	2f4c <wait_for_bootrom+0x64>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    2f3a:	4817      	ldr	r0, [pc, #92]	; (2f98 <wait_for_bootrom+0xb0>)
    2f3c:	4917      	ldr	r1, [pc, #92]	; (2f9c <wait_for_bootrom+0xb4>)
    2f3e:	4c18      	ldr	r4, [pc, #96]	; (2fa0 <wait_for_bootrom+0xb8>)
    2f40:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, 0);
    2f42:	4818      	ldr	r0, [pc, #96]	; (2fa4 <wait_for_bootrom+0xbc>)
    2f44:	2100      	movs	r1, #0
    2f46:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    2f48:	2700      	movs	r7, #0
    2f4a:	e003      	b.n	2f54 <wait_for_bootrom+0x6c>
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
    2f4c:	3f04      	subs	r7, #4
    2f4e:	427b      	negs	r3, r7
    2f50:	415f      	adcs	r7, r3
    2f52:	01ff      	lsls	r7, r7, #7
	} else {
		/*bypass this step*/
	}

	if(REV(nmi_get_chipid()) == REV_3A0)
    2f54:	4b14      	ldr	r3, [pc, #80]	; (2fa8 <wait_for_bootrom+0xc0>)
    2f56:	4798      	blx	r3
    2f58:	0500      	lsls	r0, r0, #20
    2f5a:	0d00      	lsrs	r0, r0, #20
    2f5c:	23e8      	movs	r3, #232	; 0xe8
    2f5e:	009b      	lsls	r3, r3, #2
    2f60:	4298      	cmp	r0, r3
    2f62:	d104      	bne.n	2f6e <wait_for_bootrom+0x86>
	{
		chip_apply_conf(u32GpReg1 | rHAVE_USE_PMU_BIT);
    2f64:	2002      	movs	r0, #2
    2f66:	4338      	orrs	r0, r7
    2f68:	4b10      	ldr	r3, [pc, #64]	; (2fac <wait_for_bootrom+0xc4>)
    2f6a:	4798      	blx	r3
    2f6c:	e002      	b.n	2f74 <wait_for_bootrom+0x8c>
	}
	else
	{
		chip_apply_conf(u32GpReg1);
    2f6e:	1c38      	adds	r0, r7, #0
    2f70:	4b0e      	ldr	r3, [pc, #56]	; (2fac <wait_for_bootrom+0xc4>)
    2f72:	4798      	blx	r3
	}
	
	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
    2f74:	4806      	ldr	r0, [pc, #24]	; (2f90 <wait_for_bootrom+0xa8>)
    2f76:	490e      	ldr	r1, [pc, #56]	; (2fb0 <wait_for_bootrom+0xc8>)
    2f78:	4b09      	ldr	r3, [pc, #36]	; (2fa0 <wait_for_bootrom+0xb8>)
    2f7a:	4798      	blx	r3
	rom_test();
#endif /* __ROM_TEST__ */

ERR2:
	return ret;
}
    2f7c:	2000      	movs	r0, #0
    2f7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2f80:	00001014 	.word	0x00001014
    2f84:	000030b1 	.word	0x000030b1
    2f88:	00001e5d 	.word	0x00001e5d
    2f8c:	000207bc 	.word	0x000207bc
    2f90:	000c000c 	.word	0x000c000c
    2f94:	10add09e 	.word	0x10add09e
    2f98:	000207ac 	.word	0x000207ac
    2f9c:	3c1cd57d 	.word	0x3c1cd57d
    2fa0:	000030c9 	.word	0x000030c9
    2fa4:	0000108c 	.word	0x0000108c
    2fa8:	00002e1d 	.word	0x00002e1d
    2fac:	00002c71 	.word	0x00002c71
    2fb0:	ef522f61 	.word	0xef522f61

00002fb4 <wait_for_firmware_start>:

sint8 wait_for_firmware_start(uint8 arg)
{
    2fb4:	b570      	push	{r4, r5, r6, lr}
    2fb6:	b082      	sub	sp, #8
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32Timeout = TIMEOUT;
	volatile uint32 regAddress = NMI_STATE_REG;
    2fb8:	4b15      	ldr	r3, [pc, #84]	; (3010 <wait_for_firmware_start+0x5c>)
    2fba:	9301      	str	r3, [sp, #4]
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
    2fbc:	4b15      	ldr	r3, [pc, #84]	; (3014 <wait_for_firmware_start+0x60>)
    2fbe:	9300      	str	r3, [sp, #0]
	
	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
    2fc0:	3802      	subs	r0, #2
    2fc2:	2801      	cmp	r0, #1
    2fc4:	d80c      	bhi.n	2fe0 <wait_for_firmware_start+0x2c>
		regAddress = NMI_REV_REG;
    2fc6:	4b14      	ldr	r3, [pc, #80]	; (3018 <wait_for_firmware_start+0x64>)
    2fc8:	9301      	str	r3, [sp, #4]
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
    2fca:	4b14      	ldr	r3, [pc, #80]	; (301c <wait_for_firmware_start+0x68>)
    2fcc:	9300      	str	r3, [sp, #0]
    2fce:	e007      	b.n	2fe0 <wait_for_firmware_start+0x2c>
	
	
	while (checkValue != reg)
	{
	
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    2fd0:	2002      	movs	r0, #2
    2fd2:	47b0      	blx	r6
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    2fd4:	9801      	ldr	r0, [sp, #4]
    2fd6:	47a8      	blx	r5
    2fd8:	3c01      	subs	r4, #1
		if(++cnt >= u32Timeout)
    2fda:	2c00      	cmp	r4, #0
    2fdc:	d105      	bne.n	2fea <wait_for_firmware_start+0x36>
    2fde:	e012      	b.n	3006 <wait_for_firmware_start+0x52>
ERR2:
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
    2fe0:	2401      	movs	r4, #1
    2fe2:	4264      	negs	r4, r4
    2fe4:	2000      	movs	r0, #0
	
	
	while (checkValue != reg)
	{
	
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    2fe6:	4e0e      	ldr	r6, [pc, #56]	; (3020 <wait_for_firmware_start+0x6c>)
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    2fe8:	4d0e      	ldr	r5, [pc, #56]	; (3024 <wait_for_firmware_start+0x70>)
	} else {
		/*bypass this step*/
	}
	
	
	while (checkValue != reg)
    2fea:	9b00      	ldr	r3, [sp, #0]
    2fec:	4283      	cmp	r3, r0
    2fee:	d1ef      	bne.n	2fd0 <wait_for_firmware_start+0x1c>
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    2ff0:	9a00      	ldr	r2, [sp, #0]
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    2ff2:	2000      	movs	r0, #0
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    2ff4:	4b07      	ldr	r3, [pc, #28]	; (3014 <wait_for_firmware_start+0x60>)
    2ff6:	429a      	cmp	r2, r3
    2ff8:	d106      	bne.n	3008 <wait_for_firmware_start+0x54>
	{
		nm_write_reg(NMI_STATE_REG, 0);
    2ffa:	4805      	ldr	r0, [pc, #20]	; (3010 <wait_for_firmware_start+0x5c>)
    2ffc:	2100      	movs	r1, #0
    2ffe:	4b0a      	ldr	r3, [pc, #40]	; (3028 <wait_for_firmware_start+0x74>)
    3000:	4798      	blx	r3
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    3002:	2000      	movs	r0, #0
    3004:	e000      	b.n	3008 <wait_for_firmware_start+0x54>
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
		if(++cnt >= u32Timeout)
		{
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
    3006:	20fb      	movs	r0, #251	; 0xfb
	if(M2M_FINISH_INIT_STATE == checkValue)
	{
		nm_write_reg(NMI_STATE_REG, 0);
	}
ERR:
	return ret;
    3008:	b240      	sxtb	r0, r0
}
    300a:	b002      	add	sp, #8
    300c:	bd70      	pop	{r4, r5, r6, pc}
    300e:	46c0      	nop			; (mov r8, r8)
    3010:	0000108c 	.word	0x0000108c
    3014:	02532636 	.word	0x02532636
    3018:	000207ac 	.word	0x000207ac
    301c:	d75dc1c3 	.word	0xd75dc1c3
    3020:	00001e5d 	.word	0x00001e5d
    3024:	000030b1 	.word	0x000030b1
    3028:	000030c9 	.word	0x000030c9

0000302c <chip_deinit>:

sint8 chip_deinit(void)
{
    302c:	b5f0      	push	{r4, r5, r6, r7, lr}
    302e:	b083      	sub	sp, #12
	uint32 reg = 0;
    3030:	2300      	movs	r3, #0
    3032:	9301      	str	r3, [sp, #4]
	uint8 timeout = 10;

	/**
	stop the firmware, need a re-download
	**/
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    3034:	24a0      	movs	r4, #160	; 0xa0
    3036:	0164      	lsls	r4, r4, #5
    3038:	1c20      	adds	r0, r4, #0
    303a:	a901      	add	r1, sp, #4
    303c:	4b13      	ldr	r3, [pc, #76]	; (308c <chip_deinit+0x60>)
    303e:	4798      	blx	r3
	if (ret != M2M_SUCCESS) {
		M2M_ERR("failed to de-initialize\n");
	}
	reg &= ~(1 << 10);
    3040:	4913      	ldr	r1, [pc, #76]	; (3090 <chip_deinit+0x64>)
    3042:	9b01      	ldr	r3, [sp, #4]
    3044:	4019      	ands	r1, r3
    3046:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    3048:	1c20      	adds	r0, r4, #0
    304a:	4b12      	ldr	r3, [pc, #72]	; (3094 <chip_deinit+0x68>)
    304c:	4798      	blx	r3

	if (ret != M2M_SUCCESS) {
		M2M_ERR("Error while writing reg\n");
		return ret;
    304e:	1e03      	subs	r3, r0, #0
		M2M_ERR("failed to de-initialize\n");
	}
	reg &= ~(1 << 10);
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);

	if (ret != M2M_SUCCESS) {
    3050:	d118      	bne.n	3084 <chip_deinit+0x58>
    3052:	250a      	movs	r5, #10
		M2M_ERR("Error while writing reg\n");
		return ret;
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    3054:	4e0d      	ldr	r6, [pc, #52]	; (308c <chip_deinit+0x60>)
		}
		/*Workaround to ensure that the chip is actually reset*/
		if ((reg & (1 << 10))) {
			M2M_DBG("Bit 10 not reset retry %d\n", timeout);
			reg &= ~(1 << 10);
			ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    3056:	4f0f      	ldr	r7, [pc, #60]	; (3094 <chip_deinit+0x68>)
		M2M_ERR("Error while writing reg\n");
		return ret;
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    3058:	1c20      	adds	r0, r4, #0
    305a:	a901      	add	r1, sp, #4
    305c:	47b0      	blx	r6
		if (ret != M2M_SUCCESS) {
    305e:	2800      	cmp	r0, #0
    3060:	d10d      	bne.n	307e <chip_deinit+0x52>
			M2M_ERR("Error while reading reg\n");
			return ret;
		}
		/*Workaround to ensure that the chip is actually reset*/
		if ((reg & (1 << 10))) {
    3062:	9901      	ldr	r1, [sp, #4]
    3064:	054b      	lsls	r3, r1, #21
    3066:	d50c      	bpl.n	3082 <chip_deinit+0x56>
			M2M_DBG("Bit 10 not reset retry %d\n", timeout);
			reg &= ~(1 << 10);
    3068:	4b09      	ldr	r3, [pc, #36]	; (3090 <chip_deinit+0x64>)
    306a:	4019      	ands	r1, r3
    306c:	9101      	str	r1, [sp, #4]
			ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    306e:	1c20      	adds	r0, r4, #0
    3070:	47b8      	blx	r7
    3072:	3d01      	subs	r5, #1
    3074:	b2ed      	uxtb	r5, r5
			timeout--;
		} else {
			break;
		}

	} while (timeout);
    3076:	2d00      	cmp	r5, #0
    3078:	d1ee      	bne.n	3058 <chip_deinit+0x2c>
		}
		/*Workaround to ensure that the chip is actually reset*/
		if ((reg & (1 << 10))) {
			M2M_DBG("Bit 10 not reset retry %d\n", timeout);
			reg &= ~(1 << 10);
			ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    307a:	1c03      	adds	r3, r0, #0
    307c:	e002      	b.n	3084 <chip_deinit+0x58>
		M2M_ERR("Error while writing reg\n");
		return ret;
	}

	do {
		ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    307e:	1c03      	adds	r3, r0, #0
    3080:	e000      	b.n	3084 <chip_deinit+0x58>
    3082:	2300      	movs	r3, #0
    3084:	b258      	sxtb	r0, r3
		}

	} while (timeout);

	return ret;
}
    3086:	b003      	add	sp, #12
    3088:	bdf0      	pop	{r4, r5, r6, r7, pc}
    308a:	46c0      	nop			; (mov r8, r8)
    308c:	000030bd 	.word	0x000030bd
    3090:	fffffbff 	.word	0xfffffbff
    3094:	000030c9 	.word	0x000030c9

00003098 <nm_bus_iface_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_bus_iface_init(void *pvInitVal)
{
    3098:	b508      	push	{r3, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_init(pvInitVal);
    309a:	4b01      	ldr	r3, [pc, #4]	; (30a0 <nm_bus_iface_init+0x8>)
    309c:	4798      	blx	r3

	return ret;
}
    309e:	bd08      	pop	{r3, pc}
    30a0:	00001f8d 	.word	0x00001f8d

000030a4 <nm_bus_iface_deinit>:
*	@author	Samer Sarhan
*	@date	07 April 2014
*	@version	1.0
*/
sint8 nm_bus_iface_deinit(void)
{
    30a4:	b508      	push	{r3, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_deinit();
    30a6:	4b01      	ldr	r3, [pc, #4]	; (30ac <nm_bus_iface_deinit+0x8>)
    30a8:	4798      	blx	r3

	return ret;
}
    30aa:	bd08      	pop	{r3, pc}
    30ac:	0000218d 	.word	0x0000218d

000030b0 <nm_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_read_reg(uint32 u32Addr)
{
    30b0:	b508      	push	{r3, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg(u32Addr);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg(u32Addr);
    30b2:	4b01      	ldr	r3, [pc, #4]	; (30b8 <nm_read_reg+0x8>)
    30b4:	4798      	blx	r3
	return nm_i2c_read_reg(u32Addr);
#else
#error "Plesae define bus usage"
#endif

}
    30b6:	bd08      	pop	{r3, pc}
    30b8:	000036c1 	.word	0x000036c1

000030bc <nm_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    30bc:	b508      	push	{r3, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
    30be:	4b01      	ldr	r3, [pc, #4]	; (30c4 <nm_read_reg_with_ret+0x8>)
    30c0:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
#else
#error "Plesae define bus usage"
#endif
}
    30c2:	bd08      	pop	{r3, pc}
    30c4:	000036d5 	.word	0x000036d5

000030c8 <nm_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
{
    30c8:	b508      	push	{r3, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_reg(u32Addr,u32Val);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_reg(u32Addr,u32Val);
    30ca:	4b01      	ldr	r3, [pc, #4]	; (30d0 <nm_write_reg+0x8>)
    30cc:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_write_reg(u32Addr,u32Val);
#else
#error "Plesae define bus usage"
#endif
}
    30ce:	bd08      	pop	{r3, pc}
    30d0:	000036ed 	.word	0x000036ed

000030d4 <nm_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    30d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    30d6:	464f      	mov	r7, r9
    30d8:	4646      	mov	r6, r8
    30da:	b4c0      	push	{r6, r7}
    30dc:	b083      	sub	sp, #12
    30de:	1c06      	adds	r6, r0, #0
    30e0:	4689      	mov	r9, r1
    30e2:	1c15      	adds	r5, r2, #0
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    30e4:	4b14      	ldr	r3, [pc, #80]	; (3138 <nm_read_block+0x64>)
    30e6:	881b      	ldrh	r3, [r3, #0]
    30e8:	3b08      	subs	r3, #8
    30ea:	b29b      	uxth	r3, r3
    30ec:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    30ee:	1c1c      	adds	r4, r3, #0
    30f0:	429a      	cmp	r2, r3
    30f2:	d807      	bhi.n	3104 <nm_read_block+0x30>
*	@version	1.0
*/
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    30f4:	2700      	movs	r7, #0

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);
    30f6:	1c39      	adds	r1, r7, #0
    30f8:	4449      	add	r1, r9
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    30fa:	b2aa      	uxth	r2, r5
    30fc:	1c30      	adds	r0, r6, #0
    30fe:	4b0f      	ldr	r3, [pc, #60]	; (313c <nm_read_block+0x68>)
    3100:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);
			break;
    3102:	e012      	b.n	312a <nm_read_block+0x56>
    3104:	9b01      	ldr	r3, [sp, #4]
    3106:	1ad5      	subs	r5, r2, r3
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    3108:	2700      	movs	r7, #0
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    310a:	4b0c      	ldr	r3, [pc, #48]	; (313c <nm_read_block+0x68>)
    310c:	4698      	mov	r8, r3
    310e:	464b      	mov	r3, r9
    3110:	19d9      	adds	r1, r3, r7
    3112:	1c30      	adds	r0, r6, #0
    3114:	9a01      	ldr	r2, [sp, #4]
    3116:	47c0      	blx	r8
			break;
		}
		else
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    3118:	2800      	cmp	r0, #0
    311a:	d106      	bne.n	312a <nm_read_block+0x56>
			u32Sz -= u16MaxTrxSz;
			off += u16MaxTrxSz;
    311c:	193f      	adds	r7, r7, r4
			u32Addr += u16MaxTrxSz;
    311e:	1936      	adds	r6, r6, r4
    3120:	1b2b      	subs	r3, r5, r4
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    3122:	42ac      	cmp	r4, r5
    3124:	d2e7      	bcs.n	30f6 <nm_read_block+0x22>
    3126:	1c1d      	adds	r5, r3, #0
    3128:	e7f1      	b.n	310e <nm_read_block+0x3a>
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
    312a:	b240      	sxtb	r0, r0
}
    312c:	b003      	add	sp, #12
    312e:	bc0c      	pop	{r2, r3}
    3130:	4690      	mov	r8, r2
    3132:	4699      	mov	r9, r3
    3134:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3136:	46c0      	nop			; (mov r8, r8)
    3138:	20000018 	.word	0x20000018
    313c:	0000379d 	.word	0x0000379d

00003140 <nm_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    3140:	b5f0      	push	{r4, r5, r6, r7, lr}
    3142:	464f      	mov	r7, r9
    3144:	4646      	mov	r6, r8
    3146:	b4c0      	push	{r6, r7}
    3148:	b083      	sub	sp, #12
    314a:	1c06      	adds	r6, r0, #0
    314c:	4689      	mov	r9, r1
    314e:	1c15      	adds	r5, r2, #0
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    3150:	4b14      	ldr	r3, [pc, #80]	; (31a4 <nm_write_block+0x64>)
    3152:	881b      	ldrh	r3, [r3, #0]
    3154:	3b08      	subs	r3, #8
    3156:	b29b      	uxth	r3, r3
    3158:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    315a:	1c1c      	adds	r4, r3, #0
    315c:	429a      	cmp	r2, r3
    315e:	d807      	bhi.n	3170 <nm_write_block+0x30>
*	@version	1.0
*/
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    3160:	2700      	movs	r7, #0

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);
    3162:	1c39      	adds	r1, r7, #0
    3164:	4449      	add	r1, r9
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    3166:	b2aa      	uxth	r2, r5
    3168:	1c30      	adds	r0, r6, #0
    316a:	4b0f      	ldr	r3, [pc, #60]	; (31a8 <nm_write_block+0x68>)
    316c:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);
			break;
    316e:	e012      	b.n	3196 <nm_write_block+0x56>
    3170:	9b01      	ldr	r3, [sp, #4]
    3172:	1ad5      	subs	r5, r2, r3
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    3174:	2700      	movs	r7, #0
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    3176:	4b0c      	ldr	r3, [pc, #48]	; (31a8 <nm_write_block+0x68>)
    3178:	4698      	mov	r8, r3
    317a:	464b      	mov	r3, r9
    317c:	19d9      	adds	r1, r3, r7
    317e:	1c30      	adds	r0, r6, #0
    3180:	9a01      	ldr	r2, [sp, #4]
    3182:	47c0      	blx	r8
			break;
		}
		else
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    3184:	2800      	cmp	r0, #0
    3186:	d106      	bne.n	3196 <nm_write_block+0x56>
			u32Sz -= u16MaxTrxSz;
			off += u16MaxTrxSz;
    3188:	193f      	adds	r7, r7, r4
			u32Addr += u16MaxTrxSz;
    318a:	1936      	adds	r6, r6, r4
    318c:	1b2b      	subs	r3, r5, r4
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    318e:	42ac      	cmp	r4, r5
    3190:	d2e7      	bcs.n	3162 <nm_write_block+0x22>
    3192:	1c1d      	adds	r5, r3, #0
    3194:	e7f1      	b.n	317a <nm_write_block+0x3a>
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
    3196:	b240      	sxtb	r0, r0
}
    3198:	b003      	add	sp, #12
    319a:	bc0c      	pop	{r2, r3}
    319c:	4690      	mov	r8, r2
    319e:	4699      	mov	r9, r3
    31a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    31a2:	46c0      	nop			; (mov r8, r8)
    31a4:	20000018 	.word	0x20000018
    31a8:	00003805 	.word	0x00003805

000031ac <nm_get_firmware_info>:
*	@param [out]	M2mRev
*			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
*	@version	1.0
*/
sint8 nm_get_firmware_info(tstrM2mRev* M2mRev)
{
    31ac:	b5f0      	push	{r4, r5, r6, r7, lr}
    31ae:	b083      	sub	sp, #12
    31b0:	1c04      	adds	r4, r0, #0
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
    31b2:	2300      	movs	r3, #0
    31b4:	9301      	str	r3, [sp, #4]
	sint8	ret = M2M_SUCCESS;

	ret = nm_read_reg_with_ret(NMI_REV_REG, &reg);
    31b6:	4821      	ldr	r0, [pc, #132]	; (323c <nm_get_firmware_info+0x90>)
    31b8:	a901      	add	r1, sp, #4
    31ba:	4b21      	ldr	r3, [pc, #132]	; (3240 <nm_get_firmware_info+0x94>)
    31bc:	4798      	blx	r3
    31be:	1c05      	adds	r5, r0, #0
	//In case the Firmware running is ATE fw
	if(M2M_ATE_FW_IS_UP_VALUE == reg)
    31c0:	4b20      	ldr	r3, [pc, #128]	; (3244 <nm_get_firmware_info+0x98>)
    31c2:	9a01      	ldr	r2, [sp, #4]
    31c4:	429a      	cmp	r2, r3
    31c6:	d104      	bne.n	31d2 <nm_get_firmware_info+0x26>
	{
		//Read FW info again from the register specified for ATE
		ret = nm_read_reg_with_ret(NMI_REV_REG_ATE, &reg);
    31c8:	481f      	ldr	r0, [pc, #124]	; (3248 <nm_get_firmware_info+0x9c>)
    31ca:	a901      	add	r1, sp, #4
    31cc:	4b1c      	ldr	r3, [pc, #112]	; (3240 <nm_get_firmware_info+0x94>)
    31ce:	4798      	blx	r3
    31d0:	1c05      	adds	r5, r0, #0
	}
	M2mRev->u8DriverMajor	= M2M_GET_DRV_MAJOR(reg);
    31d2:	9a01      	ldr	r2, [sp, #4]
    31d4:	0c11      	lsrs	r1, r2, #16
    31d6:	b28b      	uxth	r3, r1
    31d8:	0a18      	lsrs	r0, r3, #8
    31da:	71e0      	strb	r0, [r4, #7]
	M2mRev->u8DriverMinor   = M2M_GET_DRV_MINOR(reg);
    31dc:	091b      	lsrs	r3, r3, #4
    31de:	260f      	movs	r6, #15
    31e0:	4033      	ands	r3, r6
    31e2:	7223      	strb	r3, [r4, #8]
	M2mRev->u8DriverPatch	= M2M_GET_DRV_PATCH(reg);
    31e4:	4031      	ands	r1, r6
    31e6:	7261      	strb	r1, [r4, #9]
	M2mRev->u8FirmwareMajor	= M2M_GET_FW_MAJOR(reg);
    31e8:	b293      	uxth	r3, r2
    31ea:	0a19      	lsrs	r1, r3, #8
    31ec:	7121      	strb	r1, [r4, #4]
	M2mRev->u8FirmwareMinor = M2M_GET_FW_MINOR(reg);
    31ee:	091b      	lsrs	r3, r3, #4
    31f0:	4033      	ands	r3, r6
    31f2:	7163      	strb	r3, [r4, #5]
	M2mRev->u8FirmwarePatch = M2M_GET_FW_PATCH(reg);
    31f4:	4032      	ands	r2, r6
    31f6:	71a2      	strb	r2, [r4, #6]
	M2mRev->u32Chipid	= nmi_get_chipid();
    31f8:	4b14      	ldr	r3, [pc, #80]	; (324c <nm_get_firmware_info+0xa0>)
    31fa:	4798      	blx	r3
    31fc:	6020      	str	r0, [r4, #0]
	
	curr_firm_ver   = M2M_MAKE_VERSION(M2mRev->u8FirmwareMajor, M2mRev->u8FirmwareMinor,M2mRev->u8FirmwarePatch);
    31fe:	7923      	ldrb	r3, [r4, #4]
    3200:	021a      	lsls	r2, r3, #8
    3202:	79a3      	ldrb	r3, [r4, #6]
    3204:	4033      	ands	r3, r6
    3206:	4313      	orrs	r3, r2
    3208:	7960      	ldrb	r0, [r4, #5]
    320a:	0100      	lsls	r0, r0, #4
    320c:	27ff      	movs	r7, #255	; 0xff
    320e:	4038      	ands	r0, r7
    3210:	4303      	orrs	r3, r0
	curr_drv_ver    = M2M_MAKE_VERSION(M2M_DRIVER_VERSION_MAJOR_NO, M2M_DRIVER_VERSION_MINOR_NO, M2M_DRIVER_VERSION_PATCH_NO);
	min_req_drv_ver = M2M_MAKE_VERSION(M2mRev->u8DriverMajor, M2mRev->u8DriverMinor,M2mRev->u8DriverPatch);
    3212:	79e0      	ldrb	r0, [r4, #7]
    3214:	0200      	lsls	r0, r0, #8
    3216:	7a62      	ldrb	r2, [r4, #9]
    3218:	4016      	ands	r6, r2
    321a:	4306      	orrs	r6, r0
    321c:	7a21      	ldrb	r1, [r4, #8]
    321e:	0109      	lsls	r1, r1, #4
    3220:	4039      	ands	r1, r7
	if(curr_drv_ver <  min_req_drv_ver) {
    3222:	1c32      	adds	r2, r6, #0
    3224:	430a      	orrs	r2, r1
    3226:	490a      	ldr	r1, [pc, #40]	; (3250 <nm_get_firmware_info+0xa4>)
    3228:	428a      	cmp	r2, r1
    322a:	d900      	bls.n	322e <nm_get_firmware_info+0x82>
		/*The current driver version should be larger or equal 
		than the min driver that the current firmware support  */
		ret = M2M_ERR_FW_VER_MISMATCH;
    322c:	25f3      	movs	r5, #243	; 0xf3
	}
	if(curr_drv_ver >  curr_firm_ver) {
    322e:	4a09      	ldr	r2, [pc, #36]	; (3254 <nm_get_firmware_info+0xa8>)
    3230:	4293      	cmp	r3, r2
    3232:	d800      	bhi.n	3236 <nm_get_firmware_info+0x8a>
		/*The current driver should be equal or less than the firmware version*/
		ret = M2M_ERR_FW_VER_MISMATCH;
    3234:	25f3      	movs	r5, #243	; 0xf3
	}
	return ret;
    3236:	b268      	sxtb	r0, r5
}
    3238:	b003      	add	sp, #12
    323a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    323c:	000207ac 	.word	0x000207ac
    3240:	000030bd 	.word	0x000030bd
    3244:	d75dc1c3 	.word	0xd75dc1c3
    3248:	00001048 	.word	0x00001048
    324c:	00002e1d 	.word	0x00002e1d
    3250:	00001330 	.word	0x00001330
    3254:	0000132f 	.word	0x0000132f

00003258 <nm_drv_init>:
*	@author	M. Abdelmawla
*	@date	15 July 2012
*	@version	1.0
*/
sint8 nm_drv_init(void * arg)
{
    3258:	b538      	push	{r3, r4, r5, lr}
	sint8 ret = M2M_SUCCESS;
	uint8 u8Mode;
	
	if(NULL != arg) {
    325a:	2800      	cmp	r0, #0
    325c:	d005      	beq.n	326a <nm_drv_init+0x12>
		u8Mode = *((uint8 *)arg);
    325e:	7805      	ldrb	r5, [r0, #0]
		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
    3260:	1e6b      	subs	r3, r5, #1
    3262:	2b03      	cmp	r3, #3
    3264:	d902      	bls.n	326c <nm_drv_init+0x14>
			u8Mode = M2M_WIFI_MODE_NORMAL;
    3266:	2501      	movs	r5, #1
    3268:	e000      	b.n	326c <nm_drv_init+0x14>
		}
	} else {
		u8Mode = M2M_WIFI_MODE_NORMAL;
    326a:	2501      	movs	r5, #1
	}
	
	ret = nm_bus_iface_init(NULL);
    326c:	2000      	movs	r0, #0
    326e:	4b0d      	ldr	r3, [pc, #52]	; (32a4 <nm_drv_init+0x4c>)
    3270:	4798      	blx	r3
    3272:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    3274:	d114      	bne.n	32a0 <nm_drv_init+0x48>
	}
#endif
	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_init();
    3276:	4b0c      	ldr	r3, [pc, #48]	; (32a8 <nm_drv_init+0x50>)
    3278:	4798      	blx	r3
	ret = cpu_start();
	if (M2M_SUCCESS != ret) {
		goto ERR2;
	}
#endif
	ret = wait_for_bootrom(u8Mode);
    327a:	1c28      	adds	r0, r5, #0
    327c:	4b0b      	ldr	r3, [pc, #44]	; (32ac <nm_drv_init+0x54>)
    327e:	4798      	blx	r3
    3280:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    3282:	d10b      	bne.n	329c <nm_drv_init+0x44>
		goto ERR2;
	}
		
	ret = wait_for_firmware_start(u8Mode);
    3284:	1c28      	adds	r0, r5, #0
    3286:	4b0a      	ldr	r3, [pc, #40]	; (32b0 <nm_drv_init+0x58>)
    3288:	4798      	blx	r3
    328a:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    328c:	d106      	bne.n	329c <nm_drv_init+0x44>
		goto ERR2;
	}
	
	if((M2M_WIFI_MODE_ATE_HIGH == u8Mode)||(M2M_WIFI_MODE_ATE_LOW == u8Mode)) {
    328e:	3d02      	subs	r5, #2
    3290:	2d01      	cmp	r5, #1
    3292:	d905      	bls.n	32a0 <nm_drv_init+0x48>
		goto ERR1;
	} else {
		/*continue running*/
	}
	
	ret = enable_interrupts();
    3294:	4b07      	ldr	r3, [pc, #28]	; (32b4 <nm_drv_init+0x5c>)
    3296:	4798      	blx	r3
    3298:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    329a:	d001      	beq.n	32a0 <nm_drv_init+0x48>
		goto ERR2;
	}
	
	return ret;
ERR2:
	nm_bus_iface_deinit();
    329c:	4b06      	ldr	r3, [pc, #24]	; (32b8 <nm_drv_init+0x60>)
    329e:	4798      	blx	r3
    32a0:	b260      	sxtb	r0, r4
ERR1:
	return ret;
}
    32a2:	bd38      	pop	{r3, r4, r5, pc}
    32a4:	00003099 	.word	0x00003099
    32a8:	00003705 	.word	0x00003705
    32ac:	00002ee9 	.word	0x00002ee9
    32b0:	00002fb5 	.word	0x00002fb5
    32b4:	00002db1 	.word	0x00002db1
    32b8:	000030a5 	.word	0x000030a5

000032bc <nm_drv_deinit>:
*	@author	M. Abdelmawla
*	@date	17 July 2012
*	@version	1.0
*/
sint8 nm_drv_deinit(void * arg)
{
    32bc:	b510      	push	{r4, lr}
	sint8 ret;

	ret = chip_deinit();
    32be:	4b08      	ldr	r3, [pc, #32]	; (32e0 <nm_drv_deinit+0x24>)
    32c0:	4798      	blx	r3
    32c2:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    32c4:	d10a      	bne.n	32dc <nm_drv_deinit+0x20>
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
		goto ERR1;
	}
	
	/* Disable SPI flash to save power when the chip is off */
	ret = spi_flash_enable(0);
    32c6:	2000      	movs	r0, #0
    32c8:	4b06      	ldr	r3, [pc, #24]	; (32e4 <nm_drv_deinit+0x28>)
    32ca:	4798      	blx	r3
    32cc:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    32ce:	d105      	bne.n	32dc <nm_drv_deinit+0x20>
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
		goto ERR1;
	}

	ret = nm_bus_iface_deinit();
    32d0:	4b05      	ldr	r3, [pc, #20]	; (32e8 <nm_drv_deinit+0x2c>)
    32d2:	4798      	blx	r3
    32d4:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    32d6:	d101      	bne.n	32dc <nm_drv_deinit+0x20>
		M2M_ERR("[nmi stop]: fail init bus\n");
		goto ERR1;
	}
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_deinit();
    32d8:	4b04      	ldr	r3, [pc, #16]	; (32ec <nm_drv_deinit+0x30>)
    32da:	4798      	blx	r3
#endif

ERR1:
	return ret;
    32dc:	b260      	sxtb	r0, r4
}
    32de:	bd10      	pop	{r4, pc}
    32e0:	0000302d 	.word	0x0000302d
    32e4:	000040ad 	.word	0x000040ad
    32e8:	000030a5 	.word	0x000030a5
    32ec:	000036b1 	.word	0x000036b1

000032f0 <nmi_spi_read>:
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static uint8 	gu8Crc_off	=   0;

static sint8 nmi_spi_read(uint8* b, uint16 sz)
{
    32f0:	b500      	push	{lr}
    32f2:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = NULL;
    32f4:	ab01      	add	r3, sp, #4
    32f6:	2200      	movs	r2, #0
    32f8:	9201      	str	r2, [sp, #4]
	spi.pu8OutBuf = b;
    32fa:	9002      	str	r0, [sp, #8]
	spi.u16Sz = sz;
    32fc:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    32fe:	2003      	movs	r0, #3
    3300:	1c19      	adds	r1, r3, #0
    3302:	4b02      	ldr	r3, [pc, #8]	; (330c <nmi_spi_read+0x1c>)
    3304:	4798      	blx	r3
}
    3306:	b005      	add	sp, #20
    3308:	bd00      	pop	{pc}
    330a:	46c0      	nop			; (mov r8, r8)
    330c:	00002089 	.word	0x00002089

00003310 <spi_cmd_rsp>:

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    3310:	b5f0      	push	{r4, r5, r6, r7, lr}
    3312:	b083      	sub	sp, #12
    3314:	1e06      	subs	r6, r0, #0
	sint8 s8RetryCnt;

	/**
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
    3316:	2ecf      	cmp	r6, #207	; 0xcf
    3318:	d004      	beq.n	3324 <spi_cmd_rsp+0x14>
    331a:	1c03      	adds	r3, r0, #0
    331c:	333b      	adds	r3, #59	; 0x3b
    331e:	b2db      	uxtb	r3, r3
    3320:	2b01      	cmp	r3, #1
    3322:	d807      	bhi.n	3334 <spi_cmd_rsp+0x24>
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    3324:	466b      	mov	r3, sp
    3326:	1dd8      	adds	r0, r3, #7
    3328:	2101      	movs	r1, #1
    332a:	4b18      	ldr	r3, [pc, #96]	; (338c <spi_cmd_rsp+0x7c>)
    332c:	4798      	blx	r3
			result = N_FAIL;
    332e:	2300      	movs	r3, #0
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    3330:	2800      	cmp	r0, #0
    3332:	d128      	bne.n	3386 <spi_cmd_rsp+0x76>

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    3334:	240b      	movs	r4, #11

	/* wait for response */
	s8RetryCnt = 10;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    3336:	466b      	mov	r3, sp
    3338:	1ddd      	adds	r5, r3, #7
    333a:	4f14      	ldr	r7, [pc, #80]	; (338c <spi_cmd_rsp+0x7c>)
    333c:	1c28      	adds	r0, r5, #0
    333e:	2101      	movs	r1, #1
    3340:	47b8      	blx	r7
    3342:	2800      	cmp	r0, #0
    3344:	d11a      	bne.n	337c <spi_cmd_rsp+0x6c>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
			result = N_FAIL;
			goto _fail_;
		}
	} while((rsp != cmd) && (s8RetryCnt-- >0));
    3346:	782b      	ldrb	r3, [r5, #0]
    3348:	42b3      	cmp	r3, r6
    334a:	d005      	beq.n	3358 <spi_cmd_rsp+0x48>
    334c:	3c01      	subs	r4, #1
    334e:	b2e4      	uxtb	r4, r4
    3350:	2c00      	cmp	r4, #0
    3352:	d1f3      	bne.n	333c <spi_cmd_rsp+0x2c>
    3354:	340b      	adds	r4, #11
    3356:	e000      	b.n	335a <spi_cmd_rsp+0x4a>
    3358:	240b      	movs	r4, #11
	**/
	/* wait for response */
	s8RetryCnt = 10;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    335a:	466b      	mov	r3, sp
    335c:	1ddd      	adds	r5, r3, #7
    335e:	4e0b      	ldr	r6, [pc, #44]	; (338c <spi_cmd_rsp+0x7c>)
    3360:	1c28      	adds	r0, r5, #0
    3362:	2101      	movs	r1, #1
    3364:	47b0      	blx	r6
    3366:	2800      	cmp	r0, #0
    3368:	d10a      	bne.n	3380 <spi_cmd_rsp+0x70>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
			result = N_FAIL;
			goto _fail_;
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));
    336a:	782b      	ldrb	r3, [r5, #0]
    336c:	2b00      	cmp	r3, #0
    336e:	d009      	beq.n	3384 <spi_cmd_rsp+0x74>
    3370:	3c01      	subs	r4, #1
    3372:	b2e4      	uxtb	r4, r4
    3374:	2c00      	cmp	r4, #0
    3376:	d1f3      	bne.n	3360 <spi_cmd_rsp+0x50>
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
	uint8 rsp;
	sint8 result = N_OK;
    3378:	2301      	movs	r3, #1
    337a:	e004      	b.n	3386 <spi_cmd_rsp+0x76>
	s8RetryCnt = 10;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
			result = N_FAIL;
    337c:	2300      	movs	r3, #0
    337e:	e002      	b.n	3386 <spi_cmd_rsp+0x76>
	s8RetryCnt = 10;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
			result = N_FAIL;
    3380:	2300      	movs	r3, #0
    3382:	e000      	b.n	3386 <spi_cmd_rsp+0x76>
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
	uint8 rsp;
	sint8 result = N_OK;
    3384:	2301      	movs	r3, #1
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));

_fail_:

	return result;
    3386:	b258      	sxtb	r0, r3
}
    3388:	b003      	add	sp, #12
    338a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    338c:	000032f1 	.word	0x000032f1

00003390 <spi_data_read>:

static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
{
    3390:	b5f0      	push	{r4, r5, r6, r7, lr}
    3392:	465f      	mov	r7, fp
    3394:	4656      	mov	r6, sl
    3396:	464d      	mov	r5, r9
    3398:	4644      	mov	r4, r8
    339a:	b4f0      	push	{r4, r5, r6, r7}
    339c:	b085      	sub	sp, #20
    339e:	4682      	mov	sl, r0
    33a0:	4689      	mov	r9, r1
    33a2:	4693      	mov	fp, r2
	uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    33a4:	2300      	movs	r3, #0
    33a6:	4698      	mov	r8, r3
		/**
			Data Respnose header
		**/
		retry = 10;
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    33a8:	4f28      	ldr	r7, [pc, #160]	; (344c <spi_data_read+0xbc>)
	/**
		Data
	**/
	ix = 0;
	do {
		if (sz <= DATA_PKT_SZ)
    33aa:	2380      	movs	r3, #128	; 0x80
    33ac:	019b      	lsls	r3, r3, #6
    33ae:	4599      	cmp	r9, r3
    33b0:	d804      	bhi.n	33bc <spi_data_read+0x2c>
			nbytes = sz;
    33b2:	464b      	mov	r3, r9
    33b4:	466a      	mov	r2, sp
    33b6:	80d3      	strh	r3, [r2, #6]
    33b8:	88d6      	ldrh	r6, [r2, #6]
    33ba:	e001      	b.n	33c0 <spi_data_read+0x30>
		else
			nbytes = DATA_PKT_SZ;
    33bc:	2680      	movs	r6, #128	; 0x80
    33be:	01b6      	lsls	r6, r6, #6

		/**
			Data Respnose header
		**/
		retry = 10;
    33c0:	240a      	movs	r4, #10
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    33c2:	ab02      	add	r3, sp, #8
    33c4:	1cdd      	adds	r5, r3, #3
    33c6:	1c28      	adds	r0, r5, #0
    33c8:	2101      	movs	r1, #1
    33ca:	47b8      	blx	r7
    33cc:	2800      	cmp	r0, #0
    33ce:	d12e      	bne.n	342e <spi_data_read+0x9e>
				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
				result = N_FAIL;
				break;
			}
			if (((rsp >> 4) & 0xf) == 0xf)
    33d0:	782b      	ldrb	r3, [r5, #0]
    33d2:	091b      	lsrs	r3, r3, #4
    33d4:	2b0f      	cmp	r3, #15
    33d6:	d005      	beq.n	33e4 <spi_data_read+0x54>
    33d8:	3c01      	subs	r4, #1
    33da:	b2a4      	uxth	r4, r4
				break;
		} while (retry--);
    33dc:	b223      	sxth	r3, r4
    33de:	3301      	adds	r3, #1
    33e0:	d1f1      	bne.n	33c6 <spi_data_read+0x36>
    33e2:	e02b      	b.n	343c <spi_data_read+0xac>

		if (result == N_FAIL)
			break;

		if (retry <= 0) {
    33e4:	b224      	sxth	r4, r4
    33e6:	2c00      	cmp	r4, #0
    33e8:	dd23      	ble.n	3432 <spi_data_read+0xa2>
		}

		/**
			Read bytes
		**/
		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
    33ea:	b2b6      	uxth	r6, r6
    33ec:	4643      	mov	r3, r8
    33ee:	b218      	sxth	r0, r3
    33f0:	4450      	add	r0, sl
    33f2:	1c31      	adds	r1, r6, #0
    33f4:	4b15      	ldr	r3, [pc, #84]	; (344c <spi_data_read+0xbc>)
    33f6:	4798      	blx	r3
    33f8:	2800      	cmp	r0, #0
    33fa:	d11c      	bne.n	3436 <spi_data_read+0xa6>
			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
			result = N_FAIL;
			break;
		}
		if(!clockless)
    33fc:	465b      	mov	r3, fp
    33fe:	2b00      	cmp	r3, #0
    3400:	d109      	bne.n	3416 <spi_data_read+0x86>
		{
			/**
			Read Crc
			**/
			if (!gu8Crc_off) {
    3402:	4b13      	ldr	r3, [pc, #76]	; (3450 <spi_data_read+0xc0>)
    3404:	781b      	ldrb	r3, [r3, #0]
    3406:	2b00      	cmp	r3, #0
    3408:	d105      	bne.n	3416 <spi_data_read+0x86>
				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
    340a:	a803      	add	r0, sp, #12
    340c:	2102      	movs	r1, #2
    340e:	4b0f      	ldr	r3, [pc, #60]	; (344c <spi_data_read+0xbc>)
    3410:	4798      	blx	r3
    3412:	2800      	cmp	r0, #0
    3414:	d111      	bne.n	343a <spi_data_read+0xaa>
					result = N_FAIL;
					break;
				}
			}
		}
		ix += nbytes;
    3416:	4643      	mov	r3, r8
    3418:	18f3      	adds	r3, r6, r3
    341a:	b29b      	uxth	r3, r3
    341c:	4698      	mov	r8, r3
		sz -= nbytes;
    341e:	464b      	mov	r3, r9
    3420:	1b9e      	subs	r6, r3, r6
    3422:	b2b3      	uxth	r3, r6
    3424:	4699      	mov	r9, r3

	} while (sz);
    3426:	2b00      	cmp	r3, #0
    3428:	d1bf      	bne.n	33aa <spi_data_read+0x1a>
    342a:	2001      	movs	r0, #1
    342c:	e006      	b.n	343c <spi_data_read+0xac>
    342e:	2000      	movs	r0, #0
    3430:	e004      	b.n	343c <spi_data_read+0xac>
		if (result == N_FAIL)
			break;

		if (retry <= 0) {
			M2M_ERR("[nmi spi]: Failed data response read...(%02x)\n", rsp);
			result = N_FAIL;
    3432:	2000      	movs	r0, #0
    3434:	e002      	b.n	343c <spi_data_read+0xac>
		/**
			Read bytes
		**/
		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
			result = N_FAIL;
    3436:	2000      	movs	r0, #0
    3438:	e000      	b.n	343c <spi_data_read+0xac>
			Read Crc
			**/
			if (!gu8Crc_off) {
				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
					M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
					result = N_FAIL;
    343a:	2000      	movs	r0, #0
		ix += nbytes;
		sz -= nbytes;

	} while (sz);

	return result;
    343c:	b240      	sxtb	r0, r0
}
    343e:	b005      	add	sp, #20
    3440:	bc3c      	pop	{r2, r3, r4, r5}
    3442:	4690      	mov	r8, r2
    3444:	4699      	mov	r9, r3
    3446:	46a2      	mov	sl, r4
    3448:	46ab      	mov	fp, r5
    344a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    344c:	000032f1 	.word	0x000032f1
    3450:	20000158 	.word	0x20000158

00003454 <nmi_spi_write>:
	spi.u16Sz = sz;
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
}

static sint8 nmi_spi_write(uint8* b, uint16 sz)
{
    3454:	b500      	push	{lr}
    3456:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = b;
    3458:	ab01      	add	r3, sp, #4
    345a:	9001      	str	r0, [sp, #4]
	spi.pu8OutBuf = NULL;
    345c:	2200      	movs	r2, #0
    345e:	9202      	str	r2, [sp, #8]
	spi.u16Sz = sz;
    3460:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    3462:	2003      	movs	r0, #3
    3464:	1c19      	adds	r1, r3, #0
    3466:	4b02      	ldr	r3, [pc, #8]	; (3470 <nmi_spi_write+0x1c>)
    3468:	4798      	blx	r3
}
    346a:	b005      	add	sp, #20
    346c:	bd00      	pop	{pc}
    346e:	46c0      	nop			; (mov r8, r8)
    3470:	00002089 	.word	0x00002089

00003474 <spi_cmd>:
	Spi protocol Function

********************************************/

static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
{
    3474:	b570      	push	{r4, r5, r6, lr}
    3476:	b084      	sub	sp, #16
    3478:	ac08      	add	r4, sp, #32
    347a:	7825      	ldrb	r5, [r4, #0]
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
    347c:	ac01      	add	r4, sp, #4
    347e:	7020      	strb	r0, [r4, #0]
	switch (cmd) {
    3480:	303f      	adds	r0, #63	; 0x3f
    3482:	b2c4      	uxtb	r4, r0
    3484:	2c0e      	cmp	r4, #14
    3486:	d900      	bls.n	348a <spi_cmd+0x16>
    3488:	e085      	b.n	3596 <spi_cmd+0x122>
    348a:	00a0      	lsls	r0, r4, #2
    348c:	4c4a      	ldr	r4, [pc, #296]	; (35b8 <spi_cmd+0x144>)
    348e:	5820      	ldr	r0, [r4, r0]
    3490:	4687      	mov	pc, r0
	case CMD_SINGLE_READ:				/* single word (4 bytes) read */
		bc[1] = (uint8)(adr >> 16);
    3492:	ab01      	add	r3, sp, #4
    3494:	0c0a      	lsrs	r2, r1, #16
    3496:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    3498:	0a0a      	lsrs	r2, r1, #8
    349a:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
    349c:	70d9      	strb	r1, [r3, #3]
		len = 5;
    349e:	2105      	movs	r1, #5
		break;
    34a0:	e081      	b.n	35a6 <spi_cmd+0x132>
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    34a2:	0a0b      	lsrs	r3, r1, #8
    34a4:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    34a6:	2d00      	cmp	r5, #0
    34a8:	d102      	bne.n	34b0 <spi_cmd+0x3c>
		bc[2] = (uint8)(adr >> 8);
		bc[3] = (uint8)adr;
		len = 5;
		break;
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    34aa:	aa01      	add	r2, sp, #4
    34ac:	7053      	strb	r3, [r2, #1]
    34ae:	e004      	b.n	34ba <spi_cmd+0x46>
		if(clockless)  bc[1] |= (1 << 7);
    34b0:	2280      	movs	r2, #128	; 0x80
    34b2:	4252      	negs	r2, r2
    34b4:	4313      	orrs	r3, r2
    34b6:	aa01      	add	r2, sp, #4
    34b8:	7053      	strb	r3, [r2, #1]
		bc[2] = (uint8)adr;
    34ba:	ab01      	add	r3, sp, #4
    34bc:	7099      	strb	r1, [r3, #2]
		bc[3] = 0x00;
    34be:	2200      	movs	r2, #0
    34c0:	70da      	strb	r2, [r3, #3]
		len = 5;
    34c2:	2105      	movs	r1, #5
		break;
    34c4:	e06f      	b.n	35a6 <spi_cmd+0x132>
	case CMD_TERMINATE:					/* termination */
		bc[1] = 0x00;
    34c6:	ab01      	add	r3, sp, #4
    34c8:	2200      	movs	r2, #0
    34ca:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    34cc:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    34ce:	70da      	strb	r2, [r3, #3]
		len = 5;
    34d0:	2105      	movs	r1, #5
		break;
    34d2:	e068      	b.n	35a6 <spi_cmd+0x132>
	case CMD_REPEAT:						/* repeat */
		bc[1] = 0x00;
    34d4:	ab01      	add	r3, sp, #4
    34d6:	2200      	movs	r2, #0
    34d8:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    34da:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    34dc:	70da      	strb	r2, [r3, #3]
		len = 5;
    34de:	2105      	movs	r1, #5
		break;
    34e0:	e061      	b.n	35a6 <spi_cmd+0x132>
	case CMD_RESET:							/* reset */
		bc[1] = 0xff;
    34e2:	ab01      	add	r3, sp, #4
    34e4:	22ff      	movs	r2, #255	; 0xff
    34e6:	705a      	strb	r2, [r3, #1]
		bc[2] = 0xff;
    34e8:	709a      	strb	r2, [r3, #2]
		bc[3] = 0xff;
    34ea:	70da      	strb	r2, [r3, #3]
		len = 5;
    34ec:	2105      	movs	r1, #5
		break;
    34ee:	e05a      	b.n	35a6 <spi_cmd+0x132>
	case CMD_DMA_WRITE:					/* dma write */
	case CMD_DMA_READ:					/* dma read */
		bc[1] = (uint8)(adr >> 16);
    34f0:	aa01      	add	r2, sp, #4
    34f2:	0c08      	lsrs	r0, r1, #16
    34f4:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    34f6:	0a08      	lsrs	r0, r1, #8
    34f8:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    34fa:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 8);
    34fc:	0a19      	lsrs	r1, r3, #8
    34fe:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz);
    3500:	7153      	strb	r3, [r2, #5]
		len = 7;
    3502:	2107      	movs	r1, #7
		break;
    3504:	e04f      	b.n	35a6 <spi_cmd+0x132>
	case CMD_DMA_EXT_WRITE:		/* dma extended write */
	case CMD_DMA_EXT_READ:			/* dma extended read */
		bc[1] = (uint8)(adr >> 16);
    3506:	aa01      	add	r2, sp, #4
    3508:	0c08      	lsrs	r0, r1, #16
    350a:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    350c:	0a08      	lsrs	r0, r1, #8
    350e:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    3510:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 16);
    3512:	0c19      	lsrs	r1, r3, #16
    3514:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz >> 8);
    3516:	0a19      	lsrs	r1, r3, #8
    3518:	7151      	strb	r1, [r2, #5]
		bc[6] = (uint8)(sz);
    351a:	7193      	strb	r3, [r2, #6]
		len = 8;
    351c:	2108      	movs	r1, #8
		break;
    351e:	e042      	b.n	35a6 <spi_cmd+0x132>
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    3520:	0a0b      	lsrs	r3, r1, #8
    3522:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    3524:	2d00      	cmp	r5, #0
    3526:	d102      	bne.n	352e <spi_cmd+0xba>
		bc[5] = (uint8)(sz >> 8);
		bc[6] = (uint8)(sz);
		len = 8;
		break;
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    3528:	a801      	add	r0, sp, #4
    352a:	7043      	strb	r3, [r0, #1]
    352c:	e004      	b.n	3538 <spi_cmd+0xc4>
		if(clockless)  bc[1] |= (1 << 7);
    352e:	2080      	movs	r0, #128	; 0x80
    3530:	4240      	negs	r0, r0
    3532:	4303      	orrs	r3, r0
    3534:	a801      	add	r0, sp, #4
    3536:	7043      	strb	r3, [r0, #1]
		bc[2] = (uint8)(adr);
    3538:	ab01      	add	r3, sp, #4
    353a:	7099      	strb	r1, [r3, #2]
		bc[3] = (uint8)(u32data >> 24);
    353c:	0e11      	lsrs	r1, r2, #24
    353e:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 16);
    3540:	0c11      	lsrs	r1, r2, #16
    3542:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 8);
    3544:	0a11      	lsrs	r1, r2, #8
    3546:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data);
    3548:	719a      	strb	r2, [r3, #6]
		len = 8;
    354a:	2108      	movs	r1, #8
		break;
    354c:	e02b      	b.n	35a6 <spi_cmd+0x132>
	case CMD_SINGLE_WRITE:			/* single word write */
		bc[1] = (uint8)(adr >> 16);
    354e:	ab01      	add	r3, sp, #4
    3550:	0c08      	lsrs	r0, r1, #16
    3552:	7058      	strb	r0, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    3554:	0a08      	lsrs	r0, r1, #8
    3556:	7098      	strb	r0, [r3, #2]
		bc[3] = (uint8)(adr);
    3558:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 24);
    355a:	0e11      	lsrs	r1, r2, #24
    355c:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 16);
    355e:	0c11      	lsrs	r1, r2, #16
    3560:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data >> 8);
    3562:	0a11      	lsrs	r1, r2, #8
    3564:	7199      	strb	r1, [r3, #6]
		bc[7] = (uint8)(u32data);
    3566:	71da      	strb	r2, [r3, #7]
		len = 9;
    3568:	2109      	movs	r1, #9
		break;
    356a:	e01c      	b.n	35a6 <spi_cmd+0x132>
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    356c:	7810      	ldrb	r0, [r2, #0]
    356e:	005b      	lsls	r3, r3, #1
    3570:	4043      	eors	r3, r0
    3572:	5ce3      	ldrb	r3, [r4, r3]
    3574:	3201      	adds	r2, #1
}

static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
{
	while (len--)
    3576:	42aa      	cmp	r2, r5
    3578:	d1f8      	bne.n	356c <spi_cmd+0xf8>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    357a:	005b      	lsls	r3, r3, #1
    357c:	aa01      	add	r2, sp, #4
    357e:	5593      	strb	r3, [r2, r6]
    3580:	e001      	b.n	3586 <spi_cmd+0x112>
		else
			len-=1;
    3582:	3901      	subs	r1, #1
    3584:	b2c9      	uxtb	r1, r1

		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
    3586:	b289      	uxth	r1, r1
    3588:	a801      	add	r0, sp, #4
    358a:	4b0c      	ldr	r3, [pc, #48]	; (35bc <spi_cmd+0x148>)
    358c:	4798      	blx	r3
    358e:	4243      	negs	r3, r0
    3590:	4158      	adcs	r0, r3
    3592:	b2c0      	uxtb	r0, r0
    3594:	e00c      	b.n	35b0 <spi_cmd+0x13c>
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
	switch (cmd) {
    3596:	2000      	movs	r0, #0
    3598:	e00a      	b.n	35b0 <spi_cmd+0x13c>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    359a:	1e4e      	subs	r6, r1, #1
    359c:	aa01      	add	r2, sp, #4
    359e:	1995      	adds	r5, r2, r6
    35a0:	237f      	movs	r3, #127	; 0x7f
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    35a2:	4c07      	ldr	r4, [pc, #28]	; (35c0 <spi_cmd+0x14c>)
    35a4:	e7e2      	b.n	356c <spi_cmd+0xf8>
		result = N_FAIL;
		break;
	}

	if (result) {
		if (!gu8Crc_off)
    35a6:	4b07      	ldr	r3, [pc, #28]	; (35c4 <spi_cmd+0x150>)
    35a8:	781b      	ldrb	r3, [r3, #0]
    35aa:	2b00      	cmp	r3, #0
    35ac:	d0f5      	beq.n	359a <spi_cmd+0x126>
    35ae:	e7e8      	b.n	3582 <spi_cmd+0x10e>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
			result = N_FAIL;
		}
	}

	return result;
    35b0:	b240      	sxtb	r0, r0
}
    35b2:	b004      	add	sp, #16
    35b4:	bd70      	pop	{r4, r5, r6, pc}
    35b6:	46c0      	nop			; (mov r8, r8)
    35b8:	0000ea58 	.word	0x0000ea58
    35bc:	00003455 	.word	0x00003455
    35c0:	0000ea94 	.word	0x0000ea94
    35c4:	20000158 	.word	0x20000158

000035c8 <spi_write_reg>:
	Spi interfaces

********************************************/

static sint8 spi_write_reg(uint32 addr, uint32 u32data)
{
    35c8:	b530      	push	{r4, r5, lr}
    35ca:	b083      	sub	sp, #12
    35cc:	1c03      	adds	r3, r0, #0
    35ce:	1c0a      	adds	r2, r1, #0
	sint8 result = N_OK;
	uint8 cmd = CMD_SINGLE_WRITE;
	uint8 clockless = 0;
	if (addr <= 0x30)
    35d0:	2830      	cmp	r0, #48	; 0x30
    35d2:	d902      	bls.n	35da <spi_write_reg+0x12>
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
    35d4:	2100      	movs	r1, #0
		cmd = CMD_INTERNAL_WRITE;
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_WRITE;
    35d6:	24c9      	movs	r4, #201	; 0xc9
    35d8:	e001      	b.n	35de <spi_write_reg+0x16>
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_WRITE;
		clockless = 1;
    35da:	2101      	movs	r1, #1
	if (addr <= 0x30)
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_WRITE;
    35dc:	24c3      	movs	r4, #195	; 0xc3
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    35de:	9100      	str	r1, [sp, #0]
    35e0:	1c20      	adds	r0, r4, #0
    35e2:	1c19      	adds	r1, r3, #0
    35e4:	2304      	movs	r3, #4
    35e6:	4d0b      	ldr	r5, [pc, #44]	; (3614 <spi_write_reg+0x4c>)
    35e8:	47a8      	blx	r5
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
    35ea:	2300      	movs	r3, #0
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
	if (result != N_OK) {
    35ec:	2801      	cmp	r0, #1
    35ee:	d10d      	bne.n	360c <spi_write_reg+0x44>
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
    35f0:	1c20      	adds	r0, r4, #0
    35f2:	4b09      	ldr	r3, [pc, #36]	; (3618 <spi_write_reg+0x50>)
    35f4:	4798      	blx	r3
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
		return N_FAIL;
	}

	return N_OK;
    35f6:	2301      	movs	r3, #1
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
	if (result != N_OK) {
    35f8:	2801      	cmp	r0, #1
    35fa:	d007      	beq.n	360c <spi_write_reg+0x44>
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    35fc:	2300      	movs	r3, #0
    35fe:	9300      	str	r3, [sp, #0]
    3600:	20cf      	movs	r0, #207	; 0xcf
    3602:	2100      	movs	r1, #0
    3604:	2200      	movs	r2, #0
    3606:	4c03      	ldr	r4, [pc, #12]	; (3614 <spi_write_reg+0x4c>)
    3608:	47a0      	blx	r4
		return N_FAIL;
    360a:	2300      	movs	r3, #0
    360c:	b258      	sxtb	r0, r3
	}

	return result;

#endif
}
    360e:	b003      	add	sp, #12
    3610:	bd30      	pop	{r4, r5, pc}
    3612:	46c0      	nop			; (mov r8, r8)
    3614:	00003475 	.word	0x00003475
    3618:	00003311 	.word	0x00003311

0000361c <spi_read_reg>:

	return N_OK;
}

static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
{
    361c:	b5f0      	push	{r4, r5, r6, r7, lr}
    361e:	b085      	sub	sp, #20
    3620:	1c03      	adds	r3, r0, #0
    3622:	1c0d      	adds	r5, r1, #0
	sint8 result = N_OK;
	uint8 cmd = CMD_SINGLE_READ;
	uint8 tmp[4];
	uint8 clockless = 0;

	if (addr <= 0xff)
    3624:	28ff      	cmp	r0, #255	; 0xff
    3626:	d902      	bls.n	362e <spi_read_reg+0x12>
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_READ;
		clockless = 0;
    3628:	2600      	movs	r6, #0
		cmd = CMD_INTERNAL_READ;
		clockless = 1;
	}
	else
	{
		cmd = CMD_SINGLE_READ;
    362a:	24ca      	movs	r4, #202	; 0xca
    362c:	e001      	b.n	3632 <spi_read_reg+0x16>
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_READ;
		clockless = 1;
    362e:	2601      	movs	r6, #1
	if (addr <= 0xff)
	{
		/**
		NMC1000 clockless registers.
		**/
		cmd = CMD_INTERNAL_READ;
    3630:	24c4      	movs	r4, #196	; 0xc4
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    3632:	9600      	str	r6, [sp, #0]
    3634:	1c20      	adds	r0, r4, #0
    3636:	1c19      	adds	r1, r3, #0
    3638:	2200      	movs	r2, #0
    363a:	2304      	movs	r3, #4
    363c:	4f19      	ldr	r7, [pc, #100]	; (36a4 <spi_read_reg+0x88>)
    363e:	47b8      	blx	r7
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
    3640:	2300      	movs	r3, #0
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
	if (result != N_OK) {
    3642:	2801      	cmp	r0, #1
    3644:	d12a      	bne.n	369c <spi_read_reg+0x80>
		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
    3646:	1c20      	adds	r0, r4, #0
    3648:	4b17      	ldr	r3, [pc, #92]	; (36a8 <spi_read_reg+0x8c>)
    364a:	4798      	blx	r3
	if (result != N_OK) {
    364c:	2801      	cmp	r0, #1
    364e:	d008      	beq.n	3662 <spi_read_reg+0x46>
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    3650:	2300      	movs	r3, #0
    3652:	9300      	str	r3, [sp, #0]
    3654:	20cf      	movs	r0, #207	; 0xcf
    3656:	2100      	movs	r1, #0
    3658:	2200      	movs	r2, #0
    365a:	4c12      	ldr	r4, [pc, #72]	; (36a4 <spi_read_reg+0x88>)
    365c:	47a0      	blx	r4
		return N_FAIL;
    365e:	2300      	movs	r3, #0
    3660:	e01c      	b.n	369c <spi_read_reg+0x80>
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    3662:	a803      	add	r0, sp, #12
    3664:	2104      	movs	r1, #4
    3666:	1c32      	adds	r2, r6, #0
    3668:	4b10      	ldr	r3, [pc, #64]	; (36ac <spi_read_reg+0x90>)
    366a:	4798      	blx	r3
	if (result != N_OK) {
    366c:	2801      	cmp	r0, #1
    366e:	d008      	beq.n	3682 <spi_read_reg+0x66>
		M2M_ERR("[nmi spi]: Failed data read...\n");
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    3670:	2300      	movs	r3, #0
    3672:	9300      	str	r3, [sp, #0]
    3674:	20cf      	movs	r0, #207	; 0xcf
    3676:	2100      	movs	r1, #0
    3678:	2200      	movs	r2, #0
    367a:	4c0a      	ldr	r4, [pc, #40]	; (36a4 <spi_read_reg+0x88>)
    367c:	47a0      	blx	r4
		return N_FAIL;
    367e:	2300      	movs	r3, #0
    3680:	e00c      	b.n	369c <spi_read_reg+0x80>
	}

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
    3682:	aa03      	add	r2, sp, #12
    3684:	7853      	ldrb	r3, [r2, #1]
    3686:	0219      	lsls	r1, r3, #8
		((uint32)tmp[2] << 16) |
    3688:	7893      	ldrb	r3, [r2, #2]
    368a:	041b      	lsls	r3, r3, #16
    368c:	430b      	orrs	r3, r1
		return N_FAIL;
	}

#endif

	*u32data = tmp[0] |
    368e:	7811      	ldrb	r1, [r2, #0]
		((uint32)tmp[1] << 8) |
    3690:	430b      	orrs	r3, r1
		((uint32)tmp[2] << 16) |
		((uint32)tmp[3] << 24);
    3692:	78d2      	ldrb	r2, [r2, #3]
    3694:	0612      	lsls	r2, r2, #24

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
		((uint32)tmp[2] << 16) |
    3696:	4313      	orrs	r3, r2
		return N_FAIL;
	}

#endif

	*u32data = tmp[0] |
    3698:	602b      	str	r3, [r5, #0]
		((uint32)tmp[1] << 8) |
		((uint32)tmp[2] << 16) |
		((uint32)tmp[3] << 24);

	return N_OK;
    369a:	2301      	movs	r3, #1
    369c:	b258      	sxtb	r0, r3
}
    369e:	b005      	add	sp, #20
    36a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    36a2:	46c0      	nop			; (mov r8, r8)
    36a4:	00003475 	.word	0x00003475
    36a8:	00003311 	.word	0x00003311
    36ac:	00003391 	.word	0x00003391

000036b0 <nm_spi_deinit>:
*	@date	27 Feb 2015
*	@version	1.0
*/
sint8 nm_spi_deinit(void)
{
	gu8Crc_off = 0;
    36b0:	2200      	movs	r2, #0
    36b2:	4b02      	ldr	r3, [pc, #8]	; (36bc <nm_spi_deinit+0xc>)
    36b4:	701a      	strb	r2, [r3, #0]
	return M2M_SUCCESS;
}
    36b6:	2000      	movs	r0, #0
    36b8:	4770      	bx	lr
    36ba:	46c0      	nop			; (mov r8, r8)
    36bc:	20000158 	.word	0x20000158

000036c0 <nm_spi_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_spi_read_reg(uint32 u32Addr)
{
    36c0:	b500      	push	{lr}
    36c2:	b083      	sub	sp, #12
	uint32 u32Val;

	spi_read_reg(u32Addr, &u32Val);
    36c4:	a901      	add	r1, sp, #4
    36c6:	4b02      	ldr	r3, [pc, #8]	; (36d0 <nm_spi_read_reg+0x10>)
    36c8:	4798      	blx	r3

	return u32Val;
}
    36ca:	9801      	ldr	r0, [sp, #4]
    36cc:	b003      	add	sp, #12
    36ce:	bd00      	pop	{pc}
    36d0:	0000361d 	.word	0x0000361d

000036d4 <nm_spi_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    36d4:	b508      	push	{r3, lr}
	sint8 s8Ret;

	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
    36d6:	4b04      	ldr	r3, [pc, #16]	; (36e8 <nm_spi_read_reg_with_ret+0x14>)
    36d8:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    36da:	2300      	movs	r3, #0
    36dc:	2801      	cmp	r0, #1
    36de:	d000      	beq.n	36e2 <nm_spi_read_reg_with_ret+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    36e0:	33fa      	adds	r3, #250	; 0xfa

	return s8Ret;
    36e2:	b258      	sxtb	r0, r3
}
    36e4:	bd08      	pop	{r3, pc}
    36e6:	46c0      	nop			; (mov r8, r8)
    36e8:	0000361d 	.word	0x0000361d

000036ec <nm_spi_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
{
    36ec:	b508      	push	{r3, lr}
	sint8 s8Ret;

	s8Ret = spi_write_reg(u32Addr, u32Val);
    36ee:	4b04      	ldr	r3, [pc, #16]	; (3700 <nm_spi_write_reg+0x14>)
    36f0:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    36f2:	2300      	movs	r3, #0
    36f4:	2801      	cmp	r0, #1
    36f6:	d000      	beq.n	36fa <nm_spi_write_reg+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    36f8:	33fa      	adds	r3, #250	; 0xfa

	return s8Ret;
    36fa:	b258      	sxtb	r0, r3
}
    36fc:	bd08      	pop	{r3, pc}
    36fe:	46c0      	nop			; (mov r8, r8)
    3700:	000035c9 	.word	0x000035c9

00003704 <nm_spi_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_init(void)
{
    3704:	b510      	push	{r4, lr}
    3706:	b082      	sub	sp, #8
	uint32 chipid;
	uint32 reg =0;
    3708:	2300      	movs	r3, #0
    370a:	9300      	str	r3, [sp, #0]

	/**
		configure protocol
	**/
	gu8Crc_off = 0;
    370c:	4a1d      	ldr	r2, [pc, #116]	; (3784 <nm_spi_init+0x80>)
    370e:	7013      	strb	r3, [r2, #0]

	// TODO: We can remove the CRC trials if there is a definite way to reset
	// the SPI to it's initial value.
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
    3710:	481d      	ldr	r0, [pc, #116]	; (3788 <nm_spi_init+0x84>)
    3712:	4669      	mov	r1, sp
    3714:	4b1d      	ldr	r3, [pc, #116]	; (378c <nm_spi_init+0x88>)
    3716:	4798      	blx	r3
    3718:	2800      	cmp	r0, #0
    371a:	d108      	bne.n	372e <nm_spi_init+0x2a>
		/* Read failed. Try with CRC off. This might happen when module
		is removed but chip isn't reset*/
		gu8Crc_off = 1;
    371c:	2201      	movs	r2, #1
    371e:	4b19      	ldr	r3, [pc, #100]	; (3784 <nm_spi_init+0x80>)
    3720:	701a      	strb	r2, [r3, #0]
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
    3722:	4819      	ldr	r0, [pc, #100]	; (3788 <nm_spi_init+0x84>)
    3724:	4669      	mov	r1, sp
    3726:	4b19      	ldr	r3, [pc, #100]	; (378c <nm_spi_init+0x88>)
    3728:	4798      	blx	r3
    372a:	2800      	cmp	r0, #0
    372c:	d027      	beq.n	377e <nm_spi_init+0x7a>
			// Reaad failed with both CRC on and off, something went bad
			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
			return 0;
		}
	}
	if(gu8Crc_off == 0)
    372e:	4b15      	ldr	r3, [pc, #84]	; (3784 <nm_spi_init+0x80>)
    3730:	781b      	ldrb	r3, [r3, #0]
    3732:	2b00      	cmp	r3, #0
    3734:	d10d      	bne.n	3752 <nm_spi_init+0x4e>
	{
		reg &= ~0xc;	/* disable crc checking */
		reg &= ~0x70;
    3736:	337c      	adds	r3, #124	; 0x7c
    3738:	9900      	ldr	r1, [sp, #0]
    373a:	4399      	bics	r1, r3
		reg |= (0x5 << 4);
    373c:	3b2c      	subs	r3, #44	; 0x2c
    373e:	4319      	orrs	r1, r3
    3740:	9100      	str	r1, [sp, #0]
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
    3742:	4811      	ldr	r0, [pc, #68]	; (3788 <nm_spi_init+0x84>)
    3744:	4b12      	ldr	r3, [pc, #72]	; (3790 <nm_spi_init+0x8c>)
    3746:	4798      	blx	r3
    3748:	2800      	cmp	r0, #0
    374a:	d018      	beq.n	377e <nm_spi_init+0x7a>
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
			return 0;
		}
		gu8Crc_off = 1;
    374c:	2201      	movs	r2, #1
    374e:	4b0d      	ldr	r3, [pc, #52]	; (3784 <nm_spi_init+0x80>)
    3750:	701a      	strb	r2, [r3, #0]
	}

	/**
		make sure can read back chip id correctly
	**/
	if (!spi_read_reg(0x1000, &chipid)) {
    3752:	2080      	movs	r0, #128	; 0x80
    3754:	0140      	lsls	r0, r0, #5
    3756:	a901      	add	r1, sp, #4
    3758:	4b0c      	ldr	r3, [pc, #48]	; (378c <nm_spi_init+0x88>)
    375a:	4798      	blx	r3
    375c:	2800      	cmp	r0, #0
    375e:	d00d      	beq.n	377c <nm_spi_init+0x78>
static void spi_init_pkt_sz(void)
{
	uint32 val32;

	/* Make sure SPI max. packet size fits the defined DATA_PKT_SZ.  */
	val32 = nm_spi_read_reg(SPI_BASE+0x24);
    3760:	4c09      	ldr	r4, [pc, #36]	; (3788 <nm_spi_init+0x84>)
    3762:	1c20      	adds	r0, r4, #0
    3764:	4b0b      	ldr	r3, [pc, #44]	; (3794 <nm_spi_init+0x90>)
    3766:	4798      	blx	r3
	val32 &= ~(0x7 << 4);
    3768:	2370      	movs	r3, #112	; 0x70
    376a:	1c01      	adds	r1, r0, #0
    376c:	4399      	bics	r1, r3
	case 256:  val32 |= (0 << 4); break;
	case 512:  val32 |= (1 << 4); break;
	case 1024: val32 |= (2 << 4); break;
	case 2048: val32 |= (3 << 4); break;
	case 4096: val32 |= (4 << 4); break;
	case 8192: val32 |= (5 << 4); break;
    376e:	3b20      	subs	r3, #32
    3770:	4319      	orrs	r1, r3

	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
    3772:	1c20      	adds	r0, r4, #0
    3774:	4b08      	ldr	r3, [pc, #32]	; (3798 <nm_spi_init+0x94>)
    3776:	4798      	blx	r3

	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
	spi_init_pkt_sz();


	return M2M_SUCCESS;
    3778:	2000      	movs	r0, #0
    377a:	e000      	b.n	377e <nm_spi_init+0x7a>
	/**
		make sure can read back chip id correctly
	**/
	if (!spi_read_reg(0x1000, &chipid)) {
		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
		return M2M_ERR_BUS_FAIL;
    377c:	20fa      	movs	r0, #250	; 0xfa
    377e:	b240      	sxtb	r0, r0
	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
	spi_init_pkt_sz();


	return M2M_SUCCESS;
}
    3780:	b002      	add	sp, #8
    3782:	bd10      	pop	{r4, pc}
    3784:	20000158 	.word	0x20000158
    3788:	0000e824 	.word	0x0000e824
    378c:	0000361d 	.word	0x0000361d
    3790:	000035c9 	.word	0x000035c9
    3794:	000036c1 	.word	0x000036c1
    3798:	000036ed 	.word	0x000036ed

0000379c <nm_spi_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    379c:	b570      	push	{r4, r5, r6, lr}
    379e:	b082      	sub	sp, #8
    37a0:	1c03      	adds	r3, r0, #0
    37a2:	1c0e      	adds	r6, r1, #0
    37a4:	1c14      	adds	r4, r2, #0

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, size,0);
    37a6:	2200      	movs	r2, #0
    37a8:	9200      	str	r2, [sp, #0]
    37aa:	20c8      	movs	r0, #200	; 0xc8
    37ac:	1c19      	adds	r1, r3, #0
    37ae:	1c23      	adds	r3, r4, #0
    37b0:	4d11      	ldr	r5, [pc, #68]	; (37f8 <nm_spi_read_block+0x5c>)
    37b2:	47a8      	blx	r5
	if (result != N_OK) {
    37b4:	2801      	cmp	r0, #1
    37b6:	d11a      	bne.n	37ee <nm_spi_read_block+0x52>
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
    37b8:	30c7      	adds	r0, #199	; 0xc7
    37ba:	4b10      	ldr	r3, [pc, #64]	; (37fc <nm_spi_read_block+0x60>)
    37bc:	4798      	blx	r3
	if (result != N_OK) {
    37be:	2801      	cmp	r0, #1
    37c0:	d007      	beq.n	37d2 <nm_spi_read_block+0x36>
		M2M_ERR("[nmi spi]: Failed cmd response, read block (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    37c2:	2300      	movs	r3, #0
    37c4:	9300      	str	r3, [sp, #0]
    37c6:	20cf      	movs	r0, #207	; 0xcf
    37c8:	2100      	movs	r1, #0
    37ca:	2200      	movs	r2, #0
    37cc:	4c0a      	ldr	r4, [pc, #40]	; (37f8 <nm_spi_read_block+0x5c>)
    37ce:	47a0      	blx	r4
    37d0:	e00d      	b.n	37ee <nm_spi_read_block+0x52>
	}

	/**
		Data
	**/
	result = spi_data_read(buf, size,0);
    37d2:	1c30      	adds	r0, r6, #0
    37d4:	1c21      	adds	r1, r4, #0
    37d6:	2200      	movs	r2, #0
    37d8:	4b09      	ldr	r3, [pc, #36]	; (3800 <nm_spi_read_block+0x64>)
    37da:	4798      	blx	r3
{
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    37dc:	2300      	movs	r3, #0

	/**
		Data
	**/
	result = spi_data_read(buf, size,0);
	if (result != N_OK) {
    37de:	2801      	cmp	r0, #1
    37e0:	d006      	beq.n	37f0 <nm_spi_read_block+0x54>
		M2M_ERR("[nmi spi]: Failed block data read...\n");
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    37e2:	9300      	str	r3, [sp, #0]
    37e4:	20cf      	movs	r0, #207	; 0xcf
    37e6:	2100      	movs	r1, #0
    37e8:	2200      	movs	r2, #0
    37ea:	4c03      	ldr	r4, [pc, #12]	; (37f8 <nm_spi_read_block+0x5c>)
    37ec:	47a0      	blx	r4
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
    37ee:	23fa      	movs	r3, #250	; 0xfa

	return s8Ret;
    37f0:	b258      	sxtb	r0, r3
}
    37f2:	b002      	add	sp, #8
    37f4:	bd70      	pop	{r4, r5, r6, pc}
    37f6:	46c0      	nop			; (mov r8, r8)
    37f8:	00003475 	.word	0x00003475
    37fc:	00003311 	.word	0x00003311
    3800:	00003391 	.word	0x00003391

00003804 <nm_spi_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    3804:	b5f0      	push	{r4, r5, r6, r7, lr}
    3806:	464f      	mov	r7, r9
    3808:	4646      	mov	r6, r8
    380a:	b4c0      	push	{r6, r7}
    380c:	b087      	sub	sp, #28
    380e:	1c03      	adds	r3, r0, #0
    3810:	4689      	mov	r9, r1
    3812:	1c15      	adds	r5, r2, #0

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, size,0);
    3814:	2200      	movs	r2, #0
    3816:	9200      	str	r2, [sp, #0]
    3818:	20c7      	movs	r0, #199	; 0xc7
    381a:	1c19      	adds	r1, r3, #0
    381c:	1c2b      	adds	r3, r5, #0
    381e:	4c31      	ldr	r4, [pc, #196]	; (38e4 <nm_spi_write_block+0xe0>)
    3820:	47a0      	blx	r4
	if (result != N_OK) {
    3822:	2801      	cmp	r0, #1
    3824:	d157      	bne.n	38d6 <nm_spi_write_block+0xd2>
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
		return N_FAIL;
	}

	result = spi_cmd_rsp(cmd);
    3826:	30c6      	adds	r0, #198	; 0xc6
    3828:	4b2f      	ldr	r3, [pc, #188]	; (38e8 <nm_spi_write_block+0xe4>)
    382a:	4798      	blx	r3
	if (result != N_OK) {
    382c:	2801      	cmp	r0, #1
    382e:	d007      	beq.n	3840 <nm_spi_write_block+0x3c>
		M2M_ERR("[nmi spi ]: Failed cmd response, write block (%08x)...\n", (unsigned int)addr);
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    3830:	2300      	movs	r3, #0
    3832:	9300      	str	r3, [sp, #0]
    3834:	20cf      	movs	r0, #207	; 0xcf
    3836:	2100      	movs	r1, #0
    3838:	2200      	movs	r2, #0
    383a:	4c2a      	ldr	r4, [pc, #168]	; (38e4 <nm_spi_write_block+0xe0>)
    383c:	47a0      	blx	r4
    383e:	e04a      	b.n	38d6 <nm_spi_write_block+0xd2>
static sint8 spi_data_write(uint8 *b, uint16 sz)
{
	sint16 ix;
	uint16 nbytes;
	sint8 result = 1;
	uint8 cmd, order, crc[2] = {0};
    3840:	2200      	movs	r2, #0
    3842:	ab05      	add	r3, sp, #20
    3844:	801a      	strh	r2, [r3, #0]
	//uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    3846:	2700      	movs	r7, #0
    3848:	2380      	movs	r3, #128	; 0x80
    384a:	019b      	lsls	r3, r3, #6
    384c:	4698      	mov	r8, r3
    384e:	466a      	mov	r2, sp
    3850:	81d3      	strh	r3, [r2, #14]
				order = 0x3;
			else
				order = 0x2;
		}
		cmd |= order;
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
    3852:	4e26      	ldr	r6, [pc, #152]	; (38ec <nm_spi_write_block+0xe8>)
    3854:	1c2c      	adds	r4, r5, #0
    3856:	4545      	cmp	r5, r8
    3858:	d901      	bls.n	385e <nm_spi_write_block+0x5a>
    385a:	466b      	mov	r3, sp
    385c:	89dc      	ldrh	r4, [r3, #14]
    385e:	b2a4      	uxth	r4, r4

		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
    3860:	2f00      	cmp	r7, #0
    3862:	d104      	bne.n	386e <nm_spi_write_block+0x6a>
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
    3864:	2303      	movs	r3, #3
		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
			if (sz <= DATA_PKT_SZ)
    3866:	4545      	cmp	r5, r8
    3868:	d906      	bls.n	3878 <nm_spi_write_block+0x74>
				order = 0x3;
			else
				order = 0x1;
    386a:	3b02      	subs	r3, #2
    386c:	e004      	b.n	3878 <nm_spi_write_block+0x74>
		} else {
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
			else
				order = 0x2;
    386e:	2300      	movs	r3, #0
    3870:	4642      	mov	r2, r8
    3872:	42aa      	cmp	r2, r5
    3874:	415b      	adcs	r3, r3
    3876:	3302      	adds	r3, #2
		}
		cmd |= order;
    3878:	200b      	movs	r0, #11
    387a:	aa02      	add	r2, sp, #8
    387c:	4694      	mov	ip, r2
    387e:	4460      	add	r0, ip
    3880:	2210      	movs	r2, #16
    3882:	4252      	negs	r2, r2
    3884:	4313      	orrs	r3, r2
    3886:	7003      	strb	r3, [r0, #0]
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
    3888:	2101      	movs	r1, #1
    388a:	47b0      	blx	r6
    388c:	2800      	cmp	r0, #0
    388e:	d117      	bne.n	38c0 <nm_spi_write_block+0xbc>
		}

		/**
			Write data
		**/
		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
    3890:	b238      	sxth	r0, r7
    3892:	4448      	add	r0, r9
    3894:	1c21      	adds	r1, r4, #0
    3896:	4b15      	ldr	r3, [pc, #84]	; (38ec <nm_spi_write_block+0xe8>)
    3898:	4798      	blx	r3
    389a:	2800      	cmp	r0, #0
    389c:	d110      	bne.n	38c0 <nm_spi_write_block+0xbc>
		}

		/**
			Write Crc
		**/
		if (!gu8Crc_off) {
    389e:	4b14      	ldr	r3, [pc, #80]	; (38f0 <nm_spi_write_block+0xec>)
    38a0:	781b      	ldrb	r3, [r3, #0]
    38a2:	2b00      	cmp	r3, #0
    38a4:	d105      	bne.n	38b2 <nm_spi_write_block+0xae>
			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
    38a6:	a805      	add	r0, sp, #20
    38a8:	2102      	movs	r1, #2
    38aa:	4b10      	ldr	r3, [pc, #64]	; (38ec <nm_spi_write_block+0xe8>)
    38ac:	4798      	blx	r3
    38ae:	2800      	cmp	r0, #0
    38b0:	d106      	bne.n	38c0 <nm_spi_write_block+0xbc>
				result = N_FAIL;
				break;
			}
		}

		ix += nbytes;
    38b2:	19e7      	adds	r7, r4, r7
    38b4:	b2bf      	uxth	r7, r7
		sz -= nbytes;
    38b6:	1b2d      	subs	r5, r5, r4
    38b8:	b2ad      	uxth	r5, r5
	} while (sz);
    38ba:	2d00      	cmp	r5, #0
    38bc:	d1ca      	bne.n	3854 <nm_spi_write_block+0x50>
    38be:	e008      	b.n	38d2 <nm_spi_write_block+0xce>
		Data
	**/
	result = spi_data_write(buf, size);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    38c0:	2300      	movs	r3, #0
    38c2:	9300      	str	r3, [sp, #0]
    38c4:	20cf      	movs	r0, #207	; 0xcf
    38c6:	2100      	movs	r1, #0
    38c8:	2200      	movs	r2, #0
    38ca:	4c06      	ldr	r4, [pc, #24]	; (38e4 <nm_spi_write_block+0xe0>)
    38cc:	47a0      	blx	r4
{
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    38ce:	2000      	movs	r0, #0
    38d0:	e002      	b.n	38d8 <nm_spi_write_block+0xd4>
    38d2:	2000      	movs	r0, #0
    38d4:	e000      	b.n	38d8 <nm_spi_write_block+0xd4>
	else s8Ret = M2M_ERR_BUS_FAIL;
    38d6:	20fa      	movs	r0, #250	; 0xfa

	return s8Ret;
    38d8:	b240      	sxtb	r0, r0
}
    38da:	b007      	add	sp, #28
    38dc:	bc0c      	pop	{r2, r3}
    38de:	4690      	mov	r8, r2
    38e0:	4699      	mov	r9, r3
    38e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    38e4:	00003475 	.word	0x00003475
    38e8:	00003311 	.word	0x00003311
    38ec:	00003455 	.word	0x00003455
    38f0:	20000158 	.word	0x20000158

000038f4 <Socket_ReadSocketData>:
Date
		17 July 2012
*********************************************************************/
NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
								  uint32 u32StartAddress,uint16 u16ReadCount)
{
    38f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    38f6:	465f      	mov	r7, fp
    38f8:	4656      	mov	r6, sl
    38fa:	464d      	mov	r5, r9
    38fc:	4644      	mov	r4, r8
    38fe:	b4f0      	push	{r4, r5, r6, r7}
    3900:	b083      	sub	sp, #12
    3902:	9000      	str	r0, [sp, #0]
    3904:	1c0e      	adds	r6, r1, #0
    3906:	9201      	str	r2, [sp, #4]
    3908:	4698      	mov	r8, r3
    390a:	ab0c      	add	r3, sp, #48	; 0x30
    390c:	881c      	ldrh	r4, [r3, #0]
	if((u16ReadCount > 0) && (gastrSockets[sock].pu8UserBuffer != NULL) && (gastrSockets[sock].u16UserBufferSize > 0) && (gastrSockets[sock].bIsUsed == 1))
    390e:	2c00      	cmp	r4, #0
    3910:	d045      	beq.n	399e <Socket_ReadSocketData+0xaa>
    3912:	0103      	lsls	r3, r0, #4
    3914:	4925      	ldr	r1, [pc, #148]	; (39ac <Socket_ReadSocketData+0xb8>)
    3916:	585b      	ldr	r3, [r3, r1]
    3918:	2b00      	cmp	r3, #0
    391a:	d040      	beq.n	399e <Socket_ReadSocketData+0xaa>
    391c:	0103      	lsls	r3, r0, #4
    391e:	18cb      	adds	r3, r1, r3
    3920:	889b      	ldrh	r3, [r3, #4]
    3922:	b29b      	uxth	r3, r3
    3924:	2b00      	cmp	r3, #0
    3926:	d03a      	beq.n	399e <Socket_ReadSocketData+0xaa>
    3928:	0103      	lsls	r3, r0, #4
    392a:	18cb      	adds	r3, r1, r3
    392c:	3308      	adds	r3, #8
    392e:	789b      	ldrb	r3, [r3, #2]
    3930:	2b01      	cmp	r3, #1
    3932:	d134      	bne.n	399e <Socket_ReadSocketData+0xaa>
		uint32	u32Address = u32StartAddress;
		uint16	u16Read;
		sint16	s16Diff;
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
    3934:	80f4      	strh	r4, [r6, #6]
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    3936:	0107      	lsls	r7, r0, #4
    3938:	468a      	mov	sl, r1
    393a:	44ba      	add	sl, r7
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
			}
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
    393c:	468b      	mov	fp, r1
    393e:	46c1      	mov	r9, r8
    3940:	46b8      	mov	r8, r7
		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    3942:	4653      	mov	r3, sl
    3944:	889b      	ldrh	r3, [r3, #4]
    3946:	1ae3      	subs	r3, r4, r3
			if(s16Diff > 0)
    3948:	b21b      	sxth	r3, r3
    394a:	2b00      	cmp	r3, #0
    394c:	dd05      	ble.n	395a <Socket_ReadSocketData+0x66>
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
    394e:	4b17      	ldr	r3, [pc, #92]	; (39ac <Socket_ReadSocketData+0xb8>)
    3950:	4443      	add	r3, r8
    3952:	889d      	ldrh	r5, [r3, #4]
    3954:	b2ad      	uxth	r5, r5
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
    3956:	2300      	movs	r3, #0
    3958:	e001      	b.n	395e <Socket_ReadSocketData+0x6a>

		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
    395a:	1c25      	adds	r5, r4, #0
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
    395c:	2301      	movs	r3, #1
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
			}
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
    395e:	465a      	mov	r2, fp
    3960:	4641      	mov	r1, r8
    3962:	5889      	ldr	r1, [r1, r2]
    3964:	4648      	mov	r0, r9
    3966:	1c2a      	adds	r2, r5, #0
    3968:	4f11      	ldr	r7, [pc, #68]	; (39b0 <Socket_ReadSocketData+0xbc>)
    396a:	47b8      	blx	r7
    396c:	2800      	cmp	r0, #0
    396e:	d116      	bne.n	399e <Socket_ReadSocketData+0xaa>
			{
				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
    3970:	4b0e      	ldr	r3, [pc, #56]	; (39ac <Socket_ReadSocketData+0xb8>)
    3972:	4642      	mov	r2, r8
    3974:	58d3      	ldr	r3, [r2, r3]
    3976:	6033      	str	r3, [r6, #0]
				pstrRecv->s16BufferSize		= u16Read;
    3978:	80b5      	strh	r5, [r6, #4]
				pstrRecv->u16RemainingSize	-= u16Read;
    397a:	88f3      	ldrh	r3, [r6, #6]
    397c:	1b5b      	subs	r3, r3, r5
    397e:	80f3      	strh	r3, [r6, #6]

				if (gpfAppSocketCb)
    3980:	4b0c      	ldr	r3, [pc, #48]	; (39b4 <Socket_ReadSocketData+0xc0>)
    3982:	681b      	ldr	r3, [r3, #0]
    3984:	2b00      	cmp	r3, #0
    3986:	d005      	beq.n	3994 <Socket_ReadSocketData+0xa0>
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);
    3988:	4b0a      	ldr	r3, [pc, #40]	; (39b4 <Socket_ReadSocketData+0xc0>)
    398a:	681b      	ldr	r3, [r3, #0]
    398c:	9800      	ldr	r0, [sp, #0]
    398e:	9901      	ldr	r1, [sp, #4]
    3990:	1c32      	adds	r2, r6, #0
    3992:	4798      	blx	r3

				u16ReadCount -= u16Read;
    3994:	1b64      	subs	r4, r4, r5
    3996:	b2a4      	uxth	r4, r4
				u32Address += u16Read;
    3998:	44a9      	add	r9, r5
			else
			{
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
				break;
			}
		}while(u16ReadCount != 0);
    399a:	2c00      	cmp	r4, #0
    399c:	d1d1      	bne.n	3942 <Socket_ReadSocketData+0x4e>
	}
}
    399e:	b003      	add	sp, #12
    39a0:	bc3c      	pop	{r2, r3, r4, r5}
    39a2:	4690      	mov	r8, r2
    39a4:	4699      	mov	r9, r3
    39a6:	46a2      	mov	sl, r4
    39a8:	46ab      	mov	fp, r5
    39aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    39ac:	2000161c 	.word	0x2000161c
    39b0:	000026f9 	.word	0x000026f9
    39b4:	200016cc 	.word	0x200016cc

000039b8 <m2m_ip_cb>:

Date
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{
    39b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    39ba:	4657      	mov	r7, sl
    39bc:	464e      	mov	r6, r9
    39be:	4645      	mov	r5, r8
    39c0:	b4e0      	push	{r5, r6, r7}
    39c2:	b098      	sub	sp, #96	; 0x60
    39c4:	1c0d      	adds	r5, r1, #0
    39c6:	1c14      	adds	r4, r2, #0
	if(u8OpCode == SOCKET_CMD_BIND)
    39c8:	2841      	cmp	r0, #65	; 0x41
    39ca:	d11a      	bne.n	3a02 <m2m_ip_cb+0x4a>
	{
		tstrBindReply		strBindReply;
		tstrSocketBindMsg	strBind;

		if(hif_receive(u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
    39cc:	1c10      	adds	r0, r2, #0
    39ce:	a907      	add	r1, sp, #28
    39d0:	2204      	movs	r2, #4
    39d2:	2300      	movs	r3, #0
    39d4:	4cab      	ldr	r4, [pc, #684]	; (3c84 <m2m_ip_cb+0x2cc>)
    39d6:	47a0      	blx	r4
    39d8:	2800      	cmp	r0, #0
    39da:	d000      	beq.n	39de <m2m_ip_cb+0x26>
    39dc:	e14b      	b.n	3c76 <m2m_ip_cb+0x2be>
		{
			strBind.status = strBindReply.s8Status;
    39de:	ab07      	add	r3, sp, #28
    39e0:	785a      	ldrb	r2, [r3, #1]
    39e2:	ab03      	add	r3, sp, #12
    39e4:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    39e6:	4ba8      	ldr	r3, [pc, #672]	; (3c88 <m2m_ip_cb+0x2d0>)
    39e8:	681b      	ldr	r3, [r3, #0]
    39ea:	2b00      	cmp	r3, #0
    39ec:	d100      	bne.n	39f0 <m2m_ip_cb+0x38>
    39ee:	e142      	b.n	3c76 <m2m_ip_cb+0x2be>
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
    39f0:	4ba5      	ldr	r3, [pc, #660]	; (3c88 <m2m_ip_cb+0x2d0>)
    39f2:	681b      	ldr	r3, [r3, #0]
    39f4:	aa07      	add	r2, sp, #28
    39f6:	2000      	movs	r0, #0
    39f8:	5610      	ldrsb	r0, [r2, r0]
    39fa:	2101      	movs	r1, #1
    39fc:	aa03      	add	r2, sp, #12
    39fe:	4798      	blx	r3
    3a00:	e139      	b.n	3c76 <m2m_ip_cb+0x2be>
		}
	}
	else if(u8OpCode == SOCKET_CMD_LISTEN)
    3a02:	2842      	cmp	r0, #66	; 0x42
    3a04:	d11a      	bne.n	3a3c <m2m_ip_cb+0x84>
	{
		tstrListenReply			strListenReply;
		tstrSocketListenMsg		strListen;
		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
    3a06:	1c10      	adds	r0, r2, #0
    3a08:	a907      	add	r1, sp, #28
    3a0a:	2204      	movs	r2, #4
    3a0c:	2300      	movs	r3, #0
    3a0e:	4c9d      	ldr	r4, [pc, #628]	; (3c84 <m2m_ip_cb+0x2cc>)
    3a10:	47a0      	blx	r4
    3a12:	2800      	cmp	r0, #0
    3a14:	d000      	beq.n	3a18 <m2m_ip_cb+0x60>
    3a16:	e12e      	b.n	3c76 <m2m_ip_cb+0x2be>
		{
			strListen.status = strListenReply.s8Status;
    3a18:	ab07      	add	r3, sp, #28
    3a1a:	785a      	ldrb	r2, [r3, #1]
    3a1c:	ab03      	add	r3, sp, #12
    3a1e:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    3a20:	4b99      	ldr	r3, [pc, #612]	; (3c88 <m2m_ip_cb+0x2d0>)
    3a22:	681b      	ldr	r3, [r3, #0]
    3a24:	2b00      	cmp	r3, #0
    3a26:	d100      	bne.n	3a2a <m2m_ip_cb+0x72>
    3a28:	e125      	b.n	3c76 <m2m_ip_cb+0x2be>
				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
    3a2a:	4b97      	ldr	r3, [pc, #604]	; (3c88 <m2m_ip_cb+0x2d0>)
    3a2c:	681b      	ldr	r3, [r3, #0]
    3a2e:	aa07      	add	r2, sp, #28
    3a30:	2000      	movs	r0, #0
    3a32:	5610      	ldrsb	r0, [r2, r0]
    3a34:	2102      	movs	r1, #2
    3a36:	aa03      	add	r2, sp, #12
    3a38:	4798      	blx	r3
    3a3a:	e11c      	b.n	3c76 <m2m_ip_cb+0x2be>
		}
	}
	else if(u8OpCode == SOCKET_CMD_ACCEPT)
    3a3c:	2843      	cmp	r0, #67	; 0x43
    3a3e:	d13f      	bne.n	3ac0 <m2m_ip_cb+0x108>
	{
		tstrAcceptReply			strAcceptReply;
		tstrSocketAcceptMsg		strAccept;
		if(hif_receive(u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
    3a40:	1c10      	adds	r0, r2, #0
    3a42:	a903      	add	r1, sp, #12
    3a44:	220c      	movs	r2, #12
    3a46:	2300      	movs	r3, #0
    3a48:	4c8e      	ldr	r4, [pc, #568]	; (3c84 <m2m_ip_cb+0x2cc>)
    3a4a:	47a0      	blx	r4
    3a4c:	2800      	cmp	r0, #0
    3a4e:	d000      	beq.n	3a52 <m2m_ip_cb+0x9a>
    3a50:	e111      	b.n	3c76 <m2m_ip_cb+0x2be>
		{
			if(strAcceptReply.sConnectedSock >= 0)
    3a52:	ab03      	add	r3, sp, #12
    3a54:	7a59      	ldrb	r1, [r3, #9]
    3a56:	b24b      	sxtb	r3, r1
    3a58:	2b00      	cmp	r3, #0
    3a5a:	db1a      	blt.n	3a92 <m2m_ip_cb+0xda>
			{
				gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 	= 0;
    3a5c:	011a      	lsls	r2, r3, #4
    3a5e:	488b      	ldr	r0, [pc, #556]	; (3c8c <m2m_ip_cb+0x2d4>)
    3a60:	1882      	adds	r2, r0, r2
    3a62:	2000      	movs	r0, #0
    3a64:	72d0      	strb	r0, [r2, #11]
				gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 	= 1;
    3a66:	3001      	adds	r0, #1
    3a68:	7290      	strb	r0, [r2, #10]

				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
    3a6a:	4889      	ldr	r0, [pc, #548]	; (3c90 <m2m_ip_cb+0x2d8>)
    3a6c:	8802      	ldrh	r2, [r0, #0]
    3a6e:	3201      	adds	r2, #1
    3a70:	b292      	uxth	r2, r2
    3a72:	8002      	strh	r2, [r0, #0]
				if(gu16SessionID == 0)
    3a74:	8802      	ldrh	r2, [r0, #0]
    3a76:	b292      	uxth	r2, r2
    3a78:	2a00      	cmp	r2, #0
    3a7a:	d103      	bne.n	3a84 <m2m_ip_cb+0xcc>
					++gu16SessionID;
    3a7c:	8802      	ldrh	r2, [r0, #0]
    3a7e:	3201      	adds	r2, #1
    3a80:	b292      	uxth	r2, r2
    3a82:	8002      	strh	r2, [r0, #0]

				gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = gu16SessionID;
    3a84:	4a82      	ldr	r2, [pc, #520]	; (3c90 <m2m_ip_cb+0x2d8>)
    3a86:	8812      	ldrh	r2, [r2, #0]
    3a88:	b292      	uxth	r2, r2
    3a8a:	011b      	lsls	r3, r3, #4
    3a8c:	487f      	ldr	r0, [pc, #508]	; (3c8c <m2m_ip_cb+0x2d4>)
    3a8e:	18c3      	adds	r3, r0, r3
    3a90:	80da      	strh	r2, [r3, #6]
				M2M_DBG("Socket %d session ID = %d\r\n",strAcceptReply.sConnectedSock , gu16SessionID );		
			}
			strAccept.sock = strAcceptReply.sConnectedSock;
    3a92:	ab07      	add	r3, sp, #28
    3a94:	7019      	strb	r1, [r3, #0]
			strAccept.strAddr.sin_family		= AF_INET;
    3a96:	2202      	movs	r2, #2
    3a98:	809a      	strh	r2, [r3, #4]
			strAccept.strAddr.sin_port = strAcceptReply.strAddr.u16Port;
    3a9a:	aa03      	add	r2, sp, #12
    3a9c:	8851      	ldrh	r1, [r2, #2]
    3a9e:	80d9      	strh	r1, [r3, #6]
			strAccept.strAddr.sin_addr.s_addr = strAcceptReply.strAddr.u32IPAddr;
    3aa0:	9a04      	ldr	r2, [sp, #16]
    3aa2:	9209      	str	r2, [sp, #36]	; 0x24
			if(gpfAppSocketCb)
    3aa4:	4b78      	ldr	r3, [pc, #480]	; (3c88 <m2m_ip_cb+0x2d0>)
    3aa6:	681b      	ldr	r3, [r3, #0]
    3aa8:	2b00      	cmp	r3, #0
    3aaa:	d100      	bne.n	3aae <m2m_ip_cb+0xf6>
    3aac:	e0e3      	b.n	3c76 <m2m_ip_cb+0x2be>
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
    3aae:	4b76      	ldr	r3, [pc, #472]	; (3c88 <m2m_ip_cb+0x2d0>)
    3ab0:	681b      	ldr	r3, [r3, #0]
    3ab2:	aa03      	add	r2, sp, #12
    3ab4:	2008      	movs	r0, #8
    3ab6:	5610      	ldrsb	r0, [r2, r0]
    3ab8:	2104      	movs	r1, #4
    3aba:	aa07      	add	r2, sp, #28
    3abc:	4798      	blx	r3
    3abe:	e0da      	b.n	3c76 <m2m_ip_cb+0x2be>
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
    3ac0:	2844      	cmp	r0, #68	; 0x44
    3ac2:	d001      	beq.n	3ac8 <m2m_ip_cb+0x110>
    3ac4:	284b      	cmp	r0, #75	; 0x4b
    3ac6:	d125      	bne.n	3b14 <m2m_ip_cb+0x15c>
	{
		tstrConnectReply		strConnectReply;
		tstrSocketConnectMsg	strConnMsg;
		if(hif_receive(u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
    3ac8:	1c20      	adds	r0, r4, #0
    3aca:	a907      	add	r1, sp, #28
    3acc:	2204      	movs	r2, #4
    3ace:	2300      	movs	r3, #0
    3ad0:	4c6c      	ldr	r4, [pc, #432]	; (3c84 <m2m_ip_cb+0x2cc>)
    3ad2:	47a0      	blx	r4
    3ad4:	2800      	cmp	r0, #0
    3ad6:	d000      	beq.n	3ada <m2m_ip_cb+0x122>
    3ad8:	e0cd      	b.n	3c76 <m2m_ip_cb+0x2be>
		{
			strConnMsg.sock		= strConnectReply.sock;
    3ada:	ab07      	add	r3, sp, #28
    3adc:	7818      	ldrb	r0, [r3, #0]
    3ade:	aa03      	add	r2, sp, #12
    3ae0:	7010      	strb	r0, [r2, #0]
			strConnMsg.s8Error	= strConnectReply.s8Error;
    3ae2:	785b      	ldrb	r3, [r3, #1]
    3ae4:	7053      	strb	r3, [r2, #1]
			if(strConnectReply.s8Error == SOCK_ERR_NO_ERROR)
    3ae6:	2b00      	cmp	r3, #0
    3ae8:	d108      	bne.n	3afc <m2m_ip_cb+0x144>
			{
				gastrSockets[strConnectReply.sock].u16DataOffset = strConnectReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
    3aea:	b243      	sxtb	r3, r0
    3aec:	aa07      	add	r2, sp, #28
    3aee:	8852      	ldrh	r2, [r2, #2]
    3af0:	3a08      	subs	r2, #8
    3af2:	b292      	uxth	r2, r2
    3af4:	011b      	lsls	r3, r3, #4
    3af6:	4965      	ldr	r1, [pc, #404]	; (3c8c <m2m_ip_cb+0x2d4>)
    3af8:	18cb      	adds	r3, r1, r3
    3afa:	811a      	strh	r2, [r3, #8]
			}
			if(gpfAppSocketCb)
    3afc:	4b62      	ldr	r3, [pc, #392]	; (3c88 <m2m_ip_cb+0x2d0>)
    3afe:	681b      	ldr	r3, [r3, #0]
    3b00:	2b00      	cmp	r3, #0
    3b02:	d100      	bne.n	3b06 <m2m_ip_cb+0x14e>
    3b04:	e0b7      	b.n	3c76 <m2m_ip_cb+0x2be>
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
    3b06:	4b60      	ldr	r3, [pc, #384]	; (3c88 <m2m_ip_cb+0x2d0>)
    3b08:	681b      	ldr	r3, [r3, #0]
    3b0a:	b240      	sxtb	r0, r0
    3b0c:	2105      	movs	r1, #5
    3b0e:	aa03      	add	r2, sp, #12
    3b10:	4798      	blx	r3
			if(gpfAppSocketCb)
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
	{
    3b12:	e0b0      	b.n	3c76 <m2m_ip_cb+0x2be>
			}
			if(gpfAppSocketCb)
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
		}
	}
	else if(u8OpCode == SOCKET_CMD_DNS_RESOLVE)
    3b14:	284a      	cmp	r0, #74	; 0x4a
    3b16:	d113      	bne.n	3b40 <m2m_ip_cb+0x188>
	{
		tstrDnsReply	strDnsReply;
		if(hif_receive(u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
    3b18:	1c10      	adds	r0, r2, #0
    3b1a:	a907      	add	r1, sp, #28
    3b1c:	2244      	movs	r2, #68	; 0x44
    3b1e:	2300      	movs	r3, #0
    3b20:	4c58      	ldr	r4, [pc, #352]	; (3c84 <m2m_ip_cb+0x2cc>)
    3b22:	47a0      	blx	r4
    3b24:	2800      	cmp	r0, #0
    3b26:	d000      	beq.n	3b2a <m2m_ip_cb+0x172>
    3b28:	e0a5      	b.n	3c76 <m2m_ip_cb+0x2be>
		{
			strDnsReply.u32HostIP = strDnsReply.u32HostIP;
    3b2a:	9917      	ldr	r1, [sp, #92]	; 0x5c
			if(gpfAppResolveCb)
    3b2c:	4b59      	ldr	r3, [pc, #356]	; (3c94 <m2m_ip_cb+0x2dc>)
    3b2e:	681b      	ldr	r3, [r3, #0]
    3b30:	2b00      	cmp	r3, #0
    3b32:	d100      	bne.n	3b36 <m2m_ip_cb+0x17e>
    3b34:	e09f      	b.n	3c76 <m2m_ip_cb+0x2be>
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
    3b36:	4b57      	ldr	r3, [pc, #348]	; (3c94 <m2m_ip_cb+0x2dc>)
    3b38:	681b      	ldr	r3, [r3, #0]
    3b3a:	a807      	add	r0, sp, #28
    3b3c:	4798      	blx	r3
    3b3e:	e09a      	b.n	3c76 <m2m_ip_cb+0x2be>
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
    3b40:	2846      	cmp	r0, #70	; 0x46
    3b42:	d006      	beq.n	3b52 <m2m_ip_cb+0x19a>
    3b44:	2848      	cmp	r0, #72	; 0x48
    3b46:	d007      	beq.n	3b58 <m2m_ip_cb+0x1a0>
    3b48:	284d      	cmp	r0, #77	; 0x4d
    3b4a:	d151      	bne.n	3bf0 <m2m_ip_cb+0x238>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
    3b4c:	2306      	movs	r3, #6
    3b4e:	469a      	mov	sl, r3
    3b50:	e004      	b.n	3b5c <m2m_ip_cb+0x1a4>
    3b52:	2306      	movs	r3, #6
    3b54:	469a      	mov	sl, r3
    3b56:	e001      	b.n	3b5c <m2m_ip_cb+0x1a4>
		uint16				u16DataOffset;

		if(u8OpCode == SOCKET_CMD_RECVFROM)
			u8CallbackMsgID = SOCKET_MSG_RECVFROM;
    3b58:	2309      	movs	r3, #9
    3b5a:	469a      	mov	sl, r3

		/* Read RECV REPLY data structure.
		*/
		u16ReadSize = sizeof(tstrRecvReply);
		if(hif_receive(u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
    3b5c:	1c20      	adds	r0, r4, #0
    3b5e:	a903      	add	r1, sp, #12
    3b60:	2210      	movs	r2, #16
    3b62:	2300      	movs	r3, #0
    3b64:	4f47      	ldr	r7, [pc, #284]	; (3c84 <m2m_ip_cb+0x2cc>)
    3b66:	47b8      	blx	r7
    3b68:	2800      	cmp	r0, #0
    3b6a:	d000      	beq.n	3b6e <m2m_ip_cb+0x1b6>
    3b6c:	e083      	b.n	3c76 <m2m_ip_cb+0x2be>
		{
			uint16 u16SessionID = 0;

			sock			= strRecvReply.sock;
    3b6e:	a903      	add	r1, sp, #12
    3b70:	7b08      	ldrb	r0, [r1, #12]
			u16SessionID = strRecvReply.u16SessionID;
    3b72:	89cb      	ldrh	r3, [r1, #14]
			M2M_DBG("recv callback session ID = %d\r\n",u16SessionID);
			
			/* Reset the Socket RX Pending Flag.
			*/
			gastrSockets[sock].bIsRecvPending = 0;
    3b74:	b242      	sxtb	r2, r0
    3b76:	0112      	lsls	r2, r2, #4
    3b78:	4f44      	ldr	r7, [pc, #272]	; (3c8c <m2m_ip_cb+0x2d4>)
    3b7a:	18ba      	adds	r2, r7, r2
    3b7c:	2600      	movs	r6, #0
    3b7e:	7316      	strb	r6, [r2, #12]

			s16RecvStatus	= NM_BSP_B_L_16(strRecvReply.s16RecvStatus);
    3b80:	890e      	ldrh	r6, [r1, #8]
    3b82:	46b0      	mov	r8, r6
			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
    3b84:	894e      	ldrh	r6, [r1, #10]
    3b86:	46b1      	mov	r9, r6
			strRecvMsg.strRemoteAddr.sin_port 			= strRecvReply.strRemoteAddr.u16Port;
    3b88:	af07      	add	r7, sp, #28
    3b8a:	884e      	ldrh	r6, [r1, #2]
    3b8c:	817e      	strh	r6, [r7, #10]
			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
    3b8e:	9904      	ldr	r1, [sp, #16]
    3b90:	910a      	str	r1, [sp, #40]	; 0x28

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    3b92:	88d2      	ldrh	r2, [r2, #6]
    3b94:	b292      	uxth	r2, r2
    3b96:	429a      	cmp	r2, r3
    3b98:	d121      	bne.n	3bde <m2m_ip_cb+0x226>
			{
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
    3b9a:	4643      	mov	r3, r8
    3b9c:	b21b      	sxth	r3, r3
    3b9e:	2b00      	cmp	r3, #0
    3ba0:	dd0d      	ble.n	3bbe <m2m_ip_cb+0x206>
    3ba2:	4643      	mov	r3, r8
    3ba4:	b21b      	sxth	r3, r3
    3ba6:	42ab      	cmp	r3, r5
    3ba8:	da09      	bge.n	3bbe <m2m_ip_cb+0x206>
					/* Read the Application data and deliver it to the application callback in
					the given application buffer. If the buffer is smaller than the received data,
					the data is passed to the application in chunks according to its buffer size.
					*/
					u16ReadSize = (uint16)s16RecvStatus;
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
    3baa:	b240      	sxtb	r0, r0
			{
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
				{
					/* Skip incoming bytes until reaching the Start of Application Data. 
					*/
					u32Address += u16DataOffset;
    3bac:	1c23      	adds	r3, r4, #0
    3bae:	444b      	add	r3, r9
					/* Read the Application data and deliver it to the application callback in
					the given application buffer. If the buffer is smaller than the received data,
					the data is passed to the application in chunks according to its buffer size.
					*/
					u16ReadSize = (uint16)s16RecvStatus;
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
    3bb0:	4642      	mov	r2, r8
    3bb2:	9200      	str	r2, [sp, #0]
    3bb4:	1c39      	adds	r1, r7, #0
    3bb6:	4652      	mov	r2, sl
    3bb8:	4c37      	ldr	r4, [pc, #220]	; (3c98 <m2m_ip_cb+0x2e0>)
    3bba:	47a0      	blx	r4
    3bbc:	e05b      	b.n	3c76 <m2m_ip_cb+0x2be>
				}
				else
				{
					strRecvMsg.s16BufferSize	= s16RecvStatus;
    3bbe:	ab07      	add	r3, sp, #28
    3bc0:	4642      	mov	r2, r8
    3bc2:	809a      	strh	r2, [r3, #4]
					strRecvMsg.pu8Buffer		= NULL;
    3bc4:	2300      	movs	r3, #0
    3bc6:	9307      	str	r3, [sp, #28]
					if(gpfAppSocketCb)
    3bc8:	4b2f      	ldr	r3, [pc, #188]	; (3c88 <m2m_ip_cb+0x2d0>)
    3bca:	681b      	ldr	r3, [r3, #0]
    3bcc:	2b00      	cmp	r3, #0
    3bce:	d052      	beq.n	3c76 <m2m_ip_cb+0x2be>
						gpfAppSocketCb(sock,u8CallbackMsgID, &strRecvMsg);
    3bd0:	4b2d      	ldr	r3, [pc, #180]	; (3c88 <m2m_ip_cb+0x2d0>)
    3bd2:	681b      	ldr	r3, [r3, #0]
    3bd4:	b240      	sxtb	r0, r0
    3bd6:	4651      	mov	r1, sl
    3bd8:	aa07      	add	r2, sp, #28
    3bda:	4798      	blx	r3
    3bdc:	e04b      	b.n	3c76 <m2m_ip_cb+0x2be>
				}
			}
			else
			{
				M2M_DBG("Discard recv callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
				if(u16ReadSize < u16BufferSize)
    3bde:	2d10      	cmp	r5, #16
    3be0:	d949      	bls.n	3c76 <m2m_ip_cb+0x2be>
					hif_receive(0, NULL, 0, 1);
    3be2:	2000      	movs	r0, #0
    3be4:	2100      	movs	r1, #0
    3be6:	2200      	movs	r2, #0
    3be8:	2301      	movs	r3, #1
    3bea:	4c26      	ldr	r4, [pc, #152]	; (3c84 <m2m_ip_cb+0x2cc>)
    3bec:	47a0      	blx	r4
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
	{
    3bee:	e042      	b.n	3c76 <m2m_ip_cb+0x2be>
				if(u16ReadSize < u16BufferSize)
					hif_receive(0, NULL, 0, 1);
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    3bf0:	2845      	cmp	r0, #69	; 0x45
    3bf2:	d005      	beq.n	3c00 <m2m_ip_cb+0x248>
    3bf4:	2847      	cmp	r0, #71	; 0x47
    3bf6:	d005      	beq.n	3c04 <m2m_ip_cb+0x24c>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    3bf8:	2507      	movs	r5, #7
				if(u16ReadSize < u16BufferSize)
					hif_receive(0, NULL, 0, 1);
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    3bfa:	284c      	cmp	r0, #76	; 0x4c
    3bfc:	d003      	beq.n	3c06 <m2m_ip_cb+0x24e>
    3bfe:	e023      	b.n	3c48 <m2m_ip_cb+0x290>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    3c00:	2507      	movs	r5, #7
    3c02:	e000      	b.n	3c06 <m2m_ip_cb+0x24e>

		if(u8OpCode == SOCKET_CMD_SENDTO)
			u8CallbackMsgID = SOCKET_MSG_SENDTO;
    3c04:	2508      	movs	r5, #8

		if(hif_receive(u32Address, (uint8*)&strReply, sizeof(tstrSendReply), 0) == M2M_SUCCESS)
    3c06:	1c20      	adds	r0, r4, #0
    3c08:	a907      	add	r1, sp, #28
    3c0a:	2208      	movs	r2, #8
    3c0c:	2300      	movs	r3, #0
    3c0e:	4c1d      	ldr	r4, [pc, #116]	; (3c84 <m2m_ip_cb+0x2cc>)
    3c10:	47a0      	blx	r4
    3c12:	2800      	cmp	r0, #0
    3c14:	d12f      	bne.n	3c76 <m2m_ip_cb+0x2be>
		{
			uint16 u16SessionID = 0;
			
			sock = strReply.sock;
    3c16:	ab07      	add	r3, sp, #28
    3c18:	7818      	ldrb	r0, [r3, #0]
			u16SessionID = strReply.u16SessionID;
    3c1a:	889a      	ldrh	r2, [r3, #4]
			M2M_DBG("send callback session ID = %d\r\n",u16SessionID);
			
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
    3c1c:	8859      	ldrh	r1, [r3, #2]
    3c1e:	ab03      	add	r3, sp, #12
    3c20:	8019      	strh	r1, [r3, #0]

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    3c22:	b243      	sxtb	r3, r0
    3c24:	011b      	lsls	r3, r3, #4
    3c26:	4919      	ldr	r1, [pc, #100]	; (3c8c <m2m_ip_cb+0x2d4>)
    3c28:	18cb      	adds	r3, r1, r3
    3c2a:	88db      	ldrh	r3, [r3, #6]
    3c2c:	b29b      	uxth	r3, r3
    3c2e:	4293      	cmp	r3, r2
    3c30:	d121      	bne.n	3c76 <m2m_ip_cb+0x2be>
			{
				if(gpfAppSocketCb)
    3c32:	4b15      	ldr	r3, [pc, #84]	; (3c88 <m2m_ip_cb+0x2d0>)
    3c34:	681b      	ldr	r3, [r3, #0]
    3c36:	2b00      	cmp	r3, #0
    3c38:	d01d      	beq.n	3c76 <m2m_ip_cb+0x2be>
					gpfAppSocketCb(sock,u8CallbackMsgID, &s16Rcvd);
    3c3a:	4b13      	ldr	r3, [pc, #76]	; (3c88 <m2m_ip_cb+0x2d0>)
    3c3c:	681b      	ldr	r3, [r3, #0]
    3c3e:	b240      	sxtb	r0, r0
    3c40:	1c29      	adds	r1, r5, #0
    3c42:	aa03      	add	r2, sp, #12
    3c44:	4798      	blx	r3
					hif_receive(0, NULL, 0, 1);
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
	{
    3c46:	e016      	b.n	3c76 <m2m_ip_cb+0x2be>
			{
				M2M_DBG("Discard send callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
			}
		}
	}
	else if(u8OpCode == SOCKET_CMD_PING)
    3c48:	2852      	cmp	r0, #82	; 0x52
    3c4a:	d114      	bne.n	3c76 <m2m_ip_cb+0x2be>
	{
		tstrPingReply	strPingReply;
		if(hif_receive(u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
    3c4c:	1c10      	adds	r0, r2, #0
    3c4e:	a907      	add	r1, sp, #28
    3c50:	2214      	movs	r2, #20
    3c52:	2301      	movs	r3, #1
    3c54:	4c0b      	ldr	r4, [pc, #44]	; (3c84 <m2m_ip_cb+0x2cc>)
    3c56:	47a0      	blx	r4
    3c58:	2800      	cmp	r0, #0
    3c5a:	d10c      	bne.n	3c76 <m2m_ip_cb+0x2be>
		{
			gfpPingCb = (void (*)(uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
    3c5c:	4b0f      	ldr	r3, [pc, #60]	; (3c9c <m2m_ip_cb+0x2e4>)
    3c5e:	9a08      	ldr	r2, [sp, #32]
    3c60:	601a      	str	r2, [r3, #0]
			if(gfpPingCb != NULL)
    3c62:	681b      	ldr	r3, [r3, #0]
    3c64:	2b00      	cmp	r3, #0
    3c66:	d006      	beq.n	3c76 <m2m_ip_cb+0x2be>
			{
				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
    3c68:	4b0c      	ldr	r3, [pc, #48]	; (3c9c <m2m_ip_cb+0x2e4>)
    3c6a:	681c      	ldr	r4, [r3, #0]
    3c6c:	ab07      	add	r3, sp, #28
    3c6e:	9909      	ldr	r1, [sp, #36]	; 0x24
    3c70:	7c1a      	ldrb	r2, [r3, #16]
    3c72:	9807      	ldr	r0, [sp, #28]
    3c74:	47a0      	blx	r4
			}
		}
	}
}
    3c76:	b018      	add	sp, #96	; 0x60
    3c78:	bc1c      	pop	{r2, r3, r4}
    3c7a:	4690      	mov	r8, r2
    3c7c:	4699      	mov	r9, r3
    3c7e:	46a2      	mov	sl, r4
    3c80:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c82:	46c0      	nop			; (mov r8, r8)
    3c84:	000026f9 	.word	0x000026f9
    3c88:	200016cc 	.word	0x200016cc
    3c8c:	2000161c 	.word	0x2000161c
    3c90:	2000015a 	.word	0x2000015a
    3c94:	200016d4 	.word	0x200016d4
    3c98:	000038f5 	.word	0x000038f5
    3c9c:	200016d0 	.word	0x200016d0

00003ca0 <socketInit>:

Date
		4 June 2012
*********************************************************************/
void socketInit(void)
{
    3ca0:	b508      	push	{r3, lr}
	if(gbSocketInit==0)
    3ca2:	4b0a      	ldr	r3, [pc, #40]	; (3ccc <socketInit+0x2c>)
    3ca4:	781b      	ldrb	r3, [r3, #0]
    3ca6:	2b00      	cmp	r3, #0
    3ca8:	d10e      	bne.n	3cc8 <socketInit+0x28>
	{
		m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
    3caa:	4809      	ldr	r0, [pc, #36]	; (3cd0 <socketInit+0x30>)
    3cac:	2100      	movs	r1, #0
    3cae:	22b0      	movs	r2, #176	; 0xb0
    3cb0:	4b08      	ldr	r3, [pc, #32]	; (3cd4 <socketInit+0x34>)
    3cb2:	4798      	blx	r3
		hif_register_cb(M2M_REQ_GROUP_IP,m2m_ip_cb);
    3cb4:	2002      	movs	r0, #2
    3cb6:	4908      	ldr	r1, [pc, #32]	; (3cd8 <socketInit+0x38>)
    3cb8:	4b08      	ldr	r3, [pc, #32]	; (3cdc <socketInit+0x3c>)
    3cba:	4798      	blx	r3
		gbSocketInit=1;
    3cbc:	2201      	movs	r2, #1
    3cbe:	4b03      	ldr	r3, [pc, #12]	; (3ccc <socketInit+0x2c>)
    3cc0:	701a      	strb	r2, [r3, #0]
		gu16SessionID = 0;
    3cc2:	2200      	movs	r2, #0
    3cc4:	4b06      	ldr	r3, [pc, #24]	; (3ce0 <socketInit+0x40>)
    3cc6:	801a      	strh	r2, [r3, #0]
	}
}
    3cc8:	bd08      	pop	{r3, pc}
    3cca:	46c0      	nop			; (mov r8, r8)
    3ccc:	20000159 	.word	0x20000159
    3cd0:	2000161c 	.word	0x2000161c
    3cd4:	000021dd 	.word	0x000021dd
    3cd8:	000039b9 	.word	0x000039b9
    3cdc:	000027b9 	.word	0x000027b9
    3ce0:	2000015a 	.word	0x2000015a

00003ce4 <registerSocketCallback>:
Date
		4 June 2012
*********************************************************************/
void registerSocketCallback(tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
{
	gpfAppSocketCb = pfAppSocketCb;
    3ce4:	4b02      	ldr	r3, [pc, #8]	; (3cf0 <registerSocketCallback+0xc>)
    3ce6:	6018      	str	r0, [r3, #0]
	gpfAppResolveCb = pfAppResolveCb;
    3ce8:	4b02      	ldr	r3, [pc, #8]	; (3cf4 <registerSocketCallback+0x10>)
    3cea:	6019      	str	r1, [r3, #0]
}
    3cec:	4770      	bx	lr
    3cee:	46c0      	nop			; (mov r8, r8)
    3cf0:	200016cc 	.word	0x200016cc
    3cf4:	200016d4 	.word	0x200016d4

00003cf8 <socket>:

Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
    3cf8:	b570      	push	{r4, r5, r6, lr}
    3cfa:	b086      	sub	sp, #24
	SOCKET		sock = -1;
    3cfc:	24ff      	movs	r4, #255	; 0xff
	uint8		u8Count,u8SocketCount = MAX_SOCKET;
	volatile tstrSocket	*pstrSock;
	
	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
    3cfe:	2802      	cmp	r0, #2
    3d00:	d156      	bne.n	3db0 <socket+0xb8>
	{
		if(u8Type == SOCK_STREAM)
    3d02:	2901      	cmp	r1, #1
    3d04:	d047      	beq.n	3d96 <socket+0x9e>
			u8Count = 0;
		}
		else if(u8Type == SOCK_DGRAM)
		{
			/*--- UDP SOCKET ---*/
			u8SocketCount = MAX_SOCKET;
    3d06:	3009      	adds	r0, #9
			u8Count = TCP_SOCK_MAX;
    3d08:	3cf8      	subs	r4, #248	; 0xf8
		if(u8Type == SOCK_STREAM)
		{
			u8SocketCount = TCP_SOCK_MAX;
			u8Count = 0;
		}
		else if(u8Type == SOCK_DGRAM)
    3d0a:	2902      	cmp	r1, #2
    3d0c:	d045      	beq.n	3d9a <socket+0xa2>
			/*--- UDP SOCKET ---*/
			u8SocketCount = MAX_SOCKET;
			u8Count = TCP_SOCK_MAX;
		}
		else
			return sock;
    3d0e:	34f8      	adds	r4, #248	; 0xf8
    3d10:	e04e      	b.n	3db0 <socket+0xb8>

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			pstrSock = &gastrSockets[u8Count];
    3d12:	1c25      	adds	r5, r4, #0
			if(pstrSock->bIsUsed == 0)
    3d14:	0123      	lsls	r3, r4, #4
    3d16:	18cb      	adds	r3, r1, r3
    3d18:	3308      	adds	r3, #8
    3d1a:	789b      	ldrb	r3, [r3, #2]
    3d1c:	2b00      	cmp	r3, #0
    3d1e:	d134      	bne.n	3d8a <socket+0x92>
		else
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			pstrSock = &gastrSockets[u8Count];
    3d20:	0120      	lsls	r0, r4, #4
    3d22:	4b25      	ldr	r3, [pc, #148]	; (3db8 <socket+0xc0>)
    3d24:	18c0      	adds	r0, r0, r3
    3d26:	1c16      	adds	r6, r2, #0
			if(pstrSock->bIsUsed == 0)
			{
				m2m_memset((uint8*)pstrSock, 0, sizeof(tstrSocket));
    3d28:	2100      	movs	r1, #0
    3d2a:	2210      	movs	r2, #16
    3d2c:	4b23      	ldr	r3, [pc, #140]	; (3dbc <socket+0xc4>)
    3d2e:	4798      	blx	r3

				pstrSock->bIsUsed = 1;
    3d30:	012b      	lsls	r3, r5, #4
    3d32:	4a21      	ldr	r2, [pc, #132]	; (3db8 <socket+0xc0>)
    3d34:	18d3      	adds	r3, r2, r3
    3d36:	2201      	movs	r2, #1
    3d38:	729a      	strb	r2, [r3, #10]

				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
    3d3a:	4a21      	ldr	r2, [pc, #132]	; (3dc0 <socket+0xc8>)
    3d3c:	8813      	ldrh	r3, [r2, #0]
    3d3e:	3301      	adds	r3, #1
    3d40:	b29b      	uxth	r3, r3
    3d42:	8013      	strh	r3, [r2, #0]
				if(gu16SessionID == 0)
    3d44:	8813      	ldrh	r3, [r2, #0]
    3d46:	b29b      	uxth	r3, r3
    3d48:	2b00      	cmp	r3, #0
    3d4a:	d103      	bne.n	3d54 <socket+0x5c>
					++gu16SessionID;
    3d4c:	8813      	ldrh	r3, [r2, #0]
    3d4e:	3301      	adds	r3, #1
    3d50:	b29b      	uxth	r3, r3
    3d52:	8013      	strh	r3, [r2, #0]
				
				pstrSock->u16SessionID = gu16SessionID;
    3d54:	4b1a      	ldr	r3, [pc, #104]	; (3dc0 <socket+0xc8>)
    3d56:	881a      	ldrh	r2, [r3, #0]
    3d58:	b292      	uxth	r2, r2
    3d5a:	012b      	lsls	r3, r5, #4
    3d5c:	4916      	ldr	r1, [pc, #88]	; (3db8 <socket+0xc0>)
    3d5e:	18cb      	adds	r3, r1, r3
    3d60:	80da      	strh	r2, [r3, #6]
				M2M_DBG("1 Socket %d session ID = %d\r\n",u8Count, gu16SessionID );
				sock = (SOCKET)u8Count;
    3d62:	b2e4      	uxtb	r4, r4

				if(u8Flags & SOCKET_FLAGS_SSL)
    3d64:	07f3      	lsls	r3, r6, #31
    3d66:	d523      	bpl.n	3db0 <socket+0xb8>
				{
					tstrSSLSocketCreateCmd	strSSLCreate;
					strSSLCreate.sslSock = sock;
    3d68:	aa05      	add	r2, sp, #20
    3d6a:	7014      	strb	r4, [r2, #0]
					pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
    3d6c:	012d      	lsls	r5, r5, #4
    3d6e:	194d      	adds	r5, r1, r5
    3d70:	2321      	movs	r3, #33	; 0x21
    3d72:	72eb      	strb	r3, [r5, #11]
					SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
    3d74:	2300      	movs	r3, #0
    3d76:	9300      	str	r3, [sp, #0]
    3d78:	9301      	str	r3, [sp, #4]
    3d7a:	9302      	str	r3, [sp, #8]
    3d7c:	2002      	movs	r0, #2
    3d7e:	2150      	movs	r1, #80	; 0x50
    3d80:	3304      	adds	r3, #4
    3d82:	4d10      	ldr	r5, [pc, #64]	; (3dc4 <socket+0xcc>)
    3d84:	47a8      	blx	r5
    3d86:	e013      	b.n	3db0 <socket+0xb8>
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			pstrSock = &gastrSockets[u8Count];
			if(pstrSock->bIsUsed == 0)
    3d88:	490b      	ldr	r1, [pc, #44]	; (3db8 <socket+0xc0>)
			u8Count = TCP_SOCK_MAX;
		}
		else
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
    3d8a:	3401      	adds	r4, #1
    3d8c:	b2e4      	uxtb	r4, r4
    3d8e:	4284      	cmp	r4, r0
    3d90:	d3bf      	bcc.n	3d12 <socket+0x1a>
Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
	SOCKET		sock = -1;
    3d92:	24ff      	movs	r4, #255	; 0xff
    3d94:	e00c      	b.n	3db0 <socket+0xb8>
	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
	{
		if(u8Type == SOCK_STREAM)
		{
			u8SocketCount = TCP_SOCK_MAX;
    3d96:	2007      	movs	r0, #7
			u8Count = 0;
    3d98:	2400      	movs	r4, #0
		else
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			pstrSock = &gastrSockets[u8Count];
    3d9a:	1c25      	adds	r5, r4, #0
			if(pstrSock->bIsUsed == 0)
    3d9c:	0123      	lsls	r3, r4, #4
    3d9e:	4906      	ldr	r1, [pc, #24]	; (3db8 <socket+0xc0>)
    3da0:	18cb      	adds	r3, r1, r3
    3da2:	3308      	adds	r3, #8
    3da4:	789b      	ldrb	r3, [r3, #2]
    3da6:	2b00      	cmp	r3, #0
    3da8:	d1ee      	bne.n	3d88 <socket+0x90>
		else
			return sock;

		for(;u8Count < u8SocketCount; u8Count ++)
		{
			pstrSock = &gastrSockets[u8Count];
    3daa:	0120      	lsls	r0, r4, #4
    3dac:	1840      	adds	r0, r0, r1
    3dae:	e7ba      	b.n	3d26 <socket+0x2e>
    3db0:	b260      	sxtb	r0, r4
				break;
			}
		}
	}
	return sock;
}
    3db2:	b006      	add	sp, #24
    3db4:	bd70      	pop	{r4, r5, r6, pc}
    3db6:	46c0      	nop			; (mov r8, r8)
    3db8:	2000161c 	.word	0x2000161c
    3dbc:	000021dd 	.word	0x000021dd
    3dc0:	2000015a 	.word	0x2000015a
    3dc4:	00002379 	.word	0x00002379

00003dc8 <connect>:

Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
    3dc8:	b570      	push	{r4, r5, r6, lr}
    3dca:	b088      	sub	sp, #32
    3dcc:	1e04      	subs	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
    3dce:	db30      	blt.n	3e32 <connect+0x6a>
    3dd0:	2900      	cmp	r1, #0
    3dd2:	d030      	beq.n	3e36 <connect+0x6e>
    3dd4:	0103      	lsls	r3, r0, #4
    3dd6:	481c      	ldr	r0, [pc, #112]	; (3e48 <connect+0x80>)
    3dd8:	18c3      	adds	r3, r0, r3
    3dda:	3308      	adds	r3, #8
    3ddc:	789b      	ldrb	r3, [r3, #2]
    3dde:	2b01      	cmp	r3, #1
    3de0:	d12b      	bne.n	3e3a <connect+0x72>
    3de2:	2a00      	cmp	r2, #0
    3de4:	d02b      	beq.n	3e3e <connect+0x76>
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    3de6:	0123      	lsls	r3, r4, #4
    3de8:	18c3      	adds	r3, r0, r3
    3dea:	3308      	adds	r3, #8
    3dec:	78db      	ldrb	r3, [r3, #3]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
    3dee:	2644      	movs	r6, #68	; 0x44
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    3df0:	07db      	lsls	r3, r3, #31
    3df2:	d505      	bpl.n	3e00 <connect+0x38>
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
    3df4:	0123      	lsls	r3, r4, #4
    3df6:	18c3      	adds	r3, r0, r3
    3df8:	7ada      	ldrb	r2, [r3, #11]
    3dfa:	ab05      	add	r3, sp, #20
    3dfc:	725a      	strb	r2, [r3, #9]
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
    3dfe:	3607      	adds	r6, #7
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
		}
		strConnect.sock = sock;
    3e00:	ad05      	add	r5, sp, #20
    3e02:	722c      	strb	r4, [r5, #8]
		m2m_memcpy((uint8 *)&strConnect.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
    3e04:	1c28      	adds	r0, r5, #0
    3e06:	2208      	movs	r2, #8
    3e08:	4b10      	ldr	r3, [pc, #64]	; (3e4c <connect+0x84>)
    3e0a:	4798      	blx	r3

		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
    3e0c:	0124      	lsls	r4, r4, #4
    3e0e:	4b0e      	ldr	r3, [pc, #56]	; (3e48 <connect+0x80>)
    3e10:	191c      	adds	r4, r3, r4
    3e12:	88e3      	ldrh	r3, [r4, #6]
    3e14:	816b      	strh	r3, [r5, #10]
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
    3e16:	2300      	movs	r3, #0
    3e18:	9300      	str	r3, [sp, #0]
    3e1a:	9301      	str	r3, [sp, #4]
    3e1c:	9302      	str	r3, [sp, #8]
    3e1e:	2002      	movs	r0, #2
    3e20:	1c31      	adds	r1, r6, #0
    3e22:	1c2a      	adds	r2, r5, #0
    3e24:	330c      	adds	r3, #12
    3e26:	4c0a      	ldr	r4, [pc, #40]	; (3e50 <connect+0x88>)
    3e28:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
    3e2a:	2800      	cmp	r0, #0
    3e2c:	d008      	beq.n	3e40 <connect+0x78>
		{
			s8Ret = SOCK_ERR_INVALID;
    3e2e:	20f7      	movs	r0, #247	; 0xf7
    3e30:	e006      	b.n	3e40 <connect+0x78>
Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    3e32:	20fa      	movs	r0, #250	; 0xfa
    3e34:	e004      	b.n	3e40 <connect+0x78>
    3e36:	20fa      	movs	r0, #250	; 0xfa
    3e38:	e002      	b.n	3e40 <connect+0x78>
    3e3a:	20fa      	movs	r0, #250	; 0xfa
    3e3c:	e000      	b.n	3e40 <connect+0x78>
    3e3e:	20fa      	movs	r0, #250	; 0xfa
		if(s8Ret != SOCK_ERR_NO_ERROR)
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
    3e40:	b240      	sxtb	r0, r0
}
    3e42:	b008      	add	sp, #32
    3e44:	bd70      	pop	{r4, r5, r6, pc}
    3e46:	46c0      	nop			; (mov r8, r8)
    3e48:	2000161c 	.word	0x2000161c
    3e4c:	000021c9 	.word	0x000021c9
    3e50:	00002379 	.word	0x00002379

00003e54 <send>:

Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
    3e54:	b530      	push	{r4, r5, lr}
    3e56:	b089      	sub	sp, #36	; 0x24
    3e58:	1c0c      	adds	r4, r1, #0
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
    3e5a:	2800      	cmp	r0, #0
    3e5c:	db35      	blt.n	3eca <send+0x76>
    3e5e:	2900      	cmp	r1, #0
    3e60:	d035      	beq.n	3ece <send+0x7a>
    3e62:	23af      	movs	r3, #175	; 0xaf
    3e64:	00db      	lsls	r3, r3, #3
    3e66:	429a      	cmp	r2, r3
    3e68:	d833      	bhi.n	3ed2 <send+0x7e>
    3e6a:	0103      	lsls	r3, r0, #4
    3e6c:	491c      	ldr	r1, [pc, #112]	; (3ee0 <send+0x8c>)
    3e6e:	18cb      	adds	r3, r1, r3
    3e70:	3308      	adds	r3, #8
    3e72:	789b      	ldrb	r3, [r3, #2]
    3e74:	2b01      	cmp	r3, #1
    3e76:	d12e      	bne.n	3ed6 <send+0x82>
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;

		strSend.sock			= sock;
    3e78:	a904      	add	r1, sp, #16
    3e7a:	7008      	strb	r0, [r1, #0]
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
    3e7c:	804a      	strh	r2, [r1, #2]
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
    3e7e:	0103      	lsls	r3, r0, #4
    3e80:	4d17      	ldr	r5, [pc, #92]	; (3ee0 <send+0x8c>)
    3e82:	18eb      	adds	r3, r5, r3
    3e84:	88db      	ldrh	r3, [r3, #6]
    3e86:	818b      	strh	r3, [r1, #12]
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;
    3e88:	2550      	movs	r5, #80	; 0x50

		strSend.sock			= sock;
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;

		if(sock >= TCP_SOCK_MAX)
    3e8a:	2806      	cmp	r0, #6
    3e8c:	dd00      	ble.n	3e90 <send+0x3c>
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
    3e8e:	3d0c      	subs	r5, #12
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3e90:	0103      	lsls	r3, r0, #4
    3e92:	4913      	ldr	r1, [pc, #76]	; (3ee0 <send+0x8c>)
    3e94:	18cb      	adds	r3, r1, r3
    3e96:	3308      	adds	r3, #8
    3e98:	78db      	ldrb	r3, [r3, #3]
	{
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
    3e9a:	2145      	movs	r1, #69	; 0x45

		if(sock >= TCP_SOCK_MAX)
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3e9c:	07db      	lsls	r3, r3, #31
    3e9e:	d505      	bpl.n	3eac <send+0x58>
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
    3ea0:	0100      	lsls	r0, r0, #4
    3ea2:	4b0f      	ldr	r3, [pc, #60]	; (3ee0 <send+0x8c>)
    3ea4:	1818      	adds	r0, r3, r0
    3ea6:	8905      	ldrh	r5, [r0, #8]
    3ea8:	b2ad      	uxth	r5, r5
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
    3eaa:	3107      	adds	r1, #7
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
		}

		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
    3eac:	2380      	movs	r3, #128	; 0x80
    3eae:	4319      	orrs	r1, r3
    3eb0:	9400      	str	r4, [sp, #0]
    3eb2:	9201      	str	r2, [sp, #4]
    3eb4:	9502      	str	r5, [sp, #8]
    3eb6:	2002      	movs	r0, #2
    3eb8:	aa04      	add	r2, sp, #16
    3eba:	3b70      	subs	r3, #112	; 0x70
    3ebc:	4c09      	ldr	r4, [pc, #36]	; (3ee4 <send+0x90>)
    3ebe:	47a0      	blx	r4
    3ec0:	2300      	movs	r3, #0
		if(s16Ret != SOCK_ERR_NO_ERROR)
    3ec2:	2800      	cmp	r0, #0
    3ec4:	d008      	beq.n	3ed8 <send+0x84>
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
    3ec6:	4b08      	ldr	r3, [pc, #32]	; (3ee8 <send+0x94>)
    3ec8:	e006      	b.n	3ed8 <send+0x84>
Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    3eca:	4b08      	ldr	r3, [pc, #32]	; (3eec <send+0x98>)
    3ecc:	e004      	b.n	3ed8 <send+0x84>
    3ece:	4b07      	ldr	r3, [pc, #28]	; (3eec <send+0x98>)
    3ed0:	e002      	b.n	3ed8 <send+0x84>
    3ed2:	4b06      	ldr	r3, [pc, #24]	; (3eec <send+0x98>)
    3ed4:	e000      	b.n	3ed8 <send+0x84>
    3ed6:	4b05      	ldr	r3, [pc, #20]	; (3eec <send+0x98>)
		if(s16Ret != SOCK_ERR_NO_ERROR)
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
		}
	}
	return s16Ret;
    3ed8:	b218      	sxth	r0, r3
}
    3eda:	b009      	add	sp, #36	; 0x24
    3edc:	bd30      	pop	{r4, r5, pc}
    3ede:	46c0      	nop			; (mov r8, r8)
    3ee0:	2000161c 	.word	0x2000161c
    3ee4:	00002379 	.word	0x00002379
    3ee8:	0000fff2 	.word	0x0000fff2
    3eec:	0000fffa 	.word	0x0000fffa

00003ef0 <recv>:

Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
    3ef0:	b530      	push	{r4, r5, lr}
    3ef2:	b087      	sub	sp, #28
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
    3ef4:	2800      	cmp	r0, #0
    3ef6:	db36      	blt.n	3f66 <recv+0x76>
    3ef8:	2900      	cmp	r1, #0
    3efa:	d036      	beq.n	3f6a <recv+0x7a>
    3efc:	2a00      	cmp	r2, #0
    3efe:	d036      	beq.n	3f6e <recv+0x7e>
    3f00:	0104      	lsls	r4, r0, #4
    3f02:	4d1e      	ldr	r5, [pc, #120]	; (3f7c <recv+0x8c>)
    3f04:	192c      	adds	r4, r5, r4
    3f06:	3408      	adds	r4, #8
    3f08:	78a4      	ldrb	r4, [r4, #2]
    3f0a:	2c01      	cmp	r4, #1
    3f0c:	d131      	bne.n	3f72 <recv+0x82>
	{
		s16Ret = SOCK_ERR_NO_ERROR;
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
    3f0e:	0104      	lsls	r4, r0, #4
    3f10:	5161      	str	r1, [r4, r5]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
    3f12:	1929      	adds	r1, r5, r4
    3f14:	808a      	strh	r2, [r1, #4]

		if(!gastrSockets[sock].bIsRecvPending)
    3f16:	3108      	adds	r1, #8
    3f18:	7909      	ldrb	r1, [r1, #4]
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
	{
		s16Ret = SOCK_ERR_NO_ERROR;
    3f1a:	2200      	movs	r2, #0
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
    3f1c:	2900      	cmp	r1, #0
    3f1e:	d129      	bne.n	3f74 <recv+0x84>
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;

			gastrSockets[sock].bIsRecvPending = 1;
    3f20:	192a      	adds	r2, r5, r4
    3f22:	2101      	movs	r1, #1
    3f24:	7311      	strb	r1, [r2, #12]
    3f26:	3208      	adds	r2, #8
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3f28:	78d2      	ldrb	r2, [r2, #3]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;
    3f2a:	3145      	adds	r1, #69	; 0x45

			gastrSockets[sock].bIsRecvPending = 1;
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3f2c:	07d2      	lsls	r2, r2, #31
    3f2e:	d500      	bpl.n	3f32 <recv+0x42>
			{
				u8Cmd = SOCKET_CMD_SSL_RECV;
    3f30:	3107      	adds	r1, #7
			}

			/* Check the timeout value. */
			if(u32Timeoutmsec == 0)
    3f32:	2b00      	cmp	r3, #0
    3f34:	d102      	bne.n	3f3c <recv+0x4c>
				strRecv.u32Timeoutmsec = 0xFFFFFFFF;
    3f36:	3b01      	subs	r3, #1
    3f38:	9304      	str	r3, [sp, #16]
    3f3a:	e000      	b.n	3f3e <recv+0x4e>
			else
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
    3f3c:	9304      	str	r3, [sp, #16]
			strRecv.sock = sock;
    3f3e:	aa04      	add	r2, sp, #16
    3f40:	7110      	strb	r0, [r2, #4]
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
    3f42:	0100      	lsls	r0, r0, #4
    3f44:	4b0d      	ldr	r3, [pc, #52]	; (3f7c <recv+0x8c>)
    3f46:	1818      	adds	r0, r3, r0
    3f48:	88c3      	ldrh	r3, [r0, #6]
    3f4a:	80d3      	strh	r3, [r2, #6]
		
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
    3f4c:	2300      	movs	r3, #0
    3f4e:	9300      	str	r3, [sp, #0]
    3f50:	9301      	str	r3, [sp, #4]
    3f52:	9302      	str	r3, [sp, #8]
    3f54:	2002      	movs	r0, #2
    3f56:	3308      	adds	r3, #8
    3f58:	4c09      	ldr	r4, [pc, #36]	; (3f80 <recv+0x90>)
    3f5a:	47a0      	blx	r4
    3f5c:	2200      	movs	r2, #0
			if(s16Ret != SOCK_ERR_NO_ERROR)
    3f5e:	2800      	cmp	r0, #0
    3f60:	d008      	beq.n	3f74 <recv+0x84>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
    3f62:	4a08      	ldr	r2, [pc, #32]	; (3f84 <recv+0x94>)
    3f64:	e006      	b.n	3f74 <recv+0x84>
Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    3f66:	4a08      	ldr	r2, [pc, #32]	; (3f88 <recv+0x98>)
    3f68:	e004      	b.n	3f74 <recv+0x84>
    3f6a:	4a07      	ldr	r2, [pc, #28]	; (3f88 <recv+0x98>)
    3f6c:	e002      	b.n	3f74 <recv+0x84>
    3f6e:	4a06      	ldr	r2, [pc, #24]	; (3f88 <recv+0x98>)
    3f70:	e000      	b.n	3f74 <recv+0x84>
    3f72:	4a05      	ldr	r2, [pc, #20]	; (3f88 <recv+0x98>)
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
			}
		}
	}
	return s16Ret;
    3f74:	b210      	sxth	r0, r2
}
    3f76:	b007      	add	sp, #28
    3f78:	bd30      	pop	{r4, r5, pc}
    3f7a:	46c0      	nop			; (mov r8, r8)
    3f7c:	2000161c 	.word	0x2000161c
    3f80:	00002379 	.word	0x00002379
    3f84:	0000fff2 	.word	0x0000fff2
    3f88:	0000fffa 	.word	0x0000fffa

00003f8c <close>:

Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
    3f8c:	b530      	push	{r4, r5, lr}
    3f8e:	b087      	sub	sp, #28
    3f90:	1e04      	subs	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
    3f92:	db29      	blt.n	3fe8 <close+0x5c>
    3f94:	0103      	lsls	r3, r0, #4
    3f96:	4a17      	ldr	r2, [pc, #92]	; (3ff4 <close+0x68>)
    3f98:	18d3      	adds	r3, r2, r3
    3f9a:	3308      	adds	r3, #8
    3f9c:	789b      	ldrb	r3, [r3, #2]
    3f9e:	2b01      	cmp	r3, #1
    3fa0:	d124      	bne.n	3fec <close+0x60>
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
		tstrCloseCmd strclose;
		strclose.sock = sock; 
    3fa2:	aa05      	add	r2, sp, #20
    3fa4:	7010      	strb	r0, [r2, #0]
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
    3fa6:	0103      	lsls	r3, r0, #4
    3fa8:	4912      	ldr	r1, [pc, #72]	; (3ff4 <close+0x68>)
    3faa:	18cb      	adds	r3, r1, r3
    3fac:	88d9      	ldrh	r1, [r3, #6]
    3fae:	8051      	strh	r1, [r2, #2]
		
		gastrSockets[sock].bIsUsed = 0;
    3fb0:	2100      	movs	r1, #0
    3fb2:	7299      	strb	r1, [r3, #10]
		gastrSockets[sock].u16SessionID =0;
    3fb4:	80d9      	strh	r1, [r3, #6]
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3fb6:	7adb      	ldrb	r3, [r3, #11]
sint8 close(SOCKET sock)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
    3fb8:	3149      	adds	r1, #73	; 0x49
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
		
		gastrSockets[sock].bIsUsed = 0;
		gastrSockets[sock].u16SessionID =0;
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3fba:	07db      	lsls	r3, r3, #31
    3fbc:	d500      	bpl.n	3fc0 <close+0x34>
		{
			u8Cmd = SOCKET_CMD_SSL_CLOSE;
    3fbe:	3105      	adds	r1, #5
		}
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
    3fc0:	2300      	movs	r3, #0
    3fc2:	9300      	str	r3, [sp, #0]
    3fc4:	9301      	str	r3, [sp, #4]
    3fc6:	9302      	str	r3, [sp, #8]
    3fc8:	2002      	movs	r0, #2
    3fca:	aa05      	add	r2, sp, #20
    3fcc:	3304      	adds	r3, #4
    3fce:	4d0a      	ldr	r5, [pc, #40]	; (3ff8 <close+0x6c>)
    3fd0:	47a8      	blx	r5
    3fd2:	1e05      	subs	r5, r0, #0
		if(s8Ret != SOCK_ERR_NO_ERROR)
    3fd4:	d000      	beq.n	3fd8 <close+0x4c>
		{
			s8Ret = SOCK_ERR_INVALID;
    3fd6:	25f7      	movs	r5, #247	; 0xf7
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
    3fd8:	0124      	lsls	r4, r4, #4
    3fda:	4806      	ldr	r0, [pc, #24]	; (3ff4 <close+0x68>)
    3fdc:	1820      	adds	r0, r4, r0
    3fde:	2100      	movs	r1, #0
    3fe0:	2210      	movs	r2, #16
    3fe2:	4b06      	ldr	r3, [pc, #24]	; (3ffc <close+0x70>)
    3fe4:	4798      	blx	r3
    3fe6:	e002      	b.n	3fee <close+0x62>
Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    3fe8:	25fa      	movs	r5, #250	; 0xfa
    3fea:	e000      	b.n	3fee <close+0x62>
    3fec:	25fa      	movs	r5, #250	; 0xfa
		{
			s8Ret = SOCK_ERR_INVALID;
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
	}
	return s8Ret;
    3fee:	b268      	sxtb	r0, r5
}
    3ff0:	b007      	add	sp, #28
    3ff2:	bd30      	pop	{r4, r5, pc}
    3ff4:	2000161c 	.word	0x2000161c
    3ff8:	00002379 	.word	0x00002379
    3ffc:	000021dd 	.word	0x000021dd

00004000 <nmi_inet_addr>:

Date
		4 June 2012
*********************************************************************/
uint32 nmi_inet_addr(char *pcIpAddr)
{
    4000:	b5f0      	push	{r4, r5, r6, r7, lr}
    4002:	b083      	sub	sp, #12
	uint8	tmp;
	uint32	u32IP = 0;
    4004:	2300      	movs	r3, #0
    4006:	9301      	str	r3, [sp, #4]
    4008:	2400      	movs	r4, #0
    400a:	1c43      	adds	r3, r0, #1
    400c:	1d47      	adds	r7, r0, #5
    400e:	2600      	movs	r6, #0
    4010:	1c18      	adds	r0, r3, #0
    4012:	1e5d      	subs	r5, r3, #1
	for(i = 0; i < 4; ++i)
	{
		j = 0;
		do
		{
			c = *pcIpAddr;
    4014:	782a      	ldrb	r2, [r5, #0]
			++j;
			if(j > 4)
    4016:	42bb      	cmp	r3, r7
    4018:	d019      	beq.n	404e <nmi_inet_addr+0x4e>
			{
				return 0;
			}
			if(c == '.' || c == 0)
    401a:	2a2e      	cmp	r2, #46	; 0x2e
    401c:	d01b      	beq.n	4056 <nmi_inet_addr+0x56>
    401e:	2a00      	cmp	r2, #0
    4020:	d01c      	beq.n	405c <nmi_inet_addr+0x5c>
			{
				au8IP[i] = tmp;
				tmp = 0;
			}
			else if(c >= '0' && c <= '9')
    4022:	1c11      	adds	r1, r2, #0
    4024:	3930      	subs	r1, #48	; 0x30
    4026:	2909      	cmp	r1, #9
    4028:	d813      	bhi.n	4052 <nmi_inet_addr+0x52>
			{
				tmp = (tmp * 10) + (c - '0');
    402a:	00b1      	lsls	r1, r6, #2
    402c:	1871      	adds	r1, r6, r1
    402e:	0049      	lsls	r1, r1, #1
    4030:	3930      	subs	r1, #48	; 0x30
    4032:	188a      	adds	r2, r1, r2
    4034:	b2d6      	uxtb	r6, r2
    4036:	3301      	adds	r3, #1
    4038:	e7ea      	b.n	4010 <nmi_inet_addr+0x10>
    403a:	3401      	adds	r4, #1
	uint8 	c;
	uint8	i, j;

	tmp = 0;

	for(i = 0; i < 4; ++i)
    403c:	2c04      	cmp	r4, #4
    403e:	d1e4      	bne.n	400a <nmi_inet_addr+0xa>
				return 0;
			}
			++pcIpAddr;
		} while(c != '.' && c != 0);
	}
	m2m_memcpy((uint8*)&u32IP, au8IP, 4);
    4040:	a801      	add	r0, sp, #4
    4042:	4669      	mov	r1, sp
    4044:	2204      	movs	r2, #4
    4046:	4b08      	ldr	r3, [pc, #32]	; (4068 <nmi_inet_addr+0x68>)
    4048:	4798      	blx	r3
	return u32IP;
    404a:	9801      	ldr	r0, [sp, #4]
    404c:	e009      	b.n	4062 <nmi_inet_addr+0x62>
		{
			c = *pcIpAddr;
			++j;
			if(j > 4)
			{
				return 0;
    404e:	2000      	movs	r0, #0
    4050:	e007      	b.n	4062 <nmi_inet_addr+0x62>
			{
				tmp = (tmp * 10) + (c - '0');
			}
			else
			{
				return 0;
    4052:	2000      	movs	r0, #0
    4054:	e005      	b.n	4062 <nmi_inet_addr+0x62>
			{
				return 0;
			}
			if(c == '.' || c == 0)
			{
				au8IP[i] = tmp;
    4056:	466b      	mov	r3, sp
    4058:	54e6      	strb	r6, [r4, r3]
    405a:	e7ee      	b.n	403a <nmi_inet_addr+0x3a>
    405c:	466b      	mov	r3, sp
    405e:	54e6      	strb	r6, [r4, r3]
    4060:	e7eb      	b.n	403a <nmi_inet_addr+0x3a>
			++pcIpAddr;
		} while(c != '.' && c != 0);
	}
	m2m_memcpy((uint8*)&u32IP, au8IP, 4);
	return u32IP;
}
    4062:	b003      	add	sp, #12
    4064:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4066:	46c0      	nop			; (mov r8, r8)
    4068:	000021c9 	.word	0x000021c9

0000406c <gethostbyname>:

Date
		4 June 2012
*********************************************************************/
sint8 gethostbyname(uint8 * pcHostName)
{
    406c:	b510      	push	{r4, lr}
    406e:	b084      	sub	sp, #16
    4070:	1c04      	adds	r4, r0, #0
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
	uint8	u8HostNameSize = (uint8)m2m_strlen(pcHostName);
    4072:	4b0c      	ldr	r3, [pc, #48]	; (40a4 <gethostbyname+0x38>)
    4074:	4798      	blx	r3
	if(u8HostNameSize <= HOSTNAME_MAX_SIZE)
    4076:	b2c3      	uxtb	r3, r0
    4078:	2b40      	cmp	r3, #64	; 0x40
    407a:	d80f      	bhi.n	409c <gethostbyname+0x30>
	{
		s8Err = SOCKET_REQUEST(SOCKET_CMD_DNS_RESOLVE|M2M_REQ_DATA_PKT, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
    407c:	23ff      	movs	r3, #255	; 0xff
    407e:	4018      	ands	r0, r3
    4080:	1c43      	adds	r3, r0, #1
    4082:	2200      	movs	r2, #0
    4084:	9200      	str	r2, [sp, #0]
    4086:	9201      	str	r2, [sp, #4]
    4088:	9202      	str	r2, [sp, #8]
    408a:	2002      	movs	r0, #2
    408c:	21ca      	movs	r1, #202	; 0xca
    408e:	1c22      	adds	r2, r4, #0
    4090:	4c05      	ldr	r4, [pc, #20]	; (40a8 <gethostbyname+0x3c>)
    4092:	47a0      	blx	r4
		if(s8Err != SOCK_ERR_NO_ERROR)
    4094:	2800      	cmp	r0, #0
    4096:	d002      	beq.n	409e <gethostbyname+0x32>
		{
			s8Err = SOCK_ERR_INVALID;
    4098:	20f7      	movs	r0, #247	; 0xf7
    409a:	e000      	b.n	409e <gethostbyname+0x32>
Date
		4 June 2012
*********************************************************************/
sint8 gethostbyname(uint8 * pcHostName)
{
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
    409c:	20fa      	movs	r0, #250	; 0xfa
		if(s8Err != SOCK_ERR_NO_ERROR)
		{
			s8Err = SOCK_ERR_INVALID;
		}
	}
	return s8Err;
    409e:	b240      	sxtb	r0, r0
}
    40a0:	b004      	add	sp, #16
    40a2:	bd10      	pop	{r4, pc}
    40a4:	000021ed 	.word	0x000021ed
    40a8:	00002379 	.word	0x00002379

000040ac <spi_flash_enable>:
/**
 *	@fn		spi_flash_enable
 *	@brief	Enable spi flash operations
 */
sint8 spi_flash_enable(uint8 enable)
{
    40ac:	b570      	push	{r4, r5, r6, lr}
    40ae:	b082      	sub	sp, #8
    40b0:	1c04      	adds	r4, r0, #0
	sint8 s8Ret = M2M_SUCCESS;
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    40b2:	4b29      	ldr	r3, [pc, #164]	; (4158 <spi_flash_enable+0xac>)
    40b4:	4798      	blx	r3
    40b6:	0500      	lsls	r0, r0, #20
    40b8:	0d00      	lsrs	r0, r0, #20
 *	@fn		spi_flash_enable
 *	@brief	Enable spi flash operations
 */
sint8 spi_flash_enable(uint8 enable)
{
	sint8 s8Ret = M2M_SUCCESS;
    40ba:	2500      	movs	r5, #0
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    40bc:	4b27      	ldr	r3, [pc, #156]	; (415c <spi_flash_enable+0xb0>)
    40be:	4298      	cmp	r0, r3
    40c0:	d947      	bls.n	4152 <spi_flash_enable+0xa6>
		uint32 u32Val;
		
		/* Enable pinmux to SPI flash. */
		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
    40c2:	4827      	ldr	r0, [pc, #156]	; (4160 <spi_flash_enable+0xb4>)
    40c4:	a901      	add	r1, sp, #4
    40c6:	4b27      	ldr	r3, [pc, #156]	; (4164 <spi_flash_enable+0xb8>)
    40c8:	4798      	blx	r3
    40ca:	1e05      	subs	r5, r0, #0
		if(s8Ret != M2M_SUCCESS) {
    40cc:	d141      	bne.n	4152 <spi_flash_enable+0xa6>
			goto ERR1;
		}
		/* GPIO15/16/17/18 */
		u32Val &= ~((0x7777ul) << 12);
    40ce:	4926      	ldr	r1, [pc, #152]	; (4168 <spi_flash_enable+0xbc>)
    40d0:	9b01      	ldr	r3, [sp, #4]
    40d2:	4019      	ands	r1, r3
		u32Val |= ((0x1111ul) << 12);
    40d4:	4b25      	ldr	r3, [pc, #148]	; (416c <spi_flash_enable+0xc0>)
    40d6:	4319      	orrs	r1, r3
    40d8:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    40da:	4821      	ldr	r0, [pc, #132]	; (4160 <spi_flash_enable+0xb4>)
    40dc:	4b24      	ldr	r3, [pc, #144]	; (4170 <spi_flash_enable+0xc4>)
    40de:	4798      	blx	r3
		if(enable) {
    40e0:	2c00      	cmp	r4, #0
    40e2:	d016      	beq.n	4112 <spi_flash_enable+0x66>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xab;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    40e4:	4823      	ldr	r0, [pc, #140]	; (4174 <spi_flash_enable+0xc8>)
    40e6:	2100      	movs	r1, #0
    40e8:	4c21      	ldr	r4, [pc, #132]	; (4170 <spi_flash_enable+0xc4>)
    40ea:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    40ec:	4822      	ldr	r0, [pc, #136]	; (4178 <spi_flash_enable+0xcc>)
    40ee:	21ab      	movs	r1, #171	; 0xab
    40f0:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    40f2:	4822      	ldr	r0, [pc, #136]	; (417c <spi_flash_enable+0xd0>)
    40f4:	2101      	movs	r1, #1
    40f6:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    40f8:	4821      	ldr	r0, [pc, #132]	; (4180 <spi_flash_enable+0xd4>)
    40fa:	2100      	movs	r1, #0
    40fc:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT,  1 | (1 << 7));
    40fe:	4821      	ldr	r0, [pc, #132]	; (4184 <spi_flash_enable+0xd8>)
    4100:	2181      	movs	r1, #129	; 0x81
    4102:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    4104:	4e20      	ldr	r6, [pc, #128]	; (4188 <spi_flash_enable+0xdc>)
    4106:	4c21      	ldr	r4, [pc, #132]	; (418c <spi_flash_enable+0xe0>)
    4108:	1c30      	adds	r0, r6, #0
    410a:	47a0      	blx	r4
    410c:	2801      	cmp	r0, #1
    410e:	d1fb      	bne.n	4108 <spi_flash_enable+0x5c>
    4110:	e015      	b.n	413e <spi_flash_enable+0x92>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xb9;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    4112:	4818      	ldr	r0, [pc, #96]	; (4174 <spi_flash_enable+0xc8>)
    4114:	2100      	movs	r1, #0
    4116:	4c16      	ldr	r4, [pc, #88]	; (4170 <spi_flash_enable+0xc4>)
    4118:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    411a:	4817      	ldr	r0, [pc, #92]	; (4178 <spi_flash_enable+0xcc>)
    411c:	21b9      	movs	r1, #185	; 0xb9
    411e:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    4120:	4816      	ldr	r0, [pc, #88]	; (417c <spi_flash_enable+0xd0>)
    4122:	2101      	movs	r1, #1
    4124:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    4126:	4816      	ldr	r0, [pc, #88]	; (4180 <spi_flash_enable+0xd4>)
    4128:	2100      	movs	r1, #0
    412a:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1 << 7));
    412c:	4815      	ldr	r0, [pc, #84]	; (4184 <spi_flash_enable+0xd8>)
    412e:	2181      	movs	r1, #129	; 0x81
    4130:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    4132:	4e15      	ldr	r6, [pc, #84]	; (4188 <spi_flash_enable+0xdc>)
    4134:	4c15      	ldr	r4, [pc, #84]	; (418c <spi_flash_enable+0xe0>)
    4136:	1c30      	adds	r0, r6, #0
    4138:	47a0      	blx	r4
    413a:	2801      	cmp	r0, #1
    413c:	d1fb      	bne.n	4136 <spi_flash_enable+0x8a>
			spi_flash_leave_low_power_mode();
		} else {
			spi_flash_enter_low_power_mode();
		}
		/* Disable pinmux to SPI flash to minimize leakage. */
		u32Val &= ~((0x7777ul) << 12);
    413e:	490a      	ldr	r1, [pc, #40]	; (4168 <spi_flash_enable+0xbc>)
    4140:	9b01      	ldr	r3, [sp, #4]
    4142:	4019      	ands	r1, r3
		u32Val |= ((0x0010ul) << 12);
    4144:	2380      	movs	r3, #128	; 0x80
    4146:	025b      	lsls	r3, r3, #9
    4148:	4319      	orrs	r1, r3
    414a:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    414c:	4804      	ldr	r0, [pc, #16]	; (4160 <spi_flash_enable+0xb4>)
    414e:	4b08      	ldr	r3, [pc, #32]	; (4170 <spi_flash_enable+0xc4>)
    4150:	4798      	blx	r3
	}
ERR1:
	return s8Ret;
    4152:	b268      	sxtb	r0, r5
}
    4154:	b002      	add	sp, #8
    4156:	bd70      	pop	{r4, r5, r6, pc}
    4158:	00002e1d 	.word	0x00002e1d
    415c:	0000039f 	.word	0x0000039f
    4160:	00001410 	.word	0x00001410
    4164:	000030bd 	.word	0x000030bd
    4168:	f8888fff 	.word	0xf8888fff
    416c:	01111000 	.word	0x01111000
    4170:	000030c9 	.word	0x000030c9
    4174:	00010208 	.word	0x00010208
    4178:	0001020c 	.word	0x0001020c
    417c:	00010214 	.word	0x00010214
    4180:	0001021c 	.word	0x0001021c
    4184:	00010204 	.word	0x00010204
    4188:	00010218 	.word	0x00010218
    418c:	000030b1 	.word	0x000030b1

00004190 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    4190:	4b0c      	ldr	r3, [pc, #48]	; (41c4 <cpu_irq_enter_critical+0x34>)
    4192:	681b      	ldr	r3, [r3, #0]
    4194:	2b00      	cmp	r3, #0
    4196:	d110      	bne.n	41ba <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    4198:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    419c:	2b00      	cmp	r3, #0
    419e:	d109      	bne.n	41b4 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    41a0:	b672      	cpsid	i
    41a2:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    41a6:	2200      	movs	r2, #0
    41a8:	4b07      	ldr	r3, [pc, #28]	; (41c8 <cpu_irq_enter_critical+0x38>)
    41aa:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    41ac:	3201      	adds	r2, #1
    41ae:	4b07      	ldr	r3, [pc, #28]	; (41cc <cpu_irq_enter_critical+0x3c>)
    41b0:	701a      	strb	r2, [r3, #0]
    41b2:	e002      	b.n	41ba <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    41b4:	2200      	movs	r2, #0
    41b6:	4b05      	ldr	r3, [pc, #20]	; (41cc <cpu_irq_enter_critical+0x3c>)
    41b8:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    41ba:	4a02      	ldr	r2, [pc, #8]	; (41c4 <cpu_irq_enter_critical+0x34>)
    41bc:	6813      	ldr	r3, [r2, #0]
    41be:	3301      	adds	r3, #1
    41c0:	6013      	str	r3, [r2, #0]
}
    41c2:	4770      	bx	lr
    41c4:	2000015c 	.word	0x2000015c
    41c8:	20000020 	.word	0x20000020
    41cc:	20000160 	.word	0x20000160

000041d0 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    41d0:	4b08      	ldr	r3, [pc, #32]	; (41f4 <cpu_irq_leave_critical+0x24>)
    41d2:	681a      	ldr	r2, [r3, #0]
    41d4:	3a01      	subs	r2, #1
    41d6:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    41d8:	681b      	ldr	r3, [r3, #0]
    41da:	2b00      	cmp	r3, #0
    41dc:	d109      	bne.n	41f2 <cpu_irq_leave_critical+0x22>
    41de:	4b06      	ldr	r3, [pc, #24]	; (41f8 <cpu_irq_leave_critical+0x28>)
    41e0:	781b      	ldrb	r3, [r3, #0]
    41e2:	2b00      	cmp	r3, #0
    41e4:	d005      	beq.n	41f2 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    41e6:	2201      	movs	r2, #1
    41e8:	4b04      	ldr	r3, [pc, #16]	; (41fc <cpu_irq_leave_critical+0x2c>)
    41ea:	701a      	strb	r2, [r3, #0]
    41ec:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    41f0:	b662      	cpsie	i
	}
}
    41f2:	4770      	bx	lr
    41f4:	2000015c 	.word	0x2000015c
    41f8:	20000160 	.word	0x20000160
    41fc:	20000020 	.word	0x20000020

00004200 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    4200:	b5f0      	push	{r4, r5, r6, r7, lr}
    4202:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    4204:	ac01      	add	r4, sp, #4
    4206:	2501      	movs	r5, #1
    4208:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    420a:	2700      	movs	r7, #0
    420c:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    420e:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    4210:	2017      	movs	r0, #23
    4212:	1c21      	adds	r1, r4, #0
    4214:	4e06      	ldr	r6, [pc, #24]	; (4230 <system_board_init+0x30>)
    4216:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    4218:	2280      	movs	r2, #128	; 0x80
    421a:	0412      	lsls	r2, r2, #16
    421c:	4b05      	ldr	r3, [pc, #20]	; (4234 <system_board_init+0x34>)
    421e:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    4220:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    4222:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    4224:	2037      	movs	r0, #55	; 0x37
    4226:	1c21      	adds	r1, r4, #0
    4228:	47b0      	blx	r6
}
    422a:	b003      	add	sp, #12
    422c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    422e:	46c0      	nop			; (mov r8, r8)
    4230:	0000441d 	.word	0x0000441d
    4234:	41004400 	.word	0x41004400

00004238 <extint_register_callback>:
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    4238:	2317      	movs	r3, #23
	const enum extint_callback_type type)
{
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
    423a:	2a00      	cmp	r2, #0
    423c:	d10d      	bne.n	425a <extint_register_callback+0x22>
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	if (_extint_dev.callbacks[channel] == NULL) {
    423e:	008b      	lsls	r3, r1, #2
    4240:	4a07      	ldr	r2, [pc, #28]	; (4260 <extint_register_callback+0x28>)
    4242:	589b      	ldr	r3, [r3, r2]
    4244:	2b00      	cmp	r3, #0
    4246:	d103      	bne.n	4250 <extint_register_callback+0x18>
		_extint_dev.callbacks[channel] = callback;
    4248:	0089      	lsls	r1, r1, #2
    424a:	5088      	str	r0, [r1, r2]
		return STATUS_OK;
    424c:	2300      	movs	r3, #0
    424e:	e004      	b.n	425a <extint_register_callback+0x22>
	} else if (_extint_dev.callbacks[channel] == callback) {
    4250:	4283      	cmp	r3, r0
    4252:	d001      	beq.n	4258 <extint_register_callback+0x20>
		return STATUS_OK;
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
    4254:	231d      	movs	r3, #29
    4256:	e000      	b.n	425a <extint_register_callback+0x22>

	if (_extint_dev.callbacks[channel] == NULL) {
		_extint_dev.callbacks[channel] = callback;
		return STATUS_OK;
	} else if (_extint_dev.callbacks[channel] == callback) {
		return STATUS_OK;
    4258:	2300      	movs	r3, #0
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
}
    425a:	1c18      	adds	r0, r3, #0
    425c:	4770      	bx	lr
    425e:	46c0      	nop			; (mov r8, r8)
    4260:	200016dc 	.word	0x200016dc

00004264 <extint_chan_enable_callback>:

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    4264:	2317      	movs	r3, #23
 */
enum status_code extint_chan_enable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    4266:	2900      	cmp	r1, #0
    4268:	d107      	bne.n	427a <extint_chan_enable_callback+0x16>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    426a:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    426c:	281f      	cmp	r0, #31
    426e:	d800      	bhi.n	4272 <extint_chan_enable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    4270:	4a03      	ldr	r2, [pc, #12]	; (4280 <extint_chan_enable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENSET.reg = (1UL << channel);
    4272:	2301      	movs	r3, #1
    4274:	4083      	lsls	r3, r0
    4276:	60d3      	str	r3, [r2, #12]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    4278:	2300      	movs	r3, #0
}
    427a:	1c18      	adds	r0, r3, #0
    427c:	4770      	bx	lr
    427e:	46c0      	nop			; (mov r8, r8)
    4280:	40001800 	.word	0x40001800

00004284 <extint_chan_disable_callback>:

		eic->INTENCLR.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    4284:	2317      	movs	r3, #23
 */
enum status_code extint_chan_disable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    4286:	2900      	cmp	r1, #0
    4288:	d107      	bne.n	429a <extint_chan_disable_callback+0x16>
	} else {
		Assert(false);
		return NULL;
    428a:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    428c:	281f      	cmp	r0, #31
    428e:	d800      	bhi.n	4292 <extint_chan_disable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    4290:	4a03      	ldr	r2, [pc, #12]	; (42a0 <extint_chan_disable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENCLR.reg = (1UL << channel);
    4292:	2301      	movs	r3, #1
    4294:	4083      	lsls	r3, r0
    4296:	6093      	str	r3, [r2, #8]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    4298:	2300      	movs	r3, #0
}
    429a:	1c18      	adds	r0, r3, #0
    429c:	4770      	bx	lr
    429e:	46c0      	nop			; (mov r8, r8)
    42a0:	40001800 	.word	0x40001800

000042a4 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    42a4:	b570      	push	{r4, r5, r6, lr}
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    42a6:	2200      	movs	r2, #0
    42a8:	4b15      	ldr	r3, [pc, #84]	; (4300 <EIC_Handler+0x5c>)
    42aa:	701a      	strb	r2, [r3, #0]
    42ac:	2300      	movs	r3, #0
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    42ae:	251f      	movs	r5, #31
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    42b0:	4e14      	ldr	r6, [pc, #80]	; (4304 <EIC_Handler+0x60>)

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    42b2:	4c13      	ldr	r4, [pc, #76]	; (4300 <EIC_Handler+0x5c>)
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    42b4:	2b1f      	cmp	r3, #31
    42b6:	d919      	bls.n	42ec <EIC_Handler+0x48>
    42b8:	e00f      	b.n	42da <EIC_Handler+0x36>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    42ba:	2100      	movs	r1, #0
    42bc:	e000      	b.n	42c0 <EIC_Handler+0x1c>

	if (eic_index < EIC_INST_NUM) {
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    42be:	4912      	ldr	r1, [pc, #72]	; (4308 <EIC_Handler+0x64>)
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
    42c0:	610a      	str	r2, [r1, #16]
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    42c2:	009b      	lsls	r3, r3, #2
    42c4:	599b      	ldr	r3, [r3, r6]
    42c6:	2b00      	cmp	r3, #0
    42c8:	d000      	beq.n	42cc <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    42ca:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    42cc:	7823      	ldrb	r3, [r4, #0]
    42ce:	3301      	adds	r3, #1
    42d0:	b2db      	uxtb	r3, r3
    42d2:	7023      	strb	r3, [r4, #0]
    42d4:	2b0f      	cmp	r3, #15
    42d6:	d9ed      	bls.n	42b4 <EIC_Handler+0x10>
    42d8:	e011      	b.n	42fe <EIC_Handler+0x5a>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    42da:	1c29      	adds	r1, r5, #0
    42dc:	4019      	ands	r1, r3
    42de:	2201      	movs	r2, #1
    42e0:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    42e2:	2100      	movs	r1, #0
    42e4:	6909      	ldr	r1, [r1, #16]
		if (extint_chan_is_detected(_current_channel)) {
    42e6:	4211      	tst	r1, r2
    42e8:	d1e7      	bne.n	42ba <EIC_Handler+0x16>
    42ea:	e7ef      	b.n	42cc <EIC_Handler+0x28>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    42ec:	1c29      	adds	r1, r5, #0
    42ee:	4019      	ands	r1, r3
    42f0:	2201      	movs	r2, #1
    42f2:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    42f4:	4904      	ldr	r1, [pc, #16]	; (4308 <EIC_Handler+0x64>)
    42f6:	6909      	ldr	r1, [r1, #16]
    42f8:	4211      	tst	r1, r2
    42fa:	d1e0      	bne.n	42be <EIC_Handler+0x1a>
    42fc:	e7e6      	b.n	42cc <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
    42fe:	bd70      	pop	{r4, r5, r6, pc}
    4300:	200016d8 	.word	0x200016d8
    4304:	200016dc 	.word	0x200016dc
    4308:	40001800 	.word	0x40001800

0000430c <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    430c:	4a04      	ldr	r2, [pc, #16]	; (4320 <_extint_enable+0x14>)
    430e:	7811      	ldrb	r1, [r2, #0]
    4310:	2302      	movs	r3, #2
    4312:	430b      	orrs	r3, r1
    4314:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    4316:	7853      	ldrb	r3, [r2, #1]
    4318:	b25b      	sxtb	r3, r3
    431a:	2b00      	cmp	r3, #0
    431c:	dbfb      	blt.n	4316 <_extint_enable+0xa>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    431e:	4770      	bx	lr
    4320:	40001800 	.word	0x40001800

00004324 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    4324:	b500      	push	{lr}
    4326:	b083      	sub	sp, #12
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    4328:	4a12      	ldr	r2, [pc, #72]	; (4374 <_system_extint_init+0x50>)
    432a:	6991      	ldr	r1, [r2, #24]
    432c:	2340      	movs	r3, #64	; 0x40
    432e:	430b      	orrs	r3, r1
    4330:	6193      	str	r3, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    4332:	a901      	add	r1, sp, #4
    4334:	2300      	movs	r3, #0
    4336:	700b      	strb	r3, [r1, #0]

	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    4338:	2005      	movs	r0, #5
    433a:	4b0f      	ldr	r3, [pc, #60]	; (4378 <_system_extint_init+0x54>)
    433c:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    433e:	2005      	movs	r0, #5
    4340:	4b0e      	ldr	r3, [pc, #56]	; (437c <_system_extint_init+0x58>)
    4342:	4798      	blx	r3

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    4344:	4a0e      	ldr	r2, [pc, #56]	; (4380 <_system_extint_init+0x5c>)
    4346:	7811      	ldrb	r1, [r2, #0]
    4348:	2301      	movs	r3, #1
    434a:	430b      	orrs	r3, r1
    434c:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    434e:	7853      	ldrb	r3, [r2, #1]
    4350:	b25b      	sxtb	r3, r3
    4352:	2b00      	cmp	r3, #0
    4354:	dbfb      	blt.n	434e <_system_extint_init+0x2a>
    4356:	4b0b      	ldr	r3, [pc, #44]	; (4384 <_system_extint_init+0x60>)
    4358:	1c19      	adds	r1, r3, #0
    435a:	3140      	adds	r1, #64	; 0x40

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
		_extint_dev.callbacks[j] = NULL;
    435c:	2200      	movs	r2, #0
    435e:	c304      	stmia	r3!, {r2}
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    4360:	428b      	cmp	r3, r1
    4362:	d1fc      	bne.n	435e <_system_extint_init+0x3a>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    4364:	2210      	movs	r2, #16
    4366:	4b08      	ldr	r3, [pc, #32]	; (4388 <_system_extint_init+0x64>)
    4368:	601a      	str	r2, [r3, #0]
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
#endif

	/* Enables the driver for further use */
	_extint_enable();
    436a:	4b08      	ldr	r3, [pc, #32]	; (438c <_system_extint_init+0x68>)
    436c:	4798      	blx	r3
}
    436e:	b003      	add	sp, #12
    4370:	bd00      	pop	{pc}
    4372:	46c0      	nop			; (mov r8, r8)
    4374:	40000400 	.word	0x40000400
    4378:	00005a2d 	.word	0x00005a2d
    437c:	000059a1 	.word	0x000059a1
    4380:	40001800 	.word	0x40001800
    4384:	200016dc 	.word	0x200016dc
    4388:	e000e100 	.word	0xe000e100
    438c:	0000430d 	.word	0x0000430d

00004390 <extint_chan_get_config_defaults>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
    4390:	2300      	movs	r3, #0
    4392:	6003      	str	r3, [r0, #0]
	config->gpio_pin_mux        = 0;
    4394:	6043      	str	r3, [r0, #4]
	config->gpio_pin_pull       = EXTINT_PULL_UP;
    4396:	2201      	movs	r2, #1
    4398:	7202      	strb	r2, [r0, #8]
	config->wake_if_sleeping    = true;
    439a:	7242      	strb	r2, [r0, #9]
	config->filter_input_signal = false;
    439c:	7283      	strb	r3, [r0, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
    439e:	3302      	adds	r3, #2
    43a0:	72c3      	strb	r3, [r0, #11]
}
    43a2:	4770      	bx	lr

000043a4 <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
    43a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    43a6:	b083      	sub	sp, #12
    43a8:	1c05      	adds	r5, r0, #0
    43aa:	1c0c      	adds	r4, r1, #0
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    43ac:	a901      	add	r1, sp, #4
    43ae:	2300      	movs	r3, #0
    43b0:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    43b2:	70cb      	strb	r3, [r1, #3]
			config->detection_criteria)));

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = config->gpio_pin_mux;
    43b4:	7923      	ldrb	r3, [r4, #4]
    43b6:	700b      	strb	r3, [r1, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
    43b8:	7a23      	ldrb	r3, [r4, #8]
    43ba:	708b      	strb	r3, [r1, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
    43bc:	7820      	ldrb	r0, [r4, #0]
    43be:	4b15      	ldr	r3, [pc, #84]	; (4414 <extint_chan_set_config+0x70>)
    43c0:	4798      	blx	r3
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    43c2:	2600      	movs	r6, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    43c4:	2d1f      	cmp	r5, #31
    43c6:	d800      	bhi.n	43ca <extint_chan_set_config+0x26>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    43c8:	4e13      	ldr	r6, [pc, #76]	; (4418 <extint_chan_set_config+0x74>)

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);

	uint32_t config_pos = (4 * (channel % 8));
    43ca:	2207      	movs	r2, #7
    43cc:	402a      	ands	r2, r5
    43ce:	0092      	lsls	r2, r2, #2
	uint32_t new_config;

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
    43d0:	7ae0      	ldrb	r0, [r4, #11]

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
    43d2:	7aa3      	ldrb	r3, [r4, #10]
    43d4:	2b00      	cmp	r3, #0
    43d6:	d001      	beq.n	43dc <extint_chan_set_config+0x38>
		new_config |= EIC_CONFIG_FILTEN0;
    43d8:	2308      	movs	r3, #8
    43da:	4318      	orrs	r0, r3
    43dc:	08eb      	lsrs	r3, r5, #3
    43de:	009b      	lsls	r3, r3, #2
    43e0:	18f3      	adds	r3, r6, r3
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    43e2:	6999      	ldr	r1, [r3, #24]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);
    43e4:	4090      	lsls	r0, r2
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    43e6:	270f      	movs	r7, #15
    43e8:	4097      	lsls	r7, r2
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    43ea:	43b9      	bics	r1, r7
    43ec:	1c0a      	adds	r2, r1, #0
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    43ee:	4302      	orrs	r2, r0
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    43f0:	619a      	str	r2, [r3, #24]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
    43f2:	7a63      	ldrb	r3, [r4, #9]
    43f4:	2b00      	cmp	r3, #0
    43f6:	d006      	beq.n	4406 <extint_chan_set_config+0x62>
		EIC_module->WAKEUP.reg |=  (1UL << channel);
    43f8:	6973      	ldr	r3, [r6, #20]
    43fa:	2201      	movs	r2, #1
    43fc:	40aa      	lsls	r2, r5
    43fe:	1c15      	adds	r5, r2, #0
    4400:	431d      	orrs	r5, r3
    4402:	6175      	str	r5, [r6, #20]
    4404:	e004      	b.n	4410 <extint_chan_set_config+0x6c>
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
    4406:	6973      	ldr	r3, [r6, #20]
    4408:	2201      	movs	r2, #1
    440a:	40aa      	lsls	r2, r5
    440c:	4393      	bics	r3, r2
    440e:	6173      	str	r3, [r6, #20]
	}
}
    4410:	b003      	add	sp, #12
    4412:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4414:	00005b25 	.word	0x00005b25
    4418:	40001800 	.word	0x40001800

0000441c <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    441c:	b500      	push	{lr}
    441e:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    4420:	ab01      	add	r3, sp, #4
    4422:	2280      	movs	r2, #128	; 0x80
    4424:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    4426:	780a      	ldrb	r2, [r1, #0]
    4428:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    442a:	784a      	ldrb	r2, [r1, #1]
    442c:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    442e:	788a      	ldrb	r2, [r1, #2]
    4430:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    4432:	1c19      	adds	r1, r3, #0
    4434:	4b01      	ldr	r3, [pc, #4]	; (443c <port_pin_set_config+0x20>)
    4436:	4798      	blx	r3
}
    4438:	b003      	add	sp, #12
    443a:	bd00      	pop	{pc}
    443c:	00005b25 	.word	0x00005b25

00004440 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    4440:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    4442:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    4444:	2440      	movs	r4, #64	; 0x40
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    4446:	4281      	cmp	r1, r0
    4448:	d30c      	bcc.n	4464 <_sercom_get_sync_baud_val+0x24>
    444a:	2300      	movs	r3, #0
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
    444c:	1a09      	subs	r1, r1, r0
		baud_calculated++;
    444e:	3301      	adds	r3, #1
    4450:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
    4452:	4288      	cmp	r0, r1
    4454:	d9fa      	bls.n	444c <_sercom_get_sync_baud_val+0xc>
		clock_value = clock_value - baudrate;
		baud_calculated++;
	}
	baud_calculated = baud_calculated - 1;
    4456:	3b01      	subs	r3, #1
    4458:	b29b      	uxth	r3, r3

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    445a:	2440      	movs	r4, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
    445c:	2bff      	cmp	r3, #255	; 0xff
    445e:	d801      	bhi.n	4464 <_sercom_get_sync_baud_val+0x24>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
    4460:	8013      	strh	r3, [r2, #0]
		return STATUS_OK;
    4462:	2400      	movs	r4, #0
	}
}
    4464:	1c20      	adds	r0, r4, #0
    4466:	bd10      	pop	{r4, pc}

00004468 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    4468:	b5f0      	push	{r4, r5, r6, r7, lr}
    446a:	465f      	mov	r7, fp
    446c:	4656      	mov	r6, sl
    446e:	464d      	mov	r5, r9
    4470:	4644      	mov	r4, r8
    4472:	b4f0      	push	{r4, r5, r6, r7}
    4474:	b089      	sub	sp, #36	; 0x24
    4476:	1c1c      	adds	r4, r3, #0
    4478:	ab12      	add	r3, sp, #72	; 0x48
    447a:	781b      	ldrb	r3, [r3, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    447c:	1c06      	adds	r6, r0, #0
    447e:	435e      	muls	r6, r3
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    4480:	2540      	movs	r5, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    4482:	428e      	cmp	r6, r1
    4484:	d900      	bls.n	4488 <_sercom_get_async_baud_val+0x20>
    4486:	e0c7      	b.n	4618 <_sercom_get_async_baud_val+0x1b0>
    4488:	1c25      	adds	r5, r4, #0
    448a:	9207      	str	r2, [sp, #28]
    448c:	1c0c      	adds	r4, r1, #0
    448e:	1c02      	adds	r2, r0, #0
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    4490:	2d00      	cmp	r5, #0
    4492:	d151      	bne.n	4538 <_sercom_get_async_baud_val+0xd0>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    4494:	1c18      	adds	r0, r3, #0
    4496:	2100      	movs	r1, #0
    4498:	2300      	movs	r3, #0
    449a:	4d63      	ldr	r5, [pc, #396]	; (4628 <_sercom_get_async_baud_val+0x1c0>)
    449c:	47a8      	blx	r5
    449e:	4683      	mov	fp, r0
		ratio = long_division(temp1, peripheral_clock);
    44a0:	1c26      	adds	r6, r4, #0
    44a2:	2700      	movs	r7, #0
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    44a4:	2300      	movs	r3, #0
    44a6:	2400      	movs	r4, #0
    44a8:	9302      	str	r3, [sp, #8]
    44aa:	9403      	str	r4, [sp, #12]
    44ac:	2200      	movs	r2, #0
    44ae:	2300      	movs	r3, #0
	for (i = 63; i >= 0; i--) {
    44b0:	203f      	movs	r0, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
    44b2:	2120      	movs	r1, #32
    44b4:	468c      	mov	ip, r1
    44b6:	391f      	subs	r1, #31
    44b8:	9600      	str	r6, [sp, #0]
    44ba:	9701      	str	r7, [sp, #4]
    44bc:	2420      	movs	r4, #32
    44be:	4264      	negs	r4, r4
    44c0:	1904      	adds	r4, r0, r4
    44c2:	d403      	bmi.n	44cc <_sercom_get_async_baud_val+0x64>
    44c4:	1c0d      	adds	r5, r1, #0
    44c6:	40a5      	lsls	r5, r4
    44c8:	46a8      	mov	r8, r5
    44ca:	e004      	b.n	44d6 <_sercom_get_async_baud_val+0x6e>
    44cc:	4664      	mov	r4, ip
    44ce:	1a24      	subs	r4, r4, r0
    44d0:	1c0d      	adds	r5, r1, #0
    44d2:	40e5      	lsrs	r5, r4
    44d4:	46a8      	mov	r8, r5
    44d6:	1c0c      	adds	r4, r1, #0
    44d8:	4084      	lsls	r4, r0
    44da:	46a1      	mov	r9, r4

		r = r << 1;
    44dc:	1c14      	adds	r4, r2, #0
    44de:	1c1d      	adds	r5, r3, #0
    44e0:	18a4      	adds	r4, r4, r2
    44e2:	415d      	adcs	r5, r3
    44e4:	1c22      	adds	r2, r4, #0
    44e6:	1c2b      	adds	r3, r5, #0

		if (n & bit_shift) {
    44e8:	465e      	mov	r6, fp
    44ea:	4647      	mov	r7, r8
    44ec:	423e      	tst	r6, r7
    44ee:	d003      	beq.n	44f8 <_sercom_get_async_baud_val+0x90>
			r |= 0x01;
    44f0:	1c0e      	adds	r6, r1, #0
    44f2:	4326      	orrs	r6, r4
    44f4:	1c32      	adds	r2, r6, #0
    44f6:	1c2b      	adds	r3, r5, #0
		}

		if (r >= d) {
    44f8:	9c01      	ldr	r4, [sp, #4]
    44fa:	429c      	cmp	r4, r3
    44fc:	d810      	bhi.n	4520 <_sercom_get_async_baud_val+0xb8>
    44fe:	d102      	bne.n	4506 <_sercom_get_async_baud_val+0x9e>
    4500:	9c00      	ldr	r4, [sp, #0]
    4502:	4294      	cmp	r4, r2
    4504:	d80c      	bhi.n	4520 <_sercom_get_async_baud_val+0xb8>
			r = r - d;
    4506:	9c00      	ldr	r4, [sp, #0]
    4508:	9d01      	ldr	r5, [sp, #4]
    450a:	1b12      	subs	r2, r2, r4
    450c:	41ab      	sbcs	r3, r5
			q |= bit_shift;
    450e:	464d      	mov	r5, r9
    4510:	9e02      	ldr	r6, [sp, #8]
    4512:	9f03      	ldr	r7, [sp, #12]
    4514:	4335      	orrs	r5, r6
    4516:	1c3c      	adds	r4, r7, #0
    4518:	4646      	mov	r6, r8
    451a:	4334      	orrs	r4, r6
    451c:	9502      	str	r5, [sp, #8]
    451e:	9403      	str	r4, [sp, #12]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    4520:	3801      	subs	r0, #1
    4522:	d2cb      	bcs.n	44bc <_sercom_get_async_baud_val+0x54>

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
    4524:	2200      	movs	r2, #0
    4526:	2301      	movs	r3, #1
    4528:	9802      	ldr	r0, [sp, #8]
    452a:	9903      	ldr	r1, [sp, #12]
    452c:	1a12      	subs	r2, r2, r0
    452e:	418b      	sbcs	r3, r1
		baud_calculated = (65536 * scale) >> SHIFT;
    4530:	0c11      	lsrs	r1, r2, #16
    4532:	041b      	lsls	r3, r3, #16
    4534:	4319      	orrs	r1, r3
    4536:	e06c      	b.n	4612 <_sercom_get_async_baud_val+0x1aa>
		enum sercom_asynchronous_sample_num sample_num)
{
	/* Temporary variables  */
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
    4538:	2100      	movs	r1, #0
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    453a:	2d01      	cmp	r5, #1
    453c:	d169      	bne.n	4612 <_sercom_get_async_baud_val+0x1aa>
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
    453e:	0f61      	lsrs	r1, r4, #29
    4540:	1c0f      	adds	r7, r1, #0
    4542:	00e1      	lsls	r1, r4, #3
    4544:	4688      	mov	r8, r1
			temp2 = ((uint64_t)baudrate * sample_num);
    4546:	1c18      	adds	r0, r3, #0
    4548:	2100      	movs	r1, #0
    454a:	2300      	movs	r3, #0
    454c:	4c36      	ldr	r4, [pc, #216]	; (4628 <_sercom_get_async_baud_val+0x1c0>)
    454e:	47a0      	blx	r4
    4550:	1c04      	adds	r4, r0, #0
    4552:	1c0d      	adds	r5, r1, #0
    4554:	2300      	movs	r3, #0
    4556:	469c      	mov	ip, r3
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
		bit_shift = (uint64_t)1 << i;
    4558:	3320      	adds	r3, #32
    455a:	469b      	mov	fp, r3
    455c:	2601      	movs	r6, #1
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
    455e:	4663      	mov	r3, ip
    4560:	9305      	str	r3, [sp, #20]
    4562:	46b9      	mov	r9, r7
    4564:	466b      	mov	r3, sp
    4566:	7d1b      	ldrb	r3, [r3, #20]
    4568:	9306      	str	r3, [sp, #24]
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    456a:	2300      	movs	r3, #0
    456c:	469c      	mov	ip, r3
    456e:	2000      	movs	r0, #0
    4570:	2100      	movs	r1, #0
	for (i = 63; i >= 0; i--) {
    4572:	223f      	movs	r2, #63	; 0x3f
    4574:	9400      	str	r4, [sp, #0]
    4576:	9501      	str	r5, [sp, #4]
		bit_shift = (uint64_t)1 << i;
    4578:	2320      	movs	r3, #32
    457a:	425b      	negs	r3, r3
    457c:	18d3      	adds	r3, r2, r3
    457e:	d403      	bmi.n	4588 <_sercom_get_async_baud_val+0x120>
    4580:	1c34      	adds	r4, r6, #0
    4582:	409c      	lsls	r4, r3
    4584:	1c23      	adds	r3, r4, #0
    4586:	e004      	b.n	4592 <_sercom_get_async_baud_val+0x12a>
    4588:	465b      	mov	r3, fp
    458a:	1a9b      	subs	r3, r3, r2
    458c:	1c34      	adds	r4, r6, #0
    458e:	40dc      	lsrs	r4, r3
    4590:	1c23      	adds	r3, r4, #0
    4592:	1c37      	adds	r7, r6, #0
    4594:	4097      	lsls	r7, r2

		r = r << 1;
    4596:	1c04      	adds	r4, r0, #0
    4598:	1c0d      	adds	r5, r1, #0
    459a:	1824      	adds	r4, r4, r0
    459c:	414d      	adcs	r5, r1
    459e:	1c20      	adds	r0, r4, #0
    45a0:	1c29      	adds	r1, r5, #0
    45a2:	9002      	str	r0, [sp, #8]
    45a4:	9103      	str	r1, [sp, #12]

		if (n & bit_shift) {
    45a6:	4644      	mov	r4, r8
    45a8:	403c      	ands	r4, r7
    45aa:	46a2      	mov	sl, r4
    45ac:	464c      	mov	r4, r9
    45ae:	4023      	ands	r3, r4
    45b0:	4654      	mov	r4, sl
    45b2:	4323      	orrs	r3, r4
    45b4:	d005      	beq.n	45c2 <_sercom_get_async_baud_val+0x15a>
			r |= 0x01;
    45b6:	9b02      	ldr	r3, [sp, #8]
    45b8:	9c03      	ldr	r4, [sp, #12]
    45ba:	1c1d      	adds	r5, r3, #0
    45bc:	4335      	orrs	r5, r6
    45be:	1c28      	adds	r0, r5, #0
    45c0:	1c21      	adds	r1, r4, #0
		}

		if (r >= d) {
    45c2:	9b01      	ldr	r3, [sp, #4]
    45c4:	428b      	cmp	r3, r1
    45c6:	d80a      	bhi.n	45de <_sercom_get_async_baud_val+0x176>
    45c8:	d102      	bne.n	45d0 <_sercom_get_async_baud_val+0x168>
    45ca:	9b00      	ldr	r3, [sp, #0]
    45cc:	4283      	cmp	r3, r0
    45ce:	d806      	bhi.n	45de <_sercom_get_async_baud_val+0x176>
			r = r - d;
    45d0:	9b00      	ldr	r3, [sp, #0]
    45d2:	9c01      	ldr	r4, [sp, #4]
    45d4:	1ac0      	subs	r0, r0, r3
    45d6:	41a1      	sbcs	r1, r4
			q |= bit_shift;
    45d8:	4663      	mov	r3, ip
    45da:	433b      	orrs	r3, r7
    45dc:	469c      	mov	ip, r3
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    45de:	3a01      	subs	r2, #1
    45e0:	d2ca      	bcs.n	4578 <_sercom_get_async_baud_val+0x110>
    45e2:	9c00      	ldr	r4, [sp, #0]
    45e4:	9d01      	ldr	r5, [sp, #4]
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
			temp2 = ((uint64_t)baudrate * sample_num);
			baud_int = long_division(temp1, temp2);
			baud_int -= baud_fp;
    45e6:	4662      	mov	r2, ip
    45e8:	9905      	ldr	r1, [sp, #20]
    45ea:	1a53      	subs	r3, r2, r1
			baud_int = baud_int / BAUD_FP_MAX;
    45ec:	08db      	lsrs	r3, r3, #3
			if(baud_int < BAUD_INT_MAX) {
    45ee:	4a0f      	ldr	r2, [pc, #60]	; (462c <_sercom_get_async_baud_val+0x1c4>)
    45f0:	4293      	cmp	r3, r2
    45f2:	d908      	bls.n	4606 <_sercom_get_async_baud_val+0x19e>
    45f4:	9a06      	ldr	r2, [sp, #24]
    45f6:	3201      	adds	r2, #1
    45f8:	b2d2      	uxtb	r2, r2
    45fa:	9206      	str	r2, [sp, #24]
    45fc:	1c0a      	adds	r2, r1, #0
    45fe:	3201      	adds	r2, #1
    4600:	9205      	str	r2, [sp, #20]
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
    4602:	2a08      	cmp	r2, #8
    4604:	d1ae      	bne.n	4564 <_sercom_get_async_baud_val+0xfc>
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    4606:	2540      	movs	r5, #64	; 0x40
			baud_int = baud_int / BAUD_FP_MAX;
			if(baud_int < BAUD_INT_MAX) {
				break;
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
    4608:	9a06      	ldr	r2, [sp, #24]
    460a:	2a08      	cmp	r2, #8
    460c:	d004      	beq.n	4618 <_sercom_get_async_baud_val+0x1b0>
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
    460e:	0351      	lsls	r1, r2, #13
    4610:	4319      	orrs	r1, r3
	}

	*baudval = baud_calculated;
    4612:	9b07      	ldr	r3, [sp, #28]
    4614:	8019      	strh	r1, [r3, #0]
	return STATUS_OK;
    4616:	2500      	movs	r5, #0
}
    4618:	1c28      	adds	r0, r5, #0
    461a:	b009      	add	sp, #36	; 0x24
    461c:	bc3c      	pop	{r2, r3, r4, r5}
    461e:	4690      	mov	r8, r2
    4620:	4699      	mov	r9, r3
    4622:	46a2      	mov	sl, r4
    4624:	46ab      	mov	fp, r5
    4626:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4628:	0000c0b1 	.word	0x0000c0b1
    462c:	00001fff 	.word	0x00001fff

00004630 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    4630:	b510      	push	{r4, lr}
    4632:	b082      	sub	sp, #8
    4634:	1c04      	adds	r4, r0, #0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    4636:	4b0e      	ldr	r3, [pc, #56]	; (4670 <sercom_set_gclk_generator+0x40>)
    4638:	781b      	ldrb	r3, [r3, #0]
    463a:	2b00      	cmp	r3, #0
    463c:	d001      	beq.n	4642 <sercom_set_gclk_generator+0x12>
    463e:	2900      	cmp	r1, #0
    4640:	d00d      	beq.n	465e <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
    4642:	a901      	add	r1, sp, #4
    4644:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    4646:	2013      	movs	r0, #19
    4648:	4b0a      	ldr	r3, [pc, #40]	; (4674 <sercom_set_gclk_generator+0x44>)
    464a:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    464c:	2013      	movs	r0, #19
    464e:	4b0a      	ldr	r3, [pc, #40]	; (4678 <sercom_set_gclk_generator+0x48>)
    4650:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    4652:	4b07      	ldr	r3, [pc, #28]	; (4670 <sercom_set_gclk_generator+0x40>)
    4654:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    4656:	2201      	movs	r2, #1
    4658:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    465a:	2000      	movs	r0, #0
    465c:	e006      	b.n	466c <sercom_set_gclk_generator+0x3c>
	} else if (generator_source == _sercom_config.generator_source) {
    465e:	4b04      	ldr	r3, [pc, #16]	; (4670 <sercom_set_gclk_generator+0x40>)
    4660:	785b      	ldrb	r3, [r3, #1]
    4662:	4283      	cmp	r3, r0
    4664:	d001      	beq.n	466a <sercom_set_gclk_generator+0x3a>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    4666:	201d      	movs	r0, #29
    4668:	e000      	b.n	466c <sercom_set_gclk_generator+0x3c>
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
    466a:	2000      	movs	r0, #0
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
    466c:	b002      	add	sp, #8
    466e:	bd10      	pop	{r4, pc}
    4670:	20000164 	.word	0x20000164
    4674:	00005a2d 	.word	0x00005a2d
    4678:	000059a1 	.word	0x000059a1

0000467c <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    467c:	4b44      	ldr	r3, [pc, #272]	; (4790 <_sercom_get_default_pad+0x114>)
    467e:	4298      	cmp	r0, r3
    4680:	d033      	beq.n	46ea <_sercom_get_default_pad+0x6e>
    4682:	d806      	bhi.n	4692 <_sercom_get_default_pad+0x16>
    4684:	4b43      	ldr	r3, [pc, #268]	; (4794 <_sercom_get_default_pad+0x118>)
    4686:	4298      	cmp	r0, r3
    4688:	d00d      	beq.n	46a6 <_sercom_get_default_pad+0x2a>
    468a:	4b43      	ldr	r3, [pc, #268]	; (4798 <_sercom_get_default_pad+0x11c>)
    468c:	4298      	cmp	r0, r3
    468e:	d01b      	beq.n	46c8 <_sercom_get_default_pad+0x4c>
    4690:	e06f      	b.n	4772 <_sercom_get_default_pad+0xf6>
    4692:	4b42      	ldr	r3, [pc, #264]	; (479c <_sercom_get_default_pad+0x120>)
    4694:	4298      	cmp	r0, r3
    4696:	d04a      	beq.n	472e <_sercom_get_default_pad+0xb2>
    4698:	4b41      	ldr	r3, [pc, #260]	; (47a0 <_sercom_get_default_pad+0x124>)
    469a:	4298      	cmp	r0, r3
    469c:	d058      	beq.n	4750 <_sercom_get_default_pad+0xd4>
    469e:	4b41      	ldr	r3, [pc, #260]	; (47a4 <_sercom_get_default_pad+0x128>)
    46a0:	4298      	cmp	r0, r3
    46a2:	d166      	bne.n	4772 <_sercom_get_default_pad+0xf6>
    46a4:	e032      	b.n	470c <_sercom_get_default_pad+0x90>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    46a6:	2901      	cmp	r1, #1
    46a8:	d006      	beq.n	46b8 <_sercom_get_default_pad+0x3c>
    46aa:	2900      	cmp	r1, #0
    46ac:	d063      	beq.n	4776 <_sercom_get_default_pad+0xfa>
    46ae:	2902      	cmp	r1, #2
    46b0:	d006      	beq.n	46c0 <_sercom_get_default_pad+0x44>
    46b2:	2903      	cmp	r1, #3
    46b4:	d006      	beq.n	46c4 <_sercom_get_default_pad+0x48>
    46b6:	e001      	b.n	46bc <_sercom_get_default_pad+0x40>
    46b8:	483b      	ldr	r0, [pc, #236]	; (47a8 <_sercom_get_default_pad+0x12c>)
    46ba:	e067      	b.n	478c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    46bc:	2000      	movs	r0, #0
    46be:	e065      	b.n	478c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    46c0:	483a      	ldr	r0, [pc, #232]	; (47ac <_sercom_get_default_pad+0x130>)
    46c2:	e063      	b.n	478c <_sercom_get_default_pad+0x110>
    46c4:	483a      	ldr	r0, [pc, #232]	; (47b0 <_sercom_get_default_pad+0x134>)
    46c6:	e061      	b.n	478c <_sercom_get_default_pad+0x110>
    46c8:	2901      	cmp	r1, #1
    46ca:	d006      	beq.n	46da <_sercom_get_default_pad+0x5e>
    46cc:	2900      	cmp	r1, #0
    46ce:	d054      	beq.n	477a <_sercom_get_default_pad+0xfe>
    46d0:	2902      	cmp	r1, #2
    46d2:	d006      	beq.n	46e2 <_sercom_get_default_pad+0x66>
    46d4:	2903      	cmp	r1, #3
    46d6:	d006      	beq.n	46e6 <_sercom_get_default_pad+0x6a>
    46d8:	e001      	b.n	46de <_sercom_get_default_pad+0x62>
    46da:	4836      	ldr	r0, [pc, #216]	; (47b4 <_sercom_get_default_pad+0x138>)
    46dc:	e056      	b.n	478c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    46de:	2000      	movs	r0, #0
    46e0:	e054      	b.n	478c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    46e2:	4835      	ldr	r0, [pc, #212]	; (47b8 <_sercom_get_default_pad+0x13c>)
    46e4:	e052      	b.n	478c <_sercom_get_default_pad+0x110>
    46e6:	4835      	ldr	r0, [pc, #212]	; (47bc <_sercom_get_default_pad+0x140>)
    46e8:	e050      	b.n	478c <_sercom_get_default_pad+0x110>
    46ea:	2901      	cmp	r1, #1
    46ec:	d006      	beq.n	46fc <_sercom_get_default_pad+0x80>
    46ee:	2900      	cmp	r1, #0
    46f0:	d045      	beq.n	477e <_sercom_get_default_pad+0x102>
    46f2:	2902      	cmp	r1, #2
    46f4:	d006      	beq.n	4704 <_sercom_get_default_pad+0x88>
    46f6:	2903      	cmp	r1, #3
    46f8:	d006      	beq.n	4708 <_sercom_get_default_pad+0x8c>
    46fa:	e001      	b.n	4700 <_sercom_get_default_pad+0x84>
    46fc:	4830      	ldr	r0, [pc, #192]	; (47c0 <_sercom_get_default_pad+0x144>)
    46fe:	e045      	b.n	478c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    4700:	2000      	movs	r0, #0
    4702:	e043      	b.n	478c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    4704:	482f      	ldr	r0, [pc, #188]	; (47c4 <_sercom_get_default_pad+0x148>)
    4706:	e041      	b.n	478c <_sercom_get_default_pad+0x110>
    4708:	482f      	ldr	r0, [pc, #188]	; (47c8 <_sercom_get_default_pad+0x14c>)
    470a:	e03f      	b.n	478c <_sercom_get_default_pad+0x110>
    470c:	2901      	cmp	r1, #1
    470e:	d006      	beq.n	471e <_sercom_get_default_pad+0xa2>
    4710:	2900      	cmp	r1, #0
    4712:	d036      	beq.n	4782 <_sercom_get_default_pad+0x106>
    4714:	2902      	cmp	r1, #2
    4716:	d006      	beq.n	4726 <_sercom_get_default_pad+0xaa>
    4718:	2903      	cmp	r1, #3
    471a:	d006      	beq.n	472a <_sercom_get_default_pad+0xae>
    471c:	e001      	b.n	4722 <_sercom_get_default_pad+0xa6>
    471e:	482b      	ldr	r0, [pc, #172]	; (47cc <_sercom_get_default_pad+0x150>)
    4720:	e034      	b.n	478c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    4722:	2000      	movs	r0, #0
    4724:	e032      	b.n	478c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    4726:	482a      	ldr	r0, [pc, #168]	; (47d0 <_sercom_get_default_pad+0x154>)
    4728:	e030      	b.n	478c <_sercom_get_default_pad+0x110>
    472a:	482a      	ldr	r0, [pc, #168]	; (47d4 <_sercom_get_default_pad+0x158>)
    472c:	e02e      	b.n	478c <_sercom_get_default_pad+0x110>
    472e:	2901      	cmp	r1, #1
    4730:	d006      	beq.n	4740 <_sercom_get_default_pad+0xc4>
    4732:	2900      	cmp	r1, #0
    4734:	d027      	beq.n	4786 <_sercom_get_default_pad+0x10a>
    4736:	2902      	cmp	r1, #2
    4738:	d006      	beq.n	4748 <_sercom_get_default_pad+0xcc>
    473a:	2903      	cmp	r1, #3
    473c:	d006      	beq.n	474c <_sercom_get_default_pad+0xd0>
    473e:	e001      	b.n	4744 <_sercom_get_default_pad+0xc8>
    4740:	4825      	ldr	r0, [pc, #148]	; (47d8 <_sercom_get_default_pad+0x15c>)
    4742:	e023      	b.n	478c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    4744:	2000      	movs	r0, #0
    4746:	e021      	b.n	478c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    4748:	4824      	ldr	r0, [pc, #144]	; (47dc <_sercom_get_default_pad+0x160>)
    474a:	e01f      	b.n	478c <_sercom_get_default_pad+0x110>
    474c:	4824      	ldr	r0, [pc, #144]	; (47e0 <_sercom_get_default_pad+0x164>)
    474e:	e01d      	b.n	478c <_sercom_get_default_pad+0x110>
    4750:	2901      	cmp	r1, #1
    4752:	d006      	beq.n	4762 <_sercom_get_default_pad+0xe6>
    4754:	2900      	cmp	r1, #0
    4756:	d018      	beq.n	478a <_sercom_get_default_pad+0x10e>
    4758:	2902      	cmp	r1, #2
    475a:	d006      	beq.n	476a <_sercom_get_default_pad+0xee>
    475c:	2903      	cmp	r1, #3
    475e:	d006      	beq.n	476e <_sercom_get_default_pad+0xf2>
    4760:	e001      	b.n	4766 <_sercom_get_default_pad+0xea>
    4762:	4820      	ldr	r0, [pc, #128]	; (47e4 <_sercom_get_default_pad+0x168>)
    4764:	e012      	b.n	478c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    4766:	2000      	movs	r0, #0
    4768:	e010      	b.n	478c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    476a:	481f      	ldr	r0, [pc, #124]	; (47e8 <_sercom_get_default_pad+0x16c>)
    476c:	e00e      	b.n	478c <_sercom_get_default_pad+0x110>
    476e:	481f      	ldr	r0, [pc, #124]	; (47ec <_sercom_get_default_pad+0x170>)
    4770:	e00c      	b.n	478c <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    4772:	2000      	movs	r0, #0
    4774:	e00a      	b.n	478c <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    4776:	481e      	ldr	r0, [pc, #120]	; (47f0 <_sercom_get_default_pad+0x174>)
    4778:	e008      	b.n	478c <_sercom_get_default_pad+0x110>
    477a:	2003      	movs	r0, #3
    477c:	e006      	b.n	478c <_sercom_get_default_pad+0x110>
    477e:	481d      	ldr	r0, [pc, #116]	; (47f4 <_sercom_get_default_pad+0x178>)
    4780:	e004      	b.n	478c <_sercom_get_default_pad+0x110>
    4782:	481d      	ldr	r0, [pc, #116]	; (47f8 <_sercom_get_default_pad+0x17c>)
    4784:	e002      	b.n	478c <_sercom_get_default_pad+0x110>
    4786:	481d      	ldr	r0, [pc, #116]	; (47fc <_sercom_get_default_pad+0x180>)
    4788:	e000      	b.n	478c <_sercom_get_default_pad+0x110>
    478a:	481d      	ldr	r0, [pc, #116]	; (4800 <_sercom_get_default_pad+0x184>)
	}

	Assert(false);
	return 0;
}
    478c:	4770      	bx	lr
    478e:	46c0      	nop			; (mov r8, r8)
    4790:	42001000 	.word	0x42001000
    4794:	42000800 	.word	0x42000800
    4798:	42000c00 	.word	0x42000c00
    479c:	42001800 	.word	0x42001800
    47a0:	42001c00 	.word	0x42001c00
    47a4:	42001400 	.word	0x42001400
    47a8:	00050003 	.word	0x00050003
    47ac:	00060003 	.word	0x00060003
    47b0:	00070003 	.word	0x00070003
    47b4:	00010003 	.word	0x00010003
    47b8:	001e0003 	.word	0x001e0003
    47bc:	001f0003 	.word	0x001f0003
    47c0:	00090003 	.word	0x00090003
    47c4:	000a0003 	.word	0x000a0003
    47c8:	000b0003 	.word	0x000b0003
    47cc:	00110003 	.word	0x00110003
    47d0:	00120003 	.word	0x00120003
    47d4:	00130003 	.word	0x00130003
    47d8:	000d0003 	.word	0x000d0003
    47dc:	000e0003 	.word	0x000e0003
    47e0:	000f0003 	.word	0x000f0003
    47e4:	00170003 	.word	0x00170003
    47e8:	00180003 	.word	0x00180003
    47ec:	00190003 	.word	0x00190003
    47f0:	00040003 	.word	0x00040003
    47f4:	00080003 	.word	0x00080003
    47f8:	00100003 	.word	0x00100003
    47fc:	000c0003 	.word	0x000c0003
    4800:	00160003 	.word	0x00160003

00004804 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    4804:	b530      	push	{r4, r5, lr}
    4806:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    4808:	4b0c      	ldr	r3, [pc, #48]	; (483c <_sercom_get_sercom_inst_index+0x38>)
    480a:	466a      	mov	r2, sp
    480c:	cb32      	ldmia	r3!, {r1, r4, r5}
    480e:	c232      	stmia	r2!, {r1, r4, r5}
    4810:	cb32      	ldmia	r3!, {r1, r4, r5}
    4812:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    4814:	9b00      	ldr	r3, [sp, #0]
    4816:	4283      	cmp	r3, r0
    4818:	d006      	beq.n	4828 <_sercom_get_sercom_inst_index+0x24>
    481a:	2301      	movs	r3, #1
    481c:	009a      	lsls	r2, r3, #2
    481e:	4669      	mov	r1, sp
    4820:	5852      	ldr	r2, [r2, r1]
    4822:	4282      	cmp	r2, r0
    4824:	d103      	bne.n	482e <_sercom_get_sercom_inst_index+0x2a>
    4826:	e000      	b.n	482a <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    4828:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
    482a:	b2d8      	uxtb	r0, r3
    482c:	e003      	b.n	4836 <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    482e:	3301      	adds	r3, #1
    4830:	2b06      	cmp	r3, #6
    4832:	d1f3      	bne.n	481c <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    4834:	2000      	movs	r0, #0
}
    4836:	b007      	add	sp, #28
    4838:	bd30      	pop	{r4, r5, pc}
    483a:	46c0      	nop			; (mov r8, r8)
    483c:	0000eb94 	.word	0x0000eb94

00004840 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    4840:	4770      	bx	lr
    4842:	46c0      	nop			; (mov r8, r8)

00004844 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    4844:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    4846:	4b0a      	ldr	r3, [pc, #40]	; (4870 <_sercom_set_handler+0x2c>)
    4848:	781b      	ldrb	r3, [r3, #0]
    484a:	2b00      	cmp	r3, #0
    484c:	d10c      	bne.n	4868 <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    484e:	4f09      	ldr	r7, [pc, #36]	; (4874 <_sercom_set_handler+0x30>)
    4850:	4e09      	ldr	r6, [pc, #36]	; (4878 <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
    4852:	4d0a      	ldr	r5, [pc, #40]	; (487c <_sercom_set_handler+0x38>)
    4854:	2400      	movs	r4, #0
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    4856:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
    4858:	195a      	adds	r2, r3, r5
    485a:	6014      	str	r4, [r2, #0]
    485c:	3304      	adds	r3, #4
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    485e:	2b18      	cmp	r3, #24
    4860:	d1f9      	bne.n	4856 <_sercom_set_handler+0x12>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
    4862:	2201      	movs	r2, #1
    4864:	4b02      	ldr	r3, [pc, #8]	; (4870 <_sercom_set_handler+0x2c>)
    4866:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    4868:	0080      	lsls	r0, r0, #2
    486a:	4b02      	ldr	r3, [pc, #8]	; (4874 <_sercom_set_handler+0x30>)
    486c:	50c1      	str	r1, [r0, r3]
}
    486e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4870:	20000166 	.word	0x20000166
    4874:	20000168 	.word	0x20000168
    4878:	00004841 	.word	0x00004841
    487c:	2000171c 	.word	0x2000171c

00004880 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    4880:	b510      	push	{r4, lr}
    4882:	b082      	sub	sp, #8
    4884:	1c04      	adds	r4, r0, #0
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    4886:	4668      	mov	r0, sp
    4888:	4905      	ldr	r1, [pc, #20]	; (48a0 <_sercom_get_interrupt_vector+0x20>)
    488a:	2206      	movs	r2, #6
    488c:	4b05      	ldr	r3, [pc, #20]	; (48a4 <_sercom_get_interrupt_vector+0x24>)
    488e:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    4890:	1c20      	adds	r0, r4, #0
    4892:	4b05      	ldr	r3, [pc, #20]	; (48a8 <_sercom_get_interrupt_vector+0x28>)
    4894:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    4896:	466b      	mov	r3, sp
    4898:	5618      	ldrsb	r0, [r3, r0]
}
    489a:	b002      	add	sp, #8
    489c:	bd10      	pop	{r4, pc}
    489e:	46c0      	nop			; (mov r8, r8)
    48a0:	0000ebac 	.word	0x0000ebac
    48a4:	0000d7eb 	.word	0x0000d7eb
    48a8:	00004805 	.word	0x00004805

000048ac <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    48ac:	b508      	push	{r3, lr}
    48ae:	4b02      	ldr	r3, [pc, #8]	; (48b8 <SERCOM0_Handler+0xc>)
    48b0:	681b      	ldr	r3, [r3, #0]
    48b2:	2000      	movs	r0, #0
    48b4:	4798      	blx	r3
    48b6:	bd08      	pop	{r3, pc}
    48b8:	20000168 	.word	0x20000168

000048bc <SERCOM1_Handler>:
    48bc:	b508      	push	{r3, lr}
    48be:	4b02      	ldr	r3, [pc, #8]	; (48c8 <SERCOM1_Handler+0xc>)
    48c0:	685b      	ldr	r3, [r3, #4]
    48c2:	2001      	movs	r0, #1
    48c4:	4798      	blx	r3
    48c6:	bd08      	pop	{r3, pc}
    48c8:	20000168 	.word	0x20000168

000048cc <SERCOM2_Handler>:
    48cc:	b508      	push	{r3, lr}
    48ce:	4b02      	ldr	r3, [pc, #8]	; (48d8 <SERCOM2_Handler+0xc>)
    48d0:	689b      	ldr	r3, [r3, #8]
    48d2:	2002      	movs	r0, #2
    48d4:	4798      	blx	r3
    48d6:	bd08      	pop	{r3, pc}
    48d8:	20000168 	.word	0x20000168

000048dc <SERCOM3_Handler>:
    48dc:	b508      	push	{r3, lr}
    48de:	4b02      	ldr	r3, [pc, #8]	; (48e8 <SERCOM3_Handler+0xc>)
    48e0:	68db      	ldr	r3, [r3, #12]
    48e2:	2003      	movs	r0, #3
    48e4:	4798      	blx	r3
    48e6:	bd08      	pop	{r3, pc}
    48e8:	20000168 	.word	0x20000168

000048ec <SERCOM4_Handler>:
    48ec:	b508      	push	{r3, lr}
    48ee:	4b02      	ldr	r3, [pc, #8]	; (48f8 <SERCOM4_Handler+0xc>)
    48f0:	691b      	ldr	r3, [r3, #16]
    48f2:	2004      	movs	r0, #4
    48f4:	4798      	blx	r3
    48f6:	bd08      	pop	{r3, pc}
    48f8:	20000168 	.word	0x20000168

000048fc <SERCOM5_Handler>:
    48fc:	b508      	push	{r3, lr}
    48fe:	4b02      	ldr	r3, [pc, #8]	; (4908 <SERCOM5_Handler+0xc>)
    4900:	695b      	ldr	r3, [r3, #20]
    4902:	2005      	movs	r0, #5
    4904:	4798      	blx	r3
    4906:	bd08      	pop	{r3, pc}
    4908:	20000168 	.word	0x20000168

0000490c <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    490c:	b5f0      	push	{r4, r5, r6, r7, lr}
    490e:	b08b      	sub	sp, #44	; 0x2c
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    4910:	6001      	str	r1, [r0, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    4912:	680c      	ldr	r4, [r1, #0]
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
    4914:	231c      	movs	r3, #28
	module->hw = hw;

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    4916:	07a4      	lsls	r4, r4, #30
    4918:	d500      	bpl.n	491c <spi_init+0x10>
    491a:	e0c4      	b.n	4aa6 <spi_init+0x19a>
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    491c:	680c      	ldr	r4, [r1, #0]
		return STATUS_BUSY;
    491e:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    4920:	07e4      	lsls	r4, r4, #31
    4922:	d500      	bpl.n	4926 <spi_init+0x1a>
    4924:	e0bf      	b.n	4aa6 <spi_init+0x19a>
    4926:	1c16      	adds	r6, r2, #0
    4928:	1c0c      	adds	r4, r1, #0
    492a:	1c05      	adds	r5, r0, #0
		return STATUS_BUSY;
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    492c:	1c08      	adds	r0, r1, #0
    492e:	4b5f      	ldr	r3, [pc, #380]	; (4aac <spi_init+0x1a0>)
    4930:	4798      	blx	r3
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    4932:	495f      	ldr	r1, [pc, #380]	; (4ab0 <spi_init+0x1a4>)
    4934:	6a0a      	ldr	r2, [r1, #32]
	}
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    4936:	1c87      	adds	r7, r0, #2
#  endif
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    4938:	2301      	movs	r3, #1
    493a:	40bb      	lsls	r3, r7
    493c:	4313      	orrs	r3, r2
    493e:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    4940:	a909      	add	r1, sp, #36	; 0x24
    4942:	2724      	movs	r7, #36	; 0x24
    4944:	5df3      	ldrb	r3, [r6, r7]
    4946:	700b      	strb	r3, [r1, #0]
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    4948:	3014      	adds	r0, #20

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    494a:	b2c3      	uxtb	r3, r0
    494c:	9301      	str	r3, [sp, #4]
    494e:	1c18      	adds	r0, r3, #0
    4950:	4b58      	ldr	r3, [pc, #352]	; (4ab4 <spi_init+0x1a8>)
    4952:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    4954:	9801      	ldr	r0, [sp, #4]
    4956:	4b58      	ldr	r3, [pc, #352]	; (4ab8 <spi_init+0x1ac>)
    4958:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    495a:	5df0      	ldrb	r0, [r6, r7]
    495c:	2100      	movs	r1, #0
    495e:	4b57      	ldr	r3, [pc, #348]	; (4abc <spi_init+0x1b0>)
    4960:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    4962:	7833      	ldrb	r3, [r6, #0]
    4964:	2b01      	cmp	r3, #1
    4966:	d000      	beq.n	496a <spi_init+0x5e>
    4968:	e097      	b.n	4a9a <spi_init+0x18e>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    496a:	6822      	ldr	r2, [r4, #0]
    496c:	330b      	adds	r3, #11
    496e:	4313      	orrs	r3, r2
    4970:	6023      	str	r3, [r4, #0]
    4972:	e092      	b.n	4a9a <spi_init+0x18e>
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
    4974:	c304      	stmia	r3!, {r2}
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    4976:	428b      	cmp	r3, r1
    4978:	d1fc      	bne.n	4974 <spi_init+0x68>
		module->callback[i]        = NULL;
	}
	module->tx_buffer_ptr              = NULL;
    497a:	2300      	movs	r3, #0
    497c:	62eb      	str	r3, [r5, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
    497e:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
    4980:	2400      	movs	r4, #0
    4982:	86ab      	strh	r3, [r5, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
    4984:	862b      	strh	r3, [r5, #48]	; 0x30
	module->registered_callback        = 0x00;
    4986:	3336      	adds	r3, #54	; 0x36
    4988:	54ec      	strb	r4, [r5, r3]
	module->enabled_callback           = 0x00;
    498a:	3301      	adds	r3, #1
    498c:	54ec      	strb	r4, [r5, r3]
	module->status                     = STATUS_OK;
    498e:	3301      	adds	r3, #1
    4990:	54ec      	strb	r4, [r5, r3]
	module->dir                        = SPI_DIRECTION_IDLE;
    4992:	3b35      	subs	r3, #53	; 0x35
    4994:	726b      	strb	r3, [r5, #9]
	module->locked                     = false;
    4996:	712c      	strb	r4, [r5, #4]
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
    4998:	6828      	ldr	r0, [r5, #0]
    499a:	4b44      	ldr	r3, [pc, #272]	; (4aac <spi_init+0x1a0>)
    499c:	4798      	blx	r3
    499e:	1c07      	adds	r7, r0, #0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
    49a0:	4947      	ldr	r1, [pc, #284]	; (4ac0 <spi_init+0x1b4>)
    49a2:	4b48      	ldr	r3, [pc, #288]	; (4ac4 <spi_init+0x1b8>)
    49a4:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    49a6:	00bf      	lsls	r7, r7, #2
    49a8:	4b47      	ldr	r3, [pc, #284]	; (4ac8 <spi_init+0x1bc>)
    49aa:	50fd      	str	r5, [r7, r3]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    49ac:	682f      	ldr	r7, [r5, #0]
    49ae:	ab04      	add	r3, sp, #16
    49b0:	2280      	movs	r2, #128	; 0x80
    49b2:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    49b4:	705c      	strb	r4, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    49b6:	3a7f      	subs	r2, #127	; 0x7f
    49b8:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    49ba:	70dc      	strb	r4, [r3, #3]
	Sercom *const hw = module->hw;

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
    49bc:	7833      	ldrb	r3, [r6, #0]
    49be:	2b00      	cmp	r3, #0
    49c0:	d102      	bne.n	49c8 <spi_init+0xbc>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    49c2:	2200      	movs	r2, #0
    49c4:	ab04      	add	r3, sp, #16
    49c6:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
    49c8:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    49ca:	9305      	str	r3, [sp, #20]
    49cc:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    49ce:	9306      	str	r3, [sp, #24]
    49d0:	6b33      	ldr	r3, [r6, #48]	; 0x30
    49d2:	9307      	str	r3, [sp, #28]
    49d4:	6b73      	ldr	r3, [r6, #52]	; 0x34
    49d6:	9308      	str	r3, [sp, #32]
    49d8:	2400      	movs	r4, #0
    49da:	b2e1      	uxtb	r1, r4
    49dc:	00a3      	lsls	r3, r4, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    49de:	aa05      	add	r2, sp, #20
    49e0:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    49e2:	2800      	cmp	r0, #0
    49e4:	d102      	bne.n	49ec <spi_init+0xe0>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    49e6:	1c38      	adds	r0, r7, #0
    49e8:	4b38      	ldr	r3, [pc, #224]	; (4acc <spi_init+0x1c0>)
    49ea:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    49ec:	1c43      	adds	r3, r0, #1
    49ee:	d006      	beq.n	49fe <spi_init+0xf2>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    49f0:	ab02      	add	r3, sp, #8
    49f2:	7218      	strb	r0, [r3, #8]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    49f4:	0c00      	lsrs	r0, r0, #16
    49f6:	b2c0      	uxtb	r0, r0
    49f8:	a904      	add	r1, sp, #16
    49fa:	4b35      	ldr	r3, [pc, #212]	; (4ad0 <spi_init+0x1c4>)
    49fc:	4798      	blx	r3
    49fe:	3401      	adds	r4, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    4a00:	2c04      	cmp	r4, #4
    4a02:	d1ea      	bne.n	49da <spi_init+0xce>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    4a04:	7833      	ldrb	r3, [r6, #0]
    4a06:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
    4a08:	7c33      	ldrb	r3, [r6, #16]
    4a0a:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
    4a0c:	7cb3      	ldrb	r3, [r6, #18]
    4a0e:	71eb      	strb	r3, [r5, #7]
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	module->master_slave_select_enable = config->master_slave_select_enable;
    4a10:	7d33      	ldrb	r3, [r6, #20]
    4a12:	722b      	strb	r3, [r5, #8]
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    4a14:	2200      	movs	r2, #0
    4a16:	ab02      	add	r3, sp, #8
    4a18:	80da      	strh	r2, [r3, #6]
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    4a1a:	7833      	ldrb	r3, [r6, #0]
    4a1c:	2b01      	cmp	r3, #1
    4a1e:	d113      	bne.n	4a48 <spi_init+0x13c>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    4a20:	6828      	ldr	r0, [r5, #0]
    4a22:	4b22      	ldr	r3, [pc, #136]	; (4aac <spi_init+0x1a0>)
    4a24:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    4a26:	3014      	adds	r0, #20
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    4a28:	b2c0      	uxtb	r0, r0
    4a2a:	4b2a      	ldr	r3, [pc, #168]	; (4ad4 <spi_init+0x1c8>)
    4a2c:	4798      	blx	r3
    4a2e:	1c01      	adds	r1, r0, #0

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    4a30:	69b0      	ldr	r0, [r6, #24]
    4a32:	ab02      	add	r3, sp, #8
    4a34:	1d9a      	adds	r2, r3, #6
    4a36:	4b28      	ldr	r3, [pc, #160]	; (4ad8 <spi_init+0x1cc>)
    4a38:	4798      	blx	r3
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    4a3a:	2317      	movs	r3, #23
		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    4a3c:	2800      	cmp	r0, #0
    4a3e:	d132      	bne.n	4aa6 <spi_init+0x19a>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    4a40:	ab02      	add	r3, sp, #8
    4a42:	3306      	adds	r3, #6
    4a44:	781b      	ldrb	r3, [r3, #0]
    4a46:	733b      	strb	r3, [r7, #12]
# endif
	/* Set data order */
	ctrla |= config->data_order;

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;
    4a48:	68b3      	ldr	r3, [r6, #8]
    4a4a:	6872      	ldr	r2, [r6, #4]
    4a4c:	4313      	orrs	r3, r2

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    4a4e:	68f2      	ldr	r2, [r6, #12]
    4a50:	4313      	orrs	r3, r2

	/* Set SPI character size */
	ctrlb |= config->character_size;
    4a52:	7c32      	ldrb	r2, [r6, #16]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    4a54:	7c71      	ldrb	r1, [r6, #17]
    4a56:	2900      	cmp	r1, #0
    4a58:	d103      	bne.n	4a62 <spi_init+0x156>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    4a5a:	4920      	ldr	r1, [pc, #128]	; (4adc <spi_init+0x1d0>)
    4a5c:	7889      	ldrb	r1, [r1, #2]
    4a5e:	0789      	lsls	r1, r1, #30
    4a60:	d501      	bpl.n	4a66 <spi_init+0x15a>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    4a62:	2180      	movs	r1, #128	; 0x80
    4a64:	430b      	orrs	r3, r1
	}

	if (config->receiver_enable) {
    4a66:	7cb1      	ldrb	r1, [r6, #18]
    4a68:	2900      	cmp	r1, #0
    4a6a:	d002      	beq.n	4a72 <spi_init+0x166>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    4a6c:	2180      	movs	r1, #128	; 0x80
    4a6e:	0289      	lsls	r1, r1, #10
    4a70:	430a      	orrs	r2, r1
	}
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
    4a72:	7cf1      	ldrb	r1, [r6, #19]
    4a74:	2900      	cmp	r1, #0
    4a76:	d002      	beq.n	4a7e <spi_init+0x172>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
    4a78:	2180      	movs	r1, #128	; 0x80
    4a7a:	0089      	lsls	r1, r1, #2
    4a7c:	430a      	orrs	r2, r1
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
    4a7e:	7d31      	ldrb	r1, [r6, #20]
    4a80:	2900      	cmp	r1, #0
    4a82:	d002      	beq.n	4a8a <spi_init+0x17e>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
    4a84:	2180      	movs	r1, #128	; 0x80
    4a86:	0189      	lsls	r1, r1, #6
    4a88:	430a      	orrs	r2, r1
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    4a8a:	6839      	ldr	r1, [r7, #0]
    4a8c:	430b      	orrs	r3, r1
    4a8e:	603b      	str	r3, [r7, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
    4a90:	687b      	ldr	r3, [r7, #4]
    4a92:	431a      	orrs	r2, r3
    4a94:	607a      	str	r2, [r7, #4]

	return STATUS_OK;
    4a96:	2300      	movs	r3, #0
    4a98:	e005      	b.n	4aa6 <spi_init+0x19a>
    4a9a:	1c2b      	adds	r3, r5, #0
    4a9c:	330c      	adds	r3, #12
    4a9e:	1c29      	adds	r1, r5, #0
    4aa0:	3128      	adds	r1, #40	; 0x28
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
    4aa2:	2200      	movs	r2, #0
    4aa4:	e766      	b.n	4974 <spi_init+0x68>
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
    4aa6:	1c18      	adds	r0, r3, #0
    4aa8:	b00b      	add	sp, #44	; 0x2c
    4aaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4aac:	00004805 	.word	0x00004805
    4ab0:	40000400 	.word	0x40000400
    4ab4:	00005a2d 	.word	0x00005a2d
    4ab8:	000059a1 	.word	0x000059a1
    4abc:	00004631 	.word	0x00004631
    4ac0:	00004bd5 	.word	0x00004bd5
    4ac4:	00004845 	.word	0x00004845
    4ac8:	2000171c 	.word	0x2000171c
    4acc:	0000467d 	.word	0x0000467d
    4ad0:	00005b25 	.word	0x00005b25
    4ad4:	00005a49 	.word	0x00005a49
    4ad8:	00004441 	.word	0x00004441
    4adc:	41002000 	.word	0x41002000

00004ae0 <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    4ae0:	b510      	push	{r4, lr}
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    4ae2:	7944      	ldrb	r4, [r0, #5]
		return STATUS_ERR_UNSUPPORTED_DEV;
    4ae4:	2315      	movs	r3, #21
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    4ae6:	2c01      	cmp	r4, #1
    4ae8:	d170      	bne.n	4bcc <spi_select_slave+0xec>
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    4aea:	7a04      	ldrb	r4, [r0, #8]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4aec:	2300      	movs	r3, #0
	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    4aee:	2c00      	cmp	r4, #0
    4af0:	d16c      	bne.n	4bcc <spi_select_slave+0xec>
#  endif
	{
		if (select) {
    4af2:	2a00      	cmp	r2, #0
    4af4:	d05a      	beq.n	4bac <spi_select_slave+0xcc>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
    4af6:	784b      	ldrb	r3, [r1, #1]
    4af8:	2b00      	cmp	r3, #0
    4afa:	d046      	beq.n	4b8a <spi_select_slave+0xaa>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    4afc:	6803      	ldr	r3, [r0, #0]
    4afe:	7e1b      	ldrb	r3, [r3, #24]
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
    4b00:	07db      	lsls	r3, r3, #31
    4b02:	d410      	bmi.n	4b26 <spi_select_slave+0x46>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
    4b04:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4b06:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4b08:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4b0a:	2900      	cmp	r1, #0
    4b0c:	d104      	bne.n	4b18 <spi_select_slave+0x38>
		return &(ports[port_index]->Group[group_index]);
    4b0e:	095a      	lsrs	r2, r3, #5
    4b10:	01d2      	lsls	r2, r2, #7
    4b12:	492f      	ldr	r1, [pc, #188]	; (4bd0 <spi_select_slave+0xf0>)
    4b14:	468c      	mov	ip, r1
    4b16:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4b18:	211f      	movs	r1, #31
    4b1a:	400b      	ands	r3, r1
    4b1c:	391e      	subs	r1, #30
    4b1e:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    4b20:	6191      	str	r1, [r2, #24]
					return STATUS_BUSY;
    4b22:	2305      	movs	r3, #5
    4b24:	e052      	b.n	4bcc <spi_select_slave+0xec>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    4b26:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4b28:	09dc      	lsrs	r4, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4b2a:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4b2c:	2c00      	cmp	r4, #0
    4b2e:	d104      	bne.n	4b3a <spi_select_slave+0x5a>
		return &(ports[port_index]->Group[group_index]);
    4b30:	095a      	lsrs	r2, r3, #5
    4b32:	01d2      	lsls	r2, r2, #7
    4b34:	4c26      	ldr	r4, [pc, #152]	; (4bd0 <spi_select_slave+0xf0>)
    4b36:	46a4      	mov	ip, r4
    4b38:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4b3a:	241f      	movs	r4, #31
    4b3c:	4023      	ands	r3, r4
    4b3e:	3c1e      	subs	r4, #30
    4b40:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4b42:	6154      	str	r4, [r2, #20]

				/* Write address to slave */
				spi_write(module, slave->address);
    4b44:	788a      	ldrb	r2, [r1, #2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4b46:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    4b48:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    4b4a:	07c9      	lsls	r1, r1, #31
    4b4c:	d500      	bpl.n	4b50 <spi_select_slave+0x70>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    4b4e:	629a      	str	r2, [r3, #40]	; 0x28

				if (!(module->receiver_enabled)) {
    4b50:	79c2      	ldrb	r2, [r0, #7]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4b52:	2300      	movs	r3, #0
				port_pin_set_output_level(slave->ss_pin, false);

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    4b54:	2a00      	cmp	r2, #0
    4b56:	d139      	bne.n	4bcc <spi_select_slave+0xec>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4b58:	6802      	ldr	r2, [r0, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    4b5a:	2104      	movs	r1, #4
    4b5c:	7e13      	ldrb	r3, [r2, #24]
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
    4b5e:	420b      	tst	r3, r1
    4b60:	d0fc      	beq.n	4b5c <spi_select_slave+0x7c>
    4b62:	7e11      	ldrb	r1, [r2, #24]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4b64:	2300      	movs	r3, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    4b66:	0749      	lsls	r1, r1, #29
    4b68:	d530      	bpl.n	4bcc <spi_select_slave+0xec>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4b6a:	8b53      	ldrh	r3, [r2, #26]
    4b6c:	075b      	lsls	r3, r3, #29
    4b6e:	d503      	bpl.n	4b78 <spi_select_slave+0x98>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    4b70:	8b51      	ldrh	r1, [r2, #26]
    4b72:	2304      	movs	r3, #4
    4b74:	430b      	orrs	r3, r1
    4b76:	8353      	strh	r3, [r2, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4b78:	7983      	ldrb	r3, [r0, #6]
    4b7a:	2b01      	cmp	r3, #1
    4b7c:	d102      	bne.n	4b84 <spi_select_slave+0xa4>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    4b7e:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4b80:	2300      	movs	r3, #0
    4b82:	e023      	b.n	4bcc <spi_select_slave+0xec>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    4b84:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4b86:	2300      	movs	r3, #0
    4b88:	e020      	b.n	4bcc <spi_select_slave+0xec>
					uint16_t flush = 0;
					spi_read(module, &flush);
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    4b8a:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4b8c:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4b8e:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4b90:	2900      	cmp	r1, #0
    4b92:	d104      	bne.n	4b9e <spi_select_slave+0xbe>
		return &(ports[port_index]->Group[group_index]);
    4b94:	095a      	lsrs	r2, r3, #5
    4b96:	01d2      	lsls	r2, r2, #7
    4b98:	490d      	ldr	r1, [pc, #52]	; (4bd0 <spi_select_slave+0xf0>)
    4b9a:	468c      	mov	ip, r1
    4b9c:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4b9e:	211f      	movs	r1, #31
    4ba0:	400b      	ands	r3, r1
    4ba2:	391e      	subs	r1, #30
    4ba4:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4ba6:	6151      	str	r1, [r2, #20]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4ba8:	2300      	movs	r3, #0
    4baa:	e00f      	b.n	4bcc <spi_select_slave+0xec>
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
    4bac:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4bae:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4bb0:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4bb2:	2900      	cmp	r1, #0
    4bb4:	d104      	bne.n	4bc0 <spi_select_slave+0xe0>
		return &(ports[port_index]->Group[group_index]);
    4bb6:	095a      	lsrs	r2, r3, #5
    4bb8:	01d2      	lsls	r2, r2, #7
    4bba:	4905      	ldr	r1, [pc, #20]	; (4bd0 <spi_select_slave+0xf0>)
    4bbc:	468c      	mov	ip, r1
    4bbe:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4bc0:	211f      	movs	r1, #31
    4bc2:	400b      	ands	r3, r1
    4bc4:	391e      	subs	r1, #30
    4bc6:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    4bc8:	6191      	str	r1, [r2, #24]
		}
	}
	return STATUS_OK;
    4bca:	2300      	movs	r3, #0
}
    4bcc:	1c18      	adds	r0, r3, #0
    4bce:	bd10      	pop	{r4, pc}
    4bd0:	41004400 	.word	0x41004400

00004bd4 <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
    4bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get device instance from the look-up table */
	struct spi_module *module
    4bd6:	0080      	lsls	r0, r0, #2
    4bd8:	4b68      	ldr	r3, [pc, #416]	; (4d7c <_spi_interrupt_handler+0x1a8>)
    4bda:	58c4      	ldr	r4, [r0, r3]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    4bdc:	6826      	ldr	r6, [r4, #0]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
    4bde:	2336      	movs	r3, #54	; 0x36

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
    4be0:	5ce3      	ldrb	r3, [r4, r3]
    4be2:	2237      	movs	r2, #55	; 0x37
    4be4:	5ca7      	ldrb	r7, [r4, r2]
    4be6:	401f      	ands	r7, r3
			module->enabled_callback & module->registered_callback;

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
    4be8:	7e33      	ldrb	r3, [r6, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
    4bea:	7db5      	ldrb	r5, [r6, #22]
    4bec:	401d      	ands	r5, r3

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
    4bee:	07eb      	lsls	r3, r5, #31
    4bf0:	d53d      	bpl.n	4c6e <_spi_interrupt_handler+0x9a>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    4bf2:	7963      	ldrb	r3, [r4, #5]
    4bf4:	2b01      	cmp	r3, #1
    4bf6:	d13a      	bne.n	4c6e <_spi_interrupt_handler+0x9a>
			(module->dir == SPI_DIRECTION_READ)) {
    4bf8:	7a63      	ldrb	r3, [r4, #9]
	interrupt_status &= spi_hw->INTENSET.reg;

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    4bfa:	2b00      	cmp	r3, #0
    4bfc:	d10f      	bne.n	4c1e <_spi_interrupt_handler+0x4a>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write dummy byte */
	spi_hw->DATA.reg = dummy_write;
    4bfe:	4b60      	ldr	r3, [pc, #384]	; (4d80 <_spi_interrupt_handler+0x1ac>)
    4c00:	881b      	ldrh	r3, [r3, #0]
    4c02:	62b3      	str	r3, [r6, #40]	; 0x28

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    4c04:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    4c06:	3b01      	subs	r3, #1
    4c08:	b29b      	uxth	r3, r3
    4c0a:	8663      	strh	r3, [r4, #50]	; 0x32
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
			(module->dir == SPI_DIRECTION_READ)) {
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
			if (module->remaining_dummy_buffer_length == 0) {
    4c0c:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    4c0e:	b29b      	uxth	r3, r3
    4c10:	2b00      	cmp	r3, #0
    4c12:	d101      	bne.n	4c18 <_spi_interrupt_handler+0x44>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    4c14:	3301      	adds	r3, #1
    4c16:	7533      	strb	r3, [r6, #20]
			}
		}
#  endif

		if (0
    4c18:	7963      	ldrb	r3, [r4, #5]
    4c1a:	2b01      	cmp	r3, #1
    4c1c:	d127      	bne.n	4c6e <_spi_interrupt_handler+0x9a>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
    4c1e:	7a63      	ldrb	r3, [r4, #9]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    4c20:	2b00      	cmp	r3, #0
    4c22:	d024      	beq.n	4c6e <_spi_interrupt_handler+0x9a>
 */
static void _spi_write(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    4c24:	6820      	ldr	r0, [r4, #0]

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    4c26:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    4c28:	780b      	ldrb	r3, [r1, #0]
    4c2a:	b2da      	uxtb	r2, r3
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;
    4c2c:	1c4b      	adds	r3, r1, #1
    4c2e:	62e3      	str	r3, [r4, #44]	; 0x2c

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4c30:	79a3      	ldrb	r3, [r4, #6]
    4c32:	2b01      	cmp	r3, #1
    4c34:	d001      	beq.n	4c3a <_spi_interrupt_handler+0x66>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    4c36:	b293      	uxth	r3, r2
    4c38:	e004      	b.n	4c44 <_spi_interrupt_handler+0x70>
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
    4c3a:	784b      	ldrb	r3, [r1, #1]
    4c3c:	021b      	lsls	r3, r3, #8
    4c3e:	4313      	orrs	r3, r2
		/* Increment 8-bit pointer */
		(module->tx_buffer_ptr)++;
    4c40:	3102      	adds	r1, #2
    4c42:	62e1      	str	r1, [r4, #44]	; 0x2c
	}

	/* Write the data to send*/
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
    4c44:	05db      	lsls	r3, r3, #23
    4c46:	0ddb      	lsrs	r3, r3, #23
    4c48:	6283      	str	r3, [r0, #40]	; 0x28

	/* Decrement remaining buffer length */
	(module->remaining_tx_buffer_length)--;
    4c4a:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    4c4c:	3b01      	subs	r3, #1
    4c4e:	b29b      	uxth	r3, r3
    4c50:	86a3      	strh	r3, [r4, #52]	; 0x34
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
			if (module->remaining_tx_buffer_length == 0) {
    4c52:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    4c54:	b29b      	uxth	r3, r3
    4c56:	2b00      	cmp	r3, #0
    4c58:	d109      	bne.n	4c6e <_spi_interrupt_handler+0x9a>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    4c5a:	3301      	adds	r3, #1
    4c5c:	7533      	strb	r3, [r6, #20]

				if (module->dir == SPI_DIRECTION_WRITE &&
    4c5e:	7a63      	ldrb	r3, [r4, #9]
    4c60:	2b01      	cmp	r3, #1
    4c62:	d104      	bne.n	4c6e <_spi_interrupt_handler+0x9a>
    4c64:	79e3      	ldrb	r3, [r4, #7]
    4c66:	2b00      	cmp	r3, #0
    4c68:	d101      	bne.n	4c6e <_spi_interrupt_handler+0x9a>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    4c6a:	3302      	adds	r3, #2
    4c6c:	75b3      	strb	r3, [r6, #22]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
    4c6e:	076b      	lsls	r3, r5, #29
    4c70:	d561      	bpl.n	4d36 <_spi_interrupt_handler+0x162>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4c72:	8b73      	ldrh	r3, [r6, #26]
    4c74:	075b      	lsls	r3, r3, #29
    4c76:	d514      	bpl.n	4ca2 <_spi_interrupt_handler+0xce>
			if (module->dir != SPI_DIRECTION_WRITE) {
    4c78:	7a63      	ldrb	r3, [r4, #9]
    4c7a:	2b01      	cmp	r3, #1
    4c7c:	d00b      	beq.n	4c96 <_spi_interrupt_handler+0xc2>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
    4c7e:	221e      	movs	r2, #30
    4c80:	2338      	movs	r3, #56	; 0x38
    4c82:	54e2      	strb	r2, [r4, r3]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
    4c84:	3b35      	subs	r3, #53	; 0x35
    4c86:	7263      	strb	r3, [r4, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
    4c88:	3302      	adds	r3, #2
    4c8a:	7533      	strb	r3, [r6, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
    4c8c:	073b      	lsls	r3, r7, #28
    4c8e:	d502      	bpl.n	4c96 <_spi_interrupt_handler+0xc2>
					(module->callback[SPI_CALLBACK_ERROR])(module);
    4c90:	1c20      	adds	r0, r4, #0
    4c92:	69a3      	ldr	r3, [r4, #24]
    4c94:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
    4c96:	6ab3      	ldr	r3, [r6, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    4c98:	8b72      	ldrh	r2, [r6, #26]
    4c9a:	2304      	movs	r3, #4
    4c9c:	4313      	orrs	r3, r2
    4c9e:	8373      	strh	r3, [r6, #26]
    4ca0:	e049      	b.n	4d36 <_spi_interrupt_handler+0x162>
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
    4ca2:	7a63      	ldrb	r3, [r4, #9]
    4ca4:	2b01      	cmp	r3, #1
    4ca6:	d116      	bne.n	4cd6 <_spi_interrupt_handler+0x102>
 */
static void _spi_read_dummy(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    4ca8:	6823      	ldr	r3, [r4, #0]
	uint16_t flush = 0;

	/* Read dummy byte */
	flush = spi_hw->DATA.reg;
    4caa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	UNUSED(flush);

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    4cac:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    4cae:	3b01      	subs	r3, #1
    4cb0:	b29b      	uxth	r3, r3
    4cb2:	8663      	strh	r3, [r4, #50]	; 0x32
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
				/* Flush receive buffer when writing */
				_spi_read_dummy(module);
				if (module->remaining_dummy_buffer_length == 0) {
    4cb4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    4cb6:	b29b      	uxth	r3, r3
    4cb8:	2b00      	cmp	r3, #0
    4cba:	d13c      	bne.n	4d36 <_spi_interrupt_handler+0x162>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    4cbc:	3304      	adds	r3, #4
    4cbe:	7533      	strb	r3, [r6, #20]
					module->status = STATUS_OK;
    4cc0:	2200      	movs	r2, #0
    4cc2:	3334      	adds	r3, #52	; 0x34
    4cc4:	54e2      	strb	r2, [r4, r3]
					module->dir = SPI_DIRECTION_IDLE;
    4cc6:	3b35      	subs	r3, #53	; 0x35
    4cc8:	7263      	strb	r3, [r4, #9]
					/* Run callback if registered and enabled */
					if (callback_mask &
    4cca:	07fb      	lsls	r3, r7, #31
    4ccc:	d533      	bpl.n	4d36 <_spi_interrupt_handler+0x162>
							(1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
    4cce:	1c20      	adds	r0, r4, #0
    4cd0:	68e3      	ldr	r3, [r4, #12]
    4cd2:	4798      	blx	r3
    4cd4:	e02f      	b.n	4d36 <_spi_interrupt_handler+0x162>
 */
static void _spi_read(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    4cd6:	6823      	ldr	r3, [r4, #0]

	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
    4cd8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4cda:	05db      	lsls	r3, r3, #23
    4cdc:	0ddb      	lsrs	r3, r3, #23

	/* Read value will be at least 8-bits long */
	*(module->rx_buffer_ptr) = received_data;
    4cde:	b2da      	uxtb	r2, r3
    4ce0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    4ce2:	700a      	strb	r2, [r1, #0]
	/* Increment 8-bit pointer */
	module->rx_buffer_ptr += 1;
    4ce4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    4ce6:	1c51      	adds	r1, r2, #1
    4ce8:	62a1      	str	r1, [r4, #40]	; 0x28

	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4cea:	79a1      	ldrb	r1, [r4, #6]
    4cec:	2901      	cmp	r1, #1
    4cee:	d104      	bne.n	4cfa <_spi_interrupt_handler+0x126>
		/* 9-bit data, write next received byte to the buffer */
		*(module->rx_buffer_ptr) = (received_data >> 8);
    4cf0:	0a1b      	lsrs	r3, r3, #8
    4cf2:	7053      	strb	r3, [r2, #1]
		/* Increment 8-bit pointer */
		module->rx_buffer_ptr += 1;
    4cf4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4cf6:	3301      	adds	r3, #1
    4cf8:	62a3      	str	r3, [r4, #40]	; 0x28
	}

	/* Decrement length of the remaining buffer */
	module->remaining_rx_buffer_length--;
    4cfa:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    4cfc:	3b01      	subs	r3, #1
    4cfe:	b29b      	uxth	r3, r3
    4d00:	8623      	strh	r3, [r4, #48]	; 0x30
			} else {
				/* Read data register */
				_spi_read(module);

				/* Check if the last character have been received */
				if (module->remaining_rx_buffer_length == 0) {
    4d02:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    4d04:	b29b      	uxth	r3, r3
    4d06:	2b00      	cmp	r3, #0
    4d08:	d115      	bne.n	4d36 <_spi_interrupt_handler+0x162>
					module->status = STATUS_OK;
    4d0a:	2200      	movs	r2, #0
    4d0c:	3338      	adds	r3, #56	; 0x38
    4d0e:	54e2      	strb	r2, [r4, r3]
					/* Disable RX Complete Interrupt and set status */
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    4d10:	3b34      	subs	r3, #52	; 0x34
    4d12:	7533      	strb	r3, [r6, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
    4d14:	7a63      	ldrb	r3, [r4, #9]
    4d16:	2b02      	cmp	r3, #2
    4d18:	d105      	bne.n	4d26 <_spi_interrupt_handler+0x152>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
    4d1a:	077b      	lsls	r3, r7, #29
    4d1c:	d50b      	bpl.n	4d36 <_spi_interrupt_handler+0x162>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
    4d1e:	1c20      	adds	r0, r4, #0
    4d20:	6963      	ldr	r3, [r4, #20]
    4d22:	4798      	blx	r3
    4d24:	e007      	b.n	4d36 <_spi_interrupt_handler+0x162>
						}
					} else if (module->dir == SPI_DIRECTION_READ) {
    4d26:	7a63      	ldrb	r3, [r4, #9]
    4d28:	2b00      	cmp	r3, #0
    4d2a:	d104      	bne.n	4d36 <_spi_interrupt_handler+0x162>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
    4d2c:	07bb      	lsls	r3, r7, #30
    4d2e:	d502      	bpl.n	4d36 <_spi_interrupt_handler+0x162>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
    4d30:	1c20      	adds	r0, r4, #0
    4d32:	6923      	ldr	r3, [r4, #16]
    4d34:	4798      	blx	r3
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
    4d36:	07ab      	lsls	r3, r5, #30
    4d38:	d514      	bpl.n	4d64 <_spi_interrupt_handler+0x190>
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    4d3a:	7963      	ldrb	r3, [r4, #5]
    4d3c:	2b01      	cmp	r3, #1
    4d3e:	d111      	bne.n	4d64 <_spi_interrupt_handler+0x190>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    4d40:	7a63      	ldrb	r3, [r4, #9]
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    4d42:	2b01      	cmp	r3, #1
    4d44:	d10e      	bne.n	4d64 <_spi_interrupt_handler+0x190>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    4d46:	79e3      	ldrb	r3, [r4, #7]
    4d48:	2b00      	cmp	r3, #0
    4d4a:	d10b      	bne.n	4d64 <_spi_interrupt_handler+0x190>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
    4d4c:	3302      	adds	r3, #2
    4d4e:	7533      	strb	r3, [r6, #20]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
    4d50:	3301      	adds	r3, #1
    4d52:	7263      	strb	r3, [r4, #9]
			module->status = STATUS_OK;
    4d54:	2200      	movs	r2, #0
    4d56:	3335      	adds	r3, #53	; 0x35
    4d58:	54e2      	strb	r2, [r4, r3]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
    4d5a:	07fb      	lsls	r3, r7, #31
    4d5c:	d502      	bpl.n	4d64 <_spi_interrupt_handler+0x190>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
    4d5e:	1c20      	adds	r0, r4, #0
    4d60:	68e3      	ldr	r3, [r4, #12]
    4d62:	4798      	blx	r3
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
    4d64:	09ed      	lsrs	r5, r5, #7
    4d66:	d007      	beq.n	4d78 <_spi_interrupt_handler+0x1a4>
		/* Disable interrupts */
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    4d68:	2380      	movs	r3, #128	; 0x80
    4d6a:	7533      	strb	r3, [r6, #20]
		/* Clear interrupt flag */
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    4d6c:	7633      	strb	r3, [r6, #24]

		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
    4d6e:	067b      	lsls	r3, r7, #25
    4d70:	d502      	bpl.n	4d78 <_spi_interrupt_handler+0x1a4>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
    4d72:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4d74:	1c20      	adds	r0, r4, #0
    4d76:	4798      	blx	r3
		}
	}
#  endif
}
    4d78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    4d7a:	46c0      	nop			; (mov r8, r8)
    4d7c:	2000171c 	.word	0x2000171c
    4d80:	20001734 	.word	0x20001734

00004d84 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    4d84:	b5f0      	push	{r4, r5, r6, r7, lr}
    4d86:	465f      	mov	r7, fp
    4d88:	4656      	mov	r6, sl
    4d8a:	464d      	mov	r5, r9
    4d8c:	4644      	mov	r4, r8
    4d8e:	b4f0      	push	{r4, r5, r6, r7}
    4d90:	b091      	sub	sp, #68	; 0x44
    4d92:	1c05      	adds	r5, r0, #0
    4d94:	1c0c      	adds	r4, r1, #0
    4d96:	1c16      	adds	r6, r2, #0
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    4d98:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    4d9a:	1c08      	adds	r0, r1, #0
    4d9c:	4bb9      	ldr	r3, [pc, #740]	; (5084 <usart_init+0x300>)
    4d9e:	4798      	blx	r3
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    4da0:	6822      	ldr	r2, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    4da2:	2305      	movs	r3, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    4da4:	07d2      	lsls	r2, r2, #31
    4da6:	d500      	bpl.n	4daa <usart_init+0x26>
    4da8:	e163      	b.n	5072 <usart_init+0x2ee>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    4daa:	6822      	ldr	r2, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    4dac:	3317      	adds	r3, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    4dae:	0792      	lsls	r2, r2, #30
    4db0:	d500      	bpl.n	4db4 <usart_init+0x30>
    4db2:	e15e      	b.n	5072 <usart_init+0x2ee>
    4db4:	49b4      	ldr	r1, [pc, #720]	; (5088 <usart_init+0x304>)
    4db6:	6a0a      	ldr	r2, [r1, #32]
#else
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    4db8:	1c87      	adds	r7, r0, #2
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    4dba:	3b1b      	subs	r3, #27
    4dbc:	40bb      	lsls	r3, r7
    4dbe:	4313      	orrs	r3, r2
    4dc0:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    4dc2:	a90f      	add	r1, sp, #60	; 0x3c
    4dc4:	272d      	movs	r7, #45	; 0x2d
    4dc6:	5df3      	ldrb	r3, [r6, r7]
    4dc8:	700b      	strb	r3, [r1, #0]
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    4dca:	3014      	adds	r0, #20

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    4dcc:	b2c3      	uxtb	r3, r0
    4dce:	9302      	str	r3, [sp, #8]
    4dd0:	1c18      	adds	r0, r3, #0
    4dd2:	4bae      	ldr	r3, [pc, #696]	; (508c <usart_init+0x308>)
    4dd4:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    4dd6:	9802      	ldr	r0, [sp, #8]
    4dd8:	4bad      	ldr	r3, [pc, #692]	; (5090 <usart_init+0x30c>)
    4dda:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    4ddc:	5df0      	ldrb	r0, [r6, r7]
    4dde:	2100      	movs	r1, #0
    4de0:	4bac      	ldr	r3, [pc, #688]	; (5094 <usart_init+0x310>)
    4de2:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
    4de4:	7af3      	ldrb	r3, [r6, #11]
    4de6:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    4de8:	2324      	movs	r3, #36	; 0x24
    4dea:	5cf3      	ldrb	r3, [r6, r3]
    4dec:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
    4dee:	2325      	movs	r3, #37	; 0x25
    4df0:	5cf3      	ldrb	r3, [r6, r3]
    4df2:	71eb      	strb	r3, [r5, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
    4df4:	7ef3      	ldrb	r3, [r6, #27]
    4df6:	722b      	strb	r3, [r5, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    4df8:	7f33      	ldrb	r3, [r6, #28]
    4dfa:	726b      	strb	r3, [r5, #9]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    4dfc:	682b      	ldr	r3, [r5, #0]
    4dfe:	469a      	mov	sl, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    4e00:	1c18      	adds	r0, r3, #0
    4e02:	4ba0      	ldr	r3, [pc, #640]	; (5084 <usart_init+0x300>)
    4e04:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    4e06:	3014      	adds	r0, #20
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
    4e08:	2200      	movs	r2, #0
    4e0a:	230e      	movs	r3, #14
    4e0c:	a906      	add	r1, sp, #24
    4e0e:	468c      	mov	ip, r1
    4e10:	4463      	add	r3, ip
    4e12:	801a      	strh	r2, [r3, #0]

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
    4e14:	8a33      	ldrh	r3, [r6, #16]
    4e16:	4699      	mov	r9, r3
    4e18:	2380      	movs	r3, #128	; 0x80
    4e1a:	01db      	lsls	r3, r3, #7
    4e1c:	4599      	cmp	r9, r3
    4e1e:	d019      	beq.n	4e54 <usart_init+0xd0>
    4e20:	d804      	bhi.n	4e2c <usart_init+0xa8>
    4e22:	2380      	movs	r3, #128	; 0x80
    4e24:	019b      	lsls	r3, r3, #6
    4e26:	4599      	cmp	r9, r3
    4e28:	d00a      	beq.n	4e40 <usart_init+0xbc>
    4e2a:	e103      	b.n	5034 <usart_init+0x2b0>
    4e2c:	23c0      	movs	r3, #192	; 0xc0
    4e2e:	01db      	lsls	r3, r3, #7
    4e30:	4599      	cmp	r9, r3
    4e32:	d00a      	beq.n	4e4a <usart_init+0xc6>
    4e34:	2380      	movs	r3, #128	; 0x80
    4e36:	021b      	lsls	r3, r3, #8
    4e38:	4599      	cmp	r9, r3
    4e3a:	d100      	bne.n	4e3e <usart_init+0xba>
    4e3c:	e0ff      	b.n	503e <usart_init+0x2ba>
    4e3e:	e0f9      	b.n	5034 <usart_init+0x2b0>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    4e40:	2310      	movs	r3, #16
    4e42:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    4e44:	3b0f      	subs	r3, #15
    4e46:	9307      	str	r3, [sp, #28]
    4e48:	e0fd      	b.n	5046 <usart_init+0x2c2>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    4e4a:	2308      	movs	r3, #8
    4e4c:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    4e4e:	3b07      	subs	r3, #7
    4e50:	9307      	str	r3, [sp, #28]
    4e52:	e0f8      	b.n	5046 <usart_init+0x2c2>
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    4e54:	6833      	ldr	r3, [r6, #0]
    4e56:	469b      	mov	fp, r3
		(uint32_t)config->mux_setting |
    4e58:	68f3      	ldr	r3, [r6, #12]
    4e5a:	9302      	str	r3, [sp, #8]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    4e5c:	6973      	ldr	r3, [r6, #20]
    4e5e:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    4e60:	7e33      	ldrb	r3, [r6, #24]
    4e62:	9304      	str	r3, [sp, #16]
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    4e64:	2326      	movs	r3, #38	; 0x26
    4e66:	5cf3      	ldrb	r3, [r6, r3]
    4e68:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    4e6a:	6872      	ldr	r2, [r6, #4]
    4e6c:	9206      	str	r2, [sp, #24]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    4e6e:	2a00      	cmp	r2, #0
    4e70:	d015      	beq.n	4e9e <usart_init+0x11a>
    4e72:	2380      	movs	r3, #128	; 0x80
    4e74:	055b      	lsls	r3, r3, #21
    4e76:	429a      	cmp	r2, r3
    4e78:	d136      	bne.n	4ee8 <usart_init+0x164>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
    4e7a:	2327      	movs	r3, #39	; 0x27
    4e7c:	5cf3      	ldrb	r3, [r6, r3]
    4e7e:	2b00      	cmp	r3, #0
    4e80:	d136      	bne.n	4ef0 <usart_init+0x16c>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    4e82:	6a33      	ldr	r3, [r6, #32]
    4e84:	4698      	mov	r8, r3
    4e86:	b2c0      	uxtb	r0, r0
    4e88:	4b83      	ldr	r3, [pc, #524]	; (5098 <usart_init+0x314>)
    4e8a:	4798      	blx	r3
    4e8c:	1c01      	adds	r1, r0, #0
    4e8e:	4640      	mov	r0, r8
    4e90:	220e      	movs	r2, #14
    4e92:	ab06      	add	r3, sp, #24
    4e94:	469c      	mov	ip, r3
    4e96:	4462      	add	r2, ip
    4e98:	4b80      	ldr	r3, [pc, #512]	; (509c <usart_init+0x318>)
    4e9a:	4798      	blx	r3
    4e9c:	e025      	b.n	4eea <usart_init+0x166>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    4e9e:	2308      	movs	r3, #8
    4ea0:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    4ea2:	2300      	movs	r3, #0
    4ea4:	9307      	str	r3, [sp, #28]
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
    4ea6:	2327      	movs	r3, #39	; 0x27
    4ea8:	5cf3      	ldrb	r3, [r6, r3]
    4eaa:	2b00      	cmp	r3, #0
    4eac:	d00b      	beq.n	4ec6 <usart_init+0x142>
				status_code =
    4eae:	4643      	mov	r3, r8
    4eb0:	9300      	str	r3, [sp, #0]
    4eb2:	6a30      	ldr	r0, [r6, #32]
    4eb4:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    4eb6:	220e      	movs	r2, #14
    4eb8:	ab06      	add	r3, sp, #24
    4eba:	469c      	mov	ip, r3
    4ebc:	4462      	add	r2, ip
    4ebe:	9b07      	ldr	r3, [sp, #28]
    4ec0:	4f77      	ldr	r7, [pc, #476]	; (50a0 <usart_init+0x31c>)
    4ec2:	47b8      	blx	r7
    4ec4:	e011      	b.n	4eea <usart_init+0x166>
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
    4ec6:	6a33      	ldr	r3, [r6, #32]
    4ec8:	1c1f      	adds	r7, r3, #0
    4eca:	b2c0      	uxtb	r0, r0
    4ecc:	4b72      	ldr	r3, [pc, #456]	; (5098 <usart_init+0x314>)
    4ece:	4798      	blx	r3
    4ed0:	1c01      	adds	r1, r0, #0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
    4ed2:	4643      	mov	r3, r8
    4ed4:	9300      	str	r3, [sp, #0]
    4ed6:	1c38      	adds	r0, r7, #0
    4ed8:	220e      	movs	r2, #14
    4eda:	ab06      	add	r3, sp, #24
    4edc:	469c      	mov	ip, r3
    4ede:	4462      	add	r2, ip
    4ee0:	9b07      	ldr	r3, [sp, #28]
    4ee2:	4f6f      	ldr	r7, [pc, #444]	; (50a0 <usart_init+0x31c>)
    4ee4:	47b8      	blx	r7
    4ee6:	e000      	b.n	4eea <usart_init+0x166>
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
    4ee8:	2000      	movs	r0, #0
    4eea:	1e03      	subs	r3, r0, #0

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
    4eec:	d000      	beq.n	4ef0 <usart_init+0x16c>
    4eee:	e0c0      	b.n	5072 <usart_init+0x2ee>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
    4ef0:	7e73      	ldrb	r3, [r6, #25]
    4ef2:	2b00      	cmp	r3, #0
    4ef4:	d002      	beq.n	4efc <usart_init+0x178>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    4ef6:	7eb3      	ldrb	r3, [r6, #26]
    4ef8:	4652      	mov	r2, sl
    4efa:	7393      	strb	r3, [r2, #14]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    4efc:	682a      	ldr	r2, [r5, #0]
    4efe:	9f06      	ldr	r7, [sp, #24]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    4f00:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    4f02:	2b00      	cmp	r3, #0
    4f04:	d1fc      	bne.n	4f00 <usart_init+0x17c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
    4f06:	330e      	adds	r3, #14
    4f08:	aa06      	add	r2, sp, #24
    4f0a:	4694      	mov	ip, r2
    4f0c:	4463      	add	r3, ip
    4f0e:	881b      	ldrh	r3, [r3, #0]
    4f10:	4652      	mov	r2, sl
    4f12:	8193      	strh	r3, [r2, #12]
    4f14:	9b02      	ldr	r3, [sp, #8]
    4f16:	465a      	mov	r2, fp
    4f18:	4313      	orrs	r3, r2
    4f1a:	9a03      	ldr	r2, [sp, #12]
    4f1c:	4313      	orrs	r3, r2
    4f1e:	433b      	orrs	r3, r7
    4f20:	464a      	mov	r2, r9
    4f22:	4313      	orrs	r3, r2
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    4f24:	9a04      	ldr	r2, [sp, #16]
    4f26:	0212      	lsls	r2, r2, #8
    4f28:	4313      	orrs	r3, r2
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    4f2a:	9a05      	ldr	r2, [sp, #20]
    4f2c:	0757      	lsls	r7, r2, #29

	/*Set baud val */
	usart_hw->BAUD.reg = baud;

	/* Set sample mode */
	ctrla |= transfer_mode;
    4f2e:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
    4f30:	2327      	movs	r3, #39	; 0x27
    4f32:	5cf3      	ldrb	r3, [r6, r3]
    4f34:	2b00      	cmp	r3, #0
    4f36:	d101      	bne.n	4f3c <usart_init+0x1b8>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    4f38:	3304      	adds	r3, #4
    4f3a:	431f      	orrs	r7, r3
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    4f3c:	7f33      	ldrb	r3, [r6, #28]
    4f3e:	0259      	lsls	r1, r3, #9
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    4f40:	7e72      	ldrb	r2, [r6, #25]
    4f42:	0293      	lsls	r3, r2, #10
    4f44:	430b      	orrs	r3, r1
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    4f46:	7f72      	ldrb	r2, [r6, #29]
    4f48:	0212      	lsls	r2, r2, #8
	ctrlb =  
		#ifdef FEATURE_USART_IRDA
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    4f4a:	4313      	orrs	r3, r2
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    4f4c:	2224      	movs	r2, #36	; 0x24
    4f4e:	5cb2      	ldrb	r2, [r6, r2]
    4f50:	0452      	lsls	r2, r2, #17
		#endif
		#ifdef FEATURE_USART_START_FRAME_DECTION
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    4f52:	4313      	orrs	r3, r2
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    4f54:	2225      	movs	r2, #37	; 0x25
    4f56:	5cb2      	ldrb	r2, [r6, r2]
    4f58:	0412      	lsls	r2, r2, #16
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    4f5a:	4313      	orrs	r3, r2
				ctrlb |= USART_STOPBITS_1;
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->character_size;
    4f5c:	7af1      	ldrb	r1, [r6, #11]
    4f5e:	4319      	orrs	r1, r3
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
    4f60:	8933      	ldrh	r3, [r6, #8]
    4f62:	2bff      	cmp	r3, #255	; 0xff
    4f64:	d004      	beq.n	4f70 <usart_init+0x1ec>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    4f66:	2280      	movs	r2, #128	; 0x80
    4f68:	0452      	lsls	r2, r2, #17
    4f6a:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
    4f6c:	4319      	orrs	r1, r3
    4f6e:	e005      	b.n	4f7c <usart_init+0x1f8>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
    4f70:	7ef3      	ldrb	r3, [r6, #27]
    4f72:	2b00      	cmp	r3, #0
    4f74:	d002      	beq.n	4f7c <usart_init+0x1f8>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    4f76:	2380      	movs	r3, #128	; 0x80
    4f78:	04db      	lsls	r3, r3, #19
    4f7a:	431f      	orrs	r7, r3
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    4f7c:	232c      	movs	r3, #44	; 0x2c
    4f7e:	5cf3      	ldrb	r3, [r6, r3]
    4f80:	2b00      	cmp	r3, #0
    4f82:	d103      	bne.n	4f8c <usart_init+0x208>
    4f84:	4b47      	ldr	r3, [pc, #284]	; (50a4 <usart_init+0x320>)
    4f86:	789b      	ldrb	r3, [r3, #2]
    4f88:	079b      	lsls	r3, r3, #30
    4f8a:	d501      	bpl.n	4f90 <usart_init+0x20c>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    4f8c:	2380      	movs	r3, #128	; 0x80
    4f8e:	431f      	orrs	r7, r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    4f90:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    4f92:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    4f94:	2b00      	cmp	r3, #0
    4f96:	d1fc      	bne.n	4f92 <usart_init+0x20e>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
    4f98:	4653      	mov	r3, sl
    4f9a:	6059      	str	r1, [r3, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    4f9c:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    4f9e:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    4fa0:	2b00      	cmp	r3, #0
    4fa2:	d1fc      	bne.n	4f9e <usart_init+0x21a>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
    4fa4:	4653      	mov	r3, sl
    4fa6:	601f      	str	r7, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    4fa8:	ab0e      	add	r3, sp, #56	; 0x38
    4faa:	2280      	movs	r2, #128	; 0x80
    4fac:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    4fae:	2200      	movs	r2, #0
    4fb0:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    4fb2:	70da      	strb	r2, [r3, #3]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    4fb4:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
    4fb6:	6b33      	ldr	r3, [r6, #48]	; 0x30
    4fb8:	930a      	str	r3, [sp, #40]	; 0x28
    4fba:	6b73      	ldr	r3, [r6, #52]	; 0x34
    4fbc:	930b      	str	r3, [sp, #44]	; 0x2c
    4fbe:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    4fc0:	930c      	str	r3, [sp, #48]	; 0x30
    4fc2:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    4fc4:	9302      	str	r3, [sp, #8]
    4fc6:	930d      	str	r3, [sp, #52]	; 0x34
    4fc8:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    4fca:	ae0e      	add	r6, sp, #56	; 0x38
    4fcc:	b2f9      	uxtb	r1, r7
    4fce:	00bb      	lsls	r3, r7, #2
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    4fd0:	aa0a      	add	r2, sp, #40	; 0x28
    4fd2:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    4fd4:	2800      	cmp	r0, #0
    4fd6:	d102      	bne.n	4fde <usart_init+0x25a>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    4fd8:	1c20      	adds	r0, r4, #0
    4fda:	4b33      	ldr	r3, [pc, #204]	; (50a8 <usart_init+0x324>)
    4fdc:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    4fde:	1c43      	adds	r3, r0, #1
    4fe0:	d005      	beq.n	4fee <usart_init+0x26a>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    4fe2:	7030      	strb	r0, [r6, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    4fe4:	0c00      	lsrs	r0, r0, #16
    4fe6:	b2c0      	uxtb	r0, r0
    4fe8:	1c31      	adds	r1, r6, #0
    4fea:	4b30      	ldr	r3, [pc, #192]	; (50ac <usart_init+0x328>)
    4fec:	4798      	blx	r3
    4fee:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    4ff0:	2f04      	cmp	r7, #4
    4ff2:	d1eb      	bne.n	4fcc <usart_init+0x248>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
    4ff4:	2300      	movs	r3, #0
    4ff6:	60eb      	str	r3, [r5, #12]
    4ff8:	612b      	str	r3, [r5, #16]
    4ffa:	616b      	str	r3, [r5, #20]
    4ffc:	61ab      	str	r3, [r5, #24]
    4ffe:	61eb      	str	r3, [r5, #28]
    5000:	622b      	str	r3, [r5, #32]
	}

	module->tx_buffer_ptr              = NULL;
    5002:	62ab      	str	r3, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    5004:	626b      	str	r3, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
    5006:	2200      	movs	r2, #0
    5008:	85eb      	strh	r3, [r5, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
    500a:	85ab      	strh	r3, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    500c:	3330      	adds	r3, #48	; 0x30
    500e:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
    5010:	3301      	adds	r3, #1
    5012:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
    5014:	3301      	adds	r3, #1
    5016:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
    5018:	3301      	adds	r3, #1
    501a:	54ea      	strb	r2, [r5, r3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    501c:	6828      	ldr	r0, [r5, #0]
    501e:	4b19      	ldr	r3, [pc, #100]	; (5084 <usart_init+0x300>)
    5020:	4798      	blx	r3
    5022:	1c04      	adds	r4, r0, #0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    5024:	4922      	ldr	r1, [pc, #136]	; (50b0 <usart_init+0x32c>)
    5026:	4b23      	ldr	r3, [pc, #140]	; (50b4 <usart_init+0x330>)
    5028:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    502a:	00a4      	lsls	r4, r4, #2
    502c:	4b22      	ldr	r3, [pc, #136]	; (50b8 <usart_init+0x334>)
    502e:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
    5030:	2300      	movs	r3, #0
    5032:	e01e      	b.n	5072 <usart_init+0x2ee>
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    5034:	2310      	movs	r3, #16
    5036:	4698      	mov	r8, r3
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    5038:	2300      	movs	r3, #0
    503a:	9307      	str	r3, [sp, #28]
    503c:	e003      	b.n	5046 <usart_init+0x2c2>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    503e:	2303      	movs	r3, #3
    5040:	4698      	mov	r8, r3
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    5042:	2300      	movs	r3, #0
    5044:	9307      	str	r3, [sp, #28]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    5046:	6833      	ldr	r3, [r6, #0]
    5048:	469b      	mov	fp, r3
		(uint32_t)config->mux_setting |
    504a:	68f3      	ldr	r3, [r6, #12]
    504c:	9302      	str	r3, [sp, #8]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    504e:	6973      	ldr	r3, [r6, #20]
    5050:	9303      	str	r3, [sp, #12]
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    5052:	7e33      	ldrb	r3, [r6, #24]
    5054:	9304      	str	r3, [sp, #16]
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    5056:	2326      	movs	r3, #38	; 0x26
    5058:	5cf3      	ldrb	r3, [r6, r3]
    505a:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    505c:	6872      	ldr	r2, [r6, #4]
    505e:	9206      	str	r2, [sp, #24]
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    5060:	2a00      	cmp	r2, #0
    5062:	d100      	bne.n	5066 <usart_init+0x2e2>
    5064:	e71f      	b.n	4ea6 <usart_init+0x122>
    5066:	2380      	movs	r3, #128	; 0x80
    5068:	055b      	lsls	r3, r3, #21
    506a:	429a      	cmp	r2, r3
    506c:	d100      	bne.n	5070 <usart_init+0x2ec>
    506e:	e704      	b.n	4e7a <usart_init+0xf6>
    5070:	e73e      	b.n	4ef0 <usart_init+0x16c>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
    5072:	1c18      	adds	r0, r3, #0
    5074:	b011      	add	sp, #68	; 0x44
    5076:	bc3c      	pop	{r2, r3, r4, r5}
    5078:	4690      	mov	r8, r2
    507a:	4699      	mov	r9, r3
    507c:	46a2      	mov	sl, r4
    507e:	46ab      	mov	fp, r5
    5080:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5082:	46c0      	nop			; (mov r8, r8)
    5084:	00004805 	.word	0x00004805
    5088:	40000400 	.word	0x40000400
    508c:	00005a2d 	.word	0x00005a2d
    5090:	000059a1 	.word	0x000059a1
    5094:	00004631 	.word	0x00004631
    5098:	00005a49 	.word	0x00005a49
    509c:	00004441 	.word	0x00004441
    50a0:	00004469 	.word	0x00004469
    50a4:	41002000 	.word	0x41002000
    50a8:	0000467d 	.word	0x0000467d
    50ac:	00005b25 	.word	0x00005b25
    50b0:	00005225 	.word	0x00005225
    50b4:	00004845 	.word	0x00004845
    50b8:	2000171c 	.word	0x2000171c

000050bc <usart_read_wait>:
 * \retval STATUS_ERR_DENIED        If the receiver is not enabled
 */
enum status_code usart_read_wait(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
    50bc:	b510      	push	{r4, lr}

	/* Error variable */
	uint8_t error_code;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    50be:	6804      	ldr	r4, [r0, #0]

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    50c0:	7982      	ldrb	r2, [r0, #6]
		return STATUS_ERR_DENIED;
    50c2:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    50c4:	2a00      	cmp	r2, #0
    50c6:	d033      	beq.n	5130 <usart_read_wait+0x74>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    50c8:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    50ca:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    50cc:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    50ce:	2a00      	cmp	r2, #0
    50d0:	d12e      	bne.n	5130 <usart_read_wait+0x74>
		return STATUS_BUSY;
	}
#endif

	/* Check if USART has new data */
	if (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_RXC)) {
    50d2:	7e22      	ldrb	r2, [r4, #24]
    50d4:	0752      	lsls	r2, r2, #29
    50d6:	d52b      	bpl.n	5130 <usart_read_wait+0x74>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    50d8:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    50da:	2b00      	cmp	r3, #0
    50dc:	d1fc      	bne.n	50d8 <usart_read_wait+0x1c>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Read out the status code and mask away all but the 3 LSBs*/
	error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    50de:	8b63      	ldrh	r3, [r4, #26]
    50e0:	b2db      	uxtb	r3, r3

	/* Check if an error has occurred during the receiving */
	if (error_code) {
    50e2:	069a      	lsls	r2, r3, #26
    50e4:	d021      	beq.n	512a <usart_read_wait+0x6e>
		/* Check which error occurred */
		if (error_code & SERCOM_USART_STATUS_FERR) {
    50e6:	079a      	lsls	r2, r3, #30
    50e8:	d503      	bpl.n	50f2 <usart_read_wait+0x36>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    50ea:	2302      	movs	r3, #2
    50ec:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_BAD_FORMAT;
    50ee:	3318      	adds	r3, #24
    50f0:	e01e      	b.n	5130 <usart_read_wait+0x74>
		} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    50f2:	075a      	lsls	r2, r3, #29
    50f4:	d503      	bpl.n	50fe <usart_read_wait+0x42>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    50f6:	2304      	movs	r3, #4
    50f8:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_OVERFLOW;
    50fa:	331a      	adds	r3, #26
    50fc:	e018      	b.n	5130 <usart_read_wait+0x74>
		} else if (error_code & SERCOM_USART_STATUS_PERR) {
    50fe:	07da      	lsls	r2, r3, #31
    5100:	d503      	bpl.n	510a <usart_read_wait+0x4e>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    5102:	2301      	movs	r3, #1
    5104:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_BAD_DATA;
    5106:	3312      	adds	r3, #18
    5108:	e012      	b.n	5130 <usart_read_wait+0x74>
		}
#ifdef FEATURE_USART_LIN_SLAVE
		else if (error_code & SERCOM_USART_STATUS_ISF) {
    510a:	06da      	lsls	r2, r3, #27
    510c:	d505      	bpl.n	511a <usart_read_wait+0x5e>
			/* Clear flag by writing 1 to it  and
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    510e:	8b62      	ldrh	r2, [r4, #26]
    5110:	2310      	movs	r3, #16
    5112:	4313      	orrs	r3, r2
    5114:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_PROTOCOL;
    5116:	2342      	movs	r3, #66	; 0x42
    5118:	e00a      	b.n	5130 <usart_read_wait+0x74>
		}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
		else if (error_code & SERCOM_USART_STATUS_COLL) {
    511a:	069b      	lsls	r3, r3, #26
    511c:	d505      	bpl.n	512a <usart_read_wait+0x6e>
			/* Clear flag by writing 1 to it
			 *  return with an error code */
			usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    511e:	8b62      	ldrh	r2, [r4, #26]
    5120:	2320      	movs	r3, #32
    5122:	4313      	orrs	r3, r2
    5124:	8363      	strh	r3, [r4, #26]

			return STATUS_ERR_PACKET_COLLISION;
    5126:	2341      	movs	r3, #65	; 0x41
    5128:	e002      	b.n	5130 <usart_read_wait+0x74>
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
    512a:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    512c:	800b      	strh	r3, [r1, #0]

	return STATUS_OK;
    512e:	2300      	movs	r3, #0
}
    5130:	1c18      	adds	r0, r3, #0
    5132:	bd10      	pop	{r4, pc}

00005134 <_usart_write_buffer>:
 */
enum status_code _usart_write_buffer(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
    5134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5136:	1c06      	adds	r6, r0, #0
    5138:	1c0c      	adds	r4, r1, #0
    513a:	1c15      	adds	r5, r2, #0
	Assert(module);
	Assert(module->hw);
	Assert(tx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    513c:	6807      	ldr	r7, [r0, #0]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    513e:	4b0a      	ldr	r3, [pc, #40]	; (5168 <_usart_write_buffer+0x34>)
    5140:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Check if the USART transmitter is busy */
	if (module->remaining_tx_buffer_length > 0) {
    5142:	8df3      	ldrh	r3, [r6, #46]	; 0x2e
    5144:	b29b      	uxth	r3, r3
    5146:	2b00      	cmp	r3, #0
    5148:	d003      	beq.n	5152 <_usart_write_buffer+0x1e>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    514a:	4b08      	ldr	r3, [pc, #32]	; (516c <_usart_write_buffer+0x38>)
    514c:	4798      	blx	r3
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
    514e:	2005      	movs	r0, #5
    5150:	e009      	b.n	5166 <_usart_write_buffer+0x32>
	}

	/* Write parameters to the device instance */
	module->remaining_tx_buffer_length = length;
    5152:	85f5      	strh	r5, [r6, #46]	; 0x2e
    5154:	4b05      	ldr	r3, [pc, #20]	; (516c <_usart_write_buffer+0x38>)
    5156:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	module->tx_buffer_ptr              = tx_data;
    5158:	62b4      	str	r4, [r6, #40]	; 0x28
	module->tx_status                  = STATUS_BUSY;
    515a:	2205      	movs	r2, #5
    515c:	2333      	movs	r3, #51	; 0x33
    515e:	54f2      	strb	r2, [r6, r3]

	/* Enable the Data Register Empty Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;
    5160:	3b32      	subs	r3, #50	; 0x32
    5162:	75bb      	strb	r3, [r7, #22]

	return STATUS_OK;
    5164:	2000      	movs	r0, #0
}
    5166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5168:	00004191 	.word	0x00004191
    516c:	000041d1 	.word	0x000041d1

00005170 <_usart_read_buffer>:
 */
enum status_code _usart_read_buffer(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
    5170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5172:	1c04      	adds	r4, r0, #0
    5174:	1c0d      	adds	r5, r1, #0
    5176:	1c16      	adds	r6, r2, #0
	Assert(module);
	Assert(module->hw);
	Assert(rx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    5178:	6807      	ldr	r7, [r0, #0]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    517a:	4b0f      	ldr	r3, [pc, #60]	; (51b8 <_usart_read_buffer+0x48>)
    517c:	4798      	blx	r3

	system_interrupt_enter_critical_section();

	/* Check if the USART receiver is busy */
	if (module->remaining_rx_buffer_length > 0) {
    517e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    5180:	b29b      	uxth	r3, r3
    5182:	2b00      	cmp	r3, #0
    5184:	d003      	beq.n	518e <_usart_read_buffer+0x1e>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5186:	4b0d      	ldr	r3, [pc, #52]	; (51bc <_usart_read_buffer+0x4c>)
    5188:	4798      	blx	r3
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
    518a:	2005      	movs	r0, #5
    518c:	e013      	b.n	51b6 <_usart_read_buffer+0x46>
	}

	/* Set length for the buffer and the pointer, and let
	 * the interrupt handler do the rest */
	module->remaining_rx_buffer_length = length;
    518e:	85a6      	strh	r6, [r4, #44]	; 0x2c
    5190:	4b0a      	ldr	r3, [pc, #40]	; (51bc <_usart_read_buffer+0x4c>)
    5192:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	module->rx_buffer_ptr              = rx_data;
    5194:	6265      	str	r5, [r4, #36]	; 0x24
	module->rx_status                  = STATUS_BUSY;
    5196:	2205      	movs	r2, #5
    5198:	2332      	movs	r3, #50	; 0x32
    519a:	54e2      	strb	r2, [r4, r3]

	/* Enable the RX Complete Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
    519c:	3b2e      	subs	r3, #46	; 0x2e
    519e:	75bb      	strb	r3, [r7, #22]

#ifdef FEATURE_USART_LIN_SLAVE
	/* Enable the break character is received Interrupt */
	if(module->lin_slave_enabled) {
    51a0:	7a23      	ldrb	r3, [r4, #8]
    51a2:	2b00      	cmp	r3, #0
    51a4:	d001      	beq.n	51aa <_usart_read_buffer+0x3a>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXBRK;
    51a6:	2320      	movs	r3, #32
    51a8:	75bb      	strb	r3, [r7, #22]
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	/* Enable a start condition is detected Interrupt */
	if(module->start_frame_detection_enabled) {
    51aa:	7a63      	ldrb	r3, [r4, #9]
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
	}
#endif

	return STATUS_OK;
    51ac:	2000      	movs	r0, #0
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	/* Enable a start condition is detected Interrupt */
	if(module->start_frame_detection_enabled) {
    51ae:	2b00      	cmp	r3, #0
    51b0:	d001      	beq.n	51b6 <_usart_read_buffer+0x46>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
    51b2:	2308      	movs	r3, #8
    51b4:	75bb      	strb	r3, [r7, #22]
	}
#endif

	return STATUS_OK;
}
    51b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    51b8:	00004191 	.word	0x00004191
    51bc:	000041d1 	.word	0x000041d1

000051c0 <usart_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    51c0:	1c93      	adds	r3, r2, #2
    51c2:	009b      	lsls	r3, r3, #2
    51c4:	18c3      	adds	r3, r0, r3
    51c6:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->callback_reg_mask |= (1 << callback_type);
    51c8:	2301      	movs	r3, #1
    51ca:	4093      	lsls	r3, r2
    51cc:	1c1a      	adds	r2, r3, #0
    51ce:	2130      	movs	r1, #48	; 0x30
    51d0:	5c43      	ldrb	r3, [r0, r1]
    51d2:	431a      	orrs	r2, r3
    51d4:	5442      	strb	r2, [r0, r1]
}
    51d6:	4770      	bx	lr

000051d8 <usart_write_job>:
 * \retval STATUS_ERR_DENIED If the transmitter is not enabled
 */
enum status_code usart_write_job(
		struct usart_module *const module,
		const uint16_t *tx_data)
{
    51d8:	b508      	push	{r3, lr}
	Assert(module);
	Assert(tx_data);


	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    51da:	79c2      	ldrb	r2, [r0, #7]
		return STATUS_ERR_DENIED;
    51dc:	231c      	movs	r3, #28
	Assert(module);
	Assert(tx_data);


	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    51de:	2a00      	cmp	r2, #0
    51e0:	d003      	beq.n	51ea <usart_write_job+0x12>
		return STATUS_ERR_DENIED;
	}

	/* Call internal write buffer function with length 1 */
	return _usart_write_buffer(module, (uint8_t *)tx_data, 1);
    51e2:	2201      	movs	r2, #1
    51e4:	4b02      	ldr	r3, [pc, #8]	; (51f0 <usart_write_job+0x18>)
    51e6:	4798      	blx	r3
    51e8:	1c03      	adds	r3, r0, #0
}
    51ea:	1c18      	adds	r0, r3, #0
    51ec:	bd08      	pop	{r3, pc}
    51ee:	46c0      	nop			; (mov r8, r8)
    51f0:	00005135 	.word	0x00005135

000051f4 <usart_read_job>:
 * \retval  STATUS_BUSY  If operation was not completed
 */
enum status_code usart_read_job(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
    51f4:	b508      	push	{r3, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(rx_data);

	/* Call internal read buffer function with length 1 */
	return _usart_read_buffer(module, (uint8_t *)rx_data, 1);
    51f6:	2201      	movs	r2, #1
    51f8:	4b01      	ldr	r3, [pc, #4]	; (5200 <usart_read_job+0xc>)
    51fa:	4798      	blx	r3
}
    51fc:	bd08      	pop	{r3, pc}
    51fe:	46c0      	nop			; (mov r8, r8)
    5200:	00005171 	.word	0x00005171

00005204 <usart_get_job_status>:
	Assert(module);

	/* Variable for status code */
	enum status_code status_code;

	switch(transceiver_type) {
    5204:	2900      	cmp	r1, #0
    5206:	d002      	beq.n	520e <usart_get_job_status+0xa>
    5208:	2901      	cmp	r1, #1
    520a:	d004      	beq.n	5216 <usart_get_job_status+0x12>
    520c:	e007      	b.n	521e <usart_get_job_status+0x1a>
	case USART_TRANSCEIVER_RX:
			status_code = module->rx_status;
    520e:	2332      	movs	r3, #50	; 0x32
    5210:	5cc0      	ldrb	r0, [r0, r3]
    5212:	b2c0      	uxtb	r0, r0
			break;
    5214:	e004      	b.n	5220 <usart_get_job_status+0x1c>

	case USART_TRANSCEIVER_TX:
			status_code = module->tx_status;
    5216:	2333      	movs	r3, #51	; 0x33
    5218:	5cc0      	ldrb	r0, [r0, r3]
    521a:	b2c0      	uxtb	r0, r0
			break;
    521c:	e000      	b.n	5220 <usart_get_job_status+0x1c>

	default:
			status_code = STATUS_ERR_INVALID_ARG;
    521e:	2017      	movs	r0, #23
			break;
	}

	return status_code;
}
    5220:	4770      	bx	lr
    5222:	46c0      	nop			; (mov r8, r8)

00005224 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    5224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    5226:	0080      	lsls	r0, r0, #2
    5228:	4b65      	ldr	r3, [pc, #404]	; (53c0 <_usart_interrupt_handler+0x19c>)
    522a:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    522c:	682c      	ldr	r4, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    522e:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    5230:	2b00      	cmp	r3, #0
    5232:	d1fc      	bne.n	522e <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    5234:	7e23      	ldrb	r3, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
    5236:	7da6      	ldrb	r6, [r4, #22]
    5238:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
			module->callback_enable_mask;
    523a:	2331      	movs	r3, #49	; 0x31
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
	interrupt_status &= usart_hw->INTENSET.reg;
	callback_status = module->callback_reg_mask &
    523c:	5ceb      	ldrb	r3, [r5, r3]
    523e:	2230      	movs	r2, #48	; 0x30
    5240:	5caf      	ldrb	r7, [r5, r2]
    5242:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    5244:	07f3      	lsls	r3, r6, #31
    5246:	d522      	bpl.n	528e <_usart_interrupt_handler+0x6a>
		if (module->remaining_tx_buffer_length) {
    5248:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    524a:	b29b      	uxth	r3, r3
    524c:	2b00      	cmp	r3, #0
    524e:	d01c      	beq.n	528a <_usart_interrupt_handler+0x66>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    5250:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    5252:	7813      	ldrb	r3, [r2, #0]
    5254:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    5256:	1c51      	adds	r1, r2, #1
    5258:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    525a:	7969      	ldrb	r1, [r5, #5]
    525c:	2901      	cmp	r1, #1
    525e:	d001      	beq.n	5264 <_usart_interrupt_handler+0x40>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    5260:	b29b      	uxth	r3, r3
    5262:	e004      	b.n	526e <_usart_interrupt_handler+0x4a>
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    5264:	7851      	ldrb	r1, [r2, #1]
    5266:	0209      	lsls	r1, r1, #8
    5268:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
    526a:	3202      	adds	r2, #2
    526c:	62aa      	str	r2, [r5, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    526e:	05db      	lsls	r3, r3, #23
    5270:	0ddb      	lsrs	r3, r3, #23
    5272:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    5274:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    5276:	3b01      	subs	r3, #1
    5278:	b29b      	uxth	r3, r3
    527a:	85eb      	strh	r3, [r5, #46]	; 0x2e
    527c:	2b00      	cmp	r3, #0
    527e:	d106      	bne.n	528e <_usart_interrupt_handler+0x6a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    5280:	3301      	adds	r3, #1
    5282:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    5284:	3301      	adds	r3, #1
    5286:	75a3      	strb	r3, [r4, #22]
    5288:	e001      	b.n	528e <_usart_interrupt_handler+0x6a>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    528a:	2301      	movs	r3, #1
    528c:	7523      	strb	r3, [r4, #20]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    528e:	07b3      	lsls	r3, r6, #30
    5290:	d509      	bpl.n	52a6 <_usart_interrupt_handler+0x82>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    5292:	2302      	movs	r3, #2
    5294:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
    5296:	2200      	movs	r2, #0
    5298:	3331      	adds	r3, #49	; 0x31
    529a:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    529c:	07fb      	lsls	r3, r7, #31
    529e:	d502      	bpl.n	52a6 <_usart_interrupt_handler+0x82>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    52a0:	1c28      	adds	r0, r5, #0
    52a2:	68eb      	ldr	r3, [r5, #12]
    52a4:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    52a6:	0773      	lsls	r3, r6, #29
    52a8:	d56a      	bpl.n	5380 <_usart_interrupt_handler+0x15c>

		if (module->remaining_rx_buffer_length) {
    52aa:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    52ac:	b29b      	uxth	r3, r3
    52ae:	2b00      	cmp	r3, #0
    52b0:	d064      	beq.n	537c <_usart_interrupt_handler+0x158>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    52b2:	8b63      	ldrh	r3, [r4, #26]
    52b4:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    52b6:	071a      	lsls	r2, r3, #28
    52b8:	d402      	bmi.n	52c0 <_usart_interrupt_handler+0x9c>

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {

		if (module->remaining_rx_buffer_length) {
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    52ba:	223f      	movs	r2, #63	; 0x3f
    52bc:	4013      	ands	r3, r2
    52be:	e001      	b.n	52c4 <_usart_interrupt_handler+0xa0>
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
				error_code &= ~SERCOM_USART_STATUS_CTS;
    52c0:	2237      	movs	r2, #55	; 0x37
    52c2:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    52c4:	2b00      	cmp	r3, #0
    52c6:	d037      	beq.n	5338 <_usart_interrupt_handler+0x114>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    52c8:	079a      	lsls	r2, r3, #30
    52ca:	d507      	bpl.n	52dc <_usart_interrupt_handler+0xb8>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    52cc:	221a      	movs	r2, #26
    52ce:	2332      	movs	r3, #50	; 0x32
    52d0:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
    52d2:	8b62      	ldrh	r2, [r4, #26]
    52d4:	3b30      	subs	r3, #48	; 0x30
    52d6:	4313      	orrs	r3, r2
    52d8:	8363      	strh	r3, [r4, #26]
    52da:	e027      	b.n	532c <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    52dc:	075a      	lsls	r2, r3, #29
    52de:	d507      	bpl.n	52f0 <_usart_interrupt_handler+0xcc>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    52e0:	221e      	movs	r2, #30
    52e2:	2332      	movs	r3, #50	; 0x32
    52e4:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
    52e6:	8b62      	ldrh	r2, [r4, #26]
    52e8:	3b2e      	subs	r3, #46	; 0x2e
    52ea:	4313      	orrs	r3, r2
    52ec:	8363      	strh	r3, [r4, #26]
    52ee:	e01d      	b.n	532c <_usart_interrupt_handler+0x108>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    52f0:	07da      	lsls	r2, r3, #31
    52f2:	d507      	bpl.n	5304 <_usart_interrupt_handler+0xe0>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    52f4:	2213      	movs	r2, #19
    52f6:	2332      	movs	r3, #50	; 0x32
    52f8:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
    52fa:	8b62      	ldrh	r2, [r4, #26]
    52fc:	3b31      	subs	r3, #49	; 0x31
    52fe:	4313      	orrs	r3, r2
    5300:	8363      	strh	r3, [r4, #26]
    5302:	e013      	b.n	532c <_usart_interrupt_handler+0x108>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    5304:	06da      	lsls	r2, r3, #27
    5306:	d507      	bpl.n	5318 <_usart_interrupt_handler+0xf4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
    5308:	2242      	movs	r2, #66	; 0x42
    530a:	2332      	movs	r3, #50	; 0x32
    530c:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
    530e:	8b62      	ldrh	r2, [r4, #26]
    5310:	3b22      	subs	r3, #34	; 0x22
    5312:	4313      	orrs	r3, r2
    5314:	8363      	strh	r3, [r4, #26]
    5316:	e009      	b.n	532c <_usart_interrupt_handler+0x108>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    5318:	2220      	movs	r2, #32
    531a:	421a      	tst	r2, r3
    531c:	d006      	beq.n	532c <_usart_interrupt_handler+0x108>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    531e:	3221      	adds	r2, #33	; 0x21
    5320:	2332      	movs	r3, #50	; 0x32
    5322:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    5324:	8b62      	ldrh	r2, [r4, #26]
    5326:	3b12      	subs	r3, #18
    5328:	4313      	orrs	r3, r2
    532a:	8363      	strh	r3, [r4, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    532c:	077b      	lsls	r3, r7, #29
    532e:	d527      	bpl.n	5380 <_usart_interrupt_handler+0x15c>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    5330:	1c28      	adds	r0, r5, #0
    5332:	696b      	ldr	r3, [r5, #20]
    5334:	4798      	blx	r3
    5336:	e023      	b.n	5380 <_usart_interrupt_handler+0x15c>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    5338:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    533a:	05db      	lsls	r3, r3, #23
    533c:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    533e:	b2da      	uxtb	r2, r3
    5340:	6a69      	ldr	r1, [r5, #36]	; 0x24
    5342:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    5344:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    5346:	1c51      	adds	r1, r2, #1
    5348:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    534a:	7969      	ldrb	r1, [r5, #5]
    534c:	2901      	cmp	r1, #1
    534e:	d104      	bne.n	535a <_usart_interrupt_handler+0x136>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
    5350:	0a1b      	lsrs	r3, r3, #8
    5352:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
    5354:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    5356:	3301      	adds	r3, #1
    5358:	626b      	str	r3, [r5, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    535a:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    535c:	3b01      	subs	r3, #1
    535e:	b29b      	uxth	r3, r3
    5360:	85ab      	strh	r3, [r5, #44]	; 0x2c
    5362:	2b00      	cmp	r3, #0
    5364:	d10c      	bne.n	5380 <_usart_interrupt_handler+0x15c>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    5366:	3304      	adds	r3, #4
    5368:	7523      	strb	r3, [r4, #20]
					module->rx_status = STATUS_OK;
    536a:	2200      	movs	r2, #0
    536c:	332e      	adds	r3, #46	; 0x2e
    536e:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
    5370:	07bb      	lsls	r3, r7, #30
    5372:	d505      	bpl.n	5380 <_usart_interrupt_handler+0x15c>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    5374:	1c28      	adds	r0, r5, #0
    5376:	692b      	ldr	r3, [r5, #16]
    5378:	4798      	blx	r3
    537a:	e001      	b.n	5380 <_usart_interrupt_handler+0x15c>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    537c:	2304      	movs	r3, #4
    537e:	7523      	strb	r3, [r4, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    5380:	06f3      	lsls	r3, r6, #27
    5382:	d507      	bpl.n	5394 <_usart_interrupt_handler+0x170>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    5384:	2310      	movs	r3, #16
    5386:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    5388:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    538a:	06fb      	lsls	r3, r7, #27
    538c:	d502      	bpl.n	5394 <_usart_interrupt_handler+0x170>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    538e:	1c28      	adds	r0, r5, #0
    5390:	69eb      	ldr	r3, [r5, #28]
    5392:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    5394:	06b3      	lsls	r3, r6, #26
    5396:	d507      	bpl.n	53a8 <_usart_interrupt_handler+0x184>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    5398:	2320      	movs	r3, #32
    539a:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    539c:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    539e:	073b      	lsls	r3, r7, #28
    53a0:	d502      	bpl.n	53a8 <_usart_interrupt_handler+0x184>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    53a2:	1c28      	adds	r0, r5, #0
    53a4:	69ab      	ldr	r3, [r5, #24]
    53a6:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    53a8:	0733      	lsls	r3, r6, #28
    53aa:	d507      	bpl.n	53bc <_usart_interrupt_handler+0x198>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    53ac:	2308      	movs	r3, #8
    53ae:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    53b0:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    53b2:	06bb      	lsls	r3, r7, #26
    53b4:	d502      	bpl.n	53bc <_usart_interrupt_handler+0x198>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    53b6:	6a2b      	ldr	r3, [r5, #32]
    53b8:	1c28      	adds	r0, r5, #0
    53ba:	4798      	blx	r3
		}
	}
#endif
}
    53bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    53be:	46c0      	nop			; (mov r8, r8)
    53c0:	2000171c 	.word	0x2000171c

000053c4 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    53c4:	b508      	push	{r3, lr}
	switch (clock_source) {
    53c6:	2808      	cmp	r0, #8
    53c8:	d803      	bhi.n	53d2 <system_clock_source_get_hz+0xe>
    53ca:	0080      	lsls	r0, r0, #2
    53cc:	4b1b      	ldr	r3, [pc, #108]	; (543c <system_clock_source_get_hz+0x78>)
    53ce:	581b      	ldr	r3, [r3, r0]
    53d0:	469f      	mov	pc, r3

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
    53d2:	2000      	movs	r0, #0
    53d4:	e031      	b.n	543a <system_clock_source_get_hz+0x76>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    53d6:	4b1a      	ldr	r3, [pc, #104]	; (5440 <system_clock_source_get_hz+0x7c>)
    53d8:	6918      	ldr	r0, [r3, #16]
    53da:	e02e      	b.n	543a <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    53dc:	4b19      	ldr	r3, [pc, #100]	; (5444 <system_clock_source_get_hz+0x80>)
    53de:	6a18      	ldr	r0, [r3, #32]
    53e0:	0580      	lsls	r0, r0, #22
    53e2:	0f80      	lsrs	r0, r0, #30
    53e4:	4b18      	ldr	r3, [pc, #96]	; (5448 <system_clock_source_get_hz+0x84>)
    53e6:	40c3      	lsrs	r3, r0
    53e8:	1c18      	adds	r0, r3, #0
    53ea:	e026      	b.n	543a <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    53ec:	4b14      	ldr	r3, [pc, #80]	; (5440 <system_clock_source_get_hz+0x7c>)
    53ee:	6958      	ldr	r0, [r3, #20]
    53f0:	e023      	b.n	543a <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    53f2:	4b13      	ldr	r3, [pc, #76]	; (5440 <system_clock_source_get_hz+0x7c>)
    53f4:	681b      	ldr	r3, [r3, #0]
    53f6:	2002      	movs	r0, #2
    53f8:	4018      	ands	r0, r3
    53fa:	d01e      	beq.n	543a <system_clock_source_get_hz+0x76>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    53fc:	4911      	ldr	r1, [pc, #68]	; (5444 <system_clock_source_get_hz+0x80>)
    53fe:	2210      	movs	r2, #16
    5400:	68cb      	ldr	r3, [r1, #12]
    5402:	421a      	tst	r2, r3
    5404:	d0fc      	beq.n	5400 <system_clock_source_get_hz+0x3c>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    5406:	4b0e      	ldr	r3, [pc, #56]	; (5440 <system_clock_source_get_hz+0x7c>)
    5408:	681b      	ldr	r3, [r3, #0]
    540a:	075b      	lsls	r3, r3, #29
    540c:	d514      	bpl.n	5438 <system_clock_source_get_hz+0x74>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    540e:	2000      	movs	r0, #0
    5410:	4b0e      	ldr	r3, [pc, #56]	; (544c <system_clock_source_get_hz+0x88>)
    5412:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    5414:	4b0a      	ldr	r3, [pc, #40]	; (5440 <system_clock_source_get_hz+0x7c>)
    5416:	689b      	ldr	r3, [r3, #8]
    5418:	041b      	lsls	r3, r3, #16
    541a:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    541c:	4358      	muls	r0, r3
    541e:	e00c      	b.n	543a <system_clock_source_get_hz+0x76>

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    5420:	2350      	movs	r3, #80	; 0x50
    5422:	4a08      	ldr	r2, [pc, #32]	; (5444 <system_clock_source_get_hz+0x80>)
    5424:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    5426:	2000      	movs	r0, #0

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    5428:	075b      	lsls	r3, r3, #29
    542a:	d506      	bpl.n	543a <system_clock_source_get_hz+0x76>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
    542c:	4b04      	ldr	r3, [pc, #16]	; (5440 <system_clock_source_get_hz+0x7c>)
    542e:	68d8      	ldr	r0, [r3, #12]
    5430:	e003      	b.n	543a <system_clock_source_get_hz+0x76>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    5432:	2080      	movs	r0, #128	; 0x80
    5434:	0200      	lsls	r0, r0, #8
    5436:	e000      	b.n	543a <system_clock_source_get_hz+0x76>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    5438:	4805      	ldr	r0, [pc, #20]	; (5450 <system_clock_source_get_hz+0x8c>)
#endif

	default:
		return 0;
	}
}
    543a:	bd08      	pop	{r3, pc}
    543c:	0000ebb4 	.word	0x0000ebb4
    5440:	20000180 	.word	0x20000180
    5444:	40000800 	.word	0x40000800
    5448:	007a1200 	.word	0x007a1200
    544c:	00005a49 	.word	0x00005a49
    5450:	02dc6c00 	.word	0x02dc6c00

00005454 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    5454:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    5456:	4c0c      	ldr	r4, [pc, #48]	; (5488 <system_clock_source_osc8m_set_config+0x34>)
    5458:	6a23      	ldr	r3, [r4, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    545a:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    545c:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    545e:	7842      	ldrb	r2, [r0, #1]
    5460:	2001      	movs	r0, #1
    5462:	4002      	ands	r2, r0
    5464:	0192      	lsls	r2, r2, #6
    5466:	2640      	movs	r6, #64	; 0x40
    5468:	43b3      	bics	r3, r6
    546a:	4313      	orrs	r3, r2
    546c:	1c02      	adds	r2, r0, #0
    546e:	402a      	ands	r2, r5
    5470:	01d2      	lsls	r2, r2, #7
    5472:	307f      	adds	r0, #127	; 0x7f
    5474:	4383      	bics	r3, r0
    5476:	4313      	orrs	r3, r2
    5478:	2203      	movs	r2, #3
    547a:	400a      	ands	r2, r1
    547c:	0212      	lsls	r2, r2, #8
    547e:	4903      	ldr	r1, [pc, #12]	; (548c <system_clock_source_osc8m_set_config+0x38>)
    5480:	400b      	ands	r3, r1
    5482:	4313      	orrs	r3, r2
    5484:	6223      	str	r3, [r4, #32]
}
    5486:	bd70      	pop	{r4, r5, r6, pc}
    5488:	40000800 	.word	0x40000800
    548c:	fffffcff 	.word	0xfffffcff

00005490 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    5490:	b5f0      	push	{r4, r5, r6, r7, lr}
    5492:	465f      	mov	r7, fp
    5494:	4656      	mov	r6, sl
    5496:	464d      	mov	r5, r9
    5498:	4644      	mov	r4, r8
    549a:	b4f0      	push	{r4, r5, r6, r7}
    549c:	b083      	sub	sp, #12
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    549e:	4e2e      	ldr	r6, [pc, #184]	; (5558 <system_clock_source_xosc32k_set_config+0xc8>)
    54a0:	8ab3      	ldrh	r3, [r6, #20]
    54a2:	469c      	mov	ip, r3

	temp.bit.STARTUP = config->startup_time;
    54a4:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    54a6:	7803      	ldrb	r3, [r0, #0]
    54a8:	425a      	negs	r2, r3
    54aa:	415a      	adcs	r2, r3
    54ac:	4691      	mov	r9, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    54ae:	7883      	ldrb	r3, [r0, #2]
    54b0:	469b      	mov	fp, r3
	temp.bit.EN1K = config->enable_1khz_output;
    54b2:	78c3      	ldrb	r3, [r0, #3]
	temp.bit.EN32K = config->enable_32khz_output;
    54b4:	7902      	ldrb	r2, [r0, #4]
    54b6:	4690      	mov	r8, r2

	temp.bit.ONDEMAND = config->on_demand;
    54b8:	7b47      	ldrb	r7, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
    54ba:	7b02      	ldrb	r2, [r0, #12]
    54bc:	9201      	str	r2, [sp, #4]
	temp.bit.WRTLOCK  = config->write_once;
    54be:	7b84      	ldrb	r4, [r0, #14]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    54c0:	6882      	ldr	r2, [r0, #8]
    54c2:	4826      	ldr	r0, [pc, #152]	; (555c <system_clock_source_xosc32k_set_config+0xcc>)
    54c4:	6142      	str	r2, [r0, #20]

	SYSCTRL->XOSC32K = temp;
    54c6:	2001      	movs	r0, #1
    54c8:	464a      	mov	r2, r9
    54ca:	0092      	lsls	r2, r2, #2
    54cc:	4691      	mov	r9, r2
    54ce:	2204      	movs	r2, #4
    54d0:	4692      	mov	sl, r2
    54d2:	4662      	mov	r2, ip
    54d4:	4651      	mov	r1, sl
    54d6:	438a      	bics	r2, r1
    54d8:	4694      	mov	ip, r2
    54da:	464a      	mov	r2, r9
    54dc:	4661      	mov	r1, ip
    54de:	430a      	orrs	r2, r1
    54e0:	4694      	mov	ip, r2
    54e2:	4642      	mov	r2, r8
    54e4:	4002      	ands	r2, r0
    54e6:	00d2      	lsls	r2, r2, #3
    54e8:	4690      	mov	r8, r2
    54ea:	2208      	movs	r2, #8
    54ec:	4691      	mov	r9, r2
    54ee:	4662      	mov	r2, ip
    54f0:	4649      	mov	r1, r9
    54f2:	438a      	bics	r2, r1
    54f4:	4694      	mov	ip, r2
    54f6:	4642      	mov	r2, r8
    54f8:	4661      	mov	r1, ip
    54fa:	430a      	orrs	r2, r1
    54fc:	4694      	mov	ip, r2
    54fe:	4003      	ands	r3, r0
    5500:	011b      	lsls	r3, r3, #4
    5502:	2210      	movs	r2, #16
    5504:	4690      	mov	r8, r2
    5506:	4662      	mov	r2, ip
    5508:	4641      	mov	r1, r8
    550a:	438a      	bics	r2, r1
    550c:	4313      	orrs	r3, r2
    550e:	4659      	mov	r1, fp
    5510:	4001      	ands	r1, r0
    5512:	0149      	lsls	r1, r1, #5
    5514:	2220      	movs	r2, #32
    5516:	4393      	bics	r3, r2
    5518:	430b      	orrs	r3, r1
    551a:	9a01      	ldr	r2, [sp, #4]
    551c:	4002      	ands	r2, r0
    551e:	0192      	lsls	r2, r2, #6
    5520:	2140      	movs	r1, #64	; 0x40
    5522:	438b      	bics	r3, r1
    5524:	4313      	orrs	r3, r2
    5526:	4007      	ands	r7, r0
    5528:	01ff      	lsls	r7, r7, #7
    552a:	2280      	movs	r2, #128	; 0x80
    552c:	4393      	bics	r3, r2
    552e:	433b      	orrs	r3, r7
    5530:	3a79      	subs	r2, #121	; 0x79
    5532:	4015      	ands	r5, r2
    5534:	022d      	lsls	r5, r5, #8
    5536:	4f0a      	ldr	r7, [pc, #40]	; (5560 <system_clock_source_xosc32k_set_config+0xd0>)
    5538:	403b      	ands	r3, r7
    553a:	432b      	orrs	r3, r5
    553c:	4004      	ands	r4, r0
    553e:	0320      	lsls	r0, r4, #12
    5540:	4c08      	ldr	r4, [pc, #32]	; (5564 <system_clock_source_xosc32k_set_config+0xd4>)
    5542:	401c      	ands	r4, r3
    5544:	4304      	orrs	r4, r0
    5546:	82b4      	strh	r4, [r6, #20]
}
    5548:	b003      	add	sp, #12
    554a:	bc3c      	pop	{r2, r3, r4, r5}
    554c:	4690      	mov	r8, r2
    554e:	4699      	mov	r9, r3
    5550:	46a2      	mov	sl, r4
    5552:	46ab      	mov	fp, r5
    5554:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5556:	46c0      	nop			; (mov r8, r8)
    5558:	40000800 	.word	0x40000800
    555c:	20000180 	.word	0x20000180
    5560:	fffff8ff 	.word	0xfffff8ff
    5564:	ffffefff 	.word	0xffffefff

00005568 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    5568:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    556a:	7a03      	ldrb	r3, [r0, #8]
    556c:	069b      	lsls	r3, r3, #26
    556e:	0c1a      	lsrs	r2, r3, #16
			SYSCTRL_DFLLVAL_FINE(config->fine_value);
    5570:	8943      	ldrh	r3, [r0, #10]
    5572:	059b      	lsls	r3, r3, #22
    5574:	0d9b      	lsrs	r3, r3, #22
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    5576:	4313      	orrs	r3, r2
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    5578:	4c19      	ldr	r4, [pc, #100]	; (55e0 <system_clock_source_dfll_set_config+0x78>)
    557a:	6063      	str	r3, [r4, #4]
    557c:	8881      	ldrh	r1, [r0, #4]
    557e:	8843      	ldrh	r3, [r0, #2]
    5580:	4319      	orrs	r1, r3
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    5582:	79c3      	ldrb	r3, [r0, #7]
    5584:	7982      	ldrb	r2, [r0, #6]
    5586:	4313      	orrs	r3, r2
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    5588:	430b      	orrs	r3, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    558a:	7842      	ldrb	r2, [r0, #1]
    558c:	01d2      	lsls	r2, r2, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    558e:	4313      	orrs	r3, r2
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
    5590:	6023      	str	r3, [r4, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    5592:	7803      	ldrb	r3, [r0, #0]
    5594:	2b04      	cmp	r3, #4
    5596:	d10f      	bne.n	55b8 <system_clock_source_dfll_set_config+0x50>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    5598:	7b03      	ldrb	r3, [r0, #12]
    559a:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    559c:	8a02      	ldrh	r2, [r0, #16]
    559e:	4313      	orrs	r3, r2
    55a0:	1c19      	adds	r1, r3, #0

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    55a2:	89c3      	ldrh	r3, [r0, #14]
    55a4:	041b      	lsls	r3, r3, #16
    55a6:	4a0f      	ldr	r2, [pc, #60]	; (55e4 <system_clock_source_dfll_set_config+0x7c>)
    55a8:	4013      	ands	r3, r2
    55aa:	430b      	orrs	r3, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
    55ac:	60a3      	str	r3, [r4, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    55ae:	6821      	ldr	r1, [r4, #0]
    55b0:	2304      	movs	r3, #4
    55b2:	430b      	orrs	r3, r1
    55b4:	6023      	str	r3, [r4, #0]
    55b6:	e011      	b.n	55dc <system_clock_source_dfll_set_config+0x74>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    55b8:	2b20      	cmp	r3, #32
    55ba:	d10f      	bne.n	55dc <system_clock_source_dfll_set_config+0x74>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
    55bc:	7b03      	ldrb	r3, [r0, #12]
    55be:	069b      	lsls	r3, r3, #26
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    55c0:	8a02      	ldrh	r2, [r0, #16]
    55c2:	4313      	orrs	r3, r2
    55c4:	1c19      	adds	r1, r3, #0
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    55c6:	89c3      	ldrh	r3, [r0, #14]
    55c8:	041b      	lsls	r3, r3, #16
    55ca:	4a06      	ldr	r2, [pc, #24]	; (55e4 <system_clock_source_dfll_set_config+0x7c>)
    55cc:	4013      	ands	r3, r2
    55ce:	430b      	orrs	r3, r1
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
    55d0:	4a03      	ldr	r2, [pc, #12]	; (55e0 <system_clock_source_dfll_set_config+0x78>)
    55d2:	6093      	str	r3, [r2, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    55d4:	6813      	ldr	r3, [r2, #0]
    55d6:	4904      	ldr	r1, [pc, #16]	; (55e8 <system_clock_source_dfll_set_config+0x80>)
    55d8:	430b      	orrs	r3, r1
    55da:	6013      	str	r3, [r2, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    55dc:	bd10      	pop	{r4, pc}
    55de:	46c0      	nop			; (mov r8, r8)
    55e0:	20000180 	.word	0x20000180
    55e4:	03ff0000 	.word	0x03ff0000
    55e8:	00000424 	.word	0x00000424

000055ec <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    55ec:	2808      	cmp	r0, #8
    55ee:	d803      	bhi.n	55f8 <system_clock_source_enable+0xc>
    55f0:	0080      	lsls	r0, r0, #2
    55f2:	4b25      	ldr	r3, [pc, #148]	; (5688 <system_clock_source_enable+0x9c>)
    55f4:	581b      	ldr	r3, [r3, r0]
    55f6:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    55f8:	2017      	movs	r0, #23
    55fa:	e044      	b.n	5686 <system_clock_source_enable+0x9a>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    55fc:	4a23      	ldr	r2, [pc, #140]	; (568c <system_clock_source_enable+0xa0>)
    55fe:	6a11      	ldr	r1, [r2, #32]
    5600:	2302      	movs	r3, #2
    5602:	430b      	orrs	r3, r1
    5604:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    5606:	2000      	movs	r0, #0
    5608:	e03d      	b.n	5686 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    560a:	4a20      	ldr	r2, [pc, #128]	; (568c <system_clock_source_enable+0xa0>)
    560c:	6991      	ldr	r1, [r2, #24]
    560e:	2302      	movs	r3, #2
    5610:	430b      	orrs	r3, r1
    5612:	6193      	str	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    5614:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
    5616:	e036      	b.n	5686 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    5618:	4a1c      	ldr	r2, [pc, #112]	; (568c <system_clock_source_enable+0xa0>)
    561a:	8a11      	ldrh	r1, [r2, #16]
    561c:	2302      	movs	r3, #2
    561e:	430b      	orrs	r3, r1
    5620:	8213      	strh	r3, [r2, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    5622:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
    5624:	e02f      	b.n	5686 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    5626:	4a19      	ldr	r2, [pc, #100]	; (568c <system_clock_source_enable+0xa0>)
    5628:	8a91      	ldrh	r1, [r2, #20]
    562a:	2302      	movs	r3, #2
    562c:	430b      	orrs	r3, r1
    562e:	8293      	strh	r3, [r2, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    5630:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
    5632:	e028      	b.n	5686 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    5634:	4916      	ldr	r1, [pc, #88]	; (5690 <system_clock_source_enable+0xa4>)
    5636:	680b      	ldr	r3, [r1, #0]
    5638:	2202      	movs	r2, #2
    563a:	4313      	orrs	r3, r2
    563c:	600b      	str	r3, [r1, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    563e:	4b13      	ldr	r3, [pc, #76]	; (568c <system_clock_source_enable+0xa0>)
    5640:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    5642:	1c19      	adds	r1, r3, #0
    5644:	320e      	adds	r2, #14
    5646:	68cb      	ldr	r3, [r1, #12]
    5648:	421a      	tst	r2, r3
    564a:	d0fc      	beq.n	5646 <system_clock_source_enable+0x5a>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    564c:	4a10      	ldr	r2, [pc, #64]	; (5690 <system_clock_source_enable+0xa4>)
    564e:	6891      	ldr	r1, [r2, #8]
    5650:	4b0e      	ldr	r3, [pc, #56]	; (568c <system_clock_source_enable+0xa0>)
    5652:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    5654:	6852      	ldr	r2, [r2, #4]
    5656:	629a      	str	r2, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
    5658:	2200      	movs	r2, #0
    565a:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    565c:	1c19      	adds	r1, r3, #0
    565e:	3210      	adds	r2, #16
    5660:	68cb      	ldr	r3, [r1, #12]
    5662:	421a      	tst	r2, r3
    5664:	d0fc      	beq.n	5660 <system_clock_source_enable+0x74>
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
	_system_dfll_wait_for_sync();
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    5666:	4b0a      	ldr	r3, [pc, #40]	; (5690 <system_clock_source_enable+0xa4>)
    5668:	681b      	ldr	r3, [r3, #0]
    566a:	b29b      	uxth	r3, r3
    566c:	4a07      	ldr	r2, [pc, #28]	; (568c <system_clock_source_enable+0xa0>)
    566e:	8493      	strh	r3, [r2, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    5670:	2000      	movs	r0, #0
    5672:	e008      	b.n	5686 <system_clock_source_enable+0x9a>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    5674:	4905      	ldr	r1, [pc, #20]	; (568c <system_clock_source_enable+0xa0>)
    5676:	2244      	movs	r2, #68	; 0x44
    5678:	5c88      	ldrb	r0, [r1, r2]
    567a:	2302      	movs	r3, #2
    567c:	4303      	orrs	r3, r0
    567e:	548b      	strb	r3, [r1, r2]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    5680:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
    5682:	e000      	b.n	5686 <system_clock_source_enable+0x9a>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    5684:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
    5686:	4770      	bx	lr
    5688:	0000ebd8 	.word	0x0000ebd8
    568c:	40000800 	.word	0x40000800
    5690:	20000180 	.word	0x20000180

00005694 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    5694:	b5f0      	push	{r4, r5, r6, r7, lr}
    5696:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    5698:	22c2      	movs	r2, #194	; 0xc2
    569a:	00d2      	lsls	r2, r2, #3
    569c:	4b47      	ldr	r3, [pc, #284]	; (57bc <system_clock_init+0x128>)
    569e:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    56a0:	4947      	ldr	r1, [pc, #284]	; (57c0 <system_clock_init+0x12c>)
    56a2:	684b      	ldr	r3, [r1, #4]
    56a4:	221e      	movs	r2, #30
    56a6:	4393      	bics	r3, r2
    56a8:	3a1a      	subs	r2, #26
    56aa:	4313      	orrs	r3, r2
    56ac:	604b      	str	r3, [r1, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    56ae:	3a02      	subs	r2, #2
    56b0:	ab01      	add	r3, sp, #4
    56b2:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    56b4:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    56b6:	4d43      	ldr	r5, [pc, #268]	; (57c4 <system_clock_init+0x130>)
    56b8:	b2e0      	uxtb	r0, r4
    56ba:	a901      	add	r1, sp, #4
    56bc:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    56be:	3401      	adds	r4, #1
    56c0:	2c25      	cmp	r4, #37	; 0x25
    56c2:	d1f9      	bne.n	56b8 <system_clock_init+0x24>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    56c4:	a80a      	add	r0, sp, #40	; 0x28
    56c6:	2300      	movs	r3, #0
    56c8:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->auto_gain_control   = false;
    56ca:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
    56cc:	2280      	movs	r2, #128	; 0x80
    56ce:	0212      	lsls	r2, r2, #8
    56d0:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
    56d2:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
    56d4:	2201      	movs	r2, #1
    56d6:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
    56d8:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
    56da:	7383      	strb	r3, [r0, #14]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    56dc:	3202      	adds	r2, #2
    56de:	7042      	strb	r2, [r0, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    56e0:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    56e2:	4b39      	ldr	r3, [pc, #228]	; (57c8 <system_clock_init+0x134>)
    56e4:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    56e6:	2005      	movs	r0, #5
    56e8:	4b38      	ldr	r3, [pc, #224]	; (57cc <system_clock_init+0x138>)
    56ea:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    56ec:	4933      	ldr	r1, [pc, #204]	; (57bc <system_clock_init+0x128>)
    56ee:	2202      	movs	r2, #2
    56f0:	68cb      	ldr	r3, [r1, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    56f2:	421a      	tst	r2, r3
    56f4:	d0fc      	beq.n	56f0 <system_clock_init+0x5c>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
    56f6:	4a31      	ldr	r2, [pc, #196]	; (57bc <system_clock_init+0x128>)
    56f8:	8a91      	ldrh	r1, [r2, #20]
    56fa:	2380      	movs	r3, #128	; 0x80
    56fc:	430b      	orrs	r3, r1
    56fe:	8293      	strh	r3, [r2, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    5700:	ab05      	add	r3, sp, #20
    5702:	2100      	movs	r1, #0
    5704:	2200      	movs	r2, #0
    5706:	8059      	strh	r1, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    5708:	8099      	strh	r1, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    570a:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    570c:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
	config->fine_value      = 0xff / 4; /* Midpoint */
    570e:	313f      	adds	r1, #63	; 0x3f
    5710:	8159      	strh	r1, [r3, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    5712:	393b      	subs	r1, #59	; 0x3b
    5714:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
    5716:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
    5718:	4b2d      	ldr	r3, [pc, #180]	; (57d0 <system_clock_init+0x13c>)
    571a:	681b      	ldr	r3, [r3, #0]
    571c:	0e9b      	lsrs	r3, r3, #26
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
    571e:	2b3f      	cmp	r3, #63	; 0x3f
    5720:	d100      	bne.n	5724 <system_clock_init+0x90>
		coarse = 0x1f;
    5722:	3b20      	subs	r3, #32
	}
	dfll_conf.coarse_value = coarse;
    5724:	a805      	add	r0, sp, #20
    5726:	7203      	strb	r3, [r0, #8]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    5728:	4b2a      	ldr	r3, [pc, #168]	; (57d4 <system_clock_init+0x140>)
    572a:	8203      	strh	r3, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    572c:	2307      	movs	r3, #7
    572e:	7303      	strb	r3, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    5730:	3338      	adds	r3, #56	; 0x38
    5732:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    5734:	4b28      	ldr	r3, [pc, #160]	; (57d8 <system_clock_init+0x144>)
    5736:	4798      	blx	r3
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
    5738:	a804      	add	r0, sp, #16
    573a:	2500      	movs	r5, #0
    573c:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
    573e:	2601      	movs	r6, #1
    5740:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    5742:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    5744:	4b25      	ldr	r3, [pc, #148]	; (57dc <system_clock_init+0x148>)
    5746:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    5748:	2006      	movs	r0, #6
    574a:	4f20      	ldr	r7, [pc, #128]	; (57cc <system_clock_init+0x138>)
    574c:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    574e:	4b24      	ldr	r3, [pc, #144]	; (57e0 <system_clock_init+0x14c>)
    5750:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    5752:	ac01      	add	r4, sp, #4
    5754:	9602      	str	r6, [sp, #8]
	config->high_when_disabled = false;
    5756:	7065      	strb	r5, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    5758:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
    575a:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    575c:	2305      	movs	r3, #5
    575e:	7023      	strb	r3, [r4, #0]
    5760:	2001      	movs	r0, #1
    5762:	1c21      	adds	r1, r4, #0
    5764:	4b1f      	ldr	r3, [pc, #124]	; (57e4 <system_clock_init+0x150>)
    5766:	4798      	blx	r3
    5768:	2001      	movs	r0, #1
    576a:	4b1f      	ldr	r3, [pc, #124]	; (57e8 <system_clock_init+0x154>)
    576c:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    576e:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    5770:	2000      	movs	r0, #0
    5772:	1c21      	adds	r1, r4, #0
    5774:	4b13      	ldr	r3, [pc, #76]	; (57c4 <system_clock_init+0x130>)
    5776:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    5778:	2000      	movs	r0, #0
    577a:	4b1c      	ldr	r3, [pc, #112]	; (57ec <system_clock_init+0x158>)
    577c:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    577e:	2007      	movs	r0, #7
    5780:	47b8      	blx	r7

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    5782:	490e      	ldr	r1, [pc, #56]	; (57bc <system_clock_init+0x128>)
    5784:	22d0      	movs	r2, #208	; 0xd0
    5786:	68cb      	ldr	r3, [r1, #12]
    5788:	4013      	ands	r3, r2


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    578a:	2bd0      	cmp	r3, #208	; 0xd0
    578c:	d1fb      	bne.n	5786 <system_clock_init+0xf2>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    578e:	4a18      	ldr	r2, [pc, #96]	; (57f0 <system_clock_init+0x15c>)
    5790:	2300      	movs	r3, #0
    5792:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    5794:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    5796:	7293      	strb	r3, [r2, #10]
			break;
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
    5798:	72d3      	strb	r3, [r2, #11]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    579a:	a901      	add	r1, sp, #4
    579c:	2201      	movs	r2, #1
    579e:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    57a0:	704b      	strb	r3, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    57a2:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    57a4:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    57a6:	3307      	adds	r3, #7
    57a8:	700b      	strb	r3, [r1, #0]
    57aa:	2000      	movs	r0, #0
    57ac:	4b0d      	ldr	r3, [pc, #52]	; (57e4 <system_clock_init+0x150>)
    57ae:	4798      	blx	r3
    57b0:	2000      	movs	r0, #0
    57b2:	4b0d      	ldr	r3, [pc, #52]	; (57e8 <system_clock_init+0x154>)
    57b4:	4798      	blx	r3
#endif
}
    57b6:	b00f      	add	sp, #60	; 0x3c
    57b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    57ba:	46c0      	nop			; (mov r8, r8)
    57bc:	40000800 	.word	0x40000800
    57c0:	41004000 	.word	0x41004000
    57c4:	00005a2d 	.word	0x00005a2d
    57c8:	00005491 	.word	0x00005491
    57cc:	000055ed 	.word	0x000055ed
    57d0:	00806024 	.word	0x00806024
    57d4:	000005b9 	.word	0x000005b9
    57d8:	00005569 	.word	0x00005569
    57dc:	00005455 	.word	0x00005455
    57e0:	000057f5 	.word	0x000057f5
    57e4:	00005819 	.word	0x00005819
    57e8:	000058d1 	.word	0x000058d1
    57ec:	000059a1 	.word	0x000059a1
    57f0:	40000400 	.word	0x40000400

000057f4 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    57f4:	4a06      	ldr	r2, [pc, #24]	; (5810 <system_gclk_init+0x1c>)
    57f6:	6991      	ldr	r1, [r2, #24]
    57f8:	2308      	movs	r3, #8
    57fa:	430b      	orrs	r3, r1
    57fc:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    57fe:	2201      	movs	r2, #1
    5800:	4b04      	ldr	r3, [pc, #16]	; (5814 <system_gclk_init+0x20>)
    5802:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    5804:	1c19      	adds	r1, r3, #0
    5806:	780b      	ldrb	r3, [r1, #0]
    5808:	4213      	tst	r3, r2
    580a:	d1fc      	bne.n	5806 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    580c:	4770      	bx	lr
    580e:	46c0      	nop			; (mov r8, r8)
    5810:	40000400 	.word	0x40000400
    5814:	40000c00 	.word	0x40000c00

00005818 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    5818:	b570      	push	{r4, r5, r6, lr}
    581a:	1c06      	adds	r6, r0, #0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    581c:	1c04      	adds	r4, r0, #0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    581e:	780d      	ldrb	r5, [r1, #0]
    5820:	022d      	lsls	r5, r5, #8
    5822:	4305      	orrs	r5, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    5824:	784b      	ldrb	r3, [r1, #1]
    5826:	2b00      	cmp	r3, #0
    5828:	d002      	beq.n	5830 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    582a:	2380      	movs	r3, #128	; 0x80
    582c:	02db      	lsls	r3, r3, #11
    582e:	431d      	orrs	r5, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    5830:	7a4b      	ldrb	r3, [r1, #9]
    5832:	2b00      	cmp	r3, #0
    5834:	d002      	beq.n	583c <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    5836:	2380      	movs	r3, #128	; 0x80
    5838:	031b      	lsls	r3, r3, #12
    583a:	431d      	orrs	r5, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    583c:	6848      	ldr	r0, [r1, #4]
    583e:	2801      	cmp	r0, #1
    5840:	d918      	bls.n	5874 <system_gclk_gen_set_config+0x5c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    5842:	1e43      	subs	r3, r0, #1
    5844:	4218      	tst	r0, r3
    5846:	d110      	bne.n	586a <system_gclk_gen_set_config+0x52>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    5848:	2802      	cmp	r0, #2
    584a:	d906      	bls.n	585a <system_gclk_gen_set_config+0x42>
    584c:	2302      	movs	r3, #2
    584e:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    5850:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    5852:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    5854:	4298      	cmp	r0, r3
    5856:	d8fb      	bhi.n	5850 <system_gclk_gen_set_config+0x38>
    5858:	e000      	b.n	585c <system_gclk_gen_set_config+0x44>
    585a:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    585c:	0212      	lsls	r2, r2, #8
    585e:	4332      	orrs	r2, r6
    5860:	1c14      	adds	r4, r2, #0
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    5862:	2380      	movs	r3, #128	; 0x80
    5864:	035b      	lsls	r3, r3, #13
    5866:	431d      	orrs	r5, r3
    5868:	e004      	b.n	5874 <system_gclk_gen_set_config+0x5c>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    586a:	0204      	lsls	r4, r0, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    586c:	4334      	orrs	r4, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    586e:	2380      	movs	r3, #128	; 0x80
    5870:	029b      	lsls	r3, r3, #10
    5872:	431d      	orrs	r5, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    5874:	7a0b      	ldrb	r3, [r1, #8]
    5876:	2b00      	cmp	r3, #0
    5878:	d002      	beq.n	5880 <system_gclk_gen_set_config+0x68>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    587a:	2380      	movs	r3, #128	; 0x80
    587c:	039b      	lsls	r3, r3, #14
    587e:	431d      	orrs	r5, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5880:	4a0f      	ldr	r2, [pc, #60]	; (58c0 <system_gclk_gen_set_config+0xa8>)
    5882:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
    5884:	b25b      	sxtb	r3, r3
    5886:	2b00      	cmp	r3, #0
    5888:	dbfb      	blt.n	5882 <system_gclk_gen_set_config+0x6a>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    588a:	4b0e      	ldr	r3, [pc, #56]	; (58c4 <system_gclk_gen_set_config+0xac>)
    588c:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    588e:	4b0e      	ldr	r3, [pc, #56]	; (58c8 <system_gclk_gen_set_config+0xb0>)
    5890:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5892:	4a0b      	ldr	r2, [pc, #44]	; (58c0 <system_gclk_gen_set_config+0xa8>)
    5894:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    5896:	b25b      	sxtb	r3, r3
    5898:	2b00      	cmp	r3, #0
    589a:	dbfb      	blt.n	5894 <system_gclk_gen_set_config+0x7c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    589c:	4b08      	ldr	r3, [pc, #32]	; (58c0 <system_gclk_gen_set_config+0xa8>)
    589e:	609c      	str	r4, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    58a0:	1c1a      	adds	r2, r3, #0
    58a2:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
    58a4:	b25b      	sxtb	r3, r3
    58a6:	2b00      	cmp	r3, #0
    58a8:	dbfb      	blt.n	58a2 <system_gclk_gen_set_config+0x8a>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    58aa:	4a05      	ldr	r2, [pc, #20]	; (58c0 <system_gclk_gen_set_config+0xa8>)
    58ac:	6851      	ldr	r1, [r2, #4]
    58ae:	2380      	movs	r3, #128	; 0x80
    58b0:	025b      	lsls	r3, r3, #9
    58b2:	400b      	ands	r3, r1
    58b4:	431d      	orrs	r5, r3
    58b6:	6055      	str	r5, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    58b8:	4b04      	ldr	r3, [pc, #16]	; (58cc <system_gclk_gen_set_config+0xb4>)
    58ba:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    58bc:	bd70      	pop	{r4, r5, r6, pc}
    58be:	46c0      	nop			; (mov r8, r8)
    58c0:	40000c00 	.word	0x40000c00
    58c4:	00004191 	.word	0x00004191
    58c8:	40000c08 	.word	0x40000c08
    58cc:	000041d1 	.word	0x000041d1

000058d0 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    58d0:	b510      	push	{r4, lr}
    58d2:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    58d4:	4a0b      	ldr	r2, [pc, #44]	; (5904 <system_gclk_gen_enable+0x34>)
    58d6:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    58d8:	b25b      	sxtb	r3, r3
    58da:	2b00      	cmp	r3, #0
    58dc:	dbfb      	blt.n	58d6 <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    58de:	4b0a      	ldr	r3, [pc, #40]	; (5908 <system_gclk_gen_enable+0x38>)
    58e0:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    58e2:	4b0a      	ldr	r3, [pc, #40]	; (590c <system_gclk_gen_enable+0x3c>)
    58e4:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    58e6:	4a07      	ldr	r2, [pc, #28]	; (5904 <system_gclk_gen_enable+0x34>)
    58e8:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    58ea:	b25b      	sxtb	r3, r3
    58ec:	2b00      	cmp	r3, #0
    58ee:	dbfb      	blt.n	58e8 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    58f0:	4a04      	ldr	r2, [pc, #16]	; (5904 <system_gclk_gen_enable+0x34>)
    58f2:	6853      	ldr	r3, [r2, #4]
    58f4:	2180      	movs	r1, #128	; 0x80
    58f6:	0249      	lsls	r1, r1, #9
    58f8:	430b      	orrs	r3, r1
    58fa:	6053      	str	r3, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    58fc:	4b04      	ldr	r3, [pc, #16]	; (5910 <system_gclk_gen_enable+0x40>)
    58fe:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    5900:	bd10      	pop	{r4, pc}
    5902:	46c0      	nop			; (mov r8, r8)
    5904:	40000c00 	.word	0x40000c00
    5908:	00004191 	.word	0x00004191
    590c:	40000c04 	.word	0x40000c04
    5910:	000041d1 	.word	0x000041d1

00005914 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    5914:	b570      	push	{r4, r5, r6, lr}
    5916:	1c04      	adds	r4, r0, #0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5918:	4a1a      	ldr	r2, [pc, #104]	; (5984 <system_gclk_gen_get_hz+0x70>)
    591a:	7853      	ldrb	r3, [r2, #1]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    591c:	b25b      	sxtb	r3, r3
    591e:	2b00      	cmp	r3, #0
    5920:	dbfb      	blt.n	591a <system_gclk_gen_get_hz+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5922:	4b19      	ldr	r3, [pc, #100]	; (5988 <system_gclk_gen_get_hz+0x74>)
    5924:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    5926:	4b19      	ldr	r3, [pc, #100]	; (598c <system_gclk_gen_get_hz+0x78>)
    5928:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    592a:	4a16      	ldr	r2, [pc, #88]	; (5984 <system_gclk_gen_get_hz+0x70>)
    592c:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    592e:	b25b      	sxtb	r3, r3
    5930:	2b00      	cmp	r3, #0
    5932:	dbfb      	blt.n	592c <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    5934:	4e13      	ldr	r6, [pc, #76]	; (5984 <system_gclk_gen_get_hz+0x70>)
    5936:	6870      	ldr	r0, [r6, #4]
    5938:	04c0      	lsls	r0, r0, #19
    593a:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    593c:	4b14      	ldr	r3, [pc, #80]	; (5990 <system_gclk_gen_get_hz+0x7c>)
    593e:	4798      	blx	r3
    5940:	1c05      	adds	r5, r0, #0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    5942:	4b12      	ldr	r3, [pc, #72]	; (598c <system_gclk_gen_get_hz+0x78>)
    5944:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    5946:	6876      	ldr	r6, [r6, #4]
    5948:	02f6      	lsls	r6, r6, #11
    594a:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    594c:	4b11      	ldr	r3, [pc, #68]	; (5994 <system_gclk_gen_get_hz+0x80>)
    594e:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5950:	4a0c      	ldr	r2, [pc, #48]	; (5984 <system_gclk_gen_get_hz+0x70>)
    5952:	7853      	ldrb	r3, [r2, #1]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
    5954:	b25b      	sxtb	r3, r3
    5956:	2b00      	cmp	r3, #0
    5958:	dbfb      	blt.n	5952 <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    595a:	4b0a      	ldr	r3, [pc, #40]	; (5984 <system_gclk_gen_get_hz+0x70>)
    595c:	689c      	ldr	r4, [r3, #8]
    595e:	0a24      	lsrs	r4, r4, #8
    5960:	b2a4      	uxth	r4, r4
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5962:	4b0d      	ldr	r3, [pc, #52]	; (5998 <system_gclk_gen_get_hz+0x84>)
    5964:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    5966:	2e00      	cmp	r6, #0
    5968:	d107      	bne.n	597a <system_gclk_gen_get_hz+0x66>
    596a:	2c01      	cmp	r4, #1
    596c:	d907      	bls.n	597e <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
    596e:	1c28      	adds	r0, r5, #0
    5970:	1c21      	adds	r1, r4, #0
    5972:	4b0a      	ldr	r3, [pc, #40]	; (599c <system_gclk_gen_get_hz+0x88>)
    5974:	4798      	blx	r3
    5976:	1c05      	adds	r5, r0, #0
    5978:	e001      	b.n	597e <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    597a:	3401      	adds	r4, #1
    597c:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    597e:	1c28      	adds	r0, r5, #0
    5980:	bd70      	pop	{r4, r5, r6, pc}
    5982:	46c0      	nop			; (mov r8, r8)
    5984:	40000c00 	.word	0x40000c00
    5988:	00004191 	.word	0x00004191
    598c:	40000c04 	.word	0x40000c04
    5990:	000053c5 	.word	0x000053c5
    5994:	40000c08 	.word	0x40000c08
    5998:	000041d1 	.word	0x000041d1
    599c:	0000bdad 	.word	0x0000bdad

000059a0 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    59a0:	b510      	push	{r4, lr}
    59a2:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    59a4:	4b06      	ldr	r3, [pc, #24]	; (59c0 <system_gclk_chan_enable+0x20>)
    59a6:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    59a8:	4b06      	ldr	r3, [pc, #24]	; (59c4 <system_gclk_chan_enable+0x24>)
    59aa:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    59ac:	4a06      	ldr	r2, [pc, #24]	; (59c8 <system_gclk_chan_enable+0x28>)
    59ae:	8851      	ldrh	r1, [r2, #2]
    59b0:	2380      	movs	r3, #128	; 0x80
    59b2:	01db      	lsls	r3, r3, #7
    59b4:	430b      	orrs	r3, r1
    59b6:	8053      	strh	r3, [r2, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    59b8:	4b04      	ldr	r3, [pc, #16]	; (59cc <system_gclk_chan_enable+0x2c>)
    59ba:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    59bc:	bd10      	pop	{r4, pc}
    59be:	46c0      	nop			; (mov r8, r8)
    59c0:	00004191 	.word	0x00004191
    59c4:	40000c02 	.word	0x40000c02
    59c8:	40000c00 	.word	0x40000c00
    59cc:	000041d1 	.word	0x000041d1

000059d0 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    59d0:	b510      	push	{r4, lr}
    59d2:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    59d4:	4b0f      	ldr	r3, [pc, #60]	; (5a14 <system_gclk_chan_disable+0x44>)
    59d6:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    59d8:	4b0f      	ldr	r3, [pc, #60]	; (5a18 <system_gclk_chan_disable+0x48>)
    59da:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    59dc:	4b0f      	ldr	r3, [pc, #60]	; (5a1c <system_gclk_chan_disable+0x4c>)
    59de:	885a      	ldrh	r2, [r3, #2]
    59e0:	0512      	lsls	r2, r2, #20
    59e2:	0f10      	lsrs	r0, r2, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    59e4:	8859      	ldrh	r1, [r3, #2]
    59e6:	4a0e      	ldr	r2, [pc, #56]	; (5a20 <system_gclk_chan_disable+0x50>)
    59e8:	400a      	ands	r2, r1
    59ea:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    59ec:	8859      	ldrh	r1, [r3, #2]
    59ee:	4a0d      	ldr	r2, [pc, #52]	; (5a24 <system_gclk_chan_disable+0x54>)
    59f0:	400a      	ands	r2, r1
    59f2:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    59f4:	1c19      	adds	r1, r3, #0
    59f6:	2280      	movs	r2, #128	; 0x80
    59f8:	01d2      	lsls	r2, r2, #7
    59fa:	884b      	ldrh	r3, [r1, #2]
    59fc:	4213      	tst	r3, r2
    59fe:	d1fc      	bne.n	59fa <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    5a00:	4906      	ldr	r1, [pc, #24]	; (5a1c <system_gclk_chan_disable+0x4c>)
    5a02:	0202      	lsls	r2, r0, #8
    5a04:	8848      	ldrh	r0, [r1, #2]
    5a06:	4b06      	ldr	r3, [pc, #24]	; (5a20 <system_gclk_chan_disable+0x50>)
    5a08:	4003      	ands	r3, r0
    5a0a:	4313      	orrs	r3, r2
    5a0c:	804b      	strh	r3, [r1, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5a0e:	4b06      	ldr	r3, [pc, #24]	; (5a28 <system_gclk_chan_disable+0x58>)
    5a10:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    5a12:	bd10      	pop	{r4, pc}
    5a14:	00004191 	.word	0x00004191
    5a18:	40000c02 	.word	0x40000c02
    5a1c:	40000c00 	.word	0x40000c00
    5a20:	fffff0ff 	.word	0xfffff0ff
    5a24:	ffffbfff 	.word	0xffffbfff
    5a28:	000041d1 	.word	0x000041d1

00005a2c <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    5a2c:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    5a2e:	780c      	ldrb	r4, [r1, #0]
    5a30:	0224      	lsls	r4, r4, #8
    5a32:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    5a34:	4b02      	ldr	r3, [pc, #8]	; (5a40 <system_gclk_chan_set_config+0x14>)
    5a36:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    5a38:	b2a4      	uxth	r4, r4
    5a3a:	4b02      	ldr	r3, [pc, #8]	; (5a44 <system_gclk_chan_set_config+0x18>)
    5a3c:	805c      	strh	r4, [r3, #2]
}
    5a3e:	bd10      	pop	{r4, pc}
    5a40:	000059d1 	.word	0x000059d1
    5a44:	40000c00 	.word	0x40000c00

00005a48 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    5a48:	b510      	push	{r4, lr}
    5a4a:	1c04      	adds	r4, r0, #0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5a4c:	4b06      	ldr	r3, [pc, #24]	; (5a68 <system_gclk_chan_get_hz+0x20>)
    5a4e:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    5a50:	4b06      	ldr	r3, [pc, #24]	; (5a6c <system_gclk_chan_get_hz+0x24>)
    5a52:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    5a54:	4b06      	ldr	r3, [pc, #24]	; (5a70 <system_gclk_chan_get_hz+0x28>)
    5a56:	885c      	ldrh	r4, [r3, #2]
    5a58:	0524      	lsls	r4, r4, #20
    5a5a:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5a5c:	4b05      	ldr	r3, [pc, #20]	; (5a74 <system_gclk_chan_get_hz+0x2c>)
    5a5e:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    5a60:	1c20      	adds	r0, r4, #0
    5a62:	4b05      	ldr	r3, [pc, #20]	; (5a78 <system_gclk_chan_get_hz+0x30>)
    5a64:	4798      	blx	r3
}
    5a66:	bd10      	pop	{r4, pc}
    5a68:	00004191 	.word	0x00004191
    5a6c:	40000c02 	.word	0x40000c02
    5a70:	40000c00 	.word	0x40000c00
    5a74:	000041d1 	.word	0x000041d1
    5a78:	00005915 	.word	0x00005915

00005a7c <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    5a7c:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    5a7e:	78d3      	ldrb	r3, [r2, #3]
    5a80:	2b00      	cmp	r3, #0
    5a82:	d11e      	bne.n	5ac2 <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    5a84:	7814      	ldrb	r4, [r2, #0]
    5a86:	2c80      	cmp	r4, #128	; 0x80
    5a88:	d004      	beq.n	5a94 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    5a8a:	0624      	lsls	r4, r4, #24
    5a8c:	2380      	movs	r3, #128	; 0x80
    5a8e:	025b      	lsls	r3, r3, #9
    5a90:	431c      	orrs	r4, r3
    5a92:	e000      	b.n	5a96 <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    5a94:	2400      	movs	r4, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    5a96:	7853      	ldrb	r3, [r2, #1]
    5a98:	2502      	movs	r5, #2
    5a9a:	43ab      	bics	r3, r5
    5a9c:	d10a      	bne.n	5ab4 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    5a9e:	7893      	ldrb	r3, [r2, #2]
    5aa0:	2b00      	cmp	r3, #0
    5aa2:	d103      	bne.n	5aac <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    5aa4:	2380      	movs	r3, #128	; 0x80
    5aa6:	029b      	lsls	r3, r3, #10
    5aa8:	431c      	orrs	r4, r3
    5aaa:	e002      	b.n	5ab2 <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    5aac:	23c0      	movs	r3, #192	; 0xc0
    5aae:	02db      	lsls	r3, r3, #11
    5ab0:	431c      	orrs	r4, r3
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    5ab2:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    5ab4:	7853      	ldrb	r3, [r2, #1]
    5ab6:	3b01      	subs	r3, #1
    5ab8:	2b01      	cmp	r3, #1
    5aba:	d812      	bhi.n	5ae2 <_system_pinmux_config+0x66>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    5abc:	4b18      	ldr	r3, [pc, #96]	; (5b20 <_system_pinmux_config+0xa4>)
    5abe:	401c      	ands	r4, r3
    5ac0:	e00f      	b.n	5ae2 <_system_pinmux_config+0x66>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    5ac2:	6041      	str	r1, [r0, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    5ac4:	040b      	lsls	r3, r1, #16
    5ac6:	0c1b      	lsrs	r3, r3, #16

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    5ac8:	24a0      	movs	r4, #160	; 0xa0
    5aca:	05e4      	lsls	r4, r4, #23
    5acc:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5ace:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    5ad0:	0c0b      	lsrs	r3, r1, #16

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    5ad2:	24d0      	movs	r4, #208	; 0xd0
    5ad4:	0624      	lsls	r4, r4, #24
    5ad6:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5ad8:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    5ada:	78d3      	ldrb	r3, [r2, #3]
    5adc:	2b00      	cmp	r3, #0
    5ade:	d018      	beq.n	5b12 <_system_pinmux_config+0x96>
    5ae0:	e01c      	b.n	5b1c <_system_pinmux_config+0xa0>
		port->DIRCLR.reg = pin_mask;
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    5ae2:	040b      	lsls	r3, r1, #16
    5ae4:	0c1b      	lsrs	r3, r3, #16
    5ae6:	25a0      	movs	r5, #160	; 0xa0
    5ae8:	05ed      	lsls	r5, r5, #23
    5aea:	432b      	orrs	r3, r5

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    5aec:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5aee:	6283      	str	r3, [r0, #40]	; 0x28
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
	uint32_t upper_pin_mask = (pin_mask >> 16);
    5af0:	0c0b      	lsrs	r3, r1, #16
    5af2:	25d0      	movs	r5, #208	; 0xd0
    5af4:	062d      	lsls	r5, r5, #24
    5af6:	432b      	orrs	r3, r5

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    5af8:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5afa:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    5afc:	78d3      	ldrb	r3, [r2, #3]
    5afe:	2b00      	cmp	r3, #0
    5b00:	d10c      	bne.n	5b1c <_system_pinmux_config+0xa0>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    5b02:	0363      	lsls	r3, r4, #13
    5b04:	d505      	bpl.n	5b12 <_system_pinmux_config+0x96>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    5b06:	7893      	ldrb	r3, [r2, #2]
    5b08:	2b01      	cmp	r3, #1
    5b0a:	d101      	bne.n	5b10 <_system_pinmux_config+0x94>
				port->OUTSET.reg = pin_mask;
    5b0c:	6181      	str	r1, [r0, #24]
    5b0e:	e000      	b.n	5b12 <_system_pinmux_config+0x96>
			} else {
				port->OUTCLR.reg = pin_mask;
    5b10:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    5b12:	7853      	ldrb	r3, [r2, #1]
    5b14:	3b01      	subs	r3, #1
    5b16:	2b01      	cmp	r3, #1
    5b18:	d800      	bhi.n	5b1c <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    5b1a:	6081      	str	r1, [r0, #8]
		}
	}
}
    5b1c:	bd30      	pop	{r4, r5, pc}
    5b1e:	46c0      	nop			; (mov r8, r8)
    5b20:	fffbffff 	.word	0xfffbffff

00005b24 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    5b24:	b508      	push	{r3, lr}
    5b26:	1c03      	adds	r3, r0, #0
    5b28:	1c0a      	adds	r2, r1, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    5b2a:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    5b2c:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    5b2e:	2900      	cmp	r1, #0
    5b30:	d104      	bne.n	5b3c <system_pinmux_pin_set_config+0x18>
		return &(ports[port_index]->Group[group_index]);
    5b32:	0958      	lsrs	r0, r3, #5
    5b34:	01c0      	lsls	r0, r0, #7
    5b36:	4905      	ldr	r1, [pc, #20]	; (5b4c <system_pinmux_pin_set_config+0x28>)
    5b38:	468c      	mov	ip, r1
    5b3a:	4460      	add	r0, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    5b3c:	211f      	movs	r1, #31
    5b3e:	400b      	ands	r3, r1
    5b40:	391e      	subs	r1, #30
    5b42:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    5b44:	4b02      	ldr	r3, [pc, #8]	; (5b50 <system_pinmux_pin_set_config+0x2c>)
    5b46:	4798      	blx	r3
}
    5b48:	bd08      	pop	{r3, pc}
    5b4a:	46c0      	nop			; (mov r8, r8)
    5b4c:	41004400 	.word	0x41004400
    5b50:	00005a7d 	.word	0x00005a7d

00005b54 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    5b54:	4770      	bx	lr
    5b56:	46c0      	nop			; (mov r8, r8)

00005b58 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    5b58:	b508      	push	{r3, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    5b5a:	4b05      	ldr	r3, [pc, #20]	; (5b70 <system_init+0x18>)
    5b5c:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    5b5e:	4b05      	ldr	r3, [pc, #20]	; (5b74 <system_init+0x1c>)
    5b60:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    5b62:	4b05      	ldr	r3, [pc, #20]	; (5b78 <system_init+0x20>)
    5b64:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    5b66:	4b05      	ldr	r3, [pc, #20]	; (5b7c <system_init+0x24>)
    5b68:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    5b6a:	4b05      	ldr	r3, [pc, #20]	; (5b80 <system_init+0x28>)
    5b6c:	4798      	blx	r3
}
    5b6e:	bd08      	pop	{r3, pc}
    5b70:	00005695 	.word	0x00005695
    5b74:	00004201 	.word	0x00004201
    5b78:	00005b55 	.word	0x00005b55
    5b7c:	00004325 	.word	0x00004325
    5b80:	00005b55 	.word	0x00005b55

00005b84 <_tcc_get_inst_index>:
uint8_t _tcc_get_inst_index(
		Tcc *const hw)
{
	/* Find index for TCC instance. */
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
		if (hw == tcc_modules[i]) {
    5b84:	4b08      	ldr	r3, [pc, #32]	; (5ba8 <_tcc_get_inst_index+0x24>)
    5b86:	4298      	cmp	r0, r3
    5b88:	d00a      	beq.n	5ba0 <_tcc_get_inst_index+0x1c>
    5b8a:	4b08      	ldr	r3, [pc, #32]	; (5bac <_tcc_get_inst_index+0x28>)
    5b8c:	4298      	cmp	r0, r3
    5b8e:	d005      	beq.n	5b9c <_tcc_get_inst_index+0x18>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    5b90:	2300      	movs	r3, #0
uint8_t _tcc_get_inst_index(
		Tcc *const hw)
{
	/* Find index for TCC instance. */
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
		if (hw == tcc_modules[i]) {
    5b92:	4a07      	ldr	r2, [pc, #28]	; (5bb0 <_tcc_get_inst_index+0x2c>)
    5b94:	4290      	cmp	r0, r2
    5b96:	d105      	bne.n	5ba4 <_tcc_get_inst_index+0x20>
 */
uint8_t _tcc_get_inst_index(
		Tcc *const hw)
{
	/* Find index for TCC instance. */
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
    5b98:	3302      	adds	r3, #2
    5b9a:	e002      	b.n	5ba2 <_tcc_get_inst_index+0x1e>
    5b9c:	2301      	movs	r3, #1
    5b9e:	e000      	b.n	5ba2 <_tcc_get_inst_index+0x1e>
    5ba0:	2300      	movs	r3, #0
		if (hw == tcc_modules[i]) {
			return i;
    5ba2:	b2db      	uxtb	r3, r3
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
    5ba4:	1c18      	adds	r0, r3, #0
    5ba6:	4770      	bx	lr
    5ba8:	42002000 	.word	0x42002000
    5bac:	42002400 	.word	0x42002400
    5bb0:	42002800 	.word	0x42002800

00005bb4 <tcc_get_config_defaults>:
 *
 */
void tcc_get_config_defaults(
		struct tcc_config *const config,
		Tcc *const hw)
{
    5bb4:	b510      	push	{r4, lr}
    5bb6:	1c04      	adds	r4, r0, #0
	/* TCC instance index */
	uint8_t module_index = _tcc_get_inst_index(hw);
    5bb8:	1c08      	adds	r0, r1, #0
    5bba:	4b4f      	ldr	r3, [pc, #316]	; (5cf8 <tcc_get_config_defaults+0x144>)
    5bbc:	4798      	blx	r3

	/* Base counter defaults */
	config->counter.count                  = 0;
    5bbe:	2300      	movs	r3, #0
    5bc0:	6023      	str	r3, [r4, #0]

	config->counter.period                 = _tcc_maxs[module_index];
    5bc2:	0080      	lsls	r0, r0, #2
    5bc4:	4a4d      	ldr	r2, [pc, #308]	; (5cfc <tcc_get_config_defaults+0x148>)
    5bc6:	5882      	ldr	r2, [r0, r2]
    5bc8:	6062      	str	r2, [r4, #4]

	config->counter.clock_source           = GCLK_GENERATOR_0;
    5bca:	72a3      	strb	r3, [r4, #10]
	config->counter.clock_prescaler        = TCC_CLOCK_PRESCALER_DIV1;
    5bcc:	72e3      	strb	r3, [r4, #11]
	config->counter.reload_action          = TCC_RELOAD_ACTION_GCLK;
    5bce:	7323      	strb	r3, [r4, #12]

	config->counter.direction              = TCC_COUNT_DIRECTION_UP;
    5bd0:	7263      	strb	r3, [r4, #9]
	config->counter.oneshot                = false;
    5bd2:	7223      	strb	r3, [r4, #8]
#endif

	/* Match/Capture defaults */
#  define _TCC_CHANNEL_MATCH_VALUE_INIT(n, value) \
		config->compare.match[n] = value;
	MREPEAT(TCC_NUM_CHANNELS,
    5bd4:	61e3      	str	r3, [r4, #28]
    5bd6:	6223      	str	r3, [r4, #32]
    5bd8:	6263      	str	r3, [r4, #36]	; 0x24
    5bda:	62a3      	str	r3, [r4, #40]	; 0x28
#  undef _TCC_CHANNEL_MATCH_VALUE_INIT

	/* Wave polarity defaults */
#  define _TCC_CHANNEL_WAVE_POLARITY_INIT(n, value) \
		config->compare.wave_polarity[n] = value;
	MREPEAT(TCC_NUM_CHANNELS,
    5bdc:	7523      	strb	r3, [r4, #20]
    5bde:	7563      	strb	r3, [r4, #21]
    5be0:	75a3      	strb	r3, [r4, #22]
    5be2:	75e3      	strb	r3, [r4, #23]
		_TCC_CHANNEL_WAVE_POLARITY_INIT, TCC_WAVE_POLARITY_0)
#  undef _TCC_CHANNEL_WAVE_POLARITY_INIT

	config->compare.wave_generation = TCC_WAVE_GENERATION_NORMAL_FREQ;
    5be4:	7623      	strb	r3, [r4, #24]
	config->compare.wave_ramp       = TCC_RAMP_RAMP1;
    5be6:	7663      	strb	r3, [r4, #25]

#  define _TCC_CHANNEL_FUNCTION_INIT(n, value) \
		config->compare.channel_function[n] = value;
	MREPEAT(TCC_NUM_CHANNELS,
    5be8:	7423      	strb	r3, [r4, #16]
    5bea:	7463      	strb	r3, [r4, #17]
    5bec:	74a3      	strb	r3, [r4, #18]
    5bee:	74e3      	strb	r3, [r4, #19]
		config->wave_ext.recoverable_fault[n].source = TCC_FAULT_SOURCE_DISABLE;           \
		config->wave_ext.recoverable_fault[n].blanking = TCC_FAULT_BLANKING_DISABLE;       \
		config->wave_ext.recoverable_fault[n].halt_action = TCC_FAULT_HALT_ACTION_DISABLE; \
		config->wave_ext.recoverable_fault[n].capture_action = TCC_FAULT_CAPTURE_DISABLE;  \
		config->wave_ext.recoverable_fault[n].capture_channel = TCC_FAULT_CAPTURE_CHANNEL_0;
	MREPEAT(TCC_NUM_FAULTS, _TCC_FAULT_FUNCTION_INIT, 0)
    5bf0:	222c      	movs	r2, #44	; 0x2c
    5bf2:	54a3      	strb	r3, [r4, r2]
    5bf4:	3201      	adds	r2, #1
    5bf6:	54a3      	strb	r3, [r4, r2]
    5bf8:	3201      	adds	r2, #1
    5bfa:	54a3      	strb	r3, [r4, r2]
    5bfc:	3201      	adds	r2, #1
    5bfe:	54a3      	strb	r3, [r4, r2]
    5c00:	3201      	adds	r2, #1
    5c02:	54a3      	strb	r3, [r4, r2]
    5c04:	3201      	adds	r2, #1
    5c06:	54a3      	strb	r3, [r4, r2]
    5c08:	3201      	adds	r2, #1
    5c0a:	54a3      	strb	r3, [r4, r2]
    5c0c:	3201      	adds	r2, #1
    5c0e:	54a3      	strb	r3, [r4, r2]
    5c10:	3201      	adds	r2, #1
    5c12:	54a3      	strb	r3, [r4, r2]
    5c14:	3201      	adds	r2, #1
    5c16:	54a3      	strb	r3, [r4, r2]
    5c18:	3201      	adds	r2, #1
    5c1a:	54a3      	strb	r3, [r4, r2]
    5c1c:	3201      	adds	r2, #1
    5c1e:	54a3      	strb	r3, [r4, r2]
    5c20:	3201      	adds	r2, #1
    5c22:	54a3      	strb	r3, [r4, r2]
    5c24:	3201      	adds	r2, #1
    5c26:	54a3      	strb	r3, [r4, r2]
    5c28:	3201      	adds	r2, #1
    5c2a:	54a3      	strb	r3, [r4, r2]
    5c2c:	3201      	adds	r2, #1
    5c2e:	54a3      	strb	r3, [r4, r2]
    5c30:	3201      	adds	r2, #1
    5c32:	54a3      	strb	r3, [r4, r2]
    5c34:	3201      	adds	r2, #1
    5c36:	54a3      	strb	r3, [r4, r2]
    5c38:	3201      	adds	r2, #1
    5c3a:	54a3      	strb	r3, [r4, r2]
    5c3c:	3201      	adds	r2, #1
    5c3e:	54a3      	strb	r3, [r4, r2]

	/* Non-recoverable fault defaults */
#  define _TCC_NRF_FUNCTION_INIT(n, dummy) \
		config->wave_ext.non_recoverable_fault[n].filter_value = 0; \
		config->wave_ext.non_recoverable_fault[n].output = TCC_FAULT_STATE_OUTPUT_OFF;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_NRF_FUNCTION_INIT, 0)
    5c40:	3201      	adds	r2, #1
    5c42:	54a3      	strb	r3, [r4, r2]
    5c44:	3201      	adds	r2, #1
    5c46:	54a3      	strb	r3, [r4, r2]
    5c48:	3201      	adds	r2, #1
    5c4a:	54a3      	strb	r3, [r4, r2]
    5c4c:	3201      	adds	r2, #1
    5c4e:	54a3      	strb	r3, [r4, r2]
    5c50:	3201      	adds	r2, #1
    5c52:	54a3      	strb	r3, [r4, r2]
    5c54:	3201      	adds	r2, #1
    5c56:	54a3      	strb	r3, [r4, r2]
    5c58:	3201      	adds	r2, #1
    5c5a:	54a3      	strb	r3, [r4, r2]
    5c5c:	3201      	adds	r2, #1
    5c5e:	54a3      	strb	r3, [r4, r2]
    5c60:	3201      	adds	r2, #1
    5c62:	54a3      	strb	r3, [r4, r2]
    5c64:	3201      	adds	r2, #1
    5c66:	54a3      	strb	r3, [r4, r2]
    5c68:	3201      	adds	r2, #1
    5c6a:	54a3      	strb	r3, [r4, r2]
    5c6c:	3201      	adds	r2, #1
    5c6e:	54a3      	strb	r3, [r4, r2]
    5c70:	3201      	adds	r2, #1
    5c72:	54a3      	strb	r3, [r4, r2]
    5c74:	3201      	adds	r2, #1
    5c76:	54a3      	strb	r3, [r4, r2]
    5c78:	3201      	adds	r2, #1
    5c7a:	54a3      	strb	r3, [r4, r2]
    5c7c:	3201      	adds	r2, #1
    5c7e:	54a3      	strb	r3, [r4, r2]
#  undef _TCC_NRF_FUNCTION_INIT

	/* Output inversion defaults */
#  define _TCC_OUT_INVERT_INIT(n, value) \
		config->wave_ext.invert[n] = value;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_OUT_INVERT_INIT, false)
    5c80:	3201      	adds	r2, #1
    5c82:	54a3      	strb	r3, [r4, r2]
    5c84:	3201      	adds	r2, #1
    5c86:	54a3      	strb	r3, [r4, r2]
    5c88:	3201      	adds	r2, #1
    5c8a:	54a3      	strb	r3, [r4, r2]
    5c8c:	3201      	adds	r2, #1
    5c8e:	54a3      	strb	r3, [r4, r2]
    5c90:	3201      	adds	r2, #1
    5c92:	54a3      	strb	r3, [r4, r2]
    5c94:	3201      	adds	r2, #1
    5c96:	54a3      	strb	r3, [r4, r2]
    5c98:	3201      	adds	r2, #1
    5c9a:	54a3      	strb	r3, [r4, r2]
    5c9c:	3201      	adds	r2, #1
    5c9e:	54a3      	strb	r3, [r4, r2]

#  define _TCC_CHANNEL_OUT_PIN_INIT(n, dummy) \
		config->pins.enable_wave_out_pin[n]                = false;\
		config->pins.wave_out_pin[TCC_WAVE_OUTPUT_##n]     = 0;    \
		config->pins.wave_out_pin_mux[TCC_WAVE_OUTPUT_##n] = 0;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_CHANNEL_OUT_PIN_INIT, 0)
    5ca0:	3241      	adds	r2, #65	; 0x41
    5ca2:	54a3      	strb	r3, [r4, r2]
    5ca4:	65a3      	str	r3, [r4, #88]	; 0x58
    5ca6:	67a3      	str	r3, [r4, #120]	; 0x78
    5ca8:	3201      	adds	r2, #1
    5caa:	54a3      	strb	r3, [r4, r2]
    5cac:	65e3      	str	r3, [r4, #92]	; 0x5c
    5cae:	67e3      	str	r3, [r4, #124]	; 0x7c
    5cb0:	3201      	adds	r2, #1
    5cb2:	54a3      	strb	r3, [r4, r2]
    5cb4:	6623      	str	r3, [r4, #96]	; 0x60
    5cb6:	3a1a      	subs	r2, #26
    5cb8:	50a3      	str	r3, [r4, r2]
    5cba:	321b      	adds	r2, #27
    5cbc:	54a3      	strb	r3, [r4, r2]
    5cbe:	6663      	str	r3, [r4, #100]	; 0x64
    5cc0:	3a17      	subs	r2, #23
    5cc2:	50a3      	str	r3, [r4, r2]
    5cc4:	3218      	adds	r2, #24
    5cc6:	54a3      	strb	r3, [r4, r2]
    5cc8:	66a3      	str	r3, [r4, #104]	; 0x68
    5cca:	3a14      	subs	r2, #20
    5ccc:	50a3      	str	r3, [r4, r2]
    5cce:	3215      	adds	r2, #21
    5cd0:	54a3      	strb	r3, [r4, r2]
    5cd2:	66e3      	str	r3, [r4, #108]	; 0x6c
    5cd4:	3a11      	subs	r2, #17
    5cd6:	50a3      	str	r3, [r4, r2]
    5cd8:	3212      	adds	r2, #18
    5cda:	54a3      	strb	r3, [r4, r2]
    5cdc:	6723      	str	r3, [r4, #112]	; 0x70
    5cde:	3a0e      	subs	r2, #14
    5ce0:	50a3      	str	r3, [r4, r2]
    5ce2:	320f      	adds	r2, #15
    5ce4:	54a3      	strb	r3, [r4, r2]
    5ce6:	6763      	str	r3, [r4, #116]	; 0x74
    5ce8:	3a0b      	subs	r2, #11
    5cea:	50a3      	str	r3, [r4, r2]
#  undef _TCC_CHANNEL_OUT_PIN_INIT

	config->double_buffering_enabled  = true;
    5cec:	2101      	movs	r1, #1
    5cee:	320c      	adds	r2, #12
    5cf0:	54a1      	strb	r1, [r4, r2]
	config->run_in_standby            = false;
    5cf2:	3201      	adds	r2, #1
    5cf4:	54a3      	strb	r3, [r4, r2]
}
    5cf6:	bd10      	pop	{r4, pc}
    5cf8:	00005b85 	.word	0x00005b85
    5cfc:	0000ec0c 	.word	0x0000ec0c

00005d00 <tcc_init>:
 */
enum status_code tcc_init(
		struct tcc_module *const module_inst,
		Tcc *const hw,
		const struct tcc_config *const config)
{
    5d00:	b5f0      	push	{r4, r5, r6, r7, lr}
    5d02:	465f      	mov	r7, fp
    5d04:	4656      	mov	r6, sl
    5d06:	464d      	mov	r5, r9
    5d08:	4644      	mov	r4, r8
    5d0a:	b4f0      	push	{r4, r5, r6, r7}
    5d0c:	b08f      	sub	sp, #60	; 0x3c
    5d0e:	9000      	str	r0, [sp, #0]
    5d10:	1c0c      	adds	r4, r1, #0
    5d12:	1c17      	adds	r7, r2, #0
	Assert(hw);
	Assert(module_inst);
	Assert(config);

	/* TCC instance index */
	uint8_t module_index = _tcc_get_inst_index(hw);
    5d14:	1c08      	adds	r0, r1, #0
    5d16:	4b87      	ldr	r3, [pc, #540]	; (5f34 <tcc_init+0x234>)
    5d18:	4798      	blx	r3
    5d1a:	1c05      	adds	r5, r0, #0

	/* Enable the user interface clock for TCC */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    5d1c:	1c06      	adds	r6, r0, #0
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    5d1e:	4a86      	ldr	r2, [pc, #536]	; (5f38 <tcc_init+0x238>)
    5d20:	6a11      	ldr	r1, [r2, #32]
    5d22:	0080      	lsls	r0, r0, #2
    5d24:	4b85      	ldr	r3, [pc, #532]	; (5f3c <tcc_init+0x23c>)
    5d26:	58c3      	ldr	r3, [r0, r3]
    5d28:	430b      	orrs	r3, r1
    5d2a:	6213      	str	r3, [r2, #32]
			_tcc_apbcmasks[module_index]);

	/* Check if it's enabled. */
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
    5d2c:	6823      	ldr	r3, [r4, #0]
		return STATUS_ERR_DENIED;
    5d2e:	201c      	movs	r0, #28
	/* Enable the user interface clock for TCC */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
			_tcc_apbcmasks[module_index]);

	/* Check if it's enabled. */
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
    5d30:	079b      	lsls	r3, r3, #30
    5d32:	d500      	bpl.n	5d36 <tcc_init+0x36>
    5d34:	e1dd      	b.n	60f2 <tcc_init+0x3f2>
		return STATUS_ERR_DENIED;
	}
	/* Check if it's resetting */
	if (hw->CTRLA.reg & TCC_CTRLA_SWRST) {
    5d36:	6823      	ldr	r3, [r4, #0]
    5d38:	2201      	movs	r2, #1
    5d3a:	4013      	ands	r3, r2
    5d3c:	d000      	beq.n	5d40 <tcc_init+0x40>
    5d3e:	e1d8      	b.n	60f2 <tcc_init+0x3f2>
	}

	enum status_code status;

	/* Check COUNT, PER, CCx */
	uint32_t count_max  = _tcc_maxs[module_index];
    5d40:	00aa      	lsls	r2, r5, #2
    5d42:	497f      	ldr	r1, [pc, #508]	; (5f40 <tcc_init+0x240>)
    5d44:	5852      	ldr	r2, [r2, r1]

	/* Check all counter values */
	if ((config->counter.count > count_max)
		|| (config->counter.period > count_max)
		) {
		return STATUS_ERR_INVALID_ARG;
    5d46:	3805      	subs	r0, #5

	/* Check COUNT, PER, CCx */
	uint32_t count_max  = _tcc_maxs[module_index];

	/* Check all counter values */
	if ((config->counter.count > count_max)
    5d48:	6839      	ldr	r1, [r7, #0]
    5d4a:	428a      	cmp	r2, r1
    5d4c:	d200      	bcs.n	5d50 <tcc_init+0x50>
    5d4e:	e1d0      	b.n	60f2 <tcc_init+0x3f2>
		|| (config->counter.period > count_max)
    5d50:	6879      	ldr	r1, [r7, #4]
    5d52:	428a      	cmp	r2, r1
    5d54:	d200      	bcs.n	5d58 <tcc_init+0x58>
    5d56:	e1cc      	b.n	60f2 <tcc_init+0x3f2>
		return STATUS_ERR_INVALID_ARG;
	}

	/* Check all channel values */
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
		if ((config->compare.match[i] > count_max)
    5d58:	69f9      	ldr	r1, [r7, #28]
    5d5a:	428a      	cmp	r2, r1
    5d5c:	d200      	bcs.n	5d60 <tcc_init+0x60>
    5d5e:	e1b3      	b.n	60c8 <tcc_init+0x3c8>
    5d60:	6a39      	ldr	r1, [r7, #32]
    5d62:	4291      	cmp	r1, r2
    5d64:	d900      	bls.n	5d68 <tcc_init+0x68>
    5d66:	e1b1      	b.n	60cc <tcc_init+0x3cc>
    5d68:	6a79      	ldr	r1, [r7, #36]	; 0x24
    5d6a:	428a      	cmp	r2, r1
    5d6c:	d200      	bcs.n	5d70 <tcc_init+0x70>
    5d6e:	e1af      	b.n	60d0 <tcc_init+0x3d0>
    5d70:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    5d72:	428a      	cmp	r2, r1
    5d74:	d200      	bcs.n	5d78 <tcc_init+0x78>
    5d76:	e1ad      	b.n	60d4 <tcc_init+0x3d4>
    5d78:	2298      	movs	r2, #152	; 0x98
    5d7a:	4694      	mov	ip, r2
    5d7c:	44bc      	add	ip, r7
    5d7e:	4662      	mov	r2, ip
    5d80:	9204      	str	r2, [sp, #16]
    5d82:	4661      	mov	r1, ip
    5d84:	2200      	movs	r2, #0
		}
	}

	/* Check all outputs */
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (!config->pins.enable_wave_out_pin[i]) {
    5d86:	7808      	ldrb	r0, [r1, #0]
    5d88:	2800      	cmp	r0, #0
    5d8a:	d004      	beq.n	5d96 <tcc_init+0x96>
			continue;
		}
		/* Output line is not supported */
		if (i >= _tcc_ow_nums[module_index]) {
    5d8c:	486d      	ldr	r0, [pc, #436]	; (5f44 <tcc_init+0x244>)
    5d8e:	5d80      	ldrb	r0, [r0, r6]
    5d90:	4290      	cmp	r0, r2
    5d92:	dc00      	bgt.n	5d96 <tcc_init+0x96>
    5d94:	e1a0      	b.n	60d8 <tcc_init+0x3d8>
			return STATUS_ERR_INVALID_ARG;
		}
	}

	/* Check all outputs */
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
    5d96:	3201      	adds	r2, #1
    5d98:	3101      	adds	r1, #1
    5d9a:	2a08      	cmp	r2, #8
    5d9c:	d1f3      	bne.n	5d86 <tcc_init+0x86>
    5d9e:	2200      	movs	r2, #0
    5da0:	4690      	mov	r8, r2

			if (i > _tcc_cc_nums[module_index]) {
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
			}
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
    5da2:	2180      	movs	r1, #128	; 0x80
    5da4:	0449      	lsls	r1, r1, #17
    5da6:	468c      	mov	ip, r1
    5da8:	18b9      	adds	r1, r7, r2
{
	uint32_t ctrla = 0;

	int i;
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
		if (config->capture.channel_function[i] ==
    5daa:	7c09      	ldrb	r1, [r1, #16]
    5dac:	2901      	cmp	r1, #1
    5dae:	d109      	bne.n	5dc4 <tcc_init+0xc4>
			TCC_CHANNEL_FUNCTION_CAPTURE) {

			if (i > _tcc_cc_nums[module_index]) {
    5db0:	4965      	ldr	r1, [pc, #404]	; (5f48 <tcc_init+0x248>)
    5db2:	5d89      	ldrb	r1, [r1, r6]
    5db4:	4291      	cmp	r1, r2
    5db6:	da00      	bge.n	5dba <tcc_init+0xba>
    5db8:	e190      	b.n	60dc <tcc_init+0x3dc>
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
			}
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
    5dba:	4661      	mov	r1, ip
    5dbc:	4091      	lsls	r1, r2
    5dbe:	4640      	mov	r0, r8
    5dc0:	4308      	orrs	r0, r1
    5dc2:	4680      	mov	r8, r0
		uint32_t *value_buffer)
{
	uint32_t ctrla = 0;

	int i;
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
    5dc4:	3201      	adds	r2, #1
    5dc6:	2a04      	cmp	r2, #4
    5dc8:	d1ee      	bne.n	5da8 <tcc_init+0xa8>
			}
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
		}
	}

	if (config->run_in_standby) {
    5dca:	329d      	adds	r2, #157	; 0x9d
    5dcc:	5cba      	ldrb	r2, [r7, r2]
    5dce:	2a00      	cmp	r2, #0
    5dd0:	d004      	beq.n	5ddc <tcc_init+0xdc>
		ctrla |= TCC_CTRLA_RUNSTDBY;
    5dd2:	2280      	movs	r2, #128	; 0x80
    5dd4:	0112      	lsls	r2, r2, #4
    5dd6:	4641      	mov	r1, r8
    5dd8:	4311      	orrs	r1, r2
    5dda:	4688      	mov	r8, r1
	}
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
    5ddc:	7b3a      	ldrb	r2, [r7, #12]
    5dde:	9206      	str	r2, [sp, #24]
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
    5de0:	7afa      	ldrb	r2, [r7, #11]
    5de2:	9207      	str	r2, [sp, #28]
		const struct tcc_config *const config,
		uint8_t *value_buffer)
{
	uint8_t ctrlb = 0;

	if (config->counter.oneshot) {
    5de4:	7a3a      	ldrb	r2, [r7, #8]
		ctrlb |= TCC_CTRLBSET_ONESHOT;
    5de6:	1e51      	subs	r1, r2, #1
    5de8:	418a      	sbcs	r2, r1
    5dea:	0092      	lsls	r2, r2, #2
    5dec:	9203      	str	r2, [sp, #12]
	}
	if (config->counter.direction == TCC_COUNT_DIRECTION_DOWN) {
    5dee:	7a7a      	ldrb	r2, [r7, #9]
    5df0:	2a01      	cmp	r2, #1
    5df2:	d102      	bne.n	5dfa <tcc_init+0xfa>
		ctrlb |= TCC_CTRLBSET_DIR;
    5df4:	9903      	ldr	r1, [sp, #12]
    5df6:	4311      	orrs	r1, r2
    5df8:	9103      	str	r1, [sp, #12]
		const uint8_t module_index,
		const struct tcc_config *const config,
		uint32_t *value_buffer)
{
	struct tcc_recoverable_fault_config *cfg;
	uint8_t cc_num = _tcc_cc_nums[module_index];
    5dfa:	4a53      	ldr	r2, [pc, #332]	; (5f48 <tcc_init+0x248>)
    5dfc:	5d52      	ldrb	r2, [r2, r5]
    5dfe:	1c11      	adds	r1, r2, #0
    5e00:	9205      	str	r2, [sp, #20]
	uint32_t fault;
	int i;
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
		cfg = (struct tcc_recoverable_fault_config *)
				&config->wave_ext.recoverable_fault[i];
		if (cfg->capture_channel >= cc_num) {
    5e02:	2235      	movs	r2, #53	; 0x35
    5e04:	5cb8      	ldrb	r0, [r7, r2]
    5e06:	4281      	cmp	r1, r0
    5e08:	d800      	bhi.n	5e0c <tcc_init+0x10c>
    5e0a:	e171      	b.n	60f0 <tcc_init+0x3f0>
			return STATUS_ERR_INVALID_ARG;
		}
		if (cfg->filter_value > 0xF) {
    5e0c:	222c      	movs	r2, #44	; 0x2c
    5e0e:	5cba      	ldrb	r2, [r7, r2]
    5e10:	2a0f      	cmp	r2, #15
    5e12:	d900      	bls.n	5e16 <tcc_init+0x116>
    5e14:	e16c      	b.n	60f0 <tcc_init+0x3f0>
    5e16:	212d      	movs	r1, #45	; 0x2d
    5e18:	468c      	mov	ip, r1
    5e1a:	44bc      	add	ip, r7
    5e1c:	4661      	mov	r1, ip
    5e1e:	9101      	str	r1, [sp, #4]
    5e20:	2100      	movs	r1, #0
    5e22:	9608      	str	r6, [sp, #32]
    5e24:	4699      	mov	r9, r3
    5e26:	46bb      	mov	fp, r7
    5e28:	1c0f      	adds	r7, r1, #0
    5e2a:	46a2      	mov	sl, r4
    5e2c:	9509      	str	r5, [sp, #36]	; 0x24
    5e2e:	e00c      	b.n	5e4a <tcc_init+0x14a>
	uint32_t fault;
	int i;
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
		cfg = (struct tcc_recoverable_fault_config *)
				&config->wave_ext.recoverable_fault[i];
		if (cfg->capture_channel >= cc_num) {
    5e30:	7c90      	ldrb	r0, [r2, #18]
    5e32:	9b05      	ldr	r3, [sp, #20]
    5e34:	4283      	cmp	r3, r0
    5e36:	d800      	bhi.n	5e3a <tcc_init+0x13a>
    5e38:	e15a      	b.n	60f0 <tcc_init+0x3f0>
			return STATUS_ERR_INVALID_ARG;
		}
		if (cfg->filter_value > 0xF) {
    5e3a:	7a52      	ldrb	r2, [r2, #9]
    5e3c:	9b01      	ldr	r3, [sp, #4]
    5e3e:	330a      	adds	r3, #10
    5e40:	9301      	str	r3, [sp, #4]
    5e42:	3704      	adds	r7, #4
    5e44:	2a0f      	cmp	r2, #15
    5e46:	d900      	bls.n	5e4a <tcc_init+0x14a>
    5e48:	e152      	b.n	60f0 <tcc_init+0x3f0>
			return STATUS_ERR_INVALID_ARG;
		}
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    5e4a:	0611      	lsls	r1, r2, #24
    5e4c:	23f0      	movs	r3, #240	; 0xf0
    5e4e:	051b      	lsls	r3, r3, #20
    5e50:	4019      	ands	r1, r3
    5e52:	9b01      	ldr	r3, [sp, #4]
    5e54:	1c1a      	adds	r2, r3, #0
				| TCC_FCTRLA_BLANKVAL(cfg->blanking_cycles)
    5e56:	781d      	ldrb	r5, [r3, #0]
    5e58:	042d      	lsls	r5, r5, #16
    5e5a:	24ff      	movs	r4, #255	; 0xff
    5e5c:	0424      	lsls	r4, r4, #16
    5e5e:	4025      	ands	r5, r4
    5e60:	9502      	str	r5, [sp, #8]
				| (cfg->restart ? TCC_FCTRLA_RESTART : 0)
    5e62:	785b      	ldrb	r3, [r3, #1]
    5e64:	2480      	movs	r4, #128	; 0x80
    5e66:	2b00      	cmp	r3, #0
    5e68:	d100      	bne.n	5e6c <tcc_init+0x16c>
    5e6a:	464c      	mov	r4, r9
				| (cfg->keep ? TCC_FCTRLA_KEEP : 0)
    5e6c:	7896      	ldrb	r6, [r2, #2]
    5e6e:	2308      	movs	r3, #8
    5e70:	2e00      	cmp	r6, #0
    5e72:	d100      	bne.n	5e76 <tcc_init+0x176>
    5e74:	464b      	mov	r3, r9
				| (cfg->qualification ? TCC_FCTRLA_QUAL : 0)
    5e76:	78d6      	ldrb	r6, [r2, #3]
    5e78:	46b4      	mov	ip, r6
    5e7a:	2610      	movs	r6, #16
    5e7c:	4665      	mov	r5, ip
    5e7e:	2d00      	cmp	r5, #0
    5e80:	d100      	bne.n	5e84 <tcc_init+0x184>
    5e82:	464e      	mov	r6, r9
				| TCC_FCTRLA_SRC(cfg->source)
				| TCC_FCTRLA_BLANK(cfg->blanking)
				| TCC_FCTRLA_HALT(cfg->halt_action)
				| TCC_FCTRLA_CAPTURE(cfg->capture_action)
				| TCC_FCTRLA_CHSEL(cfg->capture_channel);
    5e84:	0280      	lsls	r0, r0, #10
    5e86:	25c0      	movs	r5, #192	; 0xc0
    5e88:	012d      	lsls	r5, r5, #4
    5e8a:	4028      	ands	r0, r5
    5e8c:	4301      	orrs	r1, r0
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
				| TCC_FCTRLA_BLANKVAL(cfg->blanking_cycles)
				| (cfg->restart ? TCC_FCTRLA_RESTART : 0)
				| (cfg->keep ? TCC_FCTRLA_KEEP : 0)
				| (cfg->qualification ? TCC_FCTRLA_QUAL : 0)
				| TCC_FCTRLA_SRC(cfg->source)
    5e8e:	7910      	ldrb	r0, [r2, #4]
    5e90:	2503      	movs	r5, #3
    5e92:	4028      	ands	r0, r5
    5e94:	4301      	orrs	r1, r0
    5e96:	9802      	ldr	r0, [sp, #8]
    5e98:	4301      	orrs	r1, r0
				| TCC_FCTRLA_BLANK(cfg->blanking)
    5e9a:	7955      	ldrb	r5, [r2, #5]
    5e9c:	016d      	lsls	r5, r5, #5
    5e9e:	2060      	movs	r0, #96	; 0x60
    5ea0:	4028      	ands	r0, r5
    5ea2:	4301      	orrs	r1, r0
    5ea4:	1c0d      	adds	r5, r1, #0
				| TCC_FCTRLA_HALT(cfg->halt_action)
    5ea6:	7990      	ldrb	r0, [r2, #6]
    5ea8:	0200      	lsls	r0, r0, #8
    5eaa:	21c0      	movs	r1, #192	; 0xc0
    5eac:	0089      	lsls	r1, r1, #2
    5eae:	4001      	ands	r1, r0
    5eb0:	430d      	orrs	r5, r1
				| TCC_FCTRLA_CAPTURE(cfg->capture_action)
    5eb2:	79d0      	ldrb	r0, [r2, #7]
    5eb4:	0300      	lsls	r0, r0, #12
    5eb6:	21e0      	movs	r1, #224	; 0xe0
    5eb8:	01c9      	lsls	r1, r1, #7
    5eba:	4001      	ands	r1, r0
    5ebc:	430d      	orrs	r5, r1
    5ebe:	432c      	orrs	r4, r5
    5ec0:	4323      	orrs	r3, r4
			return STATUS_ERR_INVALID_ARG;
		}
		if (cfg->filter_value > 0xF) {
			return STATUS_ERR_INVALID_ARG;
		}
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    5ec2:	431e      	orrs	r6, r3
				| TCC_FCTRLA_SRC(cfg->source)
				| TCC_FCTRLA_BLANK(cfg->blanking)
				| TCC_FCTRLA_HALT(cfg->halt_action)
				| TCC_FCTRLA_CAPTURE(cfg->capture_action)
				| TCC_FCTRLA_CHSEL(cfg->capture_channel);
		value_buffer[i] = fault;
    5ec4:	ab0c      	add	r3, sp, #48	; 0x30
    5ec6:	50fe      	str	r6, [r7, r3]
{
	struct tcc_recoverable_fault_config *cfg;
	uint8_t cc_num = _tcc_cc_nums[module_index];
	uint32_t fault;
	int i;
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
    5ec8:	2f04      	cmp	r7, #4
    5eca:	d1b1      	bne.n	5e30 <tcc_init+0x130>
    5ecc:	9e08      	ldr	r6, [sp, #32]
    5ece:	4654      	mov	r4, sl
    5ed0:	465f      	mov	r7, fp
    5ed2:	9d09      	ldr	r5, [sp, #36]	; 0x24
		const uint8_t module_index,
		const struct tcc_config *const config,
		uint32_t *value_buffer)
{
	uint32_t i;
	uint8_t ow_num = _tcc_ow_nums[module_index];
    5ed4:	4b1b      	ldr	r3, [pc, #108]	; (5f44 <tcc_init+0x244>)
    5ed6:	5d5b      	ldrb	r3, [r3, r5]
    5ed8:	469c      	mov	ip, r3
    5eda:	4658      	mov	r0, fp
    5edc:	3050      	adds	r0, #80	; 0x50
    5ede:	465a      	mov	r2, fp
    5ee0:	3241      	adds	r2, #65	; 0x41
	uint32_t drvctrl;

	drvctrl = 0;
    5ee2:	2300      	movs	r3, #0
			}
			if (config->wave_ext.non_recoverable_fault[i].output ==
				TCC_FAULT_STATE_OUTPUT_1) {
				drvctrl |= (TCC_DRVCTRL_NRE0 | TCC_DRVCTRL_NRV0) << i;
			} else {
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
    5ee4:	2101      	movs	r1, #1
    5ee6:	468b      	mov	fp, r1
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (config->wave_ext.invert[i]) {
			if (i >= ow_num) {
				return STATUS_ERR_INVALID_ARG;
			}
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
    5ee8:	2180      	movs	r1, #128	; 0x80
    5eea:	0249      	lsls	r1, r1, #9
    5eec:	468a      	mov	sl, r1
    5eee:	9401      	str	r4, [sp, #4]
    5ef0:	1c34      	adds	r4, r6, #0
    5ef2:	4666      	mov	r6, ip
    5ef4:	1c29      	adds	r1, r5, #0
    5ef6:	1c1d      	adds	r5, r3, #0
    5ef8:	46b9      	mov	r9, r7
    5efa:	1c0f      	adds	r7, r1, #0
    5efc:	9901      	ldr	r1, [sp, #4]
    5efe:	468c      	mov	ip, r1
	uint32_t drvctrl;

	drvctrl = 0;

	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (config->wave_ext.invert[i]) {
    5f00:	7801      	ldrb	r1, [r0, #0]
    5f02:	2900      	cmp	r1, #0
    5f04:	d009      	beq.n	5f1a <tcc_init+0x21a>
			if (i >= ow_num) {
    5f06:	429e      	cmp	r6, r3
    5f08:	d800      	bhi.n	5f0c <tcc_init+0x20c>
    5f0a:	e0e9      	b.n	60e0 <tcc_init+0x3e0>
				return STATUS_ERR_INVALID_ARG;
			}
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
    5f0c:	4651      	mov	r1, sl
    5f0e:	4099      	lsls	r1, r3
    5f10:	430d      	orrs	r5, r1
		}
		if (config->wave_ext.non_recoverable_fault[i].output !=
    5f12:	7811      	ldrb	r1, [r2, #0]
    5f14:	2900      	cmp	r1, #0
    5f16:	d106      	bne.n	5f26 <tcc_init+0x226>
    5f18:	e01b      	b.n	5f52 <tcc_init+0x252>
    5f1a:	7811      	ldrb	r1, [r2, #0]
    5f1c:	2900      	cmp	r1, #0
    5f1e:	d018      	beq.n	5f52 <tcc_init+0x252>
			TCC_FAULT_STATE_OUTPUT_OFF) {
			if (i >= ow_num) {
    5f20:	429e      	cmp	r6, r3
    5f22:	d800      	bhi.n	5f26 <tcc_init+0x226>
    5f24:	e0de      	b.n	60e4 <tcc_init+0x3e4>
				return STATUS_ERR_INVALID_ARG;
			}
			if (config->wave_ext.non_recoverable_fault[i].output ==
    5f26:	2902      	cmp	r1, #2
    5f28:	d110      	bne.n	5f4c <tcc_init+0x24c>
				TCC_FAULT_STATE_OUTPUT_1) {
				drvctrl |= (TCC_DRVCTRL_NRE0 | TCC_DRVCTRL_NRV0) << i;
    5f2a:	2102      	movs	r1, #2
    5f2c:	31ff      	adds	r1, #255	; 0xff
    5f2e:	4099      	lsls	r1, r3
    5f30:	430d      	orrs	r5, r1
    5f32:	e00e      	b.n	5f52 <tcc_init+0x252>
    5f34:	00005b85 	.word	0x00005b85
    5f38:	40000400 	.word	0x40000400
    5f3c:	0000ec00 	.word	0x0000ec00
    5f40:	0000ec0c 	.word	0x0000ec0c
    5f44:	0000ec1c 	.word	0x0000ec1c
    5f48:	0000ec18 	.word	0x0000ec18
			} else {
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
    5f4c:	4659      	mov	r1, fp
    5f4e:	4099      	lsls	r1, r3
    5f50:	430d      	orrs	r5, r1
	uint8_t ow_num = _tcc_ow_nums[module_index];
	uint32_t drvctrl;

	drvctrl = 0;

	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
    5f52:	3301      	adds	r3, #1
    5f54:	3001      	adds	r0, #1
    5f56:	3202      	adds	r2, #2
    5f58:	2b08      	cmp	r3, #8
    5f5a:	d1d1      	bne.n	5f00 <tcc_init+0x200>
    5f5c:	1c26      	adds	r6, r4, #0
    5f5e:	4664      	mov	r4, ip
    5f60:	1c3b      	adds	r3, r7, #0
    5f62:	464f      	mov	r7, r9
    5f64:	46a9      	mov	r9, r5
    5f66:	1c1d      	adds	r5, r3, #0
		const struct tcc_config *const config,
		uint32_t *value_buffer)
{
	int n;

	uint8_t cc_num = _tcc_cc_nums[module_index];
    5f68:	4b65      	ldr	r3, [pc, #404]	; (6100 <tcc_init+0x400>)
    5f6a:	5d5b      	ldrb	r3, [r3, r5]
    5f6c:	9301      	str	r3, [sp, #4]
	struct tcc_match_wave_config const *wav_cfg = &config->compare;

	uint32_t wave;

	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
    5f6e:	7e7b      	ldrb	r3, [r7, #25]
    5f70:	011b      	lsls	r3, r3, #4
    5f72:	2230      	movs	r2, #48	; 0x30
    5f74:	4013      	ands	r3, r2
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);
    5f76:	7e3a      	ldrb	r2, [r7, #24]
    5f78:	2107      	movs	r1, #7
    5f7a:	400a      	ands	r2, r1
	uint8_t cc_num = _tcc_cc_nums[module_index];
	struct tcc_match_wave_config const *wav_cfg = &config->compare;

	uint32_t wave;

	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
    5f7c:	4313      	orrs	r3, r2
    5f7e:	1c18      	adds	r0, r3, #0
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
    5f80:	2300      	movs	r3, #0
		if (wav_cfg->wave_polarity[n]) {
			if (n >= cc_num) {
				return STATUS_ERR_INVALID_ARG;
			}
			wave |= (TCC_WAVE_POL0 << n);
    5f82:	2180      	movs	r1, #128	; 0x80
    5f84:	0249      	lsls	r1, r1, #9
    5f86:	18fa      	adds	r2, r7, r3

	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
		if (wav_cfg->wave_polarity[n]) {
    5f88:	7d12      	ldrb	r2, [r2, #20]
    5f8a:	2a00      	cmp	r2, #0
    5f8c:	d006      	beq.n	5f9c <tcc_init+0x29c>
			if (n >= cc_num) {
    5f8e:	9a01      	ldr	r2, [sp, #4]
    5f90:	429a      	cmp	r2, r3
    5f92:	dc00      	bgt.n	5f96 <tcc_init+0x296>
    5f94:	e0a8      	b.n	60e8 <tcc_init+0x3e8>
				return STATUS_ERR_INVALID_ARG;
			}
			wave |= (TCC_WAVE_POL0 << n);
    5f96:	1c0a      	adds	r2, r1, #0
    5f98:	409a      	lsls	r2, r3
    5f9a:	4310      	orrs	r0, r2
	uint32_t wave;

	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
    5f9c:	3301      	adds	r3, #1
    5f9e:	2b04      	cmp	r3, #4
    5fa0:	d1f1      	bne.n	5f86 <tcc_init+0x286>
    5fa2:	9002      	str	r0, [sp, #8]
    5fa4:	9900      	ldr	r1, [sp, #0]
    5fa6:	1c0b      	adds	r3, r1, #0
    5fa8:	3304      	adds	r3, #4
    5faa:	3134      	adds	r1, #52	; 0x34

	/* Initialize module */
#if TCC_ASYNC
	/* Initialize parameters */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
		module_inst->callback[i] = NULL;
    5fac:	2200      	movs	r2, #0
    5fae:	c304      	stmia	r3!, {r2}
	}

	/* Initialize module */
#if TCC_ASYNC
	/* Initialize parameters */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
    5fb0:	428b      	cmp	r3, r1
    5fb2:	d1fc      	bne.n	5fae <tcc_init+0x2ae>
		module_inst->callback[i] = NULL;
	}
	module_inst->register_callback_mask = 0;
    5fb4:	2300      	movs	r3, #0
    5fb6:	9900      	ldr	r1, [sp, #0]
    5fb8:	634b      	str	r3, [r1, #52]	; 0x34
	module_inst->enable_callback_mask = 0;
    5fba:	638b      	str	r3, [r1, #56]	; 0x38
	_tcc_instances[module_index] = module_inst;
    5fbc:	00aa      	lsls	r2, r5, #2
    5fbe:	4b51      	ldr	r3, [pc, #324]	; (6104 <tcc_init+0x404>)
    5fc0:	50d1      	str	r1, [r2, r3]
#endif

	module_inst->hw = hw;
    5fc2:	600c      	str	r4, [r1, #0]

	module_inst->double_buffering_enabled = config->double_buffering_enabled;
    5fc4:	23a0      	movs	r3, #160	; 0xa0
    5fc6:	5cfa      	ldrb	r2, [r7, r3]
    5fc8:	3b64      	subs	r3, #100	; 0x64
    5fca:	54ca      	strb	r2, [r1, r3]

	/* Setup clock for module */
	struct system_gclk_chan_config gclk_chan_config;
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
	gclk_chan_config.source_generator = config->counter.clock_source;
    5fcc:	a90b      	add	r1, sp, #44	; 0x2c
    5fce:	7abb      	ldrb	r3, [r7, #10]
    5fd0:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(_tcc_gclk_ids[module_index], &gclk_chan_config);
    5fd2:	4b4d      	ldr	r3, [pc, #308]	; (6108 <tcc_init+0x408>)
    5fd4:	5d5b      	ldrb	r3, [r3, r5]
    5fd6:	9300      	str	r3, [sp, #0]
    5fd8:	1c18      	adds	r0, r3, #0
    5fda:	4b4c      	ldr	r3, [pc, #304]	; (610c <tcc_init+0x40c>)
    5fdc:	4798      	blx	r3
	system_gclk_chan_enable(_tcc_gclk_ids[module_index]);
    5fde:	9800      	ldr	r0, [sp, #0]
    5fe0:	4b4b      	ldr	r3, [pc, #300]	; (6110 <tcc_init+0x410>)
    5fe2:	4798      	blx	r3

	/* Initialize pins */
	struct system_pinmux_config pin_config;
	for (i = 0; i <  _tcc_ow_nums[module_index]; i ++) {
    5fe4:	4b4b      	ldr	r3, [pc, #300]	; (6114 <tcc_init+0x414>)
    5fe6:	5d5b      	ldrb	r3, [r3, r5]
    5fe8:	2b00      	cmp	r3, #0
    5fea:	dd29      	ble.n	6040 <tcc_init+0x340>
    5fec:	1c3d      	adds	r5, r7, #0
    5fee:	3558      	adds	r5, #88	; 0x58
    5ff0:	2397      	movs	r3, #151	; 0x97
    5ff2:	425b      	negs	r3, r3
    5ff4:	1bdb      	subs	r3, r3, r7
    5ff6:	469b      	mov	fp, r3
    5ff8:	4b46      	ldr	r3, [pc, #280]	; (6114 <tcc_init+0x414>)
    5ffa:	469a      	mov	sl, r3
    5ffc:	4643      	mov	r3, r8
    5ffe:	9300      	str	r3, [sp, #0]
    6000:	46a0      	mov	r8, r4
    6002:	1c34      	adds	r4, r6, #0
    6004:	9e04      	ldr	r6, [sp, #16]
    6006:	465b      	mov	r3, fp
    6008:	46bb      	mov	fp, r7
    600a:	1c1f      	adds	r7, r3, #0
		if (!config->pins.enable_wave_out_pin[i]) {
    600c:	7833      	ldrb	r3, [r6, #0]
    600e:	2b00      	cmp	r3, #0
    6010:	d00b      	beq.n	602a <tcc_init+0x32a>
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    6012:	2301      	movs	r3, #1
    6014:	aa0a      	add	r2, sp, #40	; 0x28
    6016:	7093      	strb	r3, [r2, #2]
	config->powersave    = false;
    6018:	2200      	movs	r2, #0
    601a:	a90a      	add	r1, sp, #40	; 0x28
    601c:	70ca      	strb	r2, [r1, #3]
			continue;
		}

		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pins.wave_out_pin_mux[i];
    601e:	6a2a      	ldr	r2, [r5, #32]
    6020:	700a      	strb	r2, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    6022:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    6024:	7828      	ldrb	r0, [r5, #0]
    6026:	4b3c      	ldr	r3, [pc, #240]	; (6118 <tcc_init+0x418>)
    6028:	4798      	blx	r3
    602a:	19bb      	adds	r3, r7, r6
    602c:	3601      	adds	r6, #1
    602e:	3504      	adds	r5, #4
	system_gclk_chan_set_config(_tcc_gclk_ids[module_index], &gclk_chan_config);
	system_gclk_chan_enable(_tcc_gclk_ids[module_index]);

	/* Initialize pins */
	struct system_pinmux_config pin_config;
	for (i = 0; i <  _tcc_ow_nums[module_index]; i ++) {
    6030:	4652      	mov	r2, sl
    6032:	5d12      	ldrb	r2, [r2, r4]
    6034:	429a      	cmp	r2, r3
    6036:	dce9      	bgt.n	600c <tcc_init+0x30c>
    6038:	4644      	mov	r4, r8
    603a:	9b00      	ldr	r3, [sp, #0]
    603c:	4698      	mov	r8, r3
    603e:	465f      	mov	r7, fp
	}

	if (config->run_in_standby) {
		ctrla |= TCC_CTRLA_RUNSTDBY;
	}
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
    6040:	9b06      	ldr	r3, [sp, #24]
    6042:	031a      	lsls	r2, r3, #12
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
    6044:	9b07      	ldr	r3, [sp, #28]
    6046:	021b      	lsls	r3, r3, #8
    6048:	4313      	orrs	r3, r2
    604a:	4642      	mov	r2, r8
    604c:	4313      	orrs	r3, r2
				config->pins.wave_out_pin[i], &pin_config);
	}

	/* Write to registers */

	hw->CTRLA.reg = ctrla;
    604e:	6023      	str	r3, [r4, #0]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
    6050:	2204      	movs	r2, #4
    6052:	68a3      	ldr	r3, [r4, #8]
    6054:	421a      	tst	r2, r3
    6056:	d1fc      	bne.n	6052 <tcc_init+0x352>
		/* Wait for sync */
	}

	hw->CTRLBCLR.reg = 0xFF;
    6058:	23ff      	movs	r3, #255	; 0xff
    605a:	7123      	strb	r3, [r4, #4]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
    605c:	2204      	movs	r2, #4
    605e:	68a3      	ldr	r3, [r4, #8]
    6060:	421a      	tst	r2, r3
    6062:	d1fc      	bne.n	605e <tcc_init+0x35e>
		/* Wait for sync */
	}
	hw->CTRLBSET.reg = ctrlb;
    6064:	466b      	mov	r3, sp
    6066:	7b1b      	ldrb	r3, [r3, #12]
    6068:	7163      	strb	r3, [r4, #5]

	hw->FCTRLA.reg = faults[0];
    606a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    606c:	60e3      	str	r3, [r4, #12]
	hw->FCTRLB.reg = faults[1];
    606e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    6070:	6123      	str	r3, [r4, #16]

	hw->DRVCTRL.reg = drvctrl;
    6072:	464b      	mov	r3, r9
    6074:	61a3      	str	r3, [r4, #24]

#if (!SAML21) && (!SAMC20) && (!SAMC21) && (!SAML22)
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_WAVE | TCC_SYNCBUSY_WAVEB)) {
    6076:	4a29      	ldr	r2, [pc, #164]	; (611c <tcc_init+0x41c>)
    6078:	68a3      	ldr	r3, [r4, #8]
    607a:	4213      	tst	r3, r2
    607c:	d1fc      	bne.n	6078 <tcc_init+0x378>
		/* Wait for sync */
	}
#endif
	hw->WAVE.reg = waves[0];
    607e:	9b02      	ldr	r3, [sp, #8]
    6080:	63e3      	str	r3, [r4, #60]	; 0x3c

	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_COUNT) {
    6082:	2210      	movs	r2, #16
    6084:	68a3      	ldr	r3, [r4, #8]
    6086:	421a      	tst	r2, r3
    6088:	d1fc      	bne.n	6084 <tcc_init+0x384>
		/* Wait for sync */
	}
	hw->COUNT.reg = config->counter.count;
    608a:	683b      	ldr	r3, [r7, #0]
    608c:	6363      	str	r3, [r4, #52]	; 0x34

#if (!SAML21) && (!SAMC20) && (!SAMC21) && (!SAML22)
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_PER | TCC_SYNCBUSY_PERB)) {
    608e:	4a24      	ldr	r2, [pc, #144]	; (6120 <tcc_init+0x420>)
    6090:	68a3      	ldr	r3, [r4, #8]
    6092:	4213      	tst	r3, r2
    6094:	d1fc      	bne.n	6090 <tcc_init+0x390>
		/* Wait for sync */
	}
#endif
	hw->PER.reg = (config->counter.period);
    6096:	687b      	ldr	r3, [r7, #4]
    6098:	6423      	str	r3, [r4, #64]	; 0x40

	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
    609a:	9801      	ldr	r0, [sp, #4]
    609c:	2800      	cmp	r0, #0
    609e:	dd25      	ble.n	60ec <tcc_init+0x3ec>
    60a0:	1c3d      	adds	r5, r7, #0
    60a2:	351c      	adds	r5, #28
    60a4:	2100      	movs	r1, #0
#if (!SAML21) && (!SAMC20) && (!SAMC21) && (!SAML22)
		while (hw->SYNCBUSY.reg & (
			(TCC_SYNCBUSY_CC0 | TCC_SYNCBUSY_CCB0) << i)) {
    60a6:	4e1f      	ldr	r6, [pc, #124]	; (6124 <tcc_init+0x424>)
    60a8:	1c32      	adds	r2, r6, #0
    60aa:	408a      	lsls	r2, r1
#endif
	hw->PER.reg = (config->counter.period);

	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
#if (!SAML21) && (!SAMC20) && (!SAMC21) && (!SAML22)
		while (hw->SYNCBUSY.reg & (
    60ac:	68a3      	ldr	r3, [r4, #8]
    60ae:	4213      	tst	r3, r2
    60b0:	d1fc      	bne.n	60ac <tcc_init+0x3ac>
			(TCC_SYNCBUSY_CC0 | TCC_SYNCBUSY_CCB0) << i)) {
			/* Wait for sync */
		}
#endif
		hw->CC[i].reg = (config->compare.match[i]);
    60b2:	cd04      	ldmia	r5!, {r2}
    60b4:	1c0b      	adds	r3, r1, #0
    60b6:	3310      	adds	r3, #16
    60b8:	009b      	lsls	r3, r3, #2
    60ba:	18e3      	adds	r3, r4, r3
    60bc:	605a      	str	r2, [r3, #4]
		/* Wait for sync */
	}
#endif
	hw->PER.reg = (config->counter.period);

	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
    60be:	3101      	adds	r1, #1
    60c0:	4288      	cmp	r0, r1
    60c2:	dcf1      	bgt.n	60a8 <tcc_init+0x3a8>
		}
#endif
		hw->CC[i].reg = (config->compare.match[i]);
	}

	return STATUS_OK;
    60c4:	2000      	movs	r0, #0
    60c6:	e014      	b.n	60f2 <tcc_init+0x3f2>

	/* Check all channel values */
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
		if ((config->compare.match[i] > count_max)
			) {
			return STATUS_ERR_INVALID_ARG;
    60c8:	2017      	movs	r0, #23
    60ca:	e012      	b.n	60f2 <tcc_init+0x3f2>
    60cc:	2017      	movs	r0, #23
    60ce:	e010      	b.n	60f2 <tcc_init+0x3f2>
    60d0:	2017      	movs	r0, #23
    60d2:	e00e      	b.n	60f2 <tcc_init+0x3f2>
    60d4:	2017      	movs	r0, #23
    60d6:	e00c      	b.n	60f2 <tcc_init+0x3f2>
		if (!config->pins.enable_wave_out_pin[i]) {
			continue;
		}
		/* Output line is not supported */
		if (i >= _tcc_ow_nums[module_index]) {
			return STATUS_ERR_INVALID_ARG;
    60d8:	2017      	movs	r0, #23
    60da:	e00a      	b.n	60f2 <tcc_init+0x3f2>
		if (config->capture.channel_function[i] ==
			TCC_CHANNEL_FUNCTION_CAPTURE) {

			if (i > _tcc_cc_nums[module_index]) {
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
    60dc:	2017      	movs	r0, #23
    60de:	e008      	b.n	60f2 <tcc_init+0x3f2>

	drvctrl = 0;

	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (config->wave_ext.invert[i]) {
			if (i >= ow_num) {
    60e0:	2017      	movs	r0, #23
    60e2:	e006      	b.n	60f2 <tcc_init+0x3f2>
			}
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
		}
		if (config->wave_ext.non_recoverable_fault[i].output !=
			TCC_FAULT_STATE_OUTPUT_OFF) {
			if (i >= ow_num) {
    60e4:	2017      	movs	r0, #23
    60e6:	e004      	b.n	60f2 <tcc_init+0x3f2>
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
		if (wav_cfg->wave_polarity[n]) {
			if (n >= cc_num) {
				return STATUS_ERR_INVALID_ARG;
    60e8:	2017      	movs	r0, #23
    60ea:	e002      	b.n	60f2 <tcc_init+0x3f2>
		}
#endif
		hw->CC[i].reg = (config->compare.match[i]);
	}

	return STATUS_OK;
    60ec:	2000      	movs	r0, #0
    60ee:	e000      	b.n	60f2 <tcc_init+0x3f2>
		if (config->capture.channel_function[i] ==
			TCC_CHANNEL_FUNCTION_CAPTURE) {

			if (i > _tcc_cc_nums[module_index]) {
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
    60f0:	2017      	movs	r0, #23
#endif
		hw->CC[i].reg = (config->compare.match[i]);
	}

	return STATUS_OK;
}
    60f2:	b00f      	add	sp, #60	; 0x3c
    60f4:	bc3c      	pop	{r2, r3, r4, r5}
    60f6:	4690      	mov	r8, r2
    60f8:	4699      	mov	r9, r3
    60fa:	46a2      	mov	sl, r4
    60fc:	46ab      	mov	fp, r5
    60fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6100:	0000ec18 	.word	0x0000ec18
    6104:	20001738 	.word	0x20001738
    6108:	0000ebfc 	.word	0x0000ebfc
    610c:	00005a2d 	.word	0x00005a2d
    6110:	000059a1 	.word	0x000059a1
    6114:	0000ec1c 	.word	0x0000ec1c
    6118:	00005b25 	.word	0x00005b25
    611c:	00020040 	.word	0x00020040
    6120:	00040080 	.word	0x00040080
    6124:	00080100 	.word	0x00080100

00006128 <tcc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    6128:	0092      	lsls	r2, r2, #2
    612a:	1883      	adds	r3, r0, r2
    612c:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->register_callback_mask |= _tcc_intflag[callback_type];
    612e:	4b03      	ldr	r3, [pc, #12]	; (613c <tcc_register_callback+0x14>)
    6130:	58d3      	ldr	r3, [r2, r3]
    6132:	6b42      	ldr	r2, [r0, #52]	; 0x34
    6134:	4313      	orrs	r3, r2
    6136:	6343      	str	r3, [r0, #52]	; 0x34

	return STATUS_OK;
}
    6138:	2000      	movs	r0, #0
    613a:	4770      	bx	lr
    613c:	0000ec24 	.word	0x0000ec24

00006140 <tcc_enable_callback>:
 * \param[in]     callback_type Callback type given by an enum
 */
void tcc_enable_callback(
		struct tcc_module *const module,
		const enum tcc_callback callback_type)
{
    6140:	b538      	push	{r3, r4, r5, lr}
    6142:	1c04      	adds	r4, r0, #0
    6144:	1c0d      	adds	r5, r1, #0
	Assert(module);
	Assert(module->hw);

	/* Enable interrupts for this TCC module */
	system_interrupt_enable(_tcc_interrupt_get_interrupt_vector(
			_tcc_get_inst_index(module->hw)));
    6146:	6800      	ldr	r0, [r0, #0]
    6148:	4b09      	ldr	r3, [pc, #36]	; (6170 <tcc_enable_callback+0x30>)
    614a:	4798      	blx	r3
{
	static uint8_t tcc_interrupt_vectors[TCC_INST_NUM] = {
		MREPEAT(TCC_INST_NUM, _TCC_INTERRUPT_VECT_NUM, 0)
	};

	return (enum system_interrupt_vector)tcc_interrupt_vectors[inst_num];
    614c:	4b09      	ldr	r3, [pc, #36]	; (6174 <tcc_enable_callback+0x34>)
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    614e:	5c1b      	ldrb	r3, [r3, r0]
    6150:	221f      	movs	r2, #31
    6152:	4013      	ands	r3, r2
    6154:	3a1e      	subs	r2, #30
    6156:	409a      	lsls	r2, r3
    6158:	1c13      	adds	r3, r2, #0
    615a:	4a07      	ldr	r2, [pc, #28]	; (6178 <tcc_enable_callback+0x38>)
    615c:	6013      	str	r3, [r2, #0]
	/* Enable interrupts for this TCC module */
	system_interrupt_enable(_tcc_interrupt_get_interrupt_vector(
			_tcc_get_inst_index(module->hw)));

	/* Enable channel or other callbacks */
	module->enable_callback_mask |= _tcc_intflag[callback_type];
    615e:	00ad      	lsls	r5, r5, #2
    6160:	4b06      	ldr	r3, [pc, #24]	; (617c <tcc_enable_callback+0x3c>)
    6162:	58ea      	ldr	r2, [r5, r3]
    6164:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    6166:	4313      	orrs	r3, r2
    6168:	63a3      	str	r3, [r4, #56]	; 0x38
	module->hw->INTENSET.reg = _tcc_intflag[callback_type];
    616a:	6823      	ldr	r3, [r4, #0]
    616c:	629a      	str	r2, [r3, #40]	; 0x28
}
    616e:	bd38      	pop	{r3, r4, r5, pc}
    6170:	00005b85 	.word	0x00005b85
    6174:	0000ec20 	.word	0x0000ec20
    6178:	e000e100 	.word	0xe000e100
    617c:	0000ec24 	.word	0x0000ec24

00006180 <_tcc_interrupt_handler>:
 * \param[in]  module_index  ID of the TCC instance calling the interrupt
 *                           handler
 */
void _tcc_interrupt_handler(
		uint8_t module_index)
{
    6180:	b5f0      	push	{r4, r5, r6, r7, lr}
    6182:	4647      	mov	r7, r8
    6184:	b480      	push	{r7}
	int i;

	uint32_t interrupt_and_callback_status_mask;

	struct tcc_module *module =
    6186:	0080      	lsls	r0, r0, #2
    6188:	4b0d      	ldr	r3, [pc, #52]	; (61c0 <_tcc_interrupt_handler+0x40>)
    618a:	58c7      	ldr	r7, [r0, r3]
			(struct tcc_module *)_tcc_instances[module_index];

	interrupt_and_callback_status_mask = (module->hw->INTFLAG.reg &
    618c:	683b      	ldr	r3, [r7, #0]
    618e:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    6190:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    6192:	401e      	ands	r6, r3
    6194:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    6196:	401e      	ands	r6, r3
    6198:	2400      	movs	r4, #0
			module->register_callback_mask &
			module->enable_callback_mask);

	/* Check if callback interrupt has occured */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
		if (interrupt_and_callback_status_mask & _tcc_intflag[i]) {
    619a:	4b0a      	ldr	r3, [pc, #40]	; (61c4 <_tcc_interrupt_handler+0x44>)
    619c:	4698      	mov	r8, r3
    619e:	4643      	mov	r3, r8
    61a0:	58e5      	ldr	r5, [r4, r3]
    61a2:	422e      	tst	r6, r5
    61a4:	d005      	beq.n	61b2 <_tcc_interrupt_handler+0x32>
    61a6:	193b      	adds	r3, r7, r4
			/* Invoke the registered and enabled callback function */
			(module->callback[i])(module);
    61a8:	685b      	ldr	r3, [r3, #4]
    61aa:	1c38      	adds	r0, r7, #0
    61ac:	4798      	blx	r3
			/* Clear interrupt flag */
			module->hw->INTFLAG.reg = _tcc_intflag[i];
    61ae:	683b      	ldr	r3, [r7, #0]
    61b0:	62dd      	str	r5, [r3, #44]	; 0x2c
    61b2:	3404      	adds	r4, #4
	interrupt_and_callback_status_mask = (module->hw->INTFLAG.reg &
			module->register_callback_mask &
			module->enable_callback_mask);

	/* Check if callback interrupt has occured */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
    61b4:	2c30      	cmp	r4, #48	; 0x30
    61b6:	d1f2      	bne.n	619e <_tcc_interrupt_handler+0x1e>
			(module->callback[i])(module);
			/* Clear interrupt flag */
			module->hw->INTFLAG.reg = _tcc_intflag[i];
		}
	}
}
    61b8:	bc04      	pop	{r2}
    61ba:	4690      	mov	r8, r2
    61bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    61be:	46c0      	nop			; (mov r8, r8)
    61c0:	20001738 	.word	0x20001738
    61c4:	0000ec24 	.word	0x0000ec24

000061c8 <TCC0_Handler>:
		void TCC##n##_Handler(void) \
		{ \
			_tcc_interrupt_handler(n); \
		}

MREPEAT(TCC_INST_NUM, _TCC_INTERRUPT_HANDLER, 0)
    61c8:	b508      	push	{r3, lr}
    61ca:	2000      	movs	r0, #0
    61cc:	4b01      	ldr	r3, [pc, #4]	; (61d4 <TCC0_Handler+0xc>)
    61ce:	4798      	blx	r3
    61d0:	bd08      	pop	{r3, pc}
    61d2:	46c0      	nop			; (mov r8, r8)
    61d4:	00006181 	.word	0x00006181

000061d8 <TCC1_Handler>:
    61d8:	b508      	push	{r3, lr}
    61da:	2001      	movs	r0, #1
    61dc:	4b01      	ldr	r3, [pc, #4]	; (61e4 <TCC1_Handler+0xc>)
    61de:	4798      	blx	r3
    61e0:	bd08      	pop	{r3, pc}
    61e2:	46c0      	nop			; (mov r8, r8)
    61e4:	00006181 	.word	0x00006181

000061e8 <TCC2_Handler>:
    61e8:	b508      	push	{r3, lr}
    61ea:	2002      	movs	r0, #2
    61ec:	4b01      	ldr	r3, [pc, #4]	; (61f4 <TCC2_Handler+0xc>)
    61ee:	4798      	blx	r3
    61f0:	bd08      	pop	{r3, pc}
    61f2:	46c0      	nop			; (mov r8, r8)
    61f4:	00006181 	.word	0x00006181

000061f8 <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
        while (1) {
        }
    61f8:	e7fe      	b.n	61f8 <Dummy_Handler>
    61fa:	46c0      	nop			; (mov r8, r8)

000061fc <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    61fc:	b570      	push	{r4, r5, r6, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    61fe:	4b2e      	ldr	r3, [pc, #184]	; (62b8 <Reset_Handler+0xbc>)
    6200:	4a2e      	ldr	r2, [pc, #184]	; (62bc <Reset_Handler+0xc0>)
    6202:	429a      	cmp	r2, r3
    6204:	d003      	beq.n	620e <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
    6206:	4b2e      	ldr	r3, [pc, #184]	; (62c0 <Reset_Handler+0xc4>)
    6208:	4a2b      	ldr	r2, [pc, #172]	; (62b8 <Reset_Handler+0xbc>)
    620a:	429a      	cmp	r2, r3
    620c:	d304      	bcc.n	6218 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    620e:	4b2d      	ldr	r3, [pc, #180]	; (62c4 <Reset_Handler+0xc8>)
    6210:	4a2d      	ldr	r2, [pc, #180]	; (62c8 <Reset_Handler+0xcc>)
    6212:	429a      	cmp	r2, r3
    6214:	d310      	bcc.n	6238 <Reset_Handler+0x3c>
    6216:	e01e      	b.n	6256 <Reset_Handler+0x5a>
    6218:	4a2c      	ldr	r2, [pc, #176]	; (62cc <Reset_Handler+0xd0>)
    621a:	4b29      	ldr	r3, [pc, #164]	; (62c0 <Reset_Handler+0xc4>)
    621c:	3303      	adds	r3, #3
    621e:	1a9b      	subs	r3, r3, r2
    6220:	089b      	lsrs	r3, r3, #2
    6222:	3301      	adds	r3, #1
    6224:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    6226:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    6228:	4823      	ldr	r0, [pc, #140]	; (62b8 <Reset_Handler+0xbc>)
    622a:	4924      	ldr	r1, [pc, #144]	; (62bc <Reset_Handler+0xc0>)
    622c:	588c      	ldr	r4, [r1, r2]
    622e:	5084      	str	r4, [r0, r2]
    6230:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    6232:	429a      	cmp	r2, r3
    6234:	d1fa      	bne.n	622c <Reset_Handler+0x30>
    6236:	e7ea      	b.n	620e <Reset_Handler+0x12>
    6238:	4a25      	ldr	r2, [pc, #148]	; (62d0 <Reset_Handler+0xd4>)
    623a:	4b22      	ldr	r3, [pc, #136]	; (62c4 <Reset_Handler+0xc8>)
    623c:	3303      	adds	r3, #3
    623e:	1a9b      	subs	r3, r3, r2
    6240:	089b      	lsrs	r3, r3, #2
    6242:	3301      	adds	r3, #1
    6244:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    6246:	2200      	movs	r2, #0
                *pDest++ = 0;
    6248:	481f      	ldr	r0, [pc, #124]	; (62c8 <Reset_Handler+0xcc>)
    624a:	2100      	movs	r1, #0
    624c:	1814      	adds	r4, r2, r0
    624e:	6021      	str	r1, [r4, #0]
    6250:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    6252:	429a      	cmp	r2, r3
    6254:	d1fa      	bne.n	624c <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    6256:	4a1f      	ldr	r2, [pc, #124]	; (62d4 <Reset_Handler+0xd8>)
    6258:	21ff      	movs	r1, #255	; 0xff
    625a:	4b1f      	ldr	r3, [pc, #124]	; (62d8 <Reset_Handler+0xdc>)
    625c:	438b      	bics	r3, r1
    625e:	6093      	str	r3, [r2, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    6260:	39fd      	subs	r1, #253	; 0xfd
    6262:	2390      	movs	r3, #144	; 0x90
    6264:	005b      	lsls	r3, r3, #1
    6266:	4a1d      	ldr	r2, [pc, #116]	; (62dc <Reset_Handler+0xe0>)
    6268:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    626a:	481d      	ldr	r0, [pc, #116]	; (62e0 <Reset_Handler+0xe4>)
    626c:	78c3      	ldrb	r3, [r0, #3]
    626e:	2403      	movs	r4, #3
    6270:	43a3      	bics	r3, r4
    6272:	2202      	movs	r2, #2
    6274:	4313      	orrs	r3, r2
    6276:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    6278:	78c3      	ldrb	r3, [r0, #3]
    627a:	260c      	movs	r6, #12
    627c:	43b3      	bics	r3, r6
    627e:	2108      	movs	r1, #8
    6280:	430b      	orrs	r3, r1
    6282:	70c3      	strb	r3, [r0, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
    6284:	4b17      	ldr	r3, [pc, #92]	; (62e4 <Reset_Handler+0xe8>)
    6286:	7b98      	ldrb	r0, [r3, #14]
    6288:	2530      	movs	r5, #48	; 0x30
    628a:	43a8      	bics	r0, r5
    628c:	1c05      	adds	r5, r0, #0
    628e:	2020      	movs	r0, #32
    6290:	4328      	orrs	r0, r5
    6292:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    6294:	7b98      	ldrb	r0, [r3, #14]
    6296:	43b0      	bics	r0, r6
    6298:	4301      	orrs	r1, r0
    629a:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    629c:	7b99      	ldrb	r1, [r3, #14]
    629e:	43a1      	bics	r1, r4
    62a0:	430a      	orrs	r2, r1
    62a2:	739a      	strb	r2, [r3, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    62a4:	4a10      	ldr	r2, [pc, #64]	; (62e8 <Reset_Handler+0xec>)
    62a6:	6851      	ldr	r1, [r2, #4]
    62a8:	2380      	movs	r3, #128	; 0x80
    62aa:	430b      	orrs	r3, r1
    62ac:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    62ae:	4b0f      	ldr	r3, [pc, #60]	; (62ec <Reset_Handler+0xf0>)
    62b0:	4798      	blx	r3

        /* Branch to main function */
        main();
    62b2:	4b0f      	ldr	r3, [pc, #60]	; (62f0 <Reset_Handler+0xf4>)
    62b4:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    62b6:	e7fe      	b.n	62b6 <Reset_Handler+0xba>
    62b8:	20000000 	.word	0x20000000
    62bc:	000115d4 	.word	0x000115d4
    62c0:	200000a0 	.word	0x200000a0
    62c4:	20002218 	.word	0x20002218
    62c8:	200000a0 	.word	0x200000a0
    62cc:	20000004 	.word	0x20000004
    62d0:	200000a4 	.word	0x200000a4
    62d4:	e000ed00 	.word	0xe000ed00
    62d8:	00000000 	.word	0x00000000
    62dc:	41007000 	.word	0x41007000
    62e0:	41005000 	.word	0x41005000
    62e4:	41004800 	.word	0x41004800
    62e8:	41004000 	.word	0x41004000
    62ec:	0000d76d 	.word	0x0000d76d
    62f0:	00006811 	.word	0x00006811

000062f4 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
    62f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    62f6:	4647      	mov	r7, r8
    62f8:	b480      	push	{r7}
    62fa:	1c0c      	adds	r4, r1, #0
    62fc:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
    62fe:	2800      	cmp	r0, #0
    6300:	d110      	bne.n	6324 <_read+0x30>
		return -1;
	}

	for (; len > 0; --len) {
    6302:	2a00      	cmp	r2, #0
    6304:	dd0a      	ble.n	631c <_read+0x28>
    6306:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
    6308:	4e09      	ldr	r6, [pc, #36]	; (6330 <_read+0x3c>)
    630a:	4d0a      	ldr	r5, [pc, #40]	; (6334 <_read+0x40>)
    630c:	6830      	ldr	r0, [r6, #0]
    630e:	1c21      	adds	r1, r4, #0
    6310:	682b      	ldr	r3, [r5, #0]
    6312:	4798      	blx	r3
		ptr++;
    6314:	3401      	adds	r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
    6316:	42bc      	cmp	r4, r7
    6318:	d1f8      	bne.n	630c <_read+0x18>
    631a:	e001      	b.n	6320 <_read+0x2c>
    631c:	2300      	movs	r3, #0
    631e:	4698      	mov	r8, r3
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
    6320:	4640      	mov	r0, r8
    6322:	e001      	b.n	6328 <_read+0x34>
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
    6324:	2001      	movs	r0, #1
    6326:	4240      	negs	r0, r0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
    6328:	bc04      	pop	{r2}
    632a:	4690      	mov	r8, r2
    632c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    632e:	46c0      	nop			; (mov r8, r8)
    6330:	2000174c 	.word	0x2000174c
    6334:	20001744 	.word	0x20001744

00006338 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
    6338:	b5f0      	push	{r4, r5, r6, r7, lr}
    633a:	4647      	mov	r7, r8
    633c:	b480      	push	{r7}
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
    633e:	3801      	subs	r0, #1
    6340:	2802      	cmp	r0, #2
    6342:	d815      	bhi.n	6370 <_write+0x38>
		return -1;
	}

	for (; len != 0; --len) {
    6344:	2a00      	cmp	r2, #0
    6346:	d010      	beq.n	636a <_write+0x32>
    6348:	1c15      	adds	r5, r2, #0
    634a:	1c0e      	adds	r6, r1, #0
    634c:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
    634e:	4b0c      	ldr	r3, [pc, #48]	; (6380 <_write+0x48>)
    6350:	4698      	mov	r8, r3
    6352:	4f0c      	ldr	r7, [pc, #48]	; (6384 <_write+0x4c>)
    6354:	4643      	mov	r3, r8
    6356:	6818      	ldr	r0, [r3, #0]
    6358:	5d31      	ldrb	r1, [r6, r4]
    635a:	683b      	ldr	r3, [r7, #0]
    635c:	4798      	blx	r3
    635e:	2800      	cmp	r0, #0
    6360:	db09      	blt.n	6376 <_write+0x3e>
			return -1;
		}
		++nChars;
    6362:	3401      	adds	r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
    6364:	42a5      	cmp	r5, r4
    6366:	d1f5      	bne.n	6354 <_write+0x1c>
    6368:	e000      	b.n	636c <_write+0x34>
    636a:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
	}
	return nChars;
    636c:	1c20      	adds	r0, r4, #0
    636e:	e004      	b.n	637a <_write+0x42>
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
    6370:	2001      	movs	r0, #1
    6372:	4240      	negs	r0, r0
    6374:	e001      	b.n	637a <_write+0x42>
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
    6376:	2001      	movs	r0, #1
    6378:	4240      	negs	r0, r0
		}
		++nChars;
	}
	return nChars;
}
    637a:	bc04      	pop	{r2}
    637c:	4690      	mov	r8, r2
    637e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6380:	2000174c 	.word	0x2000174c
    6384:	20001748 	.word	0x20001748

00006388 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    6388:	1c03      	adds	r3, r0, #0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    638a:	4a06      	ldr	r2, [pc, #24]	; (63a4 <_sbrk+0x1c>)
    638c:	6812      	ldr	r2, [r2, #0]
    638e:	2a00      	cmp	r2, #0
    6390:	d102      	bne.n	6398 <_sbrk+0x10>
		heap = (unsigned char *)&_end;
    6392:	4905      	ldr	r1, [pc, #20]	; (63a8 <_sbrk+0x20>)
    6394:	4a03      	ldr	r2, [pc, #12]	; (63a4 <_sbrk+0x1c>)
    6396:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
    6398:	4a02      	ldr	r2, [pc, #8]	; (63a4 <_sbrk+0x1c>)
    639a:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    639c:	18c3      	adds	r3, r0, r3
    639e:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
    63a0:	4770      	bx	lr
    63a2:	46c0      	nop			; (mov r8, r8)
    63a4:	20000198 	.word	0x20000198
    63a8:	20004218 	.word	0x20004218

000063ac <_close>:
}

extern int _close(int file)
{
	return -1;
}
    63ac:	2001      	movs	r0, #1
    63ae:	4240      	negs	r0, r0
    63b0:	4770      	bx	lr
    63b2:	46c0      	nop			; (mov r8, r8)

000063b4 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
    63b4:	2380      	movs	r3, #128	; 0x80
    63b6:	019b      	lsls	r3, r3, #6
    63b8:	604b      	str	r3, [r1, #4]

	return 0;
}
    63ba:	2000      	movs	r0, #0
    63bc:	4770      	bx	lr
    63be:	46c0      	nop			; (mov r8, r8)

000063c0 <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
    63c0:	2001      	movs	r0, #1
    63c2:	4770      	bx	lr

000063c4 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
    63c4:	2000      	movs	r0, #0
    63c6:	4770      	bx	lr

000063c8 <stream_writer_init>:
#include <string.h>
#include <asf.h>

void stream_writer_init(struct stream_writer * writer, char *buffer, size_t max_length, stream_writer_write_func_t func, void *priv_data)
{
	writer->max_size = max_length;
    63c8:	6002      	str	r2, [r0, #0]
	writer->buffer = buffer;
    63ca:	6101      	str	r1, [r0, #16]
	writer->written = 0;
    63cc:	2200      	movs	r2, #0
    63ce:	6042      	str	r2, [r0, #4]
	writer->write_func = func;
    63d0:	6083      	str	r3, [r0, #8]
	writer->priv_data = priv_data;
    63d2:	9b00      	ldr	r3, [sp, #0]
    63d4:	60c3      	str	r3, [r0, #12]
}
    63d6:	4770      	bx	lr

000063d8 <stream_writer_send_remain>:
		stream_writer_send_8(writer, *buffer);
	}
}

void stream_writer_send_remain(struct stream_writer * writer)
{
    63d8:	b510      	push	{r4, lr}
	if(writer->written > 0) {
    63da:	6842      	ldr	r2, [r0, #4]
    63dc:	2a00      	cmp	r2, #0
    63de:	d006      	beq.n	63ee <stream_writer_send_remain+0x16>
    63e0:	1c04      	adds	r4, r0, #0
		writer->write_func(writer->priv_data, writer->buffer, writer->written);
    63e2:	68c0      	ldr	r0, [r0, #12]
    63e4:	6921      	ldr	r1, [r4, #16]
    63e6:	68a3      	ldr	r3, [r4, #8]
    63e8:	4798      	blx	r3
		writer->written = 0;
    63ea:	2300      	movs	r3, #0
    63ec:	6063      	str	r3, [r4, #4]
	}
}
    63ee:	bd10      	pop	{r4, pc}

000063f0 <stream_writer_send_8>:
	writer->write_func = func;
	writer->priv_data = priv_data;
}

void stream_writer_send_8(struct stream_writer * writer, int8_t value)
{
    63f0:	b538      	push	{r3, r4, r5, lr}
    63f2:	1c04      	adds	r4, r0, #0
    63f4:	1c0d      	adds	r5, r1, #0
	int remain = writer->max_size - writer->written;
    63f6:	6803      	ldr	r3, [r0, #0]
    63f8:	6842      	ldr	r2, [r0, #4]
    63fa:	1a9b      	subs	r3, r3, r2

	if (remain < 1) {
    63fc:	2b00      	cmp	r3, #0
    63fe:	dc01      	bgt.n	6404 <stream_writer_send_8+0x14>
		stream_writer_send_remain(writer);
    6400:	4b03      	ldr	r3, [pc, #12]	; (6410 <stream_writer_send_8+0x20>)
    6402:	4798      	blx	r3
	}

	writer->buffer[writer->written++] = (char)value;
    6404:	6922      	ldr	r2, [r4, #16]
    6406:	6863      	ldr	r3, [r4, #4]
    6408:	1c59      	adds	r1, r3, #1
    640a:	6061      	str	r1, [r4, #4]
    640c:	54d5      	strb	r5, [r2, r3]
}
    640e:	bd38      	pop	{r3, r4, r5, pc}
    6410:	000063d9 	.word	0x000063d9

00006414 <stream_writer_send_16BE>:

void stream_writer_send_16BE(struct stream_writer * writer, int16_t value)
{
    6414:	b570      	push	{r4, r5, r6, lr}
    6416:	1c06      	adds	r6, r0, #0
    6418:	1c0c      	adds	r4, r1, #0
	stream_writer_send_8(writer, (value >> 8) & 0xFF);
    641a:	1209      	asrs	r1, r1, #8
    641c:	4d02      	ldr	r5, [pc, #8]	; (6428 <stream_writer_send_16BE+0x14>)
    641e:	47a8      	blx	r5
	stream_writer_send_8(writer, value & 0xFF);
    6420:	b261      	sxtb	r1, r4
    6422:	1c30      	adds	r0, r6, #0
    6424:	47a8      	blx	r5
}
    6426:	bd70      	pop	{r4, r5, r6, pc}
    6428:	000063f1 	.word	0x000063f1

0000642c <stream_writer_send_buffer>:
	stream_writer_send_8(writer, (value >> 16) & 0xFF);
	stream_writer_send_8(writer, (value >> 24) & 0xFF);
}

void stream_writer_send_buffer(struct stream_writer * writer, char *buffer, size_t length)
{
    642c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    642e:	1c06      	adds	r6, r0, #0
    6430:	1c0d      	adds	r5, r1, #0
    6432:	1e14      	subs	r4, r2, #0
	for (; length > 0; length--, buffer++) {
    6434:	d008      	beq.n	6448 <stream_writer_send_buffer+0x1c>
		stream_writer_send_8(writer, *buffer);
    6436:	4f05      	ldr	r7, [pc, #20]	; (644c <stream_writer_send_buffer+0x20>)
    6438:	2100      	movs	r1, #0
    643a:	5669      	ldrsb	r1, [r5, r1]
    643c:	1c30      	adds	r0, r6, #0
    643e:	47b8      	blx	r7
	stream_writer_send_8(writer, (value >> 24) & 0xFF);
}

void stream_writer_send_buffer(struct stream_writer * writer, char *buffer, size_t length)
{
	for (; length > 0; length--, buffer++) {
    6440:	3c01      	subs	r4, #1
    6442:	3501      	adds	r5, #1
    6444:	2c00      	cmp	r4, #0
    6446:	d1f7      	bne.n	6438 <stream_writer_send_buffer+0xc>
		stream_writer_send_8(writer, *buffer);
	}
}
    6448:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    644a:	46c0      	nop			; (mov r8, r8)
    644c:	000063f1 	.word	0x000063f1

00006450 <sw_timer_tcc_callback>:
 *
 * \param[in] module Instance of the TCC.
 */
static void sw_timer_tcc_callback(struct tcc_module *const module)
{
	sw_timer_tick++;
    6450:	4a02      	ldr	r2, [pc, #8]	; (645c <sw_timer_tcc_callback+0xc>)
    6452:	6813      	ldr	r3, [r2, #0]
    6454:	3301      	adds	r3, #1
    6456:	6013      	str	r3, [r2, #0]
}
    6458:	4770      	bx	lr
    645a:	46c0      	nop			; (mov r8, r8)
    645c:	2000019c 	.word	0x2000019c

00006460 <sw_timer_get_config_defaults>:

void sw_timer_get_config_defaults(struct sw_timer_config *const config)
{
	Assert(config);

	config->accuracy = 100;
    6460:	2364      	movs	r3, #100	; 0x64
    6462:	8043      	strh	r3, [r0, #2]
	config->tcc_dev = 0;
    6464:	2300      	movs	r3, #0
    6466:	7003      	strb	r3, [r0, #0]
	config->tcc_callback_channel = 0;
    6468:	7043      	strb	r3, [r0, #1]
}
    646a:	4770      	bx	lr

0000646c <sw_timer_init>:

void sw_timer_init(struct sw_timer_module *const module_inst, struct sw_timer_config *const config)
{
    646c:	b5f0      	push	{r4, r5, r6, r7, lr}
    646e:	4647      	mov	r7, r8
    6470:	b480      	push	{r7}
    6472:	b0ac      	sub	sp, #176	; 0xb0
    6474:	1c0d      	adds	r5, r1, #0
	struct tcc_config tcc_conf;
	struct tcc_module *tcc_module;
	Tcc *hw[] = TCC_INSTS;
    6476:	466e      	mov	r6, sp
    6478:	4b1d      	ldr	r3, [pc, #116]	; (64f0 <sw_timer_init+0x84>)
    647a:	466a      	mov	r2, sp
    647c:	cb92      	ldmia	r3!, {r1, r4, r7}
    647e:	c292      	stmia	r2!, {r1, r4, r7}
	Assert(module_inst);
	Assert(config);
	Assert(config->tcc_dev < TCC_INST_NUM);
	Assert(config->tcc_callback_channel < TCC_NUM_CHANNELS);

	module_inst->accuracy = config->accuracy;
    6480:	886b      	ldrh	r3, [r5, #2]
    6482:	6543      	str	r3, [r0, #84]	; 0x54

	/* Start the TCC module. */
	tcc_module = &module_inst->tcc_inst;
    6484:	3014      	adds	r0, #20
    6486:	1c04      	adds	r4, r0, #0
	tcc_get_config_defaults(&tcc_conf, hw[config->tcc_dev]);
    6488:	1c17      	adds	r7, r2, #0
    648a:	782b      	ldrb	r3, [r5, #0]
    648c:	009b      	lsls	r3, r3, #2
    648e:	5999      	ldr	r1, [r3, r6]
    6490:	1c10      	adds	r0, r2, #0
    6492:	4b18      	ldr	r3, [pc, #96]	; (64f4 <sw_timer_init+0x88>)
    6494:	4798      	blx	r3
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> PM->CPUSEL.reg);
    6496:	2000      	movs	r0, #0
    6498:	4b17      	ldr	r3, [pc, #92]	; (64f8 <sw_timer_init+0x8c>)
    649a:	4798      	blx	r3
    649c:	4b17      	ldr	r3, [pc, #92]	; (64fc <sw_timer_init+0x90>)
    649e:	7a1b      	ldrb	r3, [r3, #8]
    64a0:	b2db      	uxtb	r3, r3
    64a2:	40d8      	lsrs	r0, r3
    64a4:	4680      	mov	r8, r0
	tcc_conf.counter.period = system_cpu_clock_get_hz() / (64 * 1000 / config->accuracy);
    64a6:	8869      	ldrh	r1, [r5, #2]
    64a8:	20fa      	movs	r0, #250	; 0xfa
    64aa:	0200      	lsls	r0, r0, #8
    64ac:	4b14      	ldr	r3, [pc, #80]	; (6500 <sw_timer_init+0x94>)
    64ae:	4798      	blx	r3
    64b0:	1c01      	adds	r1, r0, #0
    64b2:	4640      	mov	r0, r8
    64b4:	4b13      	ldr	r3, [pc, #76]	; (6504 <sw_timer_init+0x98>)
    64b6:	4798      	blx	r3
    64b8:	6078      	str	r0, [r7, #4]
	tcc_conf.counter.clock_prescaler = TCC_CLOCK_PRESCALER_DIV64;
    64ba:	2305      	movs	r3, #5
    64bc:	72fb      	strb	r3, [r7, #11]
	tcc_init(tcc_module, hw[config->tcc_dev], &tcc_conf);
    64be:	782b      	ldrb	r3, [r5, #0]
    64c0:	009b      	lsls	r3, r3, #2
    64c2:	5999      	ldr	r1, [r3, r6]
    64c4:	1c20      	adds	r0, r4, #0
    64c6:	1c3a      	adds	r2, r7, #0
    64c8:	4b0f      	ldr	r3, [pc, #60]	; (6508 <sw_timer_init+0x9c>)
    64ca:	4798      	blx	r3
	tcc_register_callback(tcc_module, sw_timer_tcc_callback, config->tcc_callback_channel + TCC_CALLBACK_CHANNEL_0);
    64cc:	786a      	ldrb	r2, [r5, #1]
    64ce:	3208      	adds	r2, #8
    64d0:	b2d2      	uxtb	r2, r2
    64d2:	1c20      	adds	r0, r4, #0
    64d4:	490d      	ldr	r1, [pc, #52]	; (650c <sw_timer_init+0xa0>)
    64d6:	4b0e      	ldr	r3, [pc, #56]	; (6510 <sw_timer_init+0xa4>)
    64d8:	4798      	blx	r3
	tcc_enable_callback(tcc_module, config->tcc_callback_channel + TCC_CALLBACK_CHANNEL_0);
    64da:	7869      	ldrb	r1, [r5, #1]
    64dc:	3108      	adds	r1, #8
    64de:	b2c9      	uxtb	r1, r1
    64e0:	1c20      	adds	r0, r4, #0
    64e2:	4b0c      	ldr	r3, [pc, #48]	; (6514 <sw_timer_init+0xa8>)
    64e4:	4798      	blx	r3
}
    64e6:	b02c      	add	sp, #176	; 0xb0
    64e8:	bc04      	pop	{r2}
    64ea:	4690      	mov	r8, r2
    64ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    64ee:	46c0      	nop			; (mov r8, r8)
    64f0:	0000ec54 	.word	0x0000ec54
    64f4:	00005bb5 	.word	0x00005bb5
    64f8:	00005915 	.word	0x00005915
    64fc:	40000400 	.word	0x40000400
    6500:	0000becd 	.word	0x0000becd
    6504:	0000bdad 	.word	0x0000bdad
    6508:	00005d01 	.word	0x00005d01
    650c:	00006451 	.word	0x00006451
    6510:	00006129 	.word	0x00006129
    6514:	00006141 	.word	0x00006141

00006518 <sw_timer_enable>:
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	Tcc *const tcc_module = module_inst->hw;
    6518:	6942      	ldr	r2, [r0, #20]

	while (tcc_module->SYNCBUSY.reg & TCC_SYNCBUSY_ENABLE) {
    651a:	2102      	movs	r1, #2
    651c:	6893      	ldr	r3, [r2, #8]
    651e:	4219      	tst	r1, r3
    6520:	d1fc      	bne.n	651c <sw_timer_enable+0x4>
		/* Wait for sync */
	}

	/* Enable the TCC module */
	tcc_module->CTRLA.reg |= TCC_CTRLA_ENABLE;
    6522:	6811      	ldr	r1, [r2, #0]
    6524:	2302      	movs	r3, #2
    6526:	430b      	orrs	r3, r1
    6528:	6013      	str	r3, [r2, #0]
	Assert(module_inst);

	tcc_module = &module_inst->tcc_inst;

	tcc_enable(tcc_module);
}
    652a:	4770      	bx	lr

0000652c <sw_timer_register_callback>:
	tcc_disable(tcc_module);
}

int sw_timer_register_callback(struct sw_timer_module *const module_inst,
	sw_timer_callback_t callback, void *context, uint32_t period)
{
    652c:	b510      	push	{r4, lr}
	struct sw_timer_handle *handler;

	Assert(module_inst);

	for (index = 0; index < CONF_SW_TIMER_COUNT; index++) {
		if (module_inst->handler[index].used == 0) {
    652e:	7804      	ldrb	r4, [r0, #0]
    6530:	07e4      	lsls	r4, r4, #31
    6532:	d411      	bmi.n	6558 <sw_timer_register_callback+0x2c>
    6534:	1c04      	adds	r4, r0, #0
			handler = &module_inst->handler[index];
			handler->callback = callback;
    6536:	6041      	str	r1, [r0, #4]
			handler->callback_enable = 0;
    6538:	7801      	ldrb	r1, [r0, #0]
    653a:	2002      	movs	r0, #2
    653c:	4381      	bics	r1, r0
    653e:	7021      	strb	r1, [r4, #0]
			handler->context = context;
    6540:	60a2      	str	r2, [r4, #8]
			handler->period = period / module_inst->accuracy;
    6542:	1c18      	adds	r0, r3, #0
    6544:	6d61      	ldr	r1, [r4, #84]	; 0x54
    6546:	4b06      	ldr	r3, [pc, #24]	; (6560 <sw_timer_register_callback+0x34>)
    6548:	4798      	blx	r3
    654a:	60e0      	str	r0, [r4, #12]
			handler->used = 1;
    654c:	7822      	ldrb	r2, [r4, #0]
    654e:	2301      	movs	r3, #1
    6550:	4313      	orrs	r3, r2
    6552:	7023      	strb	r3, [r4, #0]
			return index;
    6554:	2000      	movs	r0, #0
    6556:	e001      	b.n	655c <sw_timer_register_callback+0x30>
		}
	}

	return -1;
    6558:	2001      	movs	r0, #1
    655a:	4240      	negs	r0, r0
}
    655c:	bd10      	pop	{r4, pc}
    655e:	46c0      	nop			; (mov r8, r8)
    6560:	0000bdad 	.word	0x0000bdad

00006564 <sw_timer_enable_callback>:

	handler->used = 0;
}

void sw_timer_enable_callback(struct sw_timer_module *const module_inst, int timer_id, uint32_t delay)
{
    6564:	b570      	push	{r4, r5, r6, lr}
    6566:	1c03      	adds	r3, r0, #0
	Assert(module_inst);
	Assert((timer_id >= 0 && timer_id < CONF_SW_TIMER_COUNT));

	handler = &module_inst->handler[timer_id];

	handler->callback_enable = 1;
    6568:	008c      	lsls	r4, r1, #2
    656a:	1865      	adds	r5, r4, r1
    656c:	00ad      	lsls	r5, r5, #2
    656e:	5c2e      	ldrb	r6, [r5, r0]
    6570:	2002      	movs	r0, #2
    6572:	4330      	orrs	r0, r6
    6574:	54e8      	strb	r0, [r5, r3]
	handler->expire_time = sw_timer_tick + (delay / module_inst->accuracy);
    6576:	195c      	adds	r4, r3, r5
    6578:	1c10      	adds	r0, r2, #0
    657a:	6d59      	ldr	r1, [r3, #84]	; 0x54
    657c:	4b03      	ldr	r3, [pc, #12]	; (658c <sw_timer_enable_callback+0x28>)
    657e:	4798      	blx	r3
    6580:	4b03      	ldr	r3, [pc, #12]	; (6590 <sw_timer_enable_callback+0x2c>)
    6582:	681b      	ldr	r3, [r3, #0]
    6584:	18c0      	adds	r0, r0, r3
    6586:	6120      	str	r0, [r4, #16]
}
    6588:	bd70      	pop	{r4, r5, r6, pc}
    658a:	46c0      	nop			; (mov r8, r8)
    658c:	0000bdad 	.word	0x0000bdad
    6590:	2000019c 	.word	0x2000019c

00006594 <sw_timer_disable_callback>:
	Assert(module_inst);
	Assert((timer_id >= 0 && timer_id < CONF_SW_TIMER_COUNT));

	handler = &module_inst->handler[timer_id];

	handler->callback_enable = 0;
    6594:	008b      	lsls	r3, r1, #2
    6596:	1859      	adds	r1, r3, r1
    6598:	0089      	lsls	r1, r1, #2
    659a:	5c0b      	ldrb	r3, [r1, r0]
    659c:	2202      	movs	r2, #2
    659e:	4393      	bics	r3, r2
    65a0:	540b      	strb	r3, [r1, r0]
}
    65a2:	4770      	bx	lr

000065a4 <sw_timer_task>:

void sw_timer_task(struct sw_timer_module *const module_inst)
{
    65a4:	b538      	push	{r3, r4, r5, lr}
	struct sw_timer_handle *handler;

	Assert(module_inst);

	for (index = 0; index < CONF_SW_TIMER_COUNT; index++) {
		if (module_inst->handler[index].used && module_inst->handler[index].callback_enable) {
    65a6:	7803      	ldrb	r3, [r0, #0]
    65a8:	07db      	lsls	r3, r3, #31
    65aa:	d524      	bpl.n	65f6 <sw_timer_task+0x52>
    65ac:	7803      	ldrb	r3, [r0, #0]
    65ae:	079b      	lsls	r3, r3, #30
    65b0:	d521      	bpl.n	65f6 <sw_timer_task+0x52>
			handler = &module_inst->handler[index];
			if ((int)(handler->expire_time - sw_timer_tick) < 0 && handler->busy == 0) {
    65b2:	4b11      	ldr	r3, [pc, #68]	; (65f8 <sw_timer_task+0x54>)
    65b4:	681b      	ldr	r3, [r3, #0]
    65b6:	6902      	ldr	r2, [r0, #16]
    65b8:	1ad3      	subs	r3, r2, r3
    65ba:	d51c      	bpl.n	65f6 <sw_timer_task+0x52>
    65bc:	7803      	ldrb	r3, [r0, #0]
    65be:	075b      	lsls	r3, r3, #29
    65c0:	d419      	bmi.n	65f6 <sw_timer_task+0x52>
    65c2:	1c04      	adds	r4, r0, #0
				/* Enter critical section. */
				handler->busy = 1;
    65c4:	7802      	ldrb	r2, [r0, #0]
    65c6:	2304      	movs	r3, #4
    65c8:	4313      	orrs	r3, r2
    65ca:	7003      	strb	r3, [r0, #0]
				/* Call callback function. */
				handler->callback(module_inst, index, handler->context, handler->period);
    65cc:	2100      	movs	r1, #0
    65ce:	68a2      	ldr	r2, [r4, #8]
    65d0:	68e3      	ldr	r3, [r4, #12]
    65d2:	6865      	ldr	r5, [r4, #4]
    65d4:	47a8      	blx	r5
				/* Timer was expired. */
				if (handler->period > 0) {
    65d6:	68e3      	ldr	r3, [r4, #12]
    65d8:	2b00      	cmp	r3, #0
    65da:	d004      	beq.n	65e6 <sw_timer_task+0x42>
					handler->expire_time = sw_timer_tick + handler->period;
    65dc:	4a06      	ldr	r2, [pc, #24]	; (65f8 <sw_timer_task+0x54>)
    65de:	6812      	ldr	r2, [r2, #0]
    65e0:	18d3      	adds	r3, r2, r3
    65e2:	6123      	str	r3, [r4, #16]
    65e4:	e003      	b.n	65ee <sw_timer_task+0x4a>
				} else {
					/* One shot. */
					handler->callback_enable = 0;
    65e6:	7823      	ldrb	r3, [r4, #0]
    65e8:	2202      	movs	r2, #2
    65ea:	4393      	bics	r3, r2
    65ec:	7023      	strb	r3, [r4, #0]
				}
				/* Leave critical section. */
				handler->busy = 0;
    65ee:	7823      	ldrb	r3, [r4, #0]
    65f0:	2204      	movs	r2, #4
    65f2:	4393      	bics	r3, r2
    65f4:	7023      	strb	r3, [r4, #0]
			}
		}
	}

}
    65f6:	bd38      	pop	{r3, r4, r5, pc}
    65f8:	2000019c 	.word	0x2000019c

000065fc <timer_callback_handler>:
* \Timer callback handler called on timer expiry
*/
static void timer_callback_handler(void)
{
	//Timer call back
	timer_cb_done = true;
    65fc:	2201      	movs	r2, #1
    65fe:	4b01      	ldr	r3, [pc, #4]	; (6604 <timer_callback_handler+0x8>)
    6600:	701a      	strb	r2, [r3, #0]
}
    6602:	4770      	bx	lr
    6604:	20000214 	.word	0x20000214

00006608 <ble_connected_app_event>:
}

static at_ble_status_t ble_connected_app_event(void *param)
{
	at_ble_connected_t *connected = (at_ble_connected_t *)param;
	bat_connection_handle = connected->handle;
    6608:	8902      	ldrh	r2, [r0, #8]
    660a:	4b02      	ldr	r3, [pc, #8]	; (6614 <ble_connected_app_event+0xc>)
    660c:	801a      	strh	r2, [r3, #0]
	ble_paired_app_event(param);
	#else
	ALL_UNUSED(param);
	#endif
	return AT_BLE_SUCCESS;
}
    660e:	2000      	movs	r0, #0
    6610:	4770      	bx	lr
    6612:	46c0      	nop			; (mov r8, r8)
    6614:	20001750 	.word	0x20001750

00006618 <ble_notification_confirmed_app_event>:

/* Callback registered for AT_BLE_NOTIFICATION_CONFIRMED event from stack */
static at_ble_status_t ble_notification_confirmed_app_event(void *param)
{
	at_ble_cmd_complete_event_t *notification_status = (at_ble_cmd_complete_event_t *)param;
	if(!notification_status->status)
    6618:	78c3      	ldrb	r3, [r0, #3]
    661a:	2b00      	cmp	r3, #0
    661c:	d102      	bne.n	6624 <ble_notification_confirmed_app_event+0xc>
	{
		flag = true;
    661e:	2201      	movs	r2, #1
    6620:	4b01      	ldr	r3, [pc, #4]	; (6628 <ble_notification_confirmed_app_event+0x10>)
    6622:	701a      	strb	r2, [r3, #0]
		//printf("sending notification to the peer success");
	}
	return AT_BLE_SUCCESS;
}
    6624:	2000      	movs	r0, #0
    6626:	4770      	bx	lr
    6628:	20000021 	.word	0x20000021

0000662c <socket_resolve_handler>:
 *
 * \param[in] doamin_name Domain name.
 * \param[in] server_ip IP of server.
 */
static void socket_resolve_handler(uint8_t *doamin_name, uint32_t server_ip)
{
    662c:	b508      	push	{r3, lr}
	mqtt_socket_resolve_handler(doamin_name, server_ip);
    662e:	4b01      	ldr	r3, [pc, #4]	; (6634 <socket_resolve_handler+0x8>)
    6630:	4798      	blx	r3
}
    6632:	bd08      	pop	{r3, pc}
    6634:	0000b235 	.word	0x0000b235

00006638 <socket_event_handler>:
 *  - [SOCKET_MSG_SENDTO](@ref SOCKET_MSG_SENDTO)
 *  - [SOCKET_MSG_RECVFROM](@ref SOCKET_MSG_RECVFROM)
 * \param[in] msg_data A structure contains notification informations.
 */
static void socket_event_handler(SOCKET sock, uint8_t msg_type, void *msg_data)
{
    6638:	b508      	push	{r3, lr}
	mqtt_socket_event_handler(sock, msg_type, msg_data);
    663a:	4b01      	ldr	r3, [pc, #4]	; (6640 <socket_event_handler+0x8>)
    663c:	4798      	blx	r3
}
    663e:	bd08      	pop	{r3, pc}
    6640:	0000bc85 	.word	0x0000bc85

00006644 <wifi_callback>:
 *  - tstrM2MAPResp
 *  - tstrM2mScanDone
 *  - tstrM2mWifiscanResult
 */
static void wifi_callback(uint8 msg_type, void *msg_data)
{
    6644:	b510      	push	{r4, lr}
    6646:	b082      	sub	sp, #8
	tstrM2mWifiStateChanged *msg_wifi_state;
	uint8 *msg_ip_addr;

	switch (msg_type) {
    6648:	282c      	cmp	r0, #44	; 0x2c
    664a:	d002      	beq.n	6652 <wifi_callback+0xe>
    664c:	2832      	cmp	r0, #50	; 0x32
    664e:	d015      	beq.n	667c <wifi_callback+0x38>
    6650:	e018      	b.n	6684 <wifi_callback+0x40>
	case M2M_WIFI_RESP_CON_STATE_CHANGED:
		msg_wifi_state = (tstrM2mWifiStateChanged *)msg_data;
		if (msg_wifi_state->u8CurrState == M2M_WIFI_CONNECTED) {
    6652:	780b      	ldrb	r3, [r1, #0]
    6654:	2b01      	cmp	r3, #1
    6656:	d102      	bne.n	665e <wifi_callback+0x1a>
			/* If Wi-Fi is connected. */
			//printf("Wi-Fi connected\r\n");
			m2m_wifi_request_dhcp_client();
    6658:	4b0b      	ldr	r3, [pc, #44]	; (6688 <wifi_callback+0x44>)
    665a:	4798      	blx	r3
    665c:	e012      	b.n	6684 <wifi_callback+0x40>
		} else if (msg_wifi_state->u8CurrState == M2M_WIFI_DISCONNECTED) {
    665e:	2b00      	cmp	r3, #0
    6660:	d110      	bne.n	6684 <wifi_callback+0x40>
			/* If Wi-Fi is disconnected. */
			//printf("Wi-Fi disconnected\r\n");
			m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID),
    6662:	33ff      	adds	r3, #255	; 0xff
    6664:	9300      	str	r3, [sp, #0]
    6666:	4809      	ldr	r0, [pc, #36]	; (668c <wifi_callback+0x48>)
    6668:	2105      	movs	r1, #5
    666a:	2202      	movs	r2, #2
    666c:	4b08      	ldr	r3, [pc, #32]	; (6690 <wifi_callback+0x4c>)
    666e:	4c09      	ldr	r4, [pc, #36]	; (6694 <wifi_callback+0x50>)
    6670:	47a0      	blx	r4
					MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
			/* Disconnect from MQTT broker. */
			/* Force close the MQTT connection, because cannot send a disconnect message to the broker when network is broken. */
			mqtt_disconnect(&mqtt_inst, 1);
    6672:	4809      	ldr	r0, [pc, #36]	; (6698 <wifi_callback+0x54>)
    6674:	2101      	movs	r1, #1
    6676:	4b09      	ldr	r3, [pc, #36]	; (669c <wifi_callback+0x58>)
    6678:	4798      	blx	r3
    667a:	e003      	b.n	6684 <wifi_callback+0x40>

	case M2M_WIFI_REQ_DHCP_CONF:
		msg_ip_addr = (uint8 *)msg_data;
		//printf("Wi-Fi IP is %u.%u.%u.%u\r\n",msg_ip_addr[0], msg_ip_addr[1], msg_ip_addr[2], msg_ip_addr[3]);
		/* Try to connect to MQTT broker when Wi-Fi was connected. */
		mqtt_connect(&mqtt_inst, main_mqtt_broker);
    667c:	4806      	ldr	r0, [pc, #24]	; (6698 <wifi_callback+0x54>)
    667e:	4908      	ldr	r1, [pc, #32]	; (66a0 <wifi_callback+0x5c>)
    6680:	4b08      	ldr	r3, [pc, #32]	; (66a4 <wifi_callback+0x60>)
    6682:	4798      	blx	r3
		break;

	default:
		break;
	}
}
    6684:	b002      	add	sp, #8
    6686:	bd10      	pop	{r4, pc}
    6688:	00002c6d 	.word	0x00002c6d
    668c:	0000ece8 	.word	0x0000ece8
    6690:	0000ecf0 	.word	0x0000ecf0
    6694:	00002c51 	.word	0x00002c51
    6698:	200001a0 	.word	0x200001a0
    669c:	0000b945 	.word	0x0000b945
    66a0:	0000ecac 	.word	0x0000ecac
    66a4:	0000b289 	.word	0x0000b289

000066a8 <ble_char_changed_app_event>:
	return AT_BLE_SUCCESS;
}

/* Callback registered for AT_BLE_CHARACTERISTIC_CHANGED event from stack */
static at_ble_status_t ble_char_changed_app_event(void *param)
{
    66a8:	b510      	push	{r4, lr}
    66aa:	1c02      	adds	r2, r0, #0
	at_ble_characteristic_changed_t *char_handle = (at_ble_characteristic_changed_t *)param;
	return bat_char_changed_event(char_handle->conn_handle,&bas_service_handler, char_handle, &flag);
    66ac:	7800      	ldrb	r0, [r0, #0]
    66ae:	4902      	ldr	r1, [pc, #8]	; (66b8 <ble_char_changed_app_event+0x10>)
    66b0:	4b02      	ldr	r3, [pc, #8]	; (66bc <ble_char_changed_app_event+0x14>)
    66b2:	4c03      	ldr	r4, [pc, #12]	; (66c0 <ble_char_changed_app_event+0x18>)
    66b4:	47a0      	blx	r4
}
    66b6:	bd10      	pop	{r4, pc}
    66b8:	200017ac 	.word	0x200017ac
    66bc:	20000021 	.word	0x20000021
    66c0:	00001d79 	.word	0x00001d79

000066c4 <ble_paired_app_event>:
}


/* Callback registered for AT_BLE_PAIR_DONE event from stack */
static at_ble_status_t ble_paired_app_event(void *param)
{
    66c4:	b508      	push	{r3, lr}
	timer_cb_done = false;
    66c6:	2200      	movs	r2, #0
    66c8:	4b03      	ldr	r3, [pc, #12]	; (66d8 <ble_paired_app_event+0x14>)
    66ca:	701a      	strb	r2, [r3, #0]
	hw_timer_start(BATTERY_UPDATE_INTERVAL);
    66cc:	2001      	movs	r0, #1
    66ce:	4b03      	ldr	r3, [pc, #12]	; (66dc <ble_paired_app_event+0x18>)
    66d0:	4798      	blx	r3
	ALL_UNUSED(param);
	return AT_BLE_SUCCESS;
}
    66d2:	2000      	movs	r0, #0
    66d4:	bd08      	pop	{r3, pc}
    66d6:	46c0      	nop			; (mov r8, r8)
    66d8:	20000214 	.word	0x20000214
    66dc:	000015b5 	.word	0x000015b5

000066e0 <mqtt_callback>:
 *  - [MQTT_CALLBACK_DISCONNECTED](@ref MQTT_CALLBACK_DISCONNECTED)
 *  - [MQTT_CALLBACK_RECV_PUBLISH](@ref MQTT_CALLBACK_RECV_PUBLISH)
 * \param[in] data A structure contains notification informations. @ref mqtt_data
 */
static void mqtt_callback(struct mqtt_module *module_inst, int type, union mqtt_data *data)
{
    66e0:	b510      	push	{r4, lr}
    66e2:	b086      	sub	sp, #24
	switch (type) {
    66e4:	2901      	cmp	r1, #1
    66e6:	d01e      	beq.n	6726 <mqtt_callback+0x46>
    66e8:	1c14      	adds	r4, r2, #0
    66ea:	2901      	cmp	r1, #1
    66ec:	dc02      	bgt.n	66f4 <mqtt_callback+0x14>
    66ee:	2900      	cmp	r1, #0
    66f0:	d005      	beq.n	66fe <mqtt_callback+0x1e>
    66f2:	e044      	b.n	677e <mqtt_callback+0x9e>
    66f4:	2905      	cmp	r1, #5
    66f6:	d03e      	beq.n	6776 <mqtt_callback+0x96>
    66f8:	2906      	cmp	r1, #6
    66fa:	d021      	beq.n	6740 <mqtt_callback+0x60>
    66fc:	e03f      	b.n	677e <mqtt_callback+0x9e>
	{
		/*
		 * If connecting to broker server is complete successfully, Start sending CONNECT message of MQTT.
		 * Or else retry to connect to broker server.
		 */
		if (data->sock_connected.result >= 0) {
    66fe:	6813      	ldr	r3, [r2, #0]
    6700:	2b00      	cmp	r3, #0
    6702:	db0c      	blt.n	671e <mqtt_callback+0x3e>
			mqtt_connect_broker(module_inst, 1, NULL, NULL, mqtt_user, NULL, NULL, 0, 0, 0);
    6704:	4b1f      	ldr	r3, [pc, #124]	; (6784 <mqtt_callback+0xa4>)
    6706:	9300      	str	r3, [sp, #0]
    6708:	2300      	movs	r3, #0
    670a:	9301      	str	r3, [sp, #4]
    670c:	9302      	str	r3, [sp, #8]
    670e:	9303      	str	r3, [sp, #12]
    6710:	9304      	str	r3, [sp, #16]
    6712:	9305      	str	r3, [sp, #20]
    6714:	2101      	movs	r1, #1
    6716:	2200      	movs	r2, #0
    6718:	4c1b      	ldr	r4, [pc, #108]	; (6788 <mqtt_callback+0xa8>)
    671a:	47a0      	blx	r4
    671c:	e02f      	b.n	677e <mqtt_callback+0x9e>
		} else {
			//printf("Connect fail to server(%s)! retry it automatically.\r\n", main_mqtt_broker);
			mqtt_connect(module_inst, main_mqtt_broker); /* Retry that. */
    671e:	491b      	ldr	r1, [pc, #108]	; (678c <mqtt_callback+0xac>)
    6720:	4b1b      	ldr	r3, [pc, #108]	; (6790 <mqtt_callback+0xb0>)
    6722:	4798      	blx	r3
    6724:	e02b      	b.n	677e <mqtt_callback+0x9e>
		}
	}
	break;

	case MQTT_CALLBACK_CONNECTED:
		if (data->connected.result == MQTT_CONN_RESULT_ACCEPT) {
    6726:	7813      	ldrb	r3, [r2, #0]
    6728:	2b00      	cmp	r3, #0
    672a:	d104      	bne.n	6736 <mqtt_callback+0x56>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    672c:	2280      	movs	r2, #128	; 0x80
    672e:	0412      	lsls	r2, r2, #16
    6730:	4b18      	ldr	r3, [pc, #96]	; (6794 <mqtt_callback+0xb4>)
    6732:	615a      	str	r2, [r3, #20]
    6734:	e023      	b.n	677e <mqtt_callback+0x9e>
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    6736:	2280      	movs	r2, #128	; 0x80
    6738:	0412      	lsls	r2, r2, #16
    673a:	4b16      	ldr	r3, [pc, #88]	; (6794 <mqtt_callback+0xb4>)
    673c:	619a      	str	r2, [r3, #24]
    673e:	e01e      	b.n	677e <mqtt_callback+0x9e>

		break;

	case MQTT_CALLBACK_RECV_PUBLISH:
		/* You received publish message which you had subscribed. */
		if (data->recv_publish.topic != NULL && data->recv_publish.msg != NULL) {
    6740:	6810      	ldr	r0, [r2, #0]
    6742:	2800      	cmp	r0, #0
    6744:	d01b      	beq.n	677e <mqtt_callback+0x9e>
    6746:	6893      	ldr	r3, [r2, #8]
    6748:	2b00      	cmp	r3, #0
    674a:	d018      	beq.n	677e <mqtt_callback+0x9e>
			if (!strncmp(data->recv_publish.topic, MAIN_MQTT_TOPIC, strlen(MAIN_MQTT_TOPIC))) {
    674c:	4912      	ldr	r1, [pc, #72]	; (6798 <mqtt_callback+0xb8>)
    674e:	221b      	movs	r2, #27
    6750:	4b12      	ldr	r3, [pc, #72]	; (679c <mqtt_callback+0xbc>)
    6752:	4798      	blx	r3
    6754:	2800      	cmp	r0, #0
    6756:	d112      	bne.n	677e <mqtt_callback+0x9e>
				/* Print user name and message */
				for (int i = strlen(MAIN_MQTT_TOPIC); i < data->recv_publish.topic_size; i++) {
    6758:	6862      	ldr	r2, [r4, #4]
    675a:	2a1b      	cmp	r2, #27
    675c:	dd03      	ble.n	6766 <mqtt_callback+0x86>
    675e:	231b      	movs	r3, #27
    6760:	3301      	adds	r3, #1
    6762:	4293      	cmp	r3, r2
    6764:	d1fc      	bne.n	6760 <mqtt_callback+0x80>
					//printf("%c", data->recv_publish.topic[i]);
				}
				//printf(" >> ");
				for (int i = 0; i < data->recv_publish.msg_size; i++) {
    6766:	68e2      	ldr	r2, [r4, #12]
    6768:	2a00      	cmp	r2, #0
    676a:	dd08      	ble.n	677e <mqtt_callback+0x9e>
    676c:	2300      	movs	r3, #0
    676e:	3301      	adds	r3, #1
    6770:	4293      	cmp	r3, r2
    6772:	d1fc      	bne.n	676e <mqtt_callback+0x8e>
    6774:	e003      	b.n	677e <mqtt_callback+0x9e>
    6776:	2280      	movs	r2, #128	; 0x80
    6778:	0412      	lsls	r2, r2, #16
    677a:	4b06      	ldr	r3, [pc, #24]	; (6794 <mqtt_callback+0xb4>)
    677c:	619a      	str	r2, [r3, #24]
		/* Stop timer and USART callback. */
		//printf("MQTT disconnected\r\n");
		LED_Off(LED0);
		break;
	}
}
    677e:	b006      	add	sp, #24
    6780:	bd10      	pop	{r4, pc}
    6782:	46c0      	nop			; (mov r8, r8)
    6784:	20000298 	.word	0x20000298
    6788:	0000b39d 	.word	0x0000b39d
    678c:	0000ecac 	.word	0x0000ecac
    6790:	0000b289 	.word	0x0000b289
    6794:	41004400 	.word	0x41004400
    6798:	0000ecfc 	.word	0x0000ecfc
    679c:	0000daab 	.word	0x0000daab

000067a0 <battery_service_advertise>:
	timer_cb_done = true;
}

/* Advertisement data set and Advertisement start */
static at_ble_status_t battery_service_advertise(void)
{
    67a0:	b510      	push	{r4, lr}
    67a2:	b084      	sub	sp, #16
	at_ble_status_t status = AT_BLE_FAILURE;
	
	if((status = ble_advertisement_data_set()) != AT_BLE_SUCCESS)
    67a4:	4b0c      	ldr	r3, [pc, #48]	; (67d8 <battery_service_advertise+0x38>)
    67a6:	4798      	blx	r3
    67a8:	1e03      	subs	r3, r0, #0
    67aa:	d112      	bne.n	67d2 <battery_service_advertise+0x32>
		//printf("advertisement data set failed reason :%d",status);
		return status;
	}
	
	/* Start of advertisement */
	if((status = at_ble_adv_start(AT_BLE_ADV_TYPE_UNDIRECTED, AT_BLE_ADV_GEN_DISCOVERABLE, NULL, AT_BLE_ADV_FP_ANY, APP_BAS_FAST_ADV, APP_BAS_ADV_TIMEOUT, 0)) == AT_BLE_SUCCESS)
    67ac:	23c8      	movs	r3, #200	; 0xc8
    67ae:	00db      	lsls	r3, r3, #3
    67b0:	9300      	str	r3, [sp, #0]
    67b2:	23fa      	movs	r3, #250	; 0xfa
    67b4:	009b      	lsls	r3, r3, #2
    67b6:	9301      	str	r3, [sp, #4]
    67b8:	2300      	movs	r3, #0
    67ba:	9302      	str	r3, [sp, #8]
    67bc:	2000      	movs	r0, #0
    67be:	2101      	movs	r1, #1
    67c0:	2200      	movs	r2, #0
    67c2:	4c06      	ldr	r4, [pc, #24]	; (67dc <battery_service_advertise+0x3c>)
    67c4:	47a0      	blx	r4
    67c6:	1e03      	subs	r3, r0, #0
    67c8:	d103      	bne.n	67d2 <battery_service_advertise+0x32>
	} else {
		port_base->OUTCLR.reg = pin_mask;
    67ca:	2180      	movs	r1, #128	; 0x80
    67cc:	0409      	lsls	r1, r1, #16
    67ce:	4a04      	ldr	r2, [pc, #16]	; (67e0 <battery_service_advertise+0x40>)
    67d0:	6151      	str	r1, [r2, #20]
	else
	{
		//printf("BLE Adv start Failed reason :%d",status);
	}
	return status;
}
    67d2:	b004      	add	sp, #16
    67d4:	bd10      	pop	{r4, pc}
    67d6:	46c0      	nop			; (mov r8, r8)
    67d8:	0000109d 	.word	0x0000109d
    67dc:	00007611 	.word	0x00007611
    67e0:	41004400 	.word	0x41004400

000067e4 <ble_disconnected_app_event>:
	return AT_BLE_SUCCESS;
}

/* Callback registered for AT_BLE_DISCONNECTED event from stack */
static at_ble_status_t ble_disconnected_app_event(void *param)
{
    67e4:	b508      	push	{r3, lr}
	timer_cb_done = false;
    67e6:	2200      	movs	r2, #0
    67e8:	4b05      	ldr	r3, [pc, #20]	; (6800 <ble_disconnected_app_event+0x1c>)
    67ea:	701a      	strb	r2, [r3, #0]
	flag = true;
    67ec:	3201      	adds	r2, #1
    67ee:	4b05      	ldr	r3, [pc, #20]	; (6804 <ble_disconnected_app_event+0x20>)
    67f0:	701a      	strb	r2, [r3, #0]
	hw_timer_stop();
    67f2:	4b05      	ldr	r3, [pc, #20]	; (6808 <ble_disconnected_app_event+0x24>)
    67f4:	4798      	blx	r3
	battery_service_advertise();
    67f6:	4b05      	ldr	r3, [pc, #20]	; (680c <ble_disconnected_app_event+0x28>)
    67f8:	4798      	blx	r3
	ALL_UNUSED(param);
	return AT_BLE_SUCCESS;
}
    67fa:	2000      	movs	r0, #0
    67fc:	bd08      	pop	{r3, pc}
    67fe:	46c0      	nop			; (mov r8, r8)
    6800:	20000214 	.word	0x20000214
    6804:	20000021 	.word	0x20000021
    6808:	00001605 	.word	0x00001605
    680c:	000067a1 	.word	0x000067a1

00006810 <main>:
 * Application entry point.
 *
 * \return program return value.
 */
int main(void)
{
    6810:	b5f0      	push	{r4, r5, r6, r7, lr}
    6812:	4647      	mov	r7, r8
    6814:	b480      	push	{r7}
    6816:	b0a4      	sub	sp, #144	; 0x90
	tstrWifiInitParam param;
	int8_t ret, ret_ble;
	char topic[strlen(MAIN_MQTT_TOPIC) + MAIN_CHAT_USER_NAME_SIZE + 1],msg[5];
	uint8_t battery_level = BATTERY_MIN_LEVEL;
    6818:	2200      	movs	r2, #0
    681a:	2367      	movs	r3, #103	; 0x67
    681c:	a902      	add	r1, sp, #8
    681e:	468c      	mov	ip, r1
    6820:	4463      	add	r3, ip
    6822:	701a      	strb	r2, [r3, #0]

	/* Initialize the board. */
	system_init();
    6824:	4b64      	ldr	r3, [pc, #400]	; (69b8 <main+0x1a8>)
    6826:	4798      	blx	r3
 * \brief Configure Timer module.
 */
static void configure_timer(void)
{
	struct sw_timer_config swt_conf;
	sw_timer_get_config_defaults(&swt_conf);
    6828:	a804      	add	r0, sp, #16
    682a:	4b64      	ldr	r3, [pc, #400]	; (69bc <main+0x1ac>)
    682c:	4798      	blx	r3

	sw_timer_init(&swt_module_inst, &swt_conf);
    682e:	4c64      	ldr	r4, [pc, #400]	; (69c0 <main+0x1b0>)
    6830:	1c20      	adds	r0, r4, #0
    6832:	a904      	add	r1, sp, #16
    6834:	4b63      	ldr	r3, [pc, #396]	; (69c4 <main+0x1b4>)
    6836:	4798      	blx	r3
	sw_timer_enable(&swt_module_inst);
    6838:	1c20      	adds	r0, r4, #0
    683a:	4b63      	ldr	r3, [pc, #396]	; (69c8 <main+0x1b8>)
    683c:	4798      	blx	r3
static void configure_mqtt(void)
{
	struct mqtt_config mqtt_conf;
	int result;

	mqtt_get_config_defaults(&mqtt_conf);
    683e:	a804      	add	r0, sp, #16
    6840:	4b62      	ldr	r3, [pc, #392]	; (69cc <main+0x1bc>)
    6842:	4798      	blx	r3
	/* To use the MQTT service, it is necessary to always set the buffer and the timer. */
	mqtt_conf.timer_inst = &swt_module_inst;
    6844:	9405      	str	r4, [sp, #20]
	mqtt_conf.recv_buffer = mqtt_buffer;
    6846:	4b62      	ldr	r3, [pc, #392]	; (69d0 <main+0x1c0>)
    6848:	9307      	str	r3, [sp, #28]
	mqtt_conf.recv_buffer_size = MAIN_MQTT_BUFFER_SIZE;
    684a:	2380      	movs	r3, #128	; 0x80
    684c:	9308      	str	r3, [sp, #32]

	result = mqtt_init(&mqtt_inst, &mqtt_conf);
    684e:	4861      	ldr	r0, [pc, #388]	; (69d4 <main+0x1c4>)
    6850:	a904      	add	r1, sp, #16
    6852:	4b61      	ldr	r3, [pc, #388]	; (69d8 <main+0x1c8>)
    6854:	4798      	blx	r3
	if (result < 0) {
    6856:	2800      	cmp	r0, #0
    6858:	da00      	bge.n	685c <main+0x4c>
    685a:	e7fe      	b.n	685a <main+0x4a>
		//printf("MQTT initialization failed. Error code is (%d)\r\n", result);
		while (1) {
		}
	}

	result = mqtt_register_callback(&mqtt_inst, mqtt_callback);
    685c:	485d      	ldr	r0, [pc, #372]	; (69d4 <main+0x1c4>)
    685e:	495f      	ldr	r1, [pc, #380]	; (69dc <main+0x1cc>)
    6860:	4b5f      	ldr	r3, [pc, #380]	; (69e0 <main+0x1d0>)
    6862:	4798      	blx	r3
	if (result < 0) {
    6864:	2800      	cmp	r0, #0
    6866:	da00      	bge.n	686a <main+0x5a>
    6868:	e7fe      	b.n	6868 <main+0x58>

	/* Initialize the MQTT service. */
	configure_mqtt();

	/* Initialize the hardware timer */
	hw_timer_init();
    686a:	4b5e      	ldr	r3, [pc, #376]	; (69e4 <main+0x1d4>)
    686c:	4798      	blx	r3

	/* Register the callback */
	hw_timer_register_callback(timer_callback_handler);
    686e:	485e      	ldr	r0, [pc, #376]	; (69e8 <main+0x1d8>)
    6870:	4b5e      	ldr	r3, [pc, #376]	; (69ec <main+0x1dc>)
    6872:	4798      	blx	r3

	/* Initialize the BSP. */
	nm_bsp_init();
    6874:	4b5e      	ldr	r3, [pc, #376]	; (69f0 <main+0x1e0>)
    6876:	4798      	blx	r3


	/* initialize the ble chip  and Set the device mac address */
	ble_device_init(NULL);
    6878:	2000      	movs	r0, #0
    687a:	4b5e      	ldr	r3, [pc, #376]	; (69f4 <main+0x1e4>)
    687c:	4798      	blx	r3

	/* Initialize the battery service */
	bat_init_service(&bas_service_handler, &battery_level);
    687e:	4c5e      	ldr	r4, [pc, #376]	; (69f8 <main+0x1e8>)
    6880:	1c20      	adds	r0, r4, #0
    6882:	2167      	movs	r1, #103	; 0x67
    6884:	ab02      	add	r3, sp, #8
    6886:	469c      	mov	ip, r3
    6888:	4461      	add	r1, ip
    688a:	4b5c      	ldr	r3, [pc, #368]	; (69fc <main+0x1ec>)
    688c:	4798      	blx	r3

	/* Define the primary service in the GATT server database */
	if((ret = bat_primary_service_define(&bas_service_handler))!= AT_BLE_SUCCESS)
    688e:	1c20      	adds	r0, r4, #0
    6890:	4b5b      	ldr	r3, [pc, #364]	; (6a00 <main+0x1f0>)
    6892:	4798      	blx	r3
	{
		//printf("defining battery service failed %d", ret);
	}

	battery_service_advertise();
    6894:	4b5b      	ldr	r3, [pc, #364]	; (6a04 <main+0x1f4>)
    6896:	4798      	blx	r3

	/* Register callbacks for gap related events */
	ble_mgr_events_callback_handler(REGISTER_CALL_BACK, BLE_GAP_EVENT_TYPE,	battery_app_gap_cb);
    6898:	2000      	movs	r0, #0
    689a:	2100      	movs	r1, #0
    689c:	4a5a      	ldr	r2, [pc, #360]	; (6a08 <main+0x1f8>)
    689e:	4c5b      	ldr	r4, [pc, #364]	; (6a0c <main+0x1fc>)
    68a0:	47a0      	blx	r4

	/* Register callbacks for gatt server related events */
	ble_mgr_events_callback_handler(REGISTER_CALL_BACK,	BLE_GATT_SERVER_EVENT_TYPE,	battery_app_gatt_server_cb);
    68a2:	2000      	movs	r0, #0
    68a4:	2102      	movs	r1, #2
    68a6:	4a5a      	ldr	r2, [pc, #360]	; (6a10 <main+0x200>)
    68a8:	47a0      	blx	r4


	/* Setup user name first */
 	sprintf(mqtt_user,"%s", MAIN_MQTT_TOPIC_NAME);
    68aa:	4a5a      	ldr	r2, [pc, #360]	; (6a14 <main+0x204>)
    68ac:	4b5a      	ldr	r3, [pc, #360]	; (6a18 <main+0x208>)
    68ae:	1c18      	adds	r0, r3, #0
    68b0:	c832      	ldmia	r0!, {r1, r4, r5}
    68b2:	c232      	stmia	r2!, {r1, r4, r5}
    68b4:	1c11      	adds	r1, r2, #0
    68b6:	8802      	ldrh	r2, [r0, #0]
    68b8:	800a      	strh	r2, [r1, #0]
	sprintf(topic, "%s%s", MAIN_MQTT_TOPIC,MAIN_MQTT_TOPIC_NAME);
    68ba:	a804      	add	r0, sp, #16
    68bc:	4957      	ldr	r1, [pc, #348]	; (6a1c <main+0x20c>)
    68be:	4a58      	ldr	r2, [pc, #352]	; (6a20 <main+0x210>)
    68c0:	4c58      	ldr	r4, [pc, #352]	; (6a24 <main+0x214>)
    68c2:	47a0      	blx	r4

	/* Initialize Wi-Fi parameters structure. */
	memset((uint8_t *)&param, 0, sizeof(tstrWifiInitParam));
    68c4:	2300      	movs	r3, #0
    68c6:	931f      	str	r3, [sp, #124]	; 0x7c
    68c8:	9320      	str	r3, [sp, #128]	; 0x80
    68ca:	9321      	str	r3, [sp, #132]	; 0x84
    68cc:	9322      	str	r3, [sp, #136]	; 0x88
    68ce:	9323      	str	r3, [sp, #140]	; 0x8c

	/* Initialize Wi-Fi driver with data and status callbacks. */
	param.pfAppWifiCb = wifi_callback; /* Set Wi-Fi event callback. */
    68d0:	4b55      	ldr	r3, [pc, #340]	; (6a28 <main+0x218>)
    68d2:	931e      	str	r3, [sp, #120]	; 0x78
	ret = m2m_wifi_init(&param);
    68d4:	a81e      	add	r0, sp, #120	; 0x78
    68d6:	4b55      	ldr	r3, [pc, #340]	; (6a2c <main+0x21c>)
    68d8:	4798      	blx	r3
	if (M2M_SUCCESS != ret) {
    68da:	2800      	cmp	r0, #0
    68dc:	d000      	beq.n	68e0 <main+0xd0>
		//printf("main: m2m_wifi_init call error!(%d)\r\n", ret);
		while (1) { /* Loop forever. */
		}
    68de:	e7fe      	b.n	68de <main+0xce>
	}

	/* Initialize socket interface. */
	socketInit();
    68e0:	4b53      	ldr	r3, [pc, #332]	; (6a30 <main+0x220>)
    68e2:	4798      	blx	r3
	registerSocketCallback(socket_event_handler, socket_resolve_handler);
    68e4:	4853      	ldr	r0, [pc, #332]	; (6a34 <main+0x224>)
    68e6:	4954      	ldr	r1, [pc, #336]	; (6a38 <main+0x228>)
    68e8:	4b54      	ldr	r3, [pc, #336]	; (6a3c <main+0x22c>)
    68ea:	4798      	blx	r3

	/* Connect to router. */
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID),
    68ec:	23ff      	movs	r3, #255	; 0xff
    68ee:	9300      	str	r3, [sp, #0]
    68f0:	4853      	ldr	r0, [pc, #332]	; (6a40 <main+0x230>)
    68f2:	2105      	movs	r1, #5
    68f4:	2202      	movs	r2, #2
    68f6:	4b53      	ldr	r3, [pc, #332]	; (6a44 <main+0x234>)
    68f8:	4c53      	ldr	r4, [pc, #332]	; (6a48 <main+0x238>)
    68fa:	47a0      	blx	r4
			MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);

	while (1) {
		/* Handle pending events from network controller. */
		m2m_wifi_handle_events(NULL);
    68fc:	4e53      	ldr	r6, [pc, #332]	; (6a4c <main+0x23c>)
		/* BLE Event Task */
		ble_event_task();
    68fe:	4d54      	ldr	r5, [pc, #336]	; (6a50 <main+0x240>)
		/* Checks the timer timeout. */
		sw_timer_task(&swt_module_inst);
    6900:	4c2f      	ldr	r4, [pc, #188]	; (69c0 <main+0x1b0>)
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID),
			MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);

	while (1) {
		/* Handle pending events from network controller. */
		m2m_wifi_handle_events(NULL);
    6902:	2000      	movs	r0, #0
    6904:	47b0      	blx	r6
		/* BLE Event Task */
		ble_event_task();
    6906:	47a8      	blx	r5
		/* Checks the timer timeout. */
		sw_timer_task(&swt_module_inst);
    6908:	1c20      	adds	r0, r4, #0
    690a:	4b52      	ldr	r3, [pc, #328]	; (6a54 <main+0x244>)
    690c:	4798      	blx	r3
		/* Checks the USART buffer. */
		if (timer_cb_done)
    690e:	4b52      	ldr	r3, [pc, #328]	; (6a58 <main+0x248>)
    6910:	781b      	ldrb	r3, [r3, #0]
    6912:	2b00      	cmp	r3, #0
    6914:	d0f5      	beq.n	6902 <main+0xf2>
		{
			timer_cb_done = false;
    6916:	2200      	movs	r2, #0
    6918:	4b4f      	ldr	r3, [pc, #316]	; (6a58 <main+0x248>)
    691a:	701a      	strb	r2, [r3, #0]
			/* send the notification and Update the battery level  */
			if(flag == true){
    691c:	4b4f      	ldr	r3, [pc, #316]	; (6a5c <main+0x24c>)
    691e:	781b      	ldrb	r3, [r3, #0]
    6920:	2b00      	cmp	r3, #0
    6922:	d027      	beq.n	6974 <main+0x164>
				ret_ble = bat_update_char_value(bat_connection_handle,&bas_service_handler, battery_level, &flag);
    6924:	4b4e      	ldr	r3, [pc, #312]	; (6a60 <main+0x250>)
    6926:	8818      	ldrh	r0, [r3, #0]
    6928:	2767      	movs	r7, #103	; 0x67
    692a:	ab02      	add	r3, sp, #8
    692c:	469c      	mov	ip, r3
    692e:	4467      	add	r7, ip
    6930:	9703      	str	r7, [sp, #12]
    6932:	783a      	ldrb	r2, [r7, #0]
    6934:	4930      	ldr	r1, [pc, #192]	; (69f8 <main+0x1e8>)
    6936:	4b49      	ldr	r3, [pc, #292]	; (6a5c <main+0x24c>)
    6938:	4f4a      	ldr	r7, [pc, #296]	; (6a64 <main+0x254>)
    693a:	47b8      	blx	r7
    693c:	4680      	mov	r8, r0
				sprintf((char*) msg, "%d",battery_level);
    693e:	9b03      	ldr	r3, [sp, #12]
    6940:	781a      	ldrb	r2, [r3, #0]
    6942:	a81c      	add	r0, sp, #112	; 0x70
    6944:	4948      	ldr	r1, [pc, #288]	; (6a68 <main+0x258>)
    6946:	4b37      	ldr	r3, [pc, #220]	; (6a24 <main+0x214>)
    6948:	4798      	blx	r3
				mqtt_publish(&mqtt_inst, topic, msg, strlen((char *)msg), 0, 0);
    694a:	a81c      	add	r0, sp, #112	; 0x70
    694c:	4b47      	ldr	r3, [pc, #284]	; (6a6c <main+0x25c>)
    694e:	4798      	blx	r3
    6950:	1c03      	adds	r3, r0, #0
    6952:	2200      	movs	r2, #0
    6954:	9200      	str	r2, [sp, #0]
    6956:	9201      	str	r2, [sp, #4]
    6958:	481e      	ldr	r0, [pc, #120]	; (69d4 <main+0x1c4>)
    695a:	a904      	add	r1, sp, #16
    695c:	aa1c      	add	r2, sp, #112	; 0x70
    695e:	4f44      	ldr	r7, [pc, #272]	; (6a70 <main+0x260>)
    6960:	47b8      	blx	r7
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Toggle pin output level */
	port_base->OUTTGL.reg = pin_mask;
    6962:	2280      	movs	r2, #128	; 0x80
    6964:	0412      	lsls	r2, r2, #16
    6966:	4b43      	ldr	r3, [pc, #268]	; (6a74 <main+0x264>)
    6968:	61da      	str	r2, [r3, #28]
				LED_Toggle(LED0);
				if (ret_ble == AT_BLE_SUCCESS) {
    696a:	4643      	mov	r3, r8
    696c:	2b00      	cmp	r3, #0
    696e:	d001      	beq.n	6974 <main+0x164>
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    6970:	4b40      	ldr	r3, [pc, #256]	; (6a74 <main+0x264>)
    6972:	619a      	str	r2, [r3, #24]
					} else {
					LED_Off(LED0);
					//printf("main: failed to send status report error!\r\n");
				}
			}
			if(battery_level == BATTERY_MAX_LEVEL)
    6974:	2367      	movs	r3, #103	; 0x67
    6976:	aa02      	add	r2, sp, #8
    6978:	4694      	mov	ip, r2
    697a:	4463      	add	r3, ip
    697c:	781b      	ldrb	r3, [r3, #0]
    697e:	2b64      	cmp	r3, #100	; 0x64
    6980:	d103      	bne.n	698a <main+0x17a>
			{
				battery_flag = false;
    6982:	2100      	movs	r1, #0
    6984:	4a3c      	ldr	r2, [pc, #240]	; (6a78 <main+0x268>)
    6986:	7011      	strb	r1, [r2, #0]
    6988:	e004      	b.n	6994 <main+0x184>
			}
			else if(battery_level == BATTERY_MIN_LEVEL)
    698a:	2b00      	cmp	r3, #0
    698c:	d102      	bne.n	6994 <main+0x184>
			{
				battery_flag = true;
    698e:	2101      	movs	r1, #1
    6990:	4a39      	ldr	r2, [pc, #228]	; (6a78 <main+0x268>)
    6992:	7011      	strb	r1, [r2, #0]
			}
			if(battery_flag)
    6994:	4a38      	ldr	r2, [pc, #224]	; (6a78 <main+0x268>)
    6996:	7812      	ldrb	r2, [r2, #0]
    6998:	2a00      	cmp	r2, #0
    699a:	d006      	beq.n	69aa <main+0x19a>
			{
				battery_level= battery_level+1;
    699c:	3301      	adds	r3, #1
    699e:	2267      	movs	r2, #103	; 0x67
    69a0:	a902      	add	r1, sp, #8
    69a2:	468c      	mov	ip, r1
    69a4:	4462      	add	r2, ip
    69a6:	7013      	strb	r3, [r2, #0]
    69a8:	e7ab      	b.n	6902 <main+0xf2>
			}
			else
			{
				battery_level= battery_level-1;
    69aa:	3b01      	subs	r3, #1
    69ac:	2267      	movs	r2, #103	; 0x67
    69ae:	a902      	add	r1, sp, #8
    69b0:	468c      	mov	ip, r1
    69b2:	4462      	add	r2, ip
    69b4:	7013      	strb	r3, [r2, #0]
    69b6:	e7a4      	b.n	6902 <main+0xf2>
    69b8:	00005b59 	.word	0x00005b59
    69bc:	00006461 	.word	0x00006461
    69c0:	20001754 	.word	0x20001754
    69c4:	0000646d 	.word	0x0000646d
    69c8:	00006519 	.word	0x00006519
    69cc:	0000b175 	.word	0x0000b175
    69d0:	20000218 	.word	0x20000218
    69d4:	200001a0 	.word	0x200001a0
    69d8:	0000b199 	.word	0x0000b199
    69dc:	000066e1 	.word	0x000066e1
    69e0:	0000b225 	.word	0x0000b225
    69e4:	00001525 	.word	0x00001525
    69e8:	000065fd 	.word	0x000065fd
    69ec:	000015a9 	.word	0x000015a9
    69f0:	00001ea5 	.word	0x00001ea5
    69f4:	00000b3d 	.word	0x00000b3d
    69f8:	200017ac 	.word	0x200017ac
    69fc:	00001ca1 	.word	0x00001ca1
    6a00:	00001d0d 	.word	0x00001d0d
    6a04:	000067a1 	.word	0x000067a1
    6a08:	0000ec60 	.word	0x0000ec60
    6a0c:	00000a6d 	.word	0x00000a6d
    6a10:	0000ecc0 	.word	0x0000ecc0
    6a14:	20000298 	.word	0x20000298
    6a18:	0000ed18 	.word	0x0000ed18
    6a1c:	0000ed28 	.word	0x0000ed28
    6a20:	0000ecfc 	.word	0x0000ecfc
    6a24:	0000da35 	.word	0x0000da35
    6a28:	00006645 	.word	0x00006645
    6a2c:	00002a55 	.word	0x00002a55
    6a30:	00003ca1 	.word	0x00003ca1
    6a34:	00006639 	.word	0x00006639
    6a38:	0000662d 	.word	0x0000662d
    6a3c:	00003ce5 	.word	0x00003ce5
    6a40:	0000ece8 	.word	0x0000ece8
    6a44:	0000ecf0 	.word	0x0000ecf0
    6a48:	00002c51 	.word	0x00002c51
    6a4c:	00002ac9 	.word	0x00002ac9
    6a50:	00001069 	.word	0x00001069
    6a54:	000065a5 	.word	0x000065a5
    6a58:	20000214 	.word	0x20000214
    6a5c:	20000021 	.word	0x20000021
    6a60:	20001750 	.word	0x20001750
    6a64:	00001d31 	.word	0x00001d31
    6a68:	0000ed30 	.word	0x0000ed30
    6a6c:	0000da9d 	.word	0x0000da9d
    6a70:	0000b64d 	.word	0x0000b64d
    6a74:	41004400 	.word	0x41004400
    6a78:	20000022 	.word	0x20000022

00006a7c <internal_event_post>:
    6a7c:	b570      	push	{r4, r5, r6, lr}
    6a7e:	4d0d      	ldr	r5, [pc, #52]	; (6ab4 <internal_event_post+0x38>)
    6a80:	682c      	ldr	r4, [r5, #0]
    6a82:	2c00      	cmp	r4, #0
    6a84:	d015      	beq.n	6ab2 <internal_event_post+0x36>
    6a86:	6826      	ldr	r6, [r4, #0]
    6a88:	60e2      	str	r2, [r4, #12]
    6a8a:	602e      	str	r6, [r5, #0]
    6a8c:	2500      	movs	r5, #0
    6a8e:	4a0a      	ldr	r2, [pc, #40]	; (6ab8 <internal_event_post+0x3c>)
    6a90:	8123      	strh	r3, [r4, #8]
    6a92:	6813      	ldr	r3, [r2, #0]
    6a94:	6025      	str	r5, [r4, #0]
    6a96:	80a0      	strh	r0, [r4, #4]
    6a98:	80e1      	strh	r1, [r4, #6]
    6a9a:	42ab      	cmp	r3, r5
    6a9c:	d101      	bne.n	6aa2 <internal_event_post+0x26>
    6a9e:	6014      	str	r4, [r2, #0]
    6aa0:	e005      	b.n	6aae <internal_event_post+0x32>
    6aa2:	681a      	ldr	r2, [r3, #0]
    6aa4:	2a00      	cmp	r2, #0
    6aa6:	d001      	beq.n	6aac <internal_event_post+0x30>
    6aa8:	1c13      	adds	r3, r2, #0
    6aaa:	e7fa      	b.n	6aa2 <internal_event_post+0x26>
    6aac:	601c      	str	r4, [r3, #0]
    6aae:	4b03      	ldr	r3, [pc, #12]	; (6abc <internal_event_post+0x40>)
    6ab0:	4798      	blx	r3
    6ab2:	bd70      	pop	{r4, r5, r6, pc}
    6ab4:	2000037c 	.word	0x2000037c
    6ab8:	20000378 	.word	0x20000378
    6abc:	00001abd 	.word	0x00001abd

00006ac0 <internal_event_init>:
    6ac0:	4b07      	ldr	r3, [pc, #28]	; (6ae0 <internal_event_init+0x20>)
    6ac2:	2200      	movs	r2, #0
    6ac4:	1c19      	adds	r1, r3, #0
    6ac6:	b510      	push	{r4, lr}
    6ac8:	6818      	ldr	r0, [r3, #0]
    6aca:	4b06      	ldr	r3, [pc, #24]	; (6ae4 <internal_event_init+0x24>)
    6acc:	189c      	adds	r4, r3, r2
    6ace:	50d0      	str	r0, [r2, r3]
    6ad0:	3210      	adds	r2, #16
    6ad2:	1c20      	adds	r0, r4, #0
    6ad4:	2aa0      	cmp	r2, #160	; 0xa0
    6ad6:	d1f8      	bne.n	6aca <internal_event_init+0xa>
    6ad8:	3390      	adds	r3, #144	; 0x90
    6ada:	600b      	str	r3, [r1, #0]
    6adc:	bd10      	pop	{r4, pc}
    6ade:	46c0      	nop			; (mov r8, r8)
    6ae0:	2000037c 	.word	0x2000037c
    6ae4:	200002d8 	.word	0x200002d8

00006ae8 <special_events_handler>:
    6ae8:	b538      	push	{r3, r4, r5, lr}
    6aea:	4c1b      	ldr	r4, [pc, #108]	; (6b58 <special_events_handler+0x70>)
    6aec:	1c03      	adds	r3, r0, #0
    6aee:	8825      	ldrh	r5, [r4, #0]
    6af0:	1c08      	adds	r0, r1, #0
    6af2:	1c21      	adds	r1, r4, #0
    6af4:	429d      	cmp	r5, r3
    6af6:	d107      	bne.n	6b08 <special_events_handler+0x20>
    6af8:	88a5      	ldrh	r5, [r4, #4]
    6afa:	4285      	cmp	r5, r0
    6afc:	d104      	bne.n	6b08 <special_events_handler+0x20>
    6afe:	2301      	movs	r3, #1
    6b00:	425b      	negs	r3, r3
    6b02:	8023      	strh	r3, [r4, #0]
    6b04:	60a2      	str	r2, [r4, #8]
    6b06:	e009      	b.n	6b1c <special_events_handler+0x34>
    6b08:	884c      	ldrh	r4, [r1, #2]
    6b0a:	429c      	cmp	r4, r3
    6b0c:	d10a      	bne.n	6b24 <special_events_handler+0x3c>
    6b0e:	888c      	ldrh	r4, [r1, #4]
    6b10:	4284      	cmp	r4, r0
    6b12:	d107      	bne.n	6b24 <special_events_handler+0x3c>
    6b14:	2301      	movs	r3, #1
    6b16:	425b      	negs	r3, r3
    6b18:	804b      	strh	r3, [r1, #2]
    6b1a:	608a      	str	r2, [r1, #8]
    6b1c:	4b0f      	ldr	r3, [pc, #60]	; (6b5c <special_events_handler+0x74>)
    6b1e:	4798      	blx	r3
    6b20:	2001      	movs	r0, #1
    6b22:	e017      	b.n	6b54 <special_events_handler+0x6c>
    6b24:	490e      	ldr	r1, [pc, #56]	; (6b60 <special_events_handler+0x78>)
    6b26:	428b      	cmp	r3, r1
    6b28:	d00e      	beq.n	6b48 <special_events_handler+0x60>
    6b2a:	490e      	ldr	r1, [pc, #56]	; (6b64 <special_events_handler+0x7c>)
    6b2c:	428b      	cmp	r3, r1
    6b2e:	d007      	beq.n	6b40 <special_events_handler+0x58>
    6b30:	490d      	ldr	r1, [pc, #52]	; (6b68 <special_events_handler+0x80>)
    6b32:	2000      	movs	r0, #0
    6b34:	428b      	cmp	r3, r1
    6b36:	d10d      	bne.n	6b54 <special_events_handler+0x6c>
    6b38:	1c10      	adds	r0, r2, #0
    6b3a:	4b0c      	ldr	r3, [pc, #48]	; (6b6c <special_events_handler+0x84>)
    6b3c:	4798      	blx	r3
    6b3e:	e7ef      	b.n	6b20 <special_events_handler+0x38>
    6b40:	1c11      	adds	r1, r2, #0
    6b42:	4b0b      	ldr	r3, [pc, #44]	; (6b70 <special_events_handler+0x88>)
    6b44:	2200      	movs	r2, #0
    6b46:	e002      	b.n	6b4e <special_events_handler+0x66>
    6b48:	1c11      	adds	r1, r2, #0
    6b4a:	2200      	movs	r2, #0
    6b4c:	4b09      	ldr	r3, [pc, #36]	; (6b74 <special_events_handler+0x8c>)
    6b4e:	4798      	blx	r3
    6b50:	4243      	negs	r3, r0
    6b52:	4158      	adcs	r0, r3
    6b54:	bd38      	pop	{r3, r4, r5, pc}
    6b56:	46c0      	nop			; (mov r8, r8)
    6b58:	200017fc 	.word	0x200017fc
    6b5c:	00001889 	.word	0x00001889
    6b60:	00000e13 	.word	0x00000e13
    6b64:	00000e15 	.word	0x00000e15
    6b68:	00000e01 	.word	0x00000e01
    6b6c:	00009019 	.word	0x00009019
    6b70:	000092c5 	.word	0x000092c5
    6b74:	0000939d 	.word	0x0000939d

00006b78 <at_ble_event_get>:
    6b78:	2300      	movs	r3, #0
    6b7a:	b5f0      	push	{r4, r5, r6, r7, lr}
    6b7c:	b087      	sub	sp, #28
    6b7e:	9204      	str	r2, [sp, #16]
    6b80:	7003      	strb	r3, [r0, #0]
    6b82:	9b04      	ldr	r3, [sp, #16]
    6b84:	9003      	str	r0, [sp, #12]
    6b86:	3b01      	subs	r3, #1
    6b88:	1c0d      	adds	r5, r1, #0
    6b8a:	9305      	str	r3, [sp, #20]
    6b8c:	3303      	adds	r3, #3
    6b8e:	d802      	bhi.n	6b96 <at_ble_event_get+0x1e>
    6b90:	9804      	ldr	r0, [sp, #16]
    6b92:	4bb6      	ldr	r3, [pc, #728]	; (6e6c <at_ble_event_get+0x2f4>)
    6b94:	4798      	blx	r3
    6b96:	2300      	movs	r3, #0
    6b98:	9302      	str	r3, [sp, #8]
    6b9a:	9b04      	ldr	r3, [sp, #16]
    6b9c:	4cb4      	ldr	r4, [pc, #720]	; (6e70 <at_ble_event_get+0x2f8>)
    6b9e:	3301      	adds	r3, #1
    6ba0:	d00b      	beq.n	6bba <at_ble_event_get+0x42>
    6ba2:	6823      	ldr	r3, [r4, #0]
    6ba4:	2b00      	cmp	r3, #0
    6ba6:	d111      	bne.n	6bcc <at_ble_event_get+0x54>
    6ba8:	9b02      	ldr	r3, [sp, #8]
    6baa:	2bd0      	cmp	r3, #208	; 0xd0
    6bac:	d100      	bne.n	6bb0 <at_ble_event_get+0x38>
    6bae:	e2a7      	b.n	7100 <at_ble_event_get+0x588>
    6bb0:	9804      	ldr	r0, [sp, #16]
    6bb2:	4bb0      	ldr	r3, [pc, #704]	; (6e74 <at_ble_event_get+0x2fc>)
    6bb4:	4798      	blx	r3
    6bb6:	9002      	str	r0, [sp, #8]
    6bb8:	e7f3      	b.n	6ba2 <at_ble_event_get+0x2a>
    6bba:	6823      	ldr	r3, [r4, #0]
    6bbc:	2b00      	cmp	r3, #0
    6bbe:	d105      	bne.n	6bcc <at_ble_event_get+0x54>
    6bc0:	2001      	movs	r0, #1
    6bc2:	4bac      	ldr	r3, [pc, #688]	; (6e74 <at_ble_event_get+0x2fc>)
    6bc4:	4240      	negs	r0, r0
    6bc6:	4798      	blx	r3
    6bc8:	9002      	str	r0, [sp, #8]
    6bca:	e7f6      	b.n	6bba <at_ble_event_get+0x42>
    6bcc:	9b02      	ldr	r3, [sp, #8]
    6bce:	2bd0      	cmp	r3, #208	; 0xd0
    6bd0:	d100      	bne.n	6bd4 <at_ble_event_get+0x5c>
    6bd2:	e295      	b.n	7100 <at_ble_event_get+0x588>
    6bd4:	6823      	ldr	r3, [r4, #0]
    6bd6:	681a      	ldr	r2, [r3, #0]
    6bd8:	68d9      	ldr	r1, [r3, #12]
    6bda:	6022      	str	r2, [r4, #0]
    6bdc:	88da      	ldrh	r2, [r3, #6]
    6bde:	9201      	str	r2, [sp, #4]
    6be0:	4aa5      	ldr	r2, [pc, #660]	; (6e78 <at_ble_event_get+0x300>)
    6be2:	889c      	ldrh	r4, [r3, #4]
    6be4:	6810      	ldr	r0, [r2, #0]
    6be6:	6013      	str	r3, [r2, #0]
    6be8:	6018      	str	r0, [r3, #0]
    6bea:	9b02      	ldr	r3, [sp, #8]
    6bec:	2b00      	cmp	r3, #0
    6bee:	d000      	beq.n	6bf2 <at_ble_event_get+0x7a>
    6bf0:	e273      	b.n	70da <at_ble_event_get+0x562>
    6bf2:	4ba2      	ldr	r3, [pc, #648]	; (6e7c <at_ble_event_get+0x304>)
    6bf4:	429c      	cmp	r4, r3
    6bf6:	d108      	bne.n	6c0a <at_ble_event_get+0x92>
    6bf8:	9b01      	ldr	r3, [sp, #4]
    6bfa:	42a3      	cmp	r3, r4
    6bfc:	d000      	beq.n	6c00 <at_ble_event_get+0x88>
    6bfe:	e25c      	b.n	70ba <at_ble_event_get+0x542>
    6c00:	2338      	movs	r3, #56	; 0x38
    6c02:	9a03      	ldr	r2, [sp, #12]
    6c04:	7013      	strb	r3, [r2, #0]
    6c06:	6029      	str	r1, [r5, #0]
    6c08:	e267      	b.n	70da <at_ble_event_get+0x562>
    6c0a:	9b01      	ldr	r3, [sp, #4]
    6c0c:	2bbb      	cmp	r3, #187	; 0xbb
    6c0e:	d125      	bne.n	6c5c <at_ble_event_get+0xe4>
    6c10:	2cbb      	cmp	r4, #187	; 0xbb
    6c12:	d123      	bne.n	6c5c <at_ble_event_get+0xe4>
    6c14:	466b      	mov	r3, sp
    6c16:	891b      	ldrh	r3, [r3, #8]
    6c18:	80ab      	strh	r3, [r5, #4]
    6c1a:	788b      	ldrb	r3, [r1, #2]
    6c1c:	784a      	ldrb	r2, [r1, #1]
    6c1e:	021b      	lsls	r3, r3, #8
    6c20:	78cc      	ldrb	r4, [r1, #3]
    6c22:	7908      	ldrb	r0, [r1, #4]
    6c24:	4313      	orrs	r3, r2
    6c26:	794a      	ldrb	r2, [r1, #5]
    6c28:	4995      	ldr	r1, [pc, #596]	; (6e80 <at_ble_event_get+0x308>)
    6c2a:	70ac      	strb	r4, [r5, #2]
    6c2c:	802b      	strh	r3, [r5, #0]
    6c2e:	428b      	cmp	r3, r1
    6c30:	d806      	bhi.n	6c40 <at_ble_event_get+0xc8>
    6c32:	4a94      	ldr	r2, [pc, #592]	; (6e84 <at_ble_event_get+0x30c>)
    6c34:	4293      	cmp	r3, r2
    6c36:	d20b      	bcs.n	6c50 <at_ble_event_get+0xd8>
    6c38:	4a93      	ldr	r2, [pc, #588]	; (6e88 <at_ble_event_get+0x310>)
    6c3a:	4293      	cmp	r3, r2
    6c3c:	d008      	beq.n	6c50 <at_ble_event_get+0xd8>
    6c3e:	e009      	b.n	6c54 <at_ble_event_get+0xdc>
    6c40:	4992      	ldr	r1, [pc, #584]	; (6e8c <at_ble_event_get+0x314>)
    6c42:	428b      	cmp	r3, r1
    6c44:	d106      	bne.n	6c54 <at_ble_event_get+0xdc>
    6c46:	0213      	lsls	r3, r2, #8
    6c48:	4303      	orrs	r3, r0
    6c4a:	80ab      	strh	r3, [r5, #4]
    6c4c:	2337      	movs	r3, #55	; 0x37
    6c4e:	e002      	b.n	6c56 <at_ble_event_get+0xde>
    6c50:	2336      	movs	r3, #54	; 0x36
    6c52:	e000      	b.n	6c56 <at_ble_event_get+0xde>
    6c54:	2300      	movs	r3, #0
    6c56:	9a03      	ldr	r2, [sp, #12]
    6c58:	7013      	strb	r3, [r2, #0]
    6c5a:	e23e      	b.n	70da <at_ble_event_get+0x562>
    6c5c:	4b8c      	ldr	r3, [pc, #560]	; (6e90 <at_ble_event_get+0x318>)
    6c5e:	429c      	cmp	r4, r3
    6c60:	d100      	bne.n	6c64 <at_ble_event_get+0xec>
    6c62:	e199      	b.n	6f98 <at_ble_event_get+0x420>
    6c64:	d900      	bls.n	6c68 <at_ble_event_get+0xf0>
    6c66:	e083      	b.n	6d70 <at_ble_event_get+0x1f8>
    6c68:	4b8a      	ldr	r3, [pc, #552]	; (6e94 <at_ble_event_get+0x31c>)
    6c6a:	429c      	cmp	r4, r3
    6c6c:	d100      	bne.n	6c70 <at_ble_event_get+0xf8>
    6c6e:	e1f4      	b.n	705a <at_ble_event_get+0x4e2>
    6c70:	d83c      	bhi.n	6cec <at_ble_event_get+0x174>
    6c72:	4b89      	ldr	r3, [pc, #548]	; (6e98 <at_ble_event_get+0x320>)
    6c74:	429c      	cmp	r4, r3
    6c76:	d100      	bne.n	6c7a <at_ble_event_get+0x102>
    6c78:	e1f3      	b.n	7062 <at_ble_event_get+0x4ea>
    6c7a:	d816      	bhi.n	6caa <at_ble_event_get+0x132>
    6c7c:	4b87      	ldr	r3, [pc, #540]	; (6e9c <at_ble_event_get+0x324>)
    6c7e:	429c      	cmp	r4, r3
    6c80:	d100      	bne.n	6c84 <at_ble_event_get+0x10c>
    6c82:	e1cc      	b.n	701e <at_ble_event_get+0x4a6>
    6c84:	d804      	bhi.n	6c90 <at_ble_event_get+0x118>
    6c86:	2638      	movs	r6, #56	; 0x38
    6c88:	42b4      	cmp	r4, r6
    6c8a:	d100      	bne.n	6c8e <at_ble_event_get+0x116>
    6c8c:	e223      	b.n	70d6 <at_ble_event_get+0x55e>
    6c8e:	e214      	b.n	70ba <at_ble_event_get+0x542>
    6c90:	4b83      	ldr	r3, [pc, #524]	; (6ea0 <at_ble_event_get+0x328>)
    6c92:	429c      	cmp	r4, r3
    6c94:	d100      	bne.n	6c98 <at_ble_event_get+0x120>
    6c96:	e1c8      	b.n	702a <at_ble_event_get+0x4b2>
    6c98:	33fe      	adds	r3, #254	; 0xfe
    6c9a:	33ff      	adds	r3, #255	; 0xff
    6c9c:	429c      	cmp	r4, r3
    6c9e:	d000      	beq.n	6ca2 <at_ble_event_get+0x12a>
    6ca0:	e20b      	b.n	70ba <at_ble_event_get+0x542>
    6ca2:	9801      	ldr	r0, [sp, #4]
    6ca4:	1c2a      	adds	r2, r5, #0
    6ca6:	4b7f      	ldr	r3, [pc, #508]	; (6ea4 <at_ble_event_get+0x32c>)
    6ca8:	e18b      	b.n	6fc2 <at_ble_event_get+0x44a>
    6caa:	4b7f      	ldr	r3, [pc, #508]	; (6ea8 <at_ble_event_get+0x330>)
    6cac:	429c      	cmp	r4, r3
    6cae:	d100      	bne.n	6cb2 <at_ble_event_get+0x13a>
    6cb0:	e1c7      	b.n	7042 <at_ble_event_get+0x4ca>
    6cb2:	d80d      	bhi.n	6cd0 <at_ble_event_get+0x158>
    6cb4:	4b7d      	ldr	r3, [pc, #500]	; (6eac <at_ble_event_get+0x334>)
    6cb6:	429c      	cmp	r4, r3
    6cb8:	d100      	bne.n	6cbc <at_ble_event_get+0x144>
    6cba:	e1bc      	b.n	7036 <at_ble_event_get+0x4be>
    6cbc:	4b7c      	ldr	r3, [pc, #496]	; (6eb0 <at_ble_event_get+0x338>)
    6cbe:	429c      	cmp	r4, r3
    6cc0:	d000      	beq.n	6cc4 <at_ble_event_get+0x14c>
    6cc2:	e1fa      	b.n	70ba <at_ble_event_get+0x542>
    6cc4:	9801      	ldr	r0, [sp, #4]
    6cc6:	1c2a      	adds	r2, r5, #0
    6cc8:	4b7a      	ldr	r3, [pc, #488]	; (6eb4 <at_ble_event_get+0x33c>)
    6cca:	4798      	blx	r3
    6ccc:	2614      	movs	r6, #20
    6cce:	e202      	b.n	70d6 <at_ble_event_get+0x55e>
    6cd0:	4b79      	ldr	r3, [pc, #484]	; (6eb8 <at_ble_event_get+0x340>)
    6cd2:	429c      	cmp	r4, r3
    6cd4:	d100      	bne.n	6cd8 <at_ble_event_get+0x160>
    6cd6:	e1ba      	b.n	704e <at_ble_event_get+0x4d6>
    6cd8:	4b78      	ldr	r3, [pc, #480]	; (6ebc <at_ble_event_get+0x344>)
    6cda:	429c      	cmp	r4, r3
    6cdc:	d000      	beq.n	6ce0 <at_ble_event_get+0x168>
    6cde:	e1ec      	b.n	70ba <at_ble_event_get+0x542>
    6ce0:	9801      	ldr	r0, [sp, #4]
    6ce2:	1c2a      	adds	r2, r5, #0
    6ce4:	4b76      	ldr	r3, [pc, #472]	; (6ec0 <at_ble_event_get+0x348>)
    6ce6:	4798      	blx	r3
    6ce8:	2618      	movs	r6, #24
    6cea:	e1f4      	b.n	70d6 <at_ble_event_get+0x55e>
    6cec:	4b75      	ldr	r3, [pc, #468]	; (6ec4 <at_ble_event_get+0x34c>)
    6cee:	429c      	cmp	r4, r3
    6cf0:	d100      	bne.n	6cf4 <at_ble_event_get+0x17c>
    6cf2:	e1c3      	b.n	707c <at_ble_event_get+0x504>
    6cf4:	d81e      	bhi.n	6d34 <at_ble_event_get+0x1bc>
    6cf6:	4b74      	ldr	r3, [pc, #464]	; (6ec8 <at_ble_event_get+0x350>)
    6cf8:	429c      	cmp	r4, r3
    6cfa:	d100      	bne.n	6cfe <at_ble_event_get+0x186>
    6cfc:	e1c5      	b.n	708a <at_ble_event_get+0x512>
    6cfe:	d80d      	bhi.n	6d1c <at_ble_event_get+0x1a4>
    6d00:	4b72      	ldr	r3, [pc, #456]	; (6ecc <at_ble_event_get+0x354>)
    6d02:	429c      	cmp	r4, r3
    6d04:	d000      	beq.n	6d08 <at_ble_event_get+0x190>
    6d06:	e1d8      	b.n	70ba <at_ble_event_get+0x542>
    6d08:	9801      	ldr	r0, [sp, #4]
    6d0a:	1c2a      	adds	r2, r5, #0
    6d0c:	4b70      	ldr	r3, [pc, #448]	; (6ed0 <at_ble_event_get+0x358>)
    6d0e:	4798      	blx	r3
    6d10:	88a9      	ldrh	r1, [r5, #4]
    6d12:	1c06      	adds	r6, r0, #0
    6d14:	4b6f      	ldr	r3, [pc, #444]	; (6ed4 <at_ble_event_get+0x35c>)
    6d16:	8828      	ldrh	r0, [r5, #0]
    6d18:	4798      	blx	r3
    6d1a:	e1dc      	b.n	70d6 <at_ble_event_get+0x55e>
    6d1c:	4b6e      	ldr	r3, [pc, #440]	; (6ed8 <at_ble_event_get+0x360>)
    6d1e:	429c      	cmp	r4, r3
    6d20:	d100      	bne.n	6d24 <at_ble_event_get+0x1ac>
    6d22:	e1a4      	b.n	706e <at_ble_event_get+0x4f6>
    6d24:	4b6d      	ldr	r3, [pc, #436]	; (6edc <at_ble_event_get+0x364>)
    6d26:	429c      	cmp	r4, r3
    6d28:	d000      	beq.n	6d2c <at_ble_event_get+0x1b4>
    6d2a:	e1c6      	b.n	70ba <at_ble_event_get+0x542>
    6d2c:	9801      	ldr	r0, [sp, #4]
    6d2e:	1c2a      	adds	r2, r5, #0
    6d30:	4b6b      	ldr	r3, [pc, #428]	; (6ee0 <at_ble_event_get+0x368>)
    6d32:	e146      	b.n	6fc2 <at_ble_event_get+0x44a>
    6d34:	4b6b      	ldr	r3, [pc, #428]	; (6ee4 <at_ble_event_get+0x36c>)
    6d36:	429c      	cmp	r4, r3
    6d38:	d100      	bne.n	6d3c <at_ble_event_get+0x1c4>
    6d3a:	e121      	b.n	6f80 <at_ble_event_get+0x408>
    6d3c:	d809      	bhi.n	6d52 <at_ble_event_get+0x1da>
    6d3e:	3b08      	subs	r3, #8
    6d40:	429c      	cmp	r4, r3
    6d42:	d100      	bne.n	6d46 <at_ble_event_get+0x1ce>
    6d44:	e118      	b.n	6f78 <at_ble_event_get+0x400>
    6d46:	4b68      	ldr	r3, [pc, #416]	; (6ee8 <at_ble_event_get+0x370>)
    6d48:	2639      	movs	r6, #57	; 0x39
    6d4a:	429c      	cmp	r4, r3
    6d4c:	d100      	bne.n	6d50 <at_ble_event_get+0x1d8>
    6d4e:	e1c2      	b.n	70d6 <at_ble_event_get+0x55e>
    6d50:	e1b3      	b.n	70ba <at_ble_event_get+0x542>
    6d52:	23d1      	movs	r3, #209	; 0xd1
    6d54:	011b      	lsls	r3, r3, #4
    6d56:	429c      	cmp	r4, r3
    6d58:	d100      	bne.n	6d5c <at_ble_event_get+0x1e4>
    6d5a:	e117      	b.n	6f8c <at_ble_event_get+0x414>
    6d5c:	4b63      	ldr	r3, [pc, #396]	; (6eec <at_ble_event_get+0x374>)
    6d5e:	429c      	cmp	r4, r3
    6d60:	d000      	beq.n	6d64 <at_ble_event_get+0x1ec>
    6d62:	e1aa      	b.n	70ba <at_ble_event_get+0x542>
    6d64:	1c08      	adds	r0, r1, #0
    6d66:	4b62      	ldr	r3, [pc, #392]	; (6ef0 <at_ble_event_get+0x378>)
    6d68:	1c29      	adds	r1, r5, #0
    6d6a:	4798      	blx	r3
    6d6c:	260f      	movs	r6, #15
    6d6e:	e1b2      	b.n	70d6 <at_ble_event_get+0x55e>
    6d70:	4b60      	ldr	r3, [pc, #384]	; (6ef4 <at_ble_event_get+0x37c>)
    6d72:	429c      	cmp	r4, r3
    6d74:	d100      	bne.n	6d78 <at_ble_event_get+0x200>
    6d76:	e12c      	b.n	6fd2 <at_ble_event_get+0x45a>
    6d78:	d83d      	bhi.n	6df6 <at_ble_event_get+0x27e>
    6d7a:	4b5f      	ldr	r3, [pc, #380]	; (6ef8 <at_ble_event_get+0x380>)
    6d7c:	429c      	cmp	r4, r3
    6d7e:	d100      	bne.n	6d82 <at_ble_event_get+0x20a>
    6d80:	e149      	b.n	7016 <at_ble_event_get+0x49e>
    6d82:	d819      	bhi.n	6db8 <at_ble_event_get+0x240>
    6d84:	4b5d      	ldr	r3, [pc, #372]	; (6efc <at_ble_event_get+0x384>)
    6d86:	429c      	cmp	r4, r3
    6d88:	d100      	bne.n	6d8c <at_ble_event_get+0x214>
    6d8a:	e111      	b.n	6fb0 <at_ble_event_get+0x438>
    6d8c:	d807      	bhi.n	6d9e <at_ble_event_get+0x226>
    6d8e:	3b03      	subs	r3, #3
    6d90:	429c      	cmp	r4, r3
    6d92:	d000      	beq.n	6d96 <at_ble_event_get+0x21e>
    6d94:	e191      	b.n	70ba <at_ble_event_get+0x542>
    6d96:	9801      	ldr	r0, [sp, #4]
    6d98:	1c2a      	adds	r2, r5, #0
    6d9a:	4b59      	ldr	r3, [pc, #356]	; (6f00 <at_ble_event_get+0x388>)
    6d9c:	e111      	b.n	6fc2 <at_ble_event_get+0x44a>
    6d9e:	4b59      	ldr	r3, [pc, #356]	; (6f04 <at_ble_event_get+0x38c>)
    6da0:	429c      	cmp	r4, r3
    6da2:	d100      	bne.n	6da6 <at_ble_event_get+0x22e>
    6da4:	e0fe      	b.n	6fa4 <at_ble_event_get+0x42c>
    6da6:	4b58      	ldr	r3, [pc, #352]	; (6f08 <at_ble_event_get+0x390>)
    6da8:	429c      	cmp	r4, r3
    6daa:	d000      	beq.n	6dae <at_ble_event_get+0x236>
    6dac:	e185      	b.n	70ba <at_ble_event_get+0x542>
    6dae:	9801      	ldr	r0, [sp, #4]
    6db0:	1c2a      	adds	r2, r5, #0
    6db2:	4b56      	ldr	r3, [pc, #344]	; (6f0c <at_ble_event_get+0x394>)
    6db4:	4798      	blx	r3
    6db6:	e166      	b.n	7086 <at_ble_event_get+0x50e>
    6db8:	4b55      	ldr	r3, [pc, #340]	; (6f10 <at_ble_event_get+0x398>)
    6dba:	429c      	cmp	r4, r3
    6dbc:	d100      	bne.n	6dc0 <at_ble_event_get+0x248>
    6dbe:	e0fd      	b.n	6fbc <at_ble_event_get+0x444>
    6dc0:	d80b      	bhi.n	6dda <at_ble_event_get+0x262>
    6dc2:	4b54      	ldr	r3, [pc, #336]	; (6f14 <at_ble_event_get+0x39c>)
    6dc4:	429c      	cmp	r4, r3
    6dc6:	d100      	bne.n	6dca <at_ble_event_get+0x252>
    6dc8:	e121      	b.n	700e <at_ble_event_get+0x496>
    6dca:	4b53      	ldr	r3, [pc, #332]	; (6f18 <at_ble_event_get+0x3a0>)
    6dcc:	429c      	cmp	r4, r3
    6dce:	d000      	beq.n	6dd2 <at_ble_event_get+0x25a>
    6dd0:	e173      	b.n	70ba <at_ble_event_get+0x542>
    6dd2:	9801      	ldr	r0, [sp, #4]
    6dd4:	1c2a      	adds	r2, r5, #0
    6dd6:	4b51      	ldr	r3, [pc, #324]	; (6f1c <at_ble_event_get+0x3a4>)
    6dd8:	e0f3      	b.n	6fc2 <at_ble_event_get+0x44a>
    6dda:	4b51      	ldr	r3, [pc, #324]	; (6f20 <at_ble_event_get+0x3a8>)
    6ddc:	429c      	cmp	r4, r3
    6dde:	d100      	bne.n	6de2 <at_ble_event_get+0x26a>
    6de0:	e0f1      	b.n	6fc6 <at_ble_event_get+0x44e>
    6de2:	4b50      	ldr	r3, [pc, #320]	; (6f24 <at_ble_event_get+0x3ac>)
    6de4:	429c      	cmp	r4, r3
    6de6:	d000      	beq.n	6dea <at_ble_event_get+0x272>
    6de8:	e167      	b.n	70ba <at_ble_event_get+0x542>
    6dea:	9801      	ldr	r0, [sp, #4]
    6dec:	1c2a      	adds	r2, r5, #0
    6dee:	4b4e      	ldr	r3, [pc, #312]	; (6f28 <at_ble_event_get+0x3b0>)
    6df0:	4798      	blx	r3
    6df2:	260e      	movs	r6, #14
    6df4:	e16f      	b.n	70d6 <at_ble_event_get+0x55e>
    6df6:	4b4d      	ldr	r3, [pc, #308]	; (6f2c <at_ble_event_get+0x3b4>)
    6df8:	429c      	cmp	r4, r3
    6dfa:	d100      	bne.n	6dfe <at_ble_event_get+0x286>
    6dfc:	e0fb      	b.n	6ff6 <at_ble_event_get+0x47e>
    6dfe:	d820      	bhi.n	6e42 <at_ble_event_get+0x2ca>
    6e00:	4b4b      	ldr	r3, [pc, #300]	; (6f30 <at_ble_event_get+0x3b8>)
    6e02:	429c      	cmp	r4, r3
    6e04:	d100      	bne.n	6e08 <at_ble_event_get+0x290>
    6e06:	e0fc      	b.n	7002 <at_ble_event_get+0x48a>
    6e08:	d80d      	bhi.n	6e26 <at_ble_event_get+0x2ae>
    6e0a:	4b4a      	ldr	r3, [pc, #296]	; (6f34 <at_ble_event_get+0x3bc>)
    6e0c:	429c      	cmp	r4, r3
    6e0e:	d100      	bne.n	6e12 <at_ble_event_get+0x29a>
    6e10:	e0e5      	b.n	6fde <at_ble_event_get+0x466>
    6e12:	4b49      	ldr	r3, [pc, #292]	; (6f38 <at_ble_event_get+0x3c0>)
    6e14:	429c      	cmp	r4, r3
    6e16:	d000      	beq.n	6e1a <at_ble_event_get+0x2a2>
    6e18:	e14f      	b.n	70ba <at_ble_event_get+0x542>
    6e1a:	9801      	ldr	r0, [sp, #4]
    6e1c:	1c2a      	adds	r2, r5, #0
    6e1e:	4b47      	ldr	r3, [pc, #284]	; (6f3c <at_ble_event_get+0x3c4>)
    6e20:	4798      	blx	r3
    6e22:	2612      	movs	r6, #18
    6e24:	e157      	b.n	70d6 <at_ble_event_get+0x55e>
    6e26:	4b46      	ldr	r3, [pc, #280]	; (6f40 <at_ble_event_get+0x3c8>)
    6e28:	429c      	cmp	r4, r3
    6e2a:	d100      	bne.n	6e2e <at_ble_event_get+0x2b6>
    6e2c:	e0dd      	b.n	6fea <at_ble_event_get+0x472>
    6e2e:	4b45      	ldr	r3, [pc, #276]	; (6f44 <at_ble_event_get+0x3cc>)
    6e30:	429c      	cmp	r4, r3
    6e32:	d000      	beq.n	6e36 <at_ble_event_get+0x2be>
    6e34:	e141      	b.n	70ba <at_ble_event_get+0x542>
    6e36:	1c08      	adds	r0, r1, #0
    6e38:	4b43      	ldr	r3, [pc, #268]	; (6f48 <at_ble_event_get+0x3d0>)
    6e3a:	1c29      	adds	r1, r5, #0
    6e3c:	4798      	blx	r3
    6e3e:	262a      	movs	r6, #42	; 0x2a
    6e40:	e149      	b.n	70d6 <at_ble_event_get+0x55e>
    6e42:	4b42      	ldr	r3, [pc, #264]	; (6f4c <at_ble_event_get+0x3d4>)
    6e44:	429c      	cmp	r4, r3
    6e46:	d100      	bne.n	6e4a <at_ble_event_get+0x2d2>
    6e48:	e12b      	b.n	70a2 <at_ble_event_get+0x52a>
    6e4a:	d900      	bls.n	6e4e <at_ble_event_get+0x2d6>
    6e4c:	e086      	b.n	6f5c <at_ble_event_get+0x3e4>
    6e4e:	4b40      	ldr	r3, [pc, #256]	; (6f50 <at_ble_event_get+0x3d8>)
    6e50:	429c      	cmp	r4, r3
    6e52:	d100      	bne.n	6e56 <at_ble_event_get+0x2de>
    6e54:	e11f      	b.n	7096 <at_ble_event_get+0x51e>
    6e56:	4b3f      	ldr	r3, [pc, #252]	; (6f54 <at_ble_event_get+0x3dc>)
    6e58:	429c      	cmp	r4, r3
    6e5a:	d000      	beq.n	6e5e <at_ble_event_get+0x2e6>
    6e5c:	e12d      	b.n	70ba <at_ble_event_get+0x542>
    6e5e:	9801      	ldr	r0, [sp, #4]
    6e60:	1c2a      	adds	r2, r5, #0
    6e62:	4b3d      	ldr	r3, [pc, #244]	; (6f58 <at_ble_event_get+0x3e0>)
    6e64:	4798      	blx	r3
    6e66:	2630      	movs	r6, #48	; 0x30
    6e68:	e135      	b.n	70d6 <at_ble_event_get+0x55e>
    6e6a:	46c0      	nop			; (mov r8, r8)
    6e6c:	0000189d 	.word	0x0000189d
    6e70:	20000378 	.word	0x20000378
    6e74:	00001ac9 	.word	0x00001ac9
    6e78:	2000037c 	.word	0x2000037c
    6e7c:	0000ffff 	.word	0x0000ffff
    6e80:	0000201e 	.word	0x0000201e
    6e84:	0000201d 	.word	0x0000201d
    6e88:	00000c03 	.word	0x00000c03
    6e8c:	0000201f 	.word	0x0000201f
    6e90:	00000d1c 	.word	0x00000d1c
    6e94:	00000c0c 	.word	0x00000c0c
    6e98:	00000c02 	.word	0x00000c02
    6e9c:	00000a02 	.word	0x00000a02
    6ea0:	00000a03 	.word	0x00000a03
    6ea4:	0000ab7d 	.word	0x0000ab7d
    6ea8:	00000c06 	.word	0x00000c06
    6eac:	00000c04 	.word	0x00000c04
    6eb0:	00000c05 	.word	0x00000c05
    6eb4:	0000aa69 	.word	0x0000aa69
    6eb8:	00000c07 	.word	0x00000c07
    6ebc:	00000c09 	.word	0x00000c09
    6ec0:	0000ac5d 	.word	0x0000ac5d
    6ec4:	00000c17 	.word	0x00000c17
    6ec8:	00000c12 	.word	0x00000c12
    6ecc:	00000c0d 	.word	0x00000c0d
    6ed0:	0000ab29 	.word	0x0000ab29
    6ed4:	0000a98d 	.word	0x0000a98d
    6ed8:	00000c13 	.word	0x00000c13
    6edc:	00000c15 	.word	0x00000c15
    6ee0:	00008035 	.word	0x00008035
    6ee4:	00000d08 	.word	0x00000d08
    6ee8:	00000d01 	.word	0x00000d01
    6eec:	00000d15 	.word	0x00000d15
    6ef0:	0000a5f5 	.word	0x0000a5f5
    6ef4:	00000e1b 	.word	0x00000e1b
    6ef8:	00000e0f 	.word	0x00000e0f
    6efc:	00000e03 	.word	0x00000e03
    6f00:	00008d7d 	.word	0x00008d7d
    6f04:	00000e06 	.word	0x00000e06
    6f08:	00000e0a 	.word	0x00000e0a
    6f0c:	00009a7d 	.word	0x00009a7d
    6f10:	00000e15 	.word	0x00000e15
    6f14:	00000e11 	.word	0x00000e11
    6f18:	00000e13 	.word	0x00000e13
    6f1c:	0000939d 	.word	0x0000939d
    6f20:	00000e17 	.word	0x00000e17
    6f24:	00000e19 	.word	0x00000e19
    6f28:	00009951 	.word	0x00009951
    6f2c:	00000e27 	.word	0x00000e27
    6f30:	00000e21 	.word	0x00000e21
    6f34:	00000e1c 	.word	0x00000e1c
    6f38:	00000e1d 	.word	0x00000e1d
    6f3c:	00009b9d 	.word	0x00009b9d
    6f40:	00000e22 	.word	0x00000e22
    6f44:	00000e25 	.word	0x00000e25
    6f48:	00009c23 	.word	0x00009c23
    6f4c:	00001b05 	.word	0x00001b05
    6f50:	00001b01 	.word	0x00001b01
    6f54:	00001b03 	.word	0x00001b03
    6f58:	0000b0a3 	.word	0x0000b0a3
    6f5c:	4b6b      	ldr	r3, [pc, #428]	; (710c <at_ble_event_get+0x594>)
    6f5e:	429c      	cmp	r4, r3
    6f60:	d100      	bne.n	6f64 <at_ble_event_get+0x3ec>
    6f62:	e0a4      	b.n	70ae <at_ble_event_get+0x536>
    6f64:	4b6a      	ldr	r3, [pc, #424]	; (7110 <at_ble_event_get+0x598>)
    6f66:	429c      	cmp	r4, r3
    6f68:	d000      	beq.n	6f6c <at_ble_event_get+0x3f4>
    6f6a:	e0a6      	b.n	70ba <at_ble_event_get+0x542>
    6f6c:	9801      	ldr	r0, [sp, #4]
    6f6e:	1c2a      	adds	r2, r5, #0
    6f70:	4b68      	ldr	r3, [pc, #416]	; (7114 <at_ble_event_get+0x59c>)
    6f72:	4798      	blx	r3
    6f74:	2632      	movs	r6, #50	; 0x32
    6f76:	e0ae      	b.n	70d6 <at_ble_event_get+0x55e>
    6f78:	1c08      	adds	r0, r1, #0
    6f7a:	4b67      	ldr	r3, [pc, #412]	; (7118 <at_ble_event_get+0x5a0>)
    6f7c:	1c29      	adds	r1, r5, #0
    6f7e:	e00e      	b.n	6f9e <at_ble_event_get+0x426>
    6f80:	1c08      	adds	r0, r1, #0
    6f82:	4b66      	ldr	r3, [pc, #408]	; (711c <at_ble_event_get+0x5a4>)
    6f84:	1c29      	adds	r1, r5, #0
    6f86:	4798      	blx	r3
    6f88:	2604      	movs	r6, #4
    6f8a:	e0a4      	b.n	70d6 <at_ble_event_get+0x55e>
    6f8c:	1c08      	adds	r0, r1, #0
    6f8e:	4b64      	ldr	r3, [pc, #400]	; (7120 <at_ble_event_get+0x5a8>)
    6f90:	1c29      	adds	r1, r5, #0
    6f92:	4798      	blx	r3
    6f94:	2601      	movs	r6, #1
    6f96:	e09e      	b.n	70d6 <at_ble_event_get+0x55e>
    6f98:	1c08      	adds	r0, r1, #0
    6f9a:	1c29      	adds	r1, r5, #0
    6f9c:	4b61      	ldr	r3, [pc, #388]	; (7124 <at_ble_event_get+0x5ac>)
    6f9e:	4798      	blx	r3
    6fa0:	1c06      	adds	r6, r0, #0
    6fa2:	e098      	b.n	70d6 <at_ble_event_get+0x55e>
    6fa4:	9801      	ldr	r0, [sp, #4]
    6fa6:	1c2a      	adds	r2, r5, #0
    6fa8:	4b5f      	ldr	r3, [pc, #380]	; (7128 <at_ble_event_get+0x5b0>)
    6faa:	4798      	blx	r3
    6fac:	2611      	movs	r6, #17
    6fae:	e092      	b.n	70d6 <at_ble_event_get+0x55e>
    6fb0:	1c08      	adds	r0, r1, #0
    6fb2:	4b5e      	ldr	r3, [pc, #376]	; (712c <at_ble_event_get+0x5b4>)
    6fb4:	1c29      	adds	r1, r5, #0
    6fb6:	4798      	blx	r3
    6fb8:	2606      	movs	r6, #6
    6fba:	e08c      	b.n	70d6 <at_ble_event_get+0x55e>
    6fbc:	1c2a      	adds	r2, r5, #0
    6fbe:	9801      	ldr	r0, [sp, #4]
    6fc0:	4b5b      	ldr	r3, [pc, #364]	; (7130 <at_ble_event_get+0x5b8>)
    6fc2:	4798      	blx	r3
    6fc4:	e7ec      	b.n	6fa0 <at_ble_event_get+0x428>
    6fc6:	9801      	ldr	r0, [sp, #4]
    6fc8:	1c2a      	adds	r2, r5, #0
    6fca:	4b5a      	ldr	r3, [pc, #360]	; (7134 <at_ble_event_get+0x5bc>)
    6fcc:	4798      	blx	r3
    6fce:	260d      	movs	r6, #13
    6fd0:	e081      	b.n	70d6 <at_ble_event_get+0x55e>
    6fd2:	9801      	ldr	r0, [sp, #4]
    6fd4:	1c2a      	adds	r2, r5, #0
    6fd6:	4b58      	ldr	r3, [pc, #352]	; (7138 <at_ble_event_get+0x5c0>)
    6fd8:	4798      	blx	r3
    6fda:	260b      	movs	r6, #11
    6fdc:	e07b      	b.n	70d6 <at_ble_event_get+0x55e>
    6fde:	9801      	ldr	r0, [sp, #4]
    6fe0:	1c2a      	adds	r2, r5, #0
    6fe2:	4b56      	ldr	r3, [pc, #344]	; (713c <at_ble_event_get+0x5c4>)
    6fe4:	4798      	blx	r3
    6fe6:	2610      	movs	r6, #16
    6fe8:	e075      	b.n	70d6 <at_ble_event_get+0x55e>
    6fea:	1c08      	adds	r0, r1, #0
    6fec:	4b54      	ldr	r3, [pc, #336]	; (7140 <at_ble_event_get+0x5c8>)
    6fee:	1c29      	adds	r1, r5, #0
    6ff0:	4798      	blx	r3
    6ff2:	2628      	movs	r6, #40	; 0x28
    6ff4:	e06f      	b.n	70d6 <at_ble_event_get+0x55e>
    6ff6:	1c08      	adds	r0, r1, #0
    6ff8:	4b52      	ldr	r3, [pc, #328]	; (7144 <at_ble_event_get+0x5cc>)
    6ffa:	1c29      	adds	r1, r5, #0
    6ffc:	4798      	blx	r3
    6ffe:	2629      	movs	r6, #41	; 0x29
    7000:	e069      	b.n	70d6 <at_ble_event_get+0x55e>
    7002:	1c08      	adds	r0, r1, #0
    7004:	4b50      	ldr	r3, [pc, #320]	; (7148 <at_ble_event_get+0x5d0>)
    7006:	1c29      	adds	r1, r5, #0
    7008:	4798      	blx	r3
    700a:	2627      	movs	r6, #39	; 0x27
    700c:	e063      	b.n	70d6 <at_ble_event_get+0x55e>
    700e:	9801      	ldr	r0, [sp, #4]
    7010:	1c2a      	adds	r2, r5, #0
    7012:	4b4e      	ldr	r3, [pc, #312]	; (714c <at_ble_event_get+0x5d4>)
    7014:	e7d5      	b.n	6fc2 <at_ble_event_get+0x44a>
    7016:	9801      	ldr	r0, [sp, #4]
    7018:	1c2a      	adds	r2, r5, #0
    701a:	4b4d      	ldr	r3, [pc, #308]	; (7150 <at_ble_event_get+0x5d8>)
    701c:	e7d1      	b.n	6fc2 <at_ble_event_get+0x44a>
    701e:	1c08      	adds	r0, r1, #0
    7020:	4b4c      	ldr	r3, [pc, #304]	; (7154 <at_ble_event_get+0x5dc>)
    7022:	1c29      	adds	r1, r5, #0
    7024:	4798      	blx	r3
    7026:	262b      	movs	r6, #43	; 0x2b
    7028:	e055      	b.n	70d6 <at_ble_event_get+0x55e>
    702a:	1c08      	adds	r0, r1, #0
    702c:	4b4a      	ldr	r3, [pc, #296]	; (7158 <at_ble_event_get+0x5e0>)
    702e:	1c29      	adds	r1, r5, #0
    7030:	4798      	blx	r3
    7032:	262c      	movs	r6, #44	; 0x2c
    7034:	e04f      	b.n	70d6 <at_ble_event_get+0x55e>
    7036:	9801      	ldr	r0, [sp, #4]
    7038:	1c2a      	adds	r2, r5, #0
    703a:	4b48      	ldr	r3, [pc, #288]	; (715c <at_ble_event_get+0x5e4>)
    703c:	4798      	blx	r3
    703e:	2613      	movs	r6, #19
    7040:	e049      	b.n	70d6 <at_ble_event_get+0x55e>
    7042:	9801      	ldr	r0, [sp, #4]
    7044:	1c2a      	adds	r2, r5, #0
    7046:	4b46      	ldr	r3, [pc, #280]	; (7160 <at_ble_event_get+0x5e8>)
    7048:	4798      	blx	r3
    704a:	2615      	movs	r6, #21
    704c:	e043      	b.n	70d6 <at_ble_event_get+0x55e>
    704e:	9801      	ldr	r0, [sp, #4]
    7050:	1c2a      	adds	r2, r5, #0
    7052:	4b44      	ldr	r3, [pc, #272]	; (7164 <at_ble_event_get+0x5ec>)
    7054:	4798      	blx	r3
    7056:	2616      	movs	r6, #22
    7058:	e03d      	b.n	70d6 <at_ble_event_get+0x55e>
    705a:	9801      	ldr	r0, [sp, #4]
    705c:	1c2a      	adds	r2, r5, #0
    705e:	4b42      	ldr	r3, [pc, #264]	; (7168 <at_ble_event_get+0x5f0>)
    7060:	e7af      	b.n	6fc2 <at_ble_event_get+0x44a>
    7062:	9801      	ldr	r0, [sp, #4]
    7064:	1c2a      	adds	r2, r5, #0
    7066:	4b41      	ldr	r3, [pc, #260]	; (716c <at_ble_event_get+0x5f4>)
    7068:	4798      	blx	r3
    706a:	2623      	movs	r6, #35	; 0x23
    706c:	e033      	b.n	70d6 <at_ble_event_get+0x55e>
    706e:	9b01      	ldr	r3, [sp, #4]
    7070:	1c08      	adds	r0, r1, #0
    7072:	0a1f      	lsrs	r7, r3, #8
    7074:	802f      	strh	r7, [r5, #0]
    7076:	1c29      	adds	r1, r5, #0
    7078:	4b3d      	ldr	r3, [pc, #244]	; (7170 <at_ble_event_get+0x5f8>)
    707a:	e790      	b.n	6f9e <at_ble_event_get+0x426>
    707c:	1c08      	adds	r0, r1, #0
    707e:	9a01      	ldr	r2, [sp, #4]
    7080:	1c29      	adds	r1, r5, #0
    7082:	4b3c      	ldr	r3, [pc, #240]	; (7174 <at_ble_event_get+0x5fc>)
    7084:	4798      	blx	r3
    7086:	263a      	movs	r6, #58	; 0x3a
    7088:	e025      	b.n	70d6 <at_ble_event_get+0x55e>
    708a:	9801      	ldr	r0, [sp, #4]
    708c:	1c2a      	adds	r2, r5, #0
    708e:	4b3a      	ldr	r3, [pc, #232]	; (7178 <at_ble_event_get+0x600>)
    7090:	4798      	blx	r3
    7092:	2620      	movs	r6, #32
    7094:	e01f      	b.n	70d6 <at_ble_event_get+0x55e>
    7096:	9801      	ldr	r0, [sp, #4]
    7098:	1c2a      	adds	r2, r5, #0
    709a:	4b38      	ldr	r3, [pc, #224]	; (717c <at_ble_event_get+0x604>)
    709c:	4798      	blx	r3
    709e:	2633      	movs	r6, #51	; 0x33
    70a0:	e019      	b.n	70d6 <at_ble_event_get+0x55e>
    70a2:	9801      	ldr	r0, [sp, #4]
    70a4:	1c2a      	adds	r2, r5, #0
    70a6:	4b36      	ldr	r3, [pc, #216]	; (7180 <at_ble_event_get+0x608>)
    70a8:	4798      	blx	r3
    70aa:	2634      	movs	r6, #52	; 0x34
    70ac:	e013      	b.n	70d6 <at_ble_event_get+0x55e>
    70ae:	9801      	ldr	r0, [sp, #4]
    70b0:	1c2a      	adds	r2, r5, #0
    70b2:	4b34      	ldr	r3, [pc, #208]	; (7184 <at_ble_event_get+0x60c>)
    70b4:	4798      	blx	r3
    70b6:	2635      	movs	r6, #53	; 0x35
    70b8:	e00d      	b.n	70d6 <at_ble_event_get+0x55e>
    70ba:	22b6      	movs	r2, #182	; 0xb6
    70bc:	4e32      	ldr	r6, [pc, #200]	; (7188 <at_ble_event_get+0x610>)
    70be:	4933      	ldr	r1, [pc, #204]	; (718c <at_ble_event_get+0x614>)
    70c0:	32ff      	adds	r2, #255	; 0xff
    70c2:	4b33      	ldr	r3, [pc, #204]	; (7190 <at_ble_event_get+0x618>)
    70c4:	6837      	ldr	r7, [r6, #0]
    70c6:	4833      	ldr	r0, [pc, #204]	; (7194 <at_ble_event_get+0x61c>)
    70c8:	47b8      	blx	r7
    70ca:	6833      	ldr	r3, [r6, #0]
    70cc:	4832      	ldr	r0, [pc, #200]	; (7198 <at_ble_event_get+0x620>)
    70ce:	9901      	ldr	r1, [sp, #4]
    70d0:	1c22      	adds	r2, r4, #0
    70d2:	4798      	blx	r3
    70d4:	2600      	movs	r6, #0
    70d6:	9b03      	ldr	r3, [sp, #12]
    70d8:	701e      	strb	r6, [r3, #0]
    70da:	9b03      	ldr	r3, [sp, #12]
    70dc:	781b      	ldrb	r3, [r3, #0]
    70de:	2b3a      	cmp	r3, #58	; 0x3a
    70e0:	d003      	beq.n	70ea <at_ble_event_get+0x572>
    70e2:	9b05      	ldr	r3, [sp, #20]
    70e4:	3303      	adds	r3, #3
    70e6:	d905      	bls.n	70f4 <at_ble_event_get+0x57c>
    70e8:	e00d      	b.n	7106 <at_ble_event_get+0x58e>
    70ea:	9b02      	ldr	r3, [sp, #8]
    70ec:	2b00      	cmp	r3, #0
    70ee:	d100      	bne.n	70f2 <at_ble_event_get+0x57a>
    70f0:	e551      	b.n	6b96 <at_ble_event_get+0x1e>
    70f2:	e7f6      	b.n	70e2 <at_ble_event_get+0x56a>
    70f4:	9b02      	ldr	r3, [sp, #8]
    70f6:	2bd0      	cmp	r3, #208	; 0xd0
    70f8:	d005      	beq.n	7106 <at_ble_event_get+0x58e>
    70fa:	4b28      	ldr	r3, [pc, #160]	; (719c <at_ble_event_get+0x624>)
    70fc:	4798      	blx	r3
    70fe:	e002      	b.n	7106 <at_ble_event_get+0x58e>
    7100:	23d0      	movs	r3, #208	; 0xd0
    7102:	9302      	str	r3, [sp, #8]
    7104:	e7e9      	b.n	70da <at_ble_event_get+0x562>
    7106:	9802      	ldr	r0, [sp, #8]
    7108:	b007      	add	sp, #28
    710a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    710c:	00001b06 	.word	0x00001b06
    7110:	00001b08 	.word	0x00001b08
    7114:	0000b0bb 	.word	0x0000b0bb
    7118:	0000a165 	.word	0x0000a165
    711c:	0000a149 	.word	0x0000a149
    7120:	0000a4a9 	.word	0x0000a4a9
    7124:	0000a619 	.word	0x0000a619
    7128:	00009b21 	.word	0x00009b21
    712c:	0000919d 	.word	0x0000919d
    7130:	000092c5 	.word	0x000092c5
    7134:	00009851 	.word	0x00009851
    7138:	00009ad5 	.word	0x00009ad5
    713c:	00009aeb 	.word	0x00009aeb
    7140:	00009bb5 	.word	0x00009bb5
    7144:	00009be3 	.word	0x00009be3
    7148:	00009bf9 	.word	0x00009bf9
    714c:	00009a21 	.word	0x00009a21
    7150:	00009a4b 	.word	0x00009a4b
    7154:	000080d9 	.word	0x000080d9
    7158:	00008105 	.word	0x00008105
    715c:	0000aa2d 	.word	0x0000aa2d
    7160:	0000aab1 	.word	0x0000aab1
    7164:	0000aaf5 	.word	0x0000aaf5
    7168:	0000ab29 	.word	0x0000ab29
    716c:	0000ac4d 	.word	0x0000ac4d
    7170:	00007fc9 	.word	0x00007fc9
    7174:	00007ff9 	.word	0x00007ff9
    7178:	0000ac9d 	.word	0x0000ac9d
    717c:	0000b099 	.word	0x0000b099
    7180:	0000b0a9 	.word	0x0000b0a9
    7184:	0000b0af 	.word	0x0000b0af
    7188:	20000038 	.word	0x20000038
    718c:	0000ed51 	.word	0x0000ed51
    7190:	0000edc1 	.word	0x0000edc1
    7194:	0000ed34 	.word	0x0000ed34
    7198:	0000ed97 	.word	0x0000ed97
    719c:	00001b89 	.word	0x00001b89

000071a0 <internal_event_flush>:
    71a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    71a2:	490e      	ldr	r1, [pc, #56]	; (71dc <internal_event_flush+0x3c>)
    71a4:	2400      	movs	r4, #0
    71a6:	680b      	ldr	r3, [r1, #0]
    71a8:	1c0f      	adds	r7, r1, #0
    71aa:	1c1e      	adds	r6, r3, #0
    71ac:	4a0c      	ldr	r2, [pc, #48]	; (71e0 <internal_event_flush+0x40>)
    71ae:	6815      	ldr	r5, [r2, #0]
    71b0:	9201      	str	r2, [sp, #4]
    71b2:	2b00      	cmp	r3, #0
    71b4:	d00e      	beq.n	71d4 <internal_event_flush+0x34>
    71b6:	889a      	ldrh	r2, [r3, #4]
    71b8:	6819      	ldr	r1, [r3, #0]
    71ba:	4282      	cmp	r2, r0
    71bc:	d107      	bne.n	71ce <internal_event_flush+0x2e>
    71be:	2c00      	cmp	r4, #0
    71c0:	d001      	beq.n	71c6 <internal_event_flush+0x26>
    71c2:	6021      	str	r1, [r4, #0]
    71c4:	e000      	b.n	71c8 <internal_event_flush+0x28>
    71c6:	1c0e      	adds	r6, r1, #0
    71c8:	601d      	str	r5, [r3, #0]
    71ca:	1c1d      	adds	r5, r3, #0
    71cc:	1c23      	adds	r3, r4, #0
    71ce:	1c1c      	adds	r4, r3, #0
    71d0:	1c0b      	adds	r3, r1, #0
    71d2:	e7ee      	b.n	71b2 <internal_event_flush+0x12>
    71d4:	9b01      	ldr	r3, [sp, #4]
    71d6:	603e      	str	r6, [r7, #0]
    71d8:	601d      	str	r5, [r3, #0]
    71da:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    71dc:	20000378 	.word	0x20000378
    71e0:	2000037c 	.word	0x2000037c

000071e4 <internal_conn_flush>:
    71e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    71e6:	4a12      	ldr	r2, [pc, #72]	; (7230 <internal_conn_flush+0x4c>)
    71e8:	9000      	str	r0, [sp, #0]
    71ea:	6813      	ldr	r3, [r2, #0]
    71ec:	4811      	ldr	r0, [pc, #68]	; (7234 <internal_conn_flush+0x50>)
    71ee:	1c1f      	adds	r7, r3, #0
    71f0:	2100      	movs	r1, #0
    71f2:	4684      	mov	ip, r0
    71f4:	6804      	ldr	r4, [r0, #0]
    71f6:	9201      	str	r2, [sp, #4]
    71f8:	2b00      	cmp	r3, #0
    71fa:	d014      	beq.n	7226 <internal_conn_flush+0x42>
    71fc:	88d8      	ldrh	r0, [r3, #6]
    71fe:	9a00      	ldr	r2, [sp, #0]
    7200:	681d      	ldr	r5, [r3, #0]
    7202:	0a06      	lsrs	r6, r0, #8
    7204:	4296      	cmp	r6, r2
    7206:	d10b      	bne.n	7220 <internal_conn_flush+0x3c>
    7208:	26fd      	movs	r6, #253	; 0xfd
    720a:	4006      	ands	r6, r0
    720c:	2e0c      	cmp	r6, #12
    720e:	d107      	bne.n	7220 <internal_conn_flush+0x3c>
    7210:	2900      	cmp	r1, #0
    7212:	d001      	beq.n	7218 <internal_conn_flush+0x34>
    7214:	600d      	str	r5, [r1, #0]
    7216:	e000      	b.n	721a <internal_conn_flush+0x36>
    7218:	1c2f      	adds	r7, r5, #0
    721a:	601c      	str	r4, [r3, #0]
    721c:	1c1c      	adds	r4, r3, #0
    721e:	1c0b      	adds	r3, r1, #0
    7220:	1c19      	adds	r1, r3, #0
    7222:	1c2b      	adds	r3, r5, #0
    7224:	e7e8      	b.n	71f8 <internal_conn_flush+0x14>
    7226:	9b01      	ldr	r3, [sp, #4]
    7228:	601f      	str	r7, [r3, #0]
    722a:	4663      	mov	r3, ip
    722c:	601c      	str	r4, [r3, #0]
    722e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    7230:	20000378 	.word	0x20000378
    7234:	2000037c 	.word	0x2000037c

00007238 <at_ble_device_name_set>:
    7238:	b538      	push	{r3, r4, r5, lr}
    723a:	2800      	cmp	r0, #0
    723c:	d002      	beq.n	7244 <at_ble_device_name_set+0xc>
    723e:	1e4b      	subs	r3, r1, #1
    7240:	2b1f      	cmp	r3, #31
    7242:	d90c      	bls.n	725e <at_ble_device_name_set+0x26>
    7244:	2291      	movs	r2, #145	; 0x91
    7246:	4c0d      	ldr	r4, [pc, #52]	; (727c <at_ble_device_name_set+0x44>)
    7248:	490d      	ldr	r1, [pc, #52]	; (7280 <at_ble_device_name_set+0x48>)
    724a:	0052      	lsls	r2, r2, #1
    724c:	4b0d      	ldr	r3, [pc, #52]	; (7284 <at_ble_device_name_set+0x4c>)
    724e:	480e      	ldr	r0, [pc, #56]	; (7288 <at_ble_device_name_set+0x50>)
    7250:	6825      	ldr	r5, [r4, #0]
    7252:	47a8      	blx	r5
    7254:	6823      	ldr	r3, [r4, #0]
    7256:	480d      	ldr	r0, [pc, #52]	; (728c <at_ble_device_name_set+0x54>)
    7258:	4798      	blx	r3
    725a:	20cf      	movs	r0, #207	; 0xcf
    725c:	e00d      	b.n	727a <at_ble_device_name_set+0x42>
    725e:	4a0c      	ldr	r2, [pc, #48]	; (7290 <at_ble_device_name_set+0x58>)
    7260:	1c13      	adds	r3, r2, #0
    7262:	33aa      	adds	r3, #170	; 0xaa
    7264:	8019      	strh	r1, [r3, #0]
    7266:	2300      	movs	r3, #0
    7268:	1c1c      	adds	r4, r3, #0
    726a:	5cc5      	ldrb	r5, [r0, r3]
    726c:	34ac      	adds	r4, #172	; 0xac
    726e:	3301      	adds	r3, #1
    7270:	5515      	strb	r5, [r2, r4]
    7272:	b2dc      	uxtb	r4, r3
    7274:	428c      	cmp	r4, r1
    7276:	d3f7      	bcc.n	7268 <at_ble_device_name_set+0x30>
    7278:	2000      	movs	r0, #0
    727a:	bd38      	pop	{r3, r4, r5, pc}
    727c:	20000038 	.word	0x20000038
    7280:	0000ee0c 	.word	0x0000ee0c
    7284:	0000f098 	.word	0x0000f098
    7288:	0000ed34 	.word	0x0000ed34
    728c:	0000ee7a 	.word	0x0000ee7a
    7290:	20001898 	.word	0x20001898

00007294 <at_ble_addr_get>:
    7294:	b510      	push	{r4, lr}
    7296:	1c04      	adds	r4, r0, #0
    7298:	20cf      	movs	r0, #207	; 0xcf
    729a:	2c00      	cmp	r4, #0
    729c:	d006      	beq.n	72ac <at_ble_addr_get+0x18>
    729e:	4b04      	ldr	r3, [pc, #16]	; (72b0 <at_ble_addr_get+0x1c>)
    72a0:	38ce      	subs	r0, #206	; 0xce
    72a2:	1c21      	adds	r1, r4, #0
    72a4:	4798      	blx	r3
    72a6:	4b03      	ldr	r3, [pc, #12]	; (72b4 <at_ble_addr_get+0x20>)
    72a8:	791b      	ldrb	r3, [r3, #4]
    72aa:	7023      	strb	r3, [r4, #0]
    72ac:	bd10      	pop	{r4, pc}
    72ae:	46c0      	nop			; (mov r8, r8)
    72b0:	00009ef1 	.word	0x00009ef1
    72b4:	20001898 	.word	0x20001898

000072b8 <at_ble_set_dev_config>:
    72b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    72ba:	7906      	ldrb	r6, [r0, #4]
    72bc:	b089      	sub	sp, #36	; 0x24
    72be:	1c04      	adds	r4, r0, #0
    72c0:	2e03      	cmp	r6, #3
    72c2:	d90c      	bls.n	72de <at_ble_set_dev_config+0x26>
    72c4:	227a      	movs	r2, #122	; 0x7a
    72c6:	4d33      	ldr	r5, [pc, #204]	; (7394 <at_ble_set_dev_config+0xdc>)
    72c8:	4933      	ldr	r1, [pc, #204]	; (7398 <at_ble_set_dev_config+0xe0>)
    72ca:	32ff      	adds	r2, #255	; 0xff
    72cc:	4b33      	ldr	r3, [pc, #204]	; (739c <at_ble_set_dev_config+0xe4>)
    72ce:	682e      	ldr	r6, [r5, #0]
    72d0:	4833      	ldr	r0, [pc, #204]	; (73a0 <at_ble_set_dev_config+0xe8>)
    72d2:	47b0      	blx	r6
    72d4:	7921      	ldrb	r1, [r4, #4]
    72d6:	682b      	ldr	r3, [r5, #0]
    72d8:	4832      	ldr	r0, [pc, #200]	; (73a4 <at_ble_set_dev_config+0xec>)
    72da:	4798      	blx	r3
    72dc:	e020      	b.n	7320 <at_ble_set_dev_config+0x68>
    72de:	7803      	ldrb	r3, [r0, #0]
    72e0:	2b0f      	cmp	r3, #15
    72e2:	d90d      	bls.n	7300 <at_ble_set_dev_config+0x48>
    72e4:	22bf      	movs	r2, #191	; 0xbf
    72e6:	4d2b      	ldr	r5, [pc, #172]	; (7394 <at_ble_set_dev_config+0xdc>)
    72e8:	492b      	ldr	r1, [pc, #172]	; (7398 <at_ble_set_dev_config+0xe0>)
    72ea:	0052      	lsls	r2, r2, #1
    72ec:	4b2b      	ldr	r3, [pc, #172]	; (739c <at_ble_set_dev_config+0xe4>)
    72ee:	682e      	ldr	r6, [r5, #0]
    72f0:	482b      	ldr	r0, [pc, #172]	; (73a0 <at_ble_set_dev_config+0xe8>)
    72f2:	47b0      	blx	r6
    72f4:	682b      	ldr	r3, [r5, #0]
    72f6:	7821      	ldrb	r1, [r4, #0]
    72f8:	482b      	ldr	r0, [pc, #172]	; (73a8 <at_ble_set_dev_config+0xf0>)
    72fa:	4798      	blx	r3
    72fc:	25e0      	movs	r5, #224	; 0xe0
    72fe:	e046      	b.n	738e <at_ble_set_dev_config+0xd6>
    7300:	2380      	movs	r3, #128	; 0x80
    7302:	8c87      	ldrh	r7, [r0, #36]	; 0x24
    7304:	009b      	lsls	r3, r3, #2
    7306:	429f      	cmp	r7, r3
    7308:	d90c      	bls.n	7324 <at_ble_set_dev_config+0x6c>
    730a:	22c2      	movs	r2, #194	; 0xc2
    730c:	4c21      	ldr	r4, [pc, #132]	; (7394 <at_ble_set_dev_config+0xdc>)
    730e:	4b23      	ldr	r3, [pc, #140]	; (739c <at_ble_set_dev_config+0xe4>)
    7310:	4823      	ldr	r0, [pc, #140]	; (73a0 <at_ble_set_dev_config+0xe8>)
    7312:	4921      	ldr	r1, [pc, #132]	; (7398 <at_ble_set_dev_config+0xe0>)
    7314:	0052      	lsls	r2, r2, #1
    7316:	6825      	ldr	r5, [r4, #0]
    7318:	47a8      	blx	r5
    731a:	6823      	ldr	r3, [r4, #0]
    731c:	4823      	ldr	r0, [pc, #140]	; (73ac <at_ble_set_dev_config+0xf4>)
    731e:	4798      	blx	r3
    7320:	25cf      	movs	r5, #207	; 0xcf
    7322:	e034      	b.n	738e <at_ble_set_dev_config+0xd6>
    7324:	7fc5      	ldrb	r5, [r0, #31]
    7326:	7f83      	ldrb	r3, [r0, #30]
    7328:	01ad      	lsls	r5, r5, #6
    732a:	015b      	lsls	r3, r3, #5
    732c:	431d      	orrs	r5, r3
    732e:	7ec3      	ldrb	r3, [r0, #27]
    7330:	431d      	orrs	r5, r3
    7332:	7f43      	ldrb	r3, [r0, #29]
    7334:	011b      	lsls	r3, r3, #4
    7336:	431d      	orrs	r5, r3
    7338:	7f03      	ldrb	r3, [r0, #28]
    733a:	009b      	lsls	r3, r3, #2
    733c:	431d      	orrs	r5, r3
    733e:	4b1c      	ldr	r3, [pc, #112]	; (73b0 <at_ble_set_dev_config+0xf8>)
    7340:	b2ed      	uxtb	r5, r5
    7342:	711e      	strb	r6, [r3, #4]
    7344:	7900      	ldrb	r0, [r0, #4]
    7346:	2803      	cmp	r0, #3
    7348:	d809      	bhi.n	735e <at_ble_set_dev_config+0xa6>
    734a:	f004 fd25 	bl	bd98 <__gnu_thumb1_case_uqi>
    734e:	0402      	.short	0x0402
    7350:	0606      	.short	0x0606
    7352:	2300      	movs	r3, #0
    7354:	e002      	b.n	735c <at_ble_set_dev_config+0xa4>
    7356:	2301      	movs	r3, #1
    7358:	e000      	b.n	735c <at_ble_set_dev_config+0xa4>
    735a:	2302      	movs	r3, #2
    735c:	7123      	strb	r3, [r4, #4]
    735e:	1c23      	adds	r3, r4, #0
    7360:	330b      	adds	r3, #11
    7362:	8861      	ldrh	r1, [r4, #2]
    7364:	9307      	str	r3, [sp, #28]
    7366:	7923      	ldrb	r3, [r4, #4]
    7368:	7820      	ldrb	r0, [r4, #0]
    736a:	9300      	str	r3, [sp, #0]
    736c:	9501      	str	r5, [sp, #4]
    736e:	8c25      	ldrh	r5, [r4, #32]
    7370:	1d62      	adds	r2, r4, #5
    7372:	9502      	str	r5, [sp, #8]
    7374:	8c65      	ldrh	r5, [r4, #34]	; 0x22
    7376:	9b07      	ldr	r3, [sp, #28]
    7378:	9503      	str	r5, [sp, #12]
    737a:	9704      	str	r7, [sp, #16]
    737c:	4d0d      	ldr	r5, [pc, #52]	; (73b4 <at_ble_set_dev_config+0xfc>)
    737e:	47a8      	blx	r5
    7380:	7126      	strb	r6, [r4, #4]
    7382:	1c05      	adds	r5, r0, #0
    7384:	1c21      	adds	r1, r4, #0
    7386:	480a      	ldr	r0, [pc, #40]	; (73b0 <at_ble_set_dev_config+0xf8>)
    7388:	2226      	movs	r2, #38	; 0x26
    738a:	4b0b      	ldr	r3, [pc, #44]	; (73b8 <at_ble_set_dev_config+0x100>)
    738c:	4798      	blx	r3
    738e:	1c28      	adds	r0, r5, #0
    7390:	b009      	add	sp, #36	; 0x24
    7392:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7394:	20000038 	.word	0x20000038
    7398:	0000ee0c 	.word	0x0000ee0c
    739c:	0000eddd 	.word	0x0000eddd
    73a0:	0000ed34 	.word	0x0000ed34
    73a4:	0000ee8d 	.word	0x0000ee8d
    73a8:	0000eeab 	.word	0x0000eeab
    73ac:	0000eec8 	.word	0x0000eec8
    73b0:	20001898 	.word	0x20001898
    73b4:	00009d49 	.word	0x00009d49
    73b8:	0000d7eb 	.word	0x0000d7eb

000073bc <at_ble_init>:
    73bc:	b570      	push	{r4, r5, r6, lr}
    73be:	b086      	sub	sp, #24
    73c0:	1c04      	adds	r4, r0, #0
    73c2:	495b      	ldr	r1, [pc, #364]	; (7530 <at_ble_init+0x174>)
    73c4:	a803      	add	r0, sp, #12
    73c6:	220b      	movs	r2, #11
    73c8:	4b5a      	ldr	r3, [pc, #360]	; (7534 <at_ble_init+0x178>)
    73ca:	4798      	blx	r3
    73cc:	4d5a      	ldr	r5, [pc, #360]	; (7538 <at_ble_init+0x17c>)
    73ce:	2c00      	cmp	r4, #0
    73d0:	d00e      	beq.n	73f0 <at_ble_init+0x34>
    73d2:	6820      	ldr	r0, [r4, #0]
    73d4:	6861      	ldr	r1, [r4, #4]
    73d6:	4b59      	ldr	r3, [pc, #356]	; (753c <at_ble_init+0x180>)
    73d8:	4798      	blx	r3
    73da:	68a0      	ldr	r0, [r4, #8]
    73dc:	2800      	cmp	r0, #0
    73de:	d007      	beq.n	73f0 <at_ble_init+0x34>
    73e0:	47a8      	blx	r5
    73e2:	1e04      	subs	r4, r0, #0
    73e4:	d016      	beq.n	7414 <at_ble_init+0x58>
    73e6:	4d56      	ldr	r5, [pc, #344]	; (7540 <at_ble_init+0x184>)
    73e8:	4856      	ldr	r0, [pc, #344]	; (7544 <at_ble_init+0x188>)
    73ea:	4957      	ldr	r1, [pc, #348]	; (7548 <at_ble_init+0x18c>)
    73ec:	223e      	movs	r2, #62	; 0x3e
    73ee:	e00b      	b.n	7408 <at_ble_init+0x4c>
    73f0:	2301      	movs	r3, #1
    73f2:	a801      	add	r0, sp, #4
    73f4:	7003      	strb	r3, [r0, #0]
    73f6:	2300      	movs	r3, #0
    73f8:	7043      	strb	r3, [r0, #1]
    73fa:	47a8      	blx	r5
    73fc:	1e04      	subs	r4, r0, #0
    73fe:	d009      	beq.n	7414 <at_ble_init+0x58>
    7400:	2248      	movs	r2, #72	; 0x48
    7402:	4d4f      	ldr	r5, [pc, #316]	; (7540 <at_ble_init+0x184>)
    7404:	484f      	ldr	r0, [pc, #316]	; (7544 <at_ble_init+0x188>)
    7406:	4950      	ldr	r1, [pc, #320]	; (7548 <at_ble_init+0x18c>)
    7408:	4b50      	ldr	r3, [pc, #320]	; (754c <at_ble_init+0x190>)
    740a:	682e      	ldr	r6, [r5, #0]
    740c:	47b0      	blx	r6
    740e:	682b      	ldr	r3, [r5, #0]
    7410:	484f      	ldr	r0, [pc, #316]	; (7550 <at_ble_init+0x194>)
    7412:	e087      	b.n	7524 <at_ble_init+0x168>
    7414:	4b4f      	ldr	r3, [pc, #316]	; (7554 <at_ble_init+0x198>)
    7416:	4798      	blx	r3
    7418:	4b4f      	ldr	r3, [pc, #316]	; (7558 <at_ble_init+0x19c>)
    741a:	4798      	blx	r3
    741c:	1e04      	subs	r4, r0, #0
    741e:	d00c      	beq.n	743a <at_ble_init+0x7e>
    7420:	4d47      	ldr	r5, [pc, #284]	; (7540 <at_ble_init+0x184>)
    7422:	4b4a      	ldr	r3, [pc, #296]	; (754c <at_ble_init+0x190>)
    7424:	4847      	ldr	r0, [pc, #284]	; (7544 <at_ble_init+0x188>)
    7426:	4948      	ldr	r1, [pc, #288]	; (7548 <at_ble_init+0x18c>)
    7428:	2253      	movs	r2, #83	; 0x53
    742a:	682e      	ldr	r6, [r5, #0]
    742c:	47b0      	blx	r6
    742e:	682b      	ldr	r3, [r5, #0]
    7430:	484a      	ldr	r0, [pc, #296]	; (755c <at_ble_init+0x1a0>)
    7432:	e077      	b.n	7524 <at_ble_init+0x168>
    7434:	7823      	ldrb	r3, [r4, #0]
    7436:	2b39      	cmp	r3, #57	; 0x39
    7438:	d009      	beq.n	744e <at_ble_init+0x92>
    743a:	466b      	mov	r3, sp
    743c:	2201      	movs	r2, #1
    743e:	1cdc      	adds	r4, r3, #3
    7440:	1c20      	adds	r0, r4, #0
    7442:	a901      	add	r1, sp, #4
    7444:	4252      	negs	r2, r2
    7446:	4b46      	ldr	r3, [pc, #280]	; (7560 <at_ble_init+0x1a4>)
    7448:	4798      	blx	r3
    744a:	2800      	cmp	r0, #0
    744c:	d0f2      	beq.n	7434 <at_ble_init+0x78>
    744e:	2201      	movs	r2, #1
    7450:	4b44      	ldr	r3, [pc, #272]	; (7564 <at_ble_init+0x1a8>)
    7452:	601a      	str	r2, [r3, #0]
    7454:	4b44      	ldr	r3, [pc, #272]	; (7568 <at_ble_init+0x1ac>)
    7456:	4798      	blx	r3
    7458:	2300      	movs	r3, #0
    745a:	1e04      	subs	r4, r0, #0
    745c:	429c      	cmp	r4, r3
    745e:	d009      	beq.n	7474 <at_ble_init+0xb8>
    7460:	4d37      	ldr	r5, [pc, #220]	; (7540 <at_ble_init+0x184>)
    7462:	4b3a      	ldr	r3, [pc, #232]	; (754c <at_ble_init+0x190>)
    7464:	4837      	ldr	r0, [pc, #220]	; (7544 <at_ble_init+0x188>)
    7466:	4938      	ldr	r1, [pc, #224]	; (7548 <at_ble_init+0x18c>)
    7468:	2263      	movs	r2, #99	; 0x63
    746a:	682e      	ldr	r6, [r5, #0]
    746c:	47b0      	blx	r6
    746e:	682b      	ldr	r3, [r5, #0]
    7470:	483e      	ldr	r0, [pc, #248]	; (756c <at_ble_init+0x1b0>)
    7472:	e057      	b.n	7524 <at_ble_init+0x168>
    7474:	2101      	movs	r1, #1
    7476:	4a3e      	ldr	r2, [pc, #248]	; (7570 <at_ble_init+0x1b4>)
    7478:	4249      	negs	r1, r1
    747a:	189a      	adds	r2, r3, r2
    747c:	3312      	adds	r3, #18
    747e:	8151      	strh	r1, [r2, #10]
    7480:	2b90      	cmp	r3, #144	; 0x90
    7482:	d1f7      	bne.n	7474 <at_ble_init+0xb8>
    7484:	4c3b      	ldr	r4, [pc, #236]	; (7574 <at_ble_init+0x1b8>)
    7486:	3b81      	subs	r3, #129	; 0x81
    7488:	7023      	strb	r3, [r4, #0]
    748a:	4b3b      	ldr	r3, [pc, #236]	; (7578 <at_ble_init+0x1bc>)
    748c:	4a3b      	ldr	r2, [pc, #236]	; (757c <at_ble_init+0x1c0>)
    748e:	8063      	strh	r3, [r4, #2]
    7490:	2300      	movs	r3, #0
    7492:	7123      	strb	r3, [r4, #4]
    7494:	3301      	adds	r3, #1
    7496:	1e58      	subs	r0, r3, #1
    7498:	0119      	lsls	r1, r3, #4
    749a:	4301      	orrs	r1, r0
    749c:	3302      	adds	r3, #2
    749e:	7011      	strb	r1, [r2, #0]
    74a0:	3201      	adds	r2, #1
    74a2:	2b21      	cmp	r3, #33	; 0x21
    74a4:	d1f7      	bne.n	7496 <at_ble_init+0xda>
    74a6:	2280      	movs	r2, #128	; 0x80
    74a8:	0092      	lsls	r2, r2, #2
    74aa:	84a2      	strh	r2, [r4, #36]	; 0x24
    74ac:	1c22      	adds	r2, r4, #0
    74ae:	2300      	movs	r3, #0
    74b0:	3273      	adds	r2, #115	; 0x73
    74b2:	7013      	strb	r3, [r2, #0]
    74b4:	1c22      	adds	r2, r4, #0
    74b6:	3272      	adds	r2, #114	; 0x72
    74b8:	7013      	strb	r3, [r2, #0]
    74ba:	1c22      	adds	r2, r4, #0
    74bc:	3276      	adds	r2, #118	; 0x76
    74be:	7013      	strb	r3, [r2, #0]
    74c0:	1c22      	adds	r2, r4, #0
    74c2:	32cc      	adds	r2, #204	; 0xcc
    74c4:	8013      	strh	r3, [r2, #0]
    74c6:	1c21      	adds	r1, r4, #0
    74c8:	22a0      	movs	r2, #160	; 0xa0
    74ca:	31d0      	adds	r1, #208	; 0xd0
    74cc:	0052      	lsls	r2, r2, #1
    74ce:	800a      	strh	r2, [r1, #0]
    74d0:	1c21      	adds	r1, r4, #0
    74d2:	31ce      	adds	r1, #206	; 0xce
    74d4:	800a      	strh	r2, [r1, #0]
    74d6:	1c22      	adds	r2, r4, #0
    74d8:	32d2      	adds	r2, #210	; 0xd2
    74da:	8013      	strh	r3, [r2, #0]
    74dc:	21fa      	movs	r1, #250	; 0xfa
    74de:	1c22      	adds	r2, r4, #0
    74e0:	0049      	lsls	r1, r1, #1
    74e2:	32d4      	adds	r2, #212	; 0xd4
    74e4:	8011      	strh	r1, [r2, #0]
    74e6:	1c22      	adds	r2, r4, #0
    74e8:	32d6      	adds	r2, #214	; 0xd6
    74ea:	76e3      	strb	r3, [r4, #27]
    74ec:	7723      	strb	r3, [r4, #28]
    74ee:	7763      	strb	r3, [r4, #29]
    74f0:	77a3      	strb	r3, [r4, #30]
    74f2:	77e3      	strb	r3, [r4, #31]
    74f4:	8423      	strh	r3, [r4, #32]
    74f6:	8463      	strh	r3, [r4, #34]	; 0x22
    74f8:	7013      	strb	r3, [r2, #0]
    74fa:	1c20      	adds	r0, r4, #0
    74fc:	4b20      	ldr	r3, [pc, #128]	; (7580 <at_ble_init+0x1c4>)
    74fe:	4798      	blx	r3
    7500:	2307      	movs	r3, #7
    7502:	3474      	adds	r4, #116	; 0x74
    7504:	7023      	strb	r3, [r4, #0]
    7506:	a803      	add	r0, sp, #12
    7508:	210b      	movs	r1, #11
    750a:	4b1e      	ldr	r3, [pc, #120]	; (7584 <at_ble_init+0x1c8>)
    750c:	4798      	blx	r3
    750e:	1e04      	subs	r4, r0, #0
    7510:	d00a      	beq.n	7528 <at_ble_init+0x16c>
    7512:	4d0b      	ldr	r5, [pc, #44]	; (7540 <at_ble_init+0x184>)
    7514:	4b0d      	ldr	r3, [pc, #52]	; (754c <at_ble_init+0x190>)
    7516:	480b      	ldr	r0, [pc, #44]	; (7544 <at_ble_init+0x188>)
    7518:	490b      	ldr	r1, [pc, #44]	; (7548 <at_ble_init+0x18c>)
    751a:	2291      	movs	r2, #145	; 0x91
    751c:	682e      	ldr	r6, [r5, #0]
    751e:	47b0      	blx	r6
    7520:	682b      	ldr	r3, [r5, #0]
    7522:	4819      	ldr	r0, [pc, #100]	; (7588 <at_ble_init+0x1cc>)
    7524:	1c21      	adds	r1, r4, #0
    7526:	4798      	blx	r3
    7528:	1c20      	adds	r0, r4, #0
    752a:	b006      	add	sp, #24
    752c:	bd70      	pop	{r4, r5, r6, pc}
    752e:	46c0      	nop			; (mov r8, r8)
    7530:	0000edd2 	.word	0x0000edd2
    7534:	0000d7eb 	.word	0x0000d7eb
    7538:	00001801 	.word	0x00001801
    753c:	00007e59 	.word	0x00007e59
    7540:	20000038 	.word	0x20000038
    7544:	0000ed34 	.word	0x0000ed34
    7548:	0000ee0c 	.word	0x0000ee0c
    754c:	0000f07a 	.word	0x0000f07a
    7550:	0000eef2 	.word	0x0000eef2
    7554:	00006ac1 	.word	0x00006ac1
    7558:	000086e1 	.word	0x000086e1
    755c:	0000ef13 	.word	0x0000ef13
    7560:	00006b79 	.word	0x00006b79
    7564:	200000d4 	.word	0x200000d4
    7568:	00009c45 	.word	0x00009c45
    756c:	0000ef31 	.word	0x0000ef31
    7570:	20001808 	.word	0x20001808
    7574:	20001898 	.word	0x20001898
    7578:	00003a98 	.word	0x00003a98
    757c:	200018a3 	.word	0x200018a3
    7580:	000072b9 	.word	0x000072b9
    7584:	00007239 	.word	0x00007239
    7588:	0000ef48 	.word	0x0000ef48

0000758c <at_ble_adv_data_set>:
    758c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    758e:	4684      	mov	ip, r0
    7590:	1c0f      	adds	r7, r1, #0
    7592:	1c16      	adds	r6, r2, #0
    7594:	1c1c      	adds	r4, r3, #0
    7596:	2800      	cmp	r0, #0
    7598:	d102      	bne.n	75a0 <at_ble_adv_data_set+0x14>
    759a:	20e2      	movs	r0, #226	; 0xe2
    759c:	2a00      	cmp	r2, #0
    759e:	d02b      	beq.n	75f8 <at_ble_adv_data_set+0x6c>
    75a0:	20cf      	movs	r0, #207	; 0xcf
    75a2:	2f1f      	cmp	r7, #31
    75a4:	d828      	bhi.n	75f8 <at_ble_adv_data_set+0x6c>
    75a6:	2c1f      	cmp	r4, #31
    75a8:	d826      	bhi.n	75f8 <at_ble_adv_data_set+0x6c>
    75aa:	4663      	mov	r3, ip
    75ac:	2b00      	cmp	r3, #0
    75ae:	d00e      	beq.n	75ce <at_ble_adv_data_set+0x42>
    75b0:	4812      	ldr	r0, [pc, #72]	; (75fc <at_ble_adv_data_set+0x70>)
    75b2:	4d13      	ldr	r5, [pc, #76]	; (7600 <at_ble_adv_data_set+0x74>)
    75b4:	2f00      	cmp	r7, #0
    75b6:	d104      	bne.n	75c2 <at_ble_adv_data_set+0x36>
    75b8:	1c39      	adds	r1, r7, #0
    75ba:	221f      	movs	r2, #31
    75bc:	4b11      	ldr	r3, [pc, #68]	; (7604 <at_ble_adv_data_set+0x78>)
    75be:	4798      	blx	r3
    75c0:	e003      	b.n	75ca <at_ble_adv_data_set+0x3e>
    75c2:	4661      	mov	r1, ip
    75c4:	1c3a      	adds	r2, r7, #0
    75c6:	4b10      	ldr	r3, [pc, #64]	; (7608 <at_ble_adv_data_set+0x7c>)
    75c8:	4798      	blx	r3
    75ca:	3572      	adds	r5, #114	; 0x72
    75cc:	702f      	strb	r7, [r5, #0]
    75ce:	1e30      	subs	r0, r6, #0
    75d0:	d012      	beq.n	75f8 <at_ble_adv_data_set+0x6c>
    75d2:	4d0b      	ldr	r5, [pc, #44]	; (7600 <at_ble_adv_data_set+0x74>)
    75d4:	480d      	ldr	r0, [pc, #52]	; (760c <at_ble_adv_data_set+0x80>)
    75d6:	2c00      	cmp	r4, #0
    75d8:	d107      	bne.n	75ea <at_ble_adv_data_set+0x5e>
    75da:	1c21      	adds	r1, r4, #0
    75dc:	221f      	movs	r2, #31
    75de:	4b09      	ldr	r3, [pc, #36]	; (7604 <at_ble_adv_data_set+0x78>)
    75e0:	3573      	adds	r5, #115	; 0x73
    75e2:	4798      	blx	r3
    75e4:	702c      	strb	r4, [r5, #0]
    75e6:	1c20      	adds	r0, r4, #0
    75e8:	e006      	b.n	75f8 <at_ble_adv_data_set+0x6c>
    75ea:	1c31      	adds	r1, r6, #0
    75ec:	1c22      	adds	r2, r4, #0
    75ee:	4b06      	ldr	r3, [pc, #24]	; (7608 <at_ble_adv_data_set+0x7c>)
    75f0:	4798      	blx	r3
    75f2:	2000      	movs	r0, #0
    75f4:	3573      	adds	r5, #115	; 0x73
    75f6:	702c      	strb	r4, [r5, #0]
    75f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    75fa:	46c0      	nop			; (mov r8, r8)
    75fc:	200018cc 	.word	0x200018cc
    7600:	20001898 	.word	0x20001898
    7604:	0000d825 	.word	0x0000d825
    7608:	0000d7eb 	.word	0x0000d7eb
    760c:	200018eb 	.word	0x200018eb

00007610 <at_ble_adv_start>:
    7610:	b5f0      	push	{r4, r5, r6, r7, lr}
    7612:	b091      	sub	sp, #68	; 0x44
    7614:	1c04      	adds	r4, r0, #0
    7616:	a816      	add	r0, sp, #88	; 0x58
    7618:	8805      	ldrh	r5, [r0, #0]
    761a:	a817      	add	r0, sp, #92	; 0x5c
    761c:	8807      	ldrh	r7, [r0, #0]
    761e:	a818      	add	r0, sp, #96	; 0x60
    7620:	7800      	ldrb	r0, [r0, #0]
    7622:	900d      	str	r0, [sp, #52]	; 0x34
    7624:	483d      	ldr	r0, [pc, #244]	; (771c <at_ble_adv_start+0x10c>)
    7626:	3073      	adds	r0, #115	; 0x73
    7628:	7800      	ldrb	r0, [r0, #0]
    762a:	900c      	str	r0, [sp, #48]	; 0x30
    762c:	20cf      	movs	r0, #207	; 0xcf
    762e:	2c01      	cmp	r4, #1
    7630:	d102      	bne.n	7638 <at_ble_adv_start+0x28>
    7632:	2f00      	cmp	r7, #0
    7634:	d170      	bne.n	7718 <at_ble_adv_start+0x108>
    7636:	e026      	b.n	7686 <at_ble_adv_start+0x76>
    7638:	2c04      	cmp	r4, #4
    763a:	d86d      	bhi.n	7718 <at_ble_adv_start+0x108>
    763c:	2680      	movs	r6, #128	; 0x80
    763e:	01f6      	lsls	r6, r6, #7
    7640:	42b5      	cmp	r5, r6
    7642:	d869      	bhi.n	7718 <at_ble_adv_start+0x108>
    7644:	2c00      	cmp	r4, #0
    7646:	d102      	bne.n	764e <at_ble_adv_start+0x3e>
    7648:	2d1f      	cmp	r5, #31
    764a:	d965      	bls.n	7718 <at_ble_adv_start+0x108>
    764c:	e003      	b.n	7656 <at_ble_adv_start+0x46>
    764e:	2d9f      	cmp	r5, #159	; 0x9f
    7650:	d801      	bhi.n	7656 <at_ble_adv_start+0x46>
    7652:	2c01      	cmp	r4, #1
    7654:	d160      	bne.n	7718 <at_ble_adv_start+0x108>
    7656:	2b00      	cmp	r3, #0
    7658:	d008      	beq.n	766c <at_ble_adv_start+0x5c>
    765a:	1e4e      	subs	r6, r1, #1
    765c:	20cf      	movs	r0, #207	; 0xcf
    765e:	2e01      	cmp	r6, #1
    7660:	d95a      	bls.n	7718 <at_ble_adv_start+0x108>
    7662:	2c01      	cmp	r4, #1
    7664:	d102      	bne.n	766c <at_ble_adv_start+0x5c>
    7666:	2d00      	cmp	r5, #0
    7668:	d100      	bne.n	766c <at_ble_adv_start+0x5c>
    766a:	3520      	adds	r5, #32
    766c:	930f      	str	r3, [sp, #60]	; 0x3c
    766e:	4b2c      	ldr	r3, [pc, #176]	; (7720 <at_ble_adv_start+0x110>)
    7670:	910e      	str	r1, [sp, #56]	; 0x38
    7672:	1c16      	adds	r6, r2, #0
    7674:	4798      	blx	r3
    7676:	1c01      	adds	r1, r0, #0
    7678:	1e60      	subs	r0, r4, #1
    767a:	2e00      	cmp	r6, #0
    767c:	d03b      	beq.n	76f6 <at_ble_adv_start+0xe6>
    767e:	7833      	ldrb	r3, [r6, #0]
    7680:	2b00      	cmp	r3, #0
    7682:	d109      	bne.n	7698 <at_ble_adv_start+0x88>
    7684:	e034      	b.n	76f0 <at_ble_adv_start+0xe0>
    7686:	2680      	movs	r6, #128	; 0x80
    7688:	01f6      	lsls	r6, r6, #7
    768a:	42b5      	cmp	r5, r6
    768c:	d844      	bhi.n	7718 <at_ble_adv_start+0x108>
    768e:	1c56      	adds	r6, r2, #1
    7690:	d042      	beq.n	7718 <at_ble_adv_start+0x108>
    7692:	2b00      	cmp	r3, #0
    7694:	d1e1      	bne.n	765a <at_ble_adv_start+0x4a>
    7696:	e7e6      	b.n	7666 <at_ble_adv_start+0x56>
    7698:	2301      	movs	r3, #1
    769a:	2803      	cmp	r0, #3
    769c:	d932      	bls.n	7704 <at_ble_adv_start+0xf4>
    769e:	200d      	movs	r0, #13
    76a0:	1c72      	adds	r2, r6, #1
    76a2:	e002      	b.n	76aa <at_ble_adv_start+0x9a>
    76a4:	200e      	movs	r0, #14
    76a6:	1e32      	subs	r2, r6, #0
    76a8:	d1fa      	bne.n	76a0 <at_ble_adv_start+0x90>
    76aa:	4c1c      	ldr	r4, [pc, #112]	; (771c <at_ble_adv_start+0x10c>)
    76ac:	3474      	adds	r4, #116	; 0x74
    76ae:	7826      	ldrb	r6, [r4, #0]
    76b0:	2407      	movs	r4, #7
    76b2:	2e00      	cmp	r6, #0
    76b4:	d000      	beq.n	76b8 <at_ble_adv_start+0xa8>
    76b6:	1c34      	adds	r4, r6, #0
    76b8:	9200      	str	r2, [sp, #0]
    76ba:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    76bc:	9403      	str	r4, [sp, #12]
    76be:	9204      	str	r2, [sp, #16]
    76c0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    76c2:	9501      	str	r5, [sp, #4]
    76c4:	9205      	str	r2, [sp, #20]
    76c6:	4a15      	ldr	r2, [pc, #84]	; (771c <at_ble_adv_start+0x10c>)
    76c8:	9502      	str	r5, [sp, #8]
    76ca:	3272      	adds	r2, #114	; 0x72
    76cc:	7812      	ldrb	r2, [r2, #0]
    76ce:	4c15      	ldr	r4, [pc, #84]	; (7724 <at_ble_adv_start+0x114>)
    76d0:	9206      	str	r2, [sp, #24]
    76d2:	4a15      	ldr	r2, [pc, #84]	; (7728 <at_ble_adv_start+0x118>)
    76d4:	9207      	str	r2, [sp, #28]
    76d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    76d8:	9208      	str	r2, [sp, #32]
    76da:	4a14      	ldr	r2, [pc, #80]	; (772c <at_ble_adv_start+0x11c>)
    76dc:	9209      	str	r2, [sp, #36]	; 0x24
    76de:	2264      	movs	r2, #100	; 0x64
    76e0:	4357      	muls	r7, r2
    76e2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    76e4:	b2bf      	uxth	r7, r7
    76e6:	920b      	str	r2, [sp, #44]	; 0x2c
    76e8:	970a      	str	r7, [sp, #40]	; 0x28
    76ea:	4a11      	ldr	r2, [pc, #68]	; (7730 <at_ble_adv_start+0x120>)
    76ec:	47a0      	blx	r4
    76ee:	e013      	b.n	7718 <at_ble_adv_start+0x108>
    76f0:	2803      	cmp	r0, #3
    76f2:	d8d4      	bhi.n	769e <at_ble_adv_start+0x8e>
    76f4:	e005      	b.n	7702 <at_ble_adv_start+0xf2>
    76f6:	2803      	cmp	r0, #3
    76f8:	d903      	bls.n	7702 <at_ble_adv_start+0xf2>
    76fa:	1c33      	adds	r3, r6, #0
    76fc:	200d      	movs	r0, #13
    76fe:	1c32      	adds	r2, r6, #0
    7700:	e7d3      	b.n	76aa <at_ble_adv_start+0x9a>
    7702:	2300      	movs	r3, #0
    7704:	f004 fb3e 	bl	bd84 <__gnu_thumb1_case_sqi>
    7708:	020406ce 	.word	0x020406ce
    770c:	200f      	movs	r0, #15
    770e:	e7ca      	b.n	76a6 <at_ble_adv_start+0x96>
    7710:	2200      	movs	r2, #0
    7712:	920c      	str	r2, [sp, #48]	; 0x30
    7714:	200c      	movs	r0, #12
    7716:	e7c6      	b.n	76a6 <at_ble_adv_start+0x96>
    7718:	b011      	add	sp, #68	; 0x44
    771a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    771c:	20001898 	.word	0x20001898
    7720:	0000a491 	.word	0x0000a491
    7724:	0000a2d9 	.word	0x0000a2d9
    7728:	200018cc 	.word	0x200018cc
    772c:	200018eb 	.word	0x200018eb
    7730:	00003a98 	.word	0x00003a98

00007734 <at_ble_scan_stop>:
    7734:	b510      	push	{r4, lr}
    7736:	4b05      	ldr	r3, [pc, #20]	; (774c <at_ble_scan_stop+0x18>)
    7738:	4798      	blx	r3
    773a:	1e04      	subs	r4, r0, #0
    773c:	d103      	bne.n	7746 <at_ble_scan_stop+0x12>
    773e:	20d1      	movs	r0, #209	; 0xd1
    7740:	4b03      	ldr	r3, [pc, #12]	; (7750 <at_ble_scan_stop+0x1c>)
    7742:	0100      	lsls	r0, r0, #4
    7744:	4798      	blx	r3
    7746:	1c20      	adds	r0, r4, #0
    7748:	bd10      	pop	{r4, pc}
    774a:	46c0      	nop			; (mov r8, r8)
    774c:	0000a06d 	.word	0x0000a06d
    7750:	000071a1 	.word	0x000071a1

00007754 <at_ble_disconnect>:
    7754:	b538      	push	{r3, r4, r5, lr}
    7756:	1c04      	adds	r4, r0, #0
    7758:	4b04      	ldr	r3, [pc, #16]	; (776c <at_ble_disconnect+0x18>)
    775a:	1c08      	adds	r0, r1, #0
    775c:	1c21      	adds	r1, r4, #0
    775e:	4798      	blx	r3
    7760:	1c05      	adds	r5, r0, #0
    7762:	4b03      	ldr	r3, [pc, #12]	; (7770 <at_ble_disconnect+0x1c>)
    7764:	1c20      	adds	r0, r4, #0
    7766:	4798      	blx	r3
    7768:	1c28      	adds	r0, r5, #0
    776a:	bd38      	pop	{r3, r4, r5, pc}
    776c:	000090f9 	.word	0x000090f9
    7770:	000071e5 	.word	0x000071e5

00007774 <at_ble_conn_update_reply>:
    7774:	b570      	push	{r4, r5, r6, lr}
    7776:	4c08      	ldr	r4, [pc, #32]	; (7798 <at_ble_conn_update_reply+0x24>)
    7778:	47a0      	blx	r4
    777a:	1e04      	subs	r4, r0, #0
    777c:	d00a      	beq.n	7794 <at_ble_conn_update_reply+0x20>
    777e:	4d07      	ldr	r5, [pc, #28]	; (779c <at_ble_conn_update_reply+0x28>)
    7780:	4907      	ldr	r1, [pc, #28]	; (77a0 <at_ble_conn_update_reply+0x2c>)
    7782:	4b08      	ldr	r3, [pc, #32]	; (77a4 <at_ble_conn_update_reply+0x30>)
    7784:	4808      	ldr	r0, [pc, #32]	; (77a8 <at_ble_conn_update_reply+0x34>)
    7786:	4a09      	ldr	r2, [pc, #36]	; (77ac <at_ble_conn_update_reply+0x38>)
    7788:	682e      	ldr	r6, [r5, #0]
    778a:	47b0      	blx	r6
    778c:	682b      	ldr	r3, [r5, #0]
    778e:	4808      	ldr	r0, [pc, #32]	; (77b0 <at_ble_conn_update_reply+0x3c>)
    7790:	1c21      	adds	r1, r4, #0
    7792:	4798      	blx	r3
    7794:	1c20      	adds	r0, r4, #0
    7796:	bd70      	pop	{r4, r5, r6, pc}
    7798:	00009961 	.word	0x00009961
    779c:	20000038 	.word	0x20000038
    77a0:	0000ee0c 	.word	0x0000ee0c
    77a4:	0000edf3 	.word	0x0000edf3
    77a8:	0000ed34 	.word	0x0000ed34
    77ac:	0000036b 	.word	0x0000036b
    77b0:	0000ee69 	.word	0x0000ee69

000077b4 <at_ble_random_address_resolve>:
    77b4:	b510      	push	{r4, lr}
    77b6:	23cf      	movs	r3, #207	; 0xcf
    77b8:	2800      	cmp	r0, #0
    77ba:	d00a      	beq.n	77d2 <at_ble_random_address_resolve+0x1e>
    77bc:	2900      	cmp	r1, #0
    77be:	d008      	beq.n	77d2 <at_ble_random_address_resolve+0x1e>
    77c0:	2a00      	cmp	r2, #0
    77c2:	d006      	beq.n	77d2 <at_ble_random_address_resolve+0x1e>
    77c4:	780c      	ldrb	r4, [r1, #0]
    77c6:	2c02      	cmp	r4, #2
    77c8:	d103      	bne.n	77d2 <at_ble_random_address_resolve+0x1e>
    77ca:	4b03      	ldr	r3, [pc, #12]	; (77d8 <at_ble_random_address_resolve+0x24>)
    77cc:	3101      	adds	r1, #1
    77ce:	4798      	blx	r3
    77d0:	2300      	movs	r3, #0
    77d2:	1c18      	adds	r0, r3, #0
    77d4:	bd10      	pop	{r4, pc}
    77d6:	46c0      	nop			; (mov r8, r8)
    77d8:	0000a531 	.word	0x0000a531

000077dc <at_ble_uuid_type2len>:
    77dc:	23cf      	movs	r3, #207	; 0xcf
    77de:	2802      	cmp	r0, #2
    77e0:	d801      	bhi.n	77e6 <at_ble_uuid_type2len+0xa>
    77e2:	4b02      	ldr	r3, [pc, #8]	; (77ec <at_ble_uuid_type2len+0x10>)
    77e4:	5c1b      	ldrb	r3, [r3, r0]
    77e6:	1c18      	adds	r0, r3, #0
    77e8:	4770      	bx	lr
    77ea:	46c0      	nop			; (mov r8, r8)
    77ec:	0000f086 	.word	0x0000f086

000077f0 <at_ble_uuid_len2type>:
    77f0:	1e83      	subs	r3, r0, #2
    77f2:	b2db      	uxtb	r3, r3
    77f4:	2003      	movs	r0, #3
    77f6:	2b0e      	cmp	r3, #14
    77f8:	d801      	bhi.n	77fe <at_ble_uuid_len2type+0xe>
    77fa:	4a01      	ldr	r2, [pc, #4]	; (7800 <at_ble_uuid_len2type+0x10>)
    77fc:	5cd0      	ldrb	r0, [r2, r3]
    77fe:	4770      	bx	lr
    7800:	0000f089 	.word	0x0000f089

00007804 <db_searchATT>:
    7804:	b570      	push	{r4, r5, r6, lr}
    7806:	1c05      	adds	r5, r0, #0
    7808:	2400      	movs	r4, #0
    780a:	4b0c      	ldr	r3, [pc, #48]	; (783c <db_searchATT+0x38>)
    780c:	6819      	ldr	r1, [r3, #0]
    780e:	4b0c      	ldr	r3, [pc, #48]	; (7840 <db_searchATT+0x3c>)
    7810:	681e      	ldr	r6, [r3, #0]
    7812:	428c      	cmp	r4, r1
    7814:	dc10      	bgt.n	7838 <db_searchATT+0x34>
    7816:	200c      	movs	r0, #12
    7818:	1863      	adds	r3, r4, r1
    781a:	0fda      	lsrs	r2, r3, #31
    781c:	18d3      	adds	r3, r2, r3
    781e:	1c02      	adds	r2, r0, #0
    7820:	105b      	asrs	r3, r3, #1
    7822:	435a      	muls	r2, r3
    7824:	18b0      	adds	r0, r6, r2
    7826:	8802      	ldrh	r2, [r0, #0]
    7828:	42aa      	cmp	r2, r5
    782a:	d201      	bcs.n	7830 <db_searchATT+0x2c>
    782c:	1e59      	subs	r1, r3, #1
    782e:	e7f0      	b.n	7812 <db_searchATT+0xe>
    7830:	42aa      	cmp	r2, r5
    7832:	d902      	bls.n	783a <db_searchATT+0x36>
    7834:	1c5c      	adds	r4, r3, #1
    7836:	e7ec      	b.n	7812 <db_searchATT+0xe>
    7838:	2000      	movs	r0, #0
    783a:	bd70      	pop	{r4, r5, r6, pc}
    783c:	20000394 	.word	0x20000394
    7840:	2000038c 	.word	0x2000038c

00007844 <att_permissions>:
    7844:	b530      	push	{r4, r5, lr}
    7846:	2403      	movs	r4, #3
    7848:	1c05      	adds	r5, r0, #0
    784a:	2301      	movs	r3, #1
    784c:	4025      	ands	r5, r4
    784e:	42a5      	cmp	r5, r4
    7850:	d009      	beq.n	7866 <att_permissions+0x22>
    7852:	1c23      	adds	r3, r4, #0
    7854:	1924      	adds	r4, r4, r4
    7856:	4220      	tst	r0, r4
    7858:	d105      	bne.n	7866 <att_permissions+0x22>
    785a:	3b02      	subs	r3, #2
    785c:	4218      	tst	r0, r3
    785e:	d102      	bne.n	7866 <att_permissions+0x22>
    7860:	1e4b      	subs	r3, r1, #1
    7862:	4199      	sbcs	r1, r3
    7864:	b28b      	uxth	r3, r1
    7866:	2130      	movs	r1, #48	; 0x30
    7868:	4001      	ands	r1, r0
    786a:	2930      	cmp	r1, #48	; 0x30
    786c:	d007      	beq.n	787e <att_permissions+0x3a>
    786e:	0641      	lsls	r1, r0, #25
    7870:	d401      	bmi.n	7876 <att_permissions+0x32>
    7872:	0681      	lsls	r1, r0, #26
    7874:	d501      	bpl.n	787a <att_permissions+0x36>
    7876:	4807      	ldr	r0, [pc, #28]	; (7894 <att_permissions+0x50>)
    7878:	e009      	b.n	788e <att_permissions+0x4a>
    787a:	06c1      	lsls	r1, r0, #27
    787c:	d501      	bpl.n	7882 <att_permissions+0x3e>
    787e:	4806      	ldr	r0, [pc, #24]	; (7898 <att_permissions+0x54>)
    7880:	e005      	b.n	788e <att_permissions+0x4a>
    7882:	2a00      	cmp	r2, #0
    7884:	d001      	beq.n	788a <att_permissions+0x46>
    7886:	2204      	movs	r2, #4
    7888:	4313      	orrs	r3, r2
    788a:	2080      	movs	r0, #128	; 0x80
    788c:	0180      	lsls	r0, r0, #6
    788e:	4318      	orrs	r0, r3
    7890:	bd30      	pop	{r4, r5, pc}
    7892:	46c0      	nop			; (mov r8, r8)
    7894:	0000200c 	.word	0x0000200c
    7898:	00002004 	.word	0x00002004

0000789c <char_permissions>:
    789c:	b530      	push	{r4, r5, lr}
    789e:	2300      	movs	r3, #0
    78a0:	0784      	lsls	r4, r0, #30
    78a2:	d503      	bpl.n	78ac <char_permissions+0x10>
    78a4:	3301      	adds	r3, #1
    78a6:	4219      	tst	r1, r3
    78a8:	d100      	bne.n	78ac <char_permissions+0x10>
    78aa:	3302      	adds	r3, #2
    78ac:	0704      	lsls	r4, r0, #28
    78ae:	d508      	bpl.n	78c2 <char_permissions+0x26>
    78b0:	06cc      	lsls	r4, r1, #27
    78b2:	d501      	bpl.n	78b8 <char_permissions+0x1c>
    78b4:	2404      	movs	r4, #4
    78b6:	e000      	b.n	78ba <char_permissions+0x1e>
    78b8:	240c      	movs	r4, #12
    78ba:	4323      	orrs	r3, r4
    78bc:	2480      	movs	r4, #128	; 0x80
    78be:	01a4      	lsls	r4, r4, #6
    78c0:	4323      	orrs	r3, r4
    78c2:	0684      	lsls	r4, r0, #26
    78c4:	d506      	bpl.n	78d4 <char_permissions+0x38>
    78c6:	2406      	movs	r4, #6
    78c8:	4221      	tst	r1, r4
    78ca:	d101      	bne.n	78d0 <char_permissions+0x34>
    78cc:	340a      	adds	r4, #10
    78ce:	e000      	b.n	78d2 <char_permissions+0x36>
    78d0:	2430      	movs	r4, #48	; 0x30
    78d2:	4323      	orrs	r3, r4
    78d4:	06c4      	lsls	r4, r0, #27
    78d6:	d506      	bpl.n	78e6 <char_permissions+0x4a>
    78d8:	2406      	movs	r4, #6
    78da:	4221      	tst	r1, r4
    78dc:	d101      	bne.n	78e2 <char_permissions+0x46>
    78de:	343a      	adds	r4, #58	; 0x3a
    78e0:	e000      	b.n	78e4 <char_permissions+0x48>
    78e2:	24c0      	movs	r4, #192	; 0xc0
    78e4:	4323      	orrs	r3, r4
    78e6:	2480      	movs	r4, #128	; 0x80
    78e8:	0064      	lsls	r4, r4, #1
    78ea:	4220      	tst	r0, r4
    78ec:	d000      	beq.n	78f0 <char_permissions+0x54>
    78ee:	4323      	orrs	r3, r4
    78f0:	07c4      	lsls	r4, r0, #31
    78f2:	d502      	bpl.n	78fa <char_permissions+0x5e>
    78f4:	2480      	movs	r4, #128	; 0x80
    78f6:	00a4      	lsls	r4, r4, #2
    78f8:	4323      	orrs	r3, r4
    78fa:	2404      	movs	r4, #4
    78fc:	4220      	tst	r0, r4
    78fe:	d006      	beq.n	790e <char_permissions+0x72>
    7900:	06cd      	lsls	r5, r1, #27
    7902:	d400      	bmi.n	7906 <char_permissions+0x6a>
    7904:	240c      	movs	r4, #12
    7906:	4323      	orrs	r3, r4
    7908:	2480      	movs	r4, #128	; 0x80
    790a:	0124      	lsls	r4, r4, #4
    790c:	4323      	orrs	r3, r4
    790e:	0644      	lsls	r4, r0, #25
    7910:	d501      	bpl.n	7916 <char_permissions+0x7a>
    7912:	4c08      	ldr	r4, [pc, #32]	; (7934 <char_permissions+0x98>)
    7914:	4323      	orrs	r3, r4
    7916:	0600      	lsls	r0, r0, #24
    7918:	d507      	bpl.n	792a <char_permissions+0x8e>
    791a:	2004      	movs	r0, #4
    791c:	06c9      	lsls	r1, r1, #27
    791e:	d400      	bmi.n	7922 <char_permissions+0x86>
    7920:	200c      	movs	r0, #12
    7922:	4303      	orrs	r3, r0
    7924:	2084      	movs	r0, #132	; 0x84
    7926:	0180      	lsls	r0, r0, #6
    7928:	4303      	orrs	r3, r0
    792a:	0390      	lsls	r0, r2, #14
    792c:	4303      	orrs	r3, r0
    792e:	b298      	uxth	r0, r3
    7930:	bd30      	pop	{r4, r5, pc}
    7932:	46c0      	nop			; (mov r8, r8)
    7934:	00001004 	.word	0x00001004

00007938 <presentation_format_define>:
    7938:	b507      	push	{r0, r1, r2, lr}
    793a:	466a      	mov	r2, sp
    793c:	780b      	ldrb	r3, [r1, #0]
    793e:	7013      	strb	r3, [r2, #0]
    7940:	784b      	ldrb	r3, [r1, #1]
    7942:	7053      	strb	r3, [r2, #1]
    7944:	884b      	ldrh	r3, [r1, #2]
    7946:	7093      	strb	r3, [r2, #2]
    7948:	0a1b      	lsrs	r3, r3, #8
    794a:	70d3      	strb	r3, [r2, #3]
    794c:	790b      	ldrb	r3, [r1, #4]
    794e:	7113      	strb	r3, [r2, #4]
    7950:	88cb      	ldrh	r3, [r1, #6]
    7952:	2107      	movs	r1, #7
    7954:	7153      	strb	r3, [r2, #5]
    7956:	0a1b      	lsrs	r3, r3, #8
    7958:	7193      	strb	r3, [r2, #6]
    795a:	4b01      	ldr	r3, [pc, #4]	; (7960 <presentation_format_define+0x28>)
    795c:	4798      	blx	r3
    795e:	bd0e      	pop	{r1, r2, r3, pc}
    7960:	0000ae8d 	.word	0x0000ae8d

00007964 <db_addATT>:
    7964:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7966:	4c29      	ldr	r4, [pc, #164]	; (7a0c <db_addATT+0xa8>)
    7968:	1c1d      	adds	r5, r3, #0
    796a:	6823      	ldr	r3, [r4, #0]
    796c:	9001      	str	r0, [sp, #4]
    796e:	26d3      	movs	r6, #211	; 0xd3
    7970:	2b00      	cmp	r3, #0
    7972:	d048      	beq.n	7a06 <db_addATT+0xa2>
    7974:	1c1e      	adds	r6, r3, #0
    7976:	3e0c      	subs	r6, #12
    7978:	6026      	str	r6, [r4, #0]
    797a:	2900      	cmp	r1, #0
    797c:	d005      	beq.n	798a <db_addATT+0x26>
    797e:	4f24      	ldr	r7, [pc, #144]	; (7a10 <db_addATT+0xac>)
    7980:	46bc      	mov	ip, r7
    7982:	4660      	mov	r0, ip
    7984:	683f      	ldr	r7, [r7, #0]
    7986:	18bf      	adds	r7, r7, r2
    7988:	6007      	str	r7, [r0, #0]
    798a:	4821      	ldr	r0, [pc, #132]	; (7a10 <db_addATT+0xac>)
    798c:	6807      	ldr	r7, [r0, #0]
    798e:	4684      	mov	ip, r0
    7990:	42be      	cmp	r6, r7
    7992:	d932      	bls.n	79fa <db_addATT+0x96>
    7994:	4668      	mov	r0, sp
    7996:	8880      	ldrh	r0, [r0, #4]
    7998:	3b0c      	subs	r3, #12
    799a:	8018      	strh	r0, [r3, #0]
    799c:	6823      	ldr	r3, [r4, #0]
    799e:	2900      	cmp	r1, #0
    79a0:	d009      	beq.n	79b6 <db_addATT+0x52>
    79a2:	2a00      	cmp	r2, #0
    79a4:	d007      	beq.n	79b6 <db_addATT+0x52>
    79a6:	4660      	mov	r0, ip
    79a8:	6800      	ldr	r0, [r0, #0]
    79aa:	809a      	strh	r2, [r3, #4]
    79ac:	1a80      	subs	r0, r0, r2
    79ae:	6098      	str	r0, [r3, #8]
    79b0:	4b18      	ldr	r3, [pc, #96]	; (7a14 <db_addATT+0xb0>)
    79b2:	4798      	blx	r3
    79b4:	e002      	b.n	79bc <db_addATT+0x58>
    79b6:	2100      	movs	r1, #0
    79b8:	809a      	strh	r2, [r3, #4]
    79ba:	6099      	str	r1, [r3, #8]
    79bc:	2300      	movs	r3, #0
    79be:	6822      	ldr	r2, [r4, #0]
    79c0:	7093      	strb	r3, [r2, #2]
    79c2:	3303      	adds	r3, #3
    79c4:	402b      	ands	r3, r5
    79c6:	2b03      	cmp	r3, #3
    79c8:	d001      	beq.n	79ce <db_addATT+0x6a>
    79ca:	076b      	lsls	r3, r5, #29
    79cc:	d504      	bpl.n	79d8 <db_addATT+0x74>
    79ce:	2101      	movs	r1, #1
    79d0:	6822      	ldr	r2, [r4, #0]
    79d2:	7893      	ldrb	r3, [r2, #2]
    79d4:	430b      	orrs	r3, r1
    79d6:	7093      	strb	r3, [r2, #2]
    79d8:	2330      	movs	r3, #48	; 0x30
    79da:	402b      	ands	r3, r5
    79dc:	2b30      	cmp	r3, #48	; 0x30
    79de:	d001      	beq.n	79e4 <db_addATT+0x80>
    79e0:	066b      	lsls	r3, r5, #25
    79e2:	d504      	bpl.n	79ee <db_addATT+0x8a>
    79e4:	2102      	movs	r1, #2
    79e6:	6822      	ldr	r2, [r4, #0]
    79e8:	7893      	ldrb	r3, [r2, #2]
    79ea:	430b      	orrs	r3, r1
    79ec:	7093      	strb	r3, [r2, #2]
    79ee:	4a0a      	ldr	r2, [pc, #40]	; (7a18 <db_addATT+0xb4>)
    79f0:	2600      	movs	r6, #0
    79f2:	6813      	ldr	r3, [r2, #0]
    79f4:	3301      	adds	r3, #1
    79f6:	6013      	str	r3, [r2, #0]
    79f8:	e005      	b.n	7a06 <db_addATT+0xa2>
    79fa:	6023      	str	r3, [r4, #0]
    79fc:	2611      	movs	r6, #17
    79fe:	2900      	cmp	r1, #0
    7a00:	d001      	beq.n	7a06 <db_addATT+0xa2>
    7a02:	1aba      	subs	r2, r7, r2
    7a04:	6002      	str	r2, [r0, #0]
    7a06:	1c30      	adds	r0, r6, #0
    7a08:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    7a0a:	46c0      	nop			; (mov r8, r8)
    7a0c:	2000038c 	.word	0x2000038c
    7a10:	20000390 	.word	0x20000390
    7a14:	0000d7eb 	.word	0x0000d7eb
    7a18:	20000394 	.word	0x20000394

00007a1c <user_description_define>:
    7a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7a1e:	1c06      	adds	r6, r0, #0
    7a20:	1c0c      	adds	r4, r1, #0
    7a22:	1c15      	adds	r5, r2, #0
    7a24:	1c1f      	adds	r7, r3, #0
    7a26:	2a00      	cmp	r2, #0
    7a28:	d01b      	beq.n	7a62 <user_description_define+0x46>
    7a2a:	2203      	movs	r2, #3
    7a2c:	400a      	ands	r2, r1
    7a2e:	3a03      	subs	r2, #3
    7a30:	4253      	negs	r3, r2
    7a32:	4153      	adcs	r3, r2
    7a34:	074a      	lsls	r2, r1, #29
    7a36:	0fd2      	lsrs	r2, r2, #31
    7a38:	431a      	orrs	r2, r3
    7a3a:	4b10      	ldr	r3, [pc, #64]	; (7a7c <user_description_define+0x60>)
    7a3c:	03d2      	lsls	r2, r2, #15
    7a3e:	469c      	mov	ip, r3
    7a40:	d004      	beq.n	7a4c <user_description_define+0x30>
    7a42:	1c29      	adds	r1, r5, #0
    7a44:	1c3a      	adds	r2, r7, #0
    7a46:	1c23      	adds	r3, r4, #0
    7a48:	47e0      	blx	ip
    7a4a:	e016      	b.n	7a7a <user_description_define+0x5e>
    7a4c:	1c11      	adds	r1, r2, #0
    7a4e:	1c23      	adds	r3, r4, #0
    7a50:	47e0      	blx	ip
    7a52:	2800      	cmp	r0, #0
    7a54:	d111      	bne.n	7a7a <user_description_define+0x5e>
    7a56:	1c30      	adds	r0, r6, #0
    7a58:	1c39      	adds	r1, r7, #0
    7a5a:	1c2a      	adds	r2, r5, #0
    7a5c:	4b08      	ldr	r3, [pc, #32]	; (7a80 <user_description_define+0x64>)
    7a5e:	4798      	blx	r3
    7a60:	e00b      	b.n	7a7a <user_description_define+0x5e>
    7a62:	2286      	movs	r2, #134	; 0x86
    7a64:	4c07      	ldr	r4, [pc, #28]	; (7a84 <user_description_define+0x68>)
    7a66:	4908      	ldr	r1, [pc, #32]	; (7a88 <user_description_define+0x6c>)
    7a68:	0052      	lsls	r2, r2, #1
    7a6a:	4b08      	ldr	r3, [pc, #32]	; (7a8c <user_description_define+0x70>)
    7a6c:	4808      	ldr	r0, [pc, #32]	; (7a90 <user_description_define+0x74>)
    7a6e:	6825      	ldr	r5, [r4, #0]
    7a70:	47a8      	blx	r5
    7a72:	6823      	ldr	r3, [r4, #0]
    7a74:	4807      	ldr	r0, [pc, #28]	; (7a94 <user_description_define+0x78>)
    7a76:	4798      	blx	r3
    7a78:	20cf      	movs	r0, #207	; 0xcf
    7a7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7a7c:	00007965 	.word	0x00007965
    7a80:	0000ae8d 	.word	0x0000ae8d
    7a84:	20000038 	.word	0x20000038
    7a88:	0000f0af 	.word	0x0000f0af
    7a8c:	0000f0fb 	.word	0x0000f0fb
    7a90:	0000ed34 	.word	0x0000ed34
    7a94:	0000eef0 	.word	0x0000eef0

00007a98 <at_ble_read_authorize_reply.part.2>:
    7a98:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7a9a:	4b09      	ldr	r3, [pc, #36]	; (7ac0 <at_ble_read_authorize_reply.part.2+0x28>)
    7a9c:	1c05      	adds	r5, r0, #0
    7a9e:	1c08      	adds	r0, r1, #0
    7aa0:	1c0c      	adds	r4, r1, #0
    7aa2:	4798      	blx	r3
    7aa4:	2800      	cmp	r0, #0
    7aa6:	d009      	beq.n	7abc <at_ble_read_authorize_reply.part.2+0x24>
    7aa8:	6882      	ldr	r2, [r0, #8]
    7aaa:	2a00      	cmp	r2, #0
    7aac:	d006      	beq.n	7abc <at_ble_read_authorize_reply.part.2+0x24>
    7aae:	8883      	ldrh	r3, [r0, #4]
    7ab0:	1c29      	adds	r1, r5, #0
    7ab2:	9200      	str	r2, [sp, #0]
    7ab4:	1c20      	adds	r0, r4, #0
    7ab6:	2200      	movs	r2, #0
    7ab8:	4c02      	ldr	r4, [pc, #8]	; (7ac4 <at_ble_read_authorize_reply.part.2+0x2c>)
    7aba:	47a0      	blx	r4
    7abc:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    7abe:	46c0      	nop			; (mov r8, r8)
    7ac0:	00007805 	.word	0x00007805
    7ac4:	0000a689 	.word	0x0000a689

00007ac8 <internal_at_ble_service_define.part.1>:
    7ac8:	b5f0      	push	{r4, r5, r6, r7, lr}
    7aca:	b08b      	sub	sp, #44	; 0x2c
    7acc:	9304      	str	r3, [sp, #16]
    7ace:	ab10      	add	r3, sp, #64	; 0x40
    7ad0:	2400      	movs	r4, #0
    7ad2:	9202      	str	r2, [sp, #8]
    7ad4:	cb04      	ldmia	r3!, {r2}
    7ad6:	2210      	movs	r2, #16
    7ad8:	1c05      	adds	r5, r0, #0
    7ada:	881b      	ldrh	r3, [r3, #0]
    7adc:	9106      	str	r1, [sp, #24]
    7ade:	9305      	str	r3, [sp, #20]
    7ae0:	ab12      	add	r3, sp, #72	; 0x48
    7ae2:	781b      	ldrb	r3, [r3, #0]
    7ae4:	1c21      	adds	r1, r4, #0
    7ae6:	9303      	str	r3, [sp, #12]
    7ae8:	4bc4      	ldr	r3, [pc, #784]	; (7dfc <internal_at_ble_service_define.part.1+0x334>)
    7aea:	681e      	ldr	r6, [r3, #0]
    7aec:	4bc4      	ldr	r3, [pc, #784]	; (7e00 <internal_at_ble_service_define.part.1+0x338>)
    7aee:	1db7      	adds	r7, r6, #6
    7af0:	8072      	strh	r2, [r6, #2]
    7af2:	8034      	strh	r4, [r6, #0]
    7af4:	1c38      	adds	r0, r7, #0
    7af6:	4798      	blx	r3
    7af8:	4bc2      	ldr	r3, [pc, #776]	; (7e04 <internal_at_ble_service_define.part.1+0x33c>)
    7afa:	7828      	ldrb	r0, [r5, #0]
    7afc:	4798      	blx	r3
    7afe:	4bc2      	ldr	r3, [pc, #776]	; (7e08 <internal_at_ble_service_define.part.1+0x340>)
    7b00:	1c02      	adds	r2, r0, #0
    7b02:	1c69      	adds	r1, r5, #1
    7b04:	1c38      	adds	r0, r7, #0
    7b06:	4798      	blx	r3
    7b08:	2204      	movs	r2, #4
    7b0a:	782b      	ldrb	r3, [r5, #0]
    7b0c:	7174      	strb	r4, [r6, #5]
    7b0e:	011b      	lsls	r3, r3, #4
    7b10:	4313      	orrs	r3, r2
    7b12:	9a03      	ldr	r2, [sp, #12]
    7b14:	9c02      	ldr	r4, [sp, #8]
    7b16:	0192      	lsls	r2, r2, #6
    7b18:	4313      	orrs	r3, r2
    7b1a:	7133      	strb	r3, [r6, #4]
    7b1c:	2316      	movs	r3, #22
    7b1e:	9a04      	ldr	r2, [sp, #16]
    7b20:	3412      	adds	r4, #18
    7b22:	4353      	muls	r3, r2
    7b24:	9a02      	ldr	r2, [sp, #8]
    7b26:	3312      	adds	r3, #18
    7b28:	18d7      	adds	r7, r2, r3
    7b2a:	42bc      	cmp	r4, r7
    7b2c:	d00f      	beq.n	7b4e <internal_at_ble_service_define.part.1+0x86>
    7b2e:	4bb7      	ldr	r3, [pc, #732]	; (7e0c <internal_at_ble_service_define.part.1+0x344>)
    7b30:	8821      	ldrh	r1, [r4, #0]
    7b32:	9300      	str	r3, [sp, #0]
    7b34:	230e      	movs	r3, #14
    7b36:	aa06      	add	r2, sp, #24
    7b38:	189b      	adds	r3, r3, r2
    7b3a:	9301      	str	r3, [sp, #4]
    7b3c:	4db4      	ldr	r5, [pc, #720]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7b3e:	1c30      	adds	r0, r6, #0
    7b40:	2201      	movs	r2, #1
    7b42:	2302      	movs	r3, #2
    7b44:	47a8      	blx	r5
    7b46:	3416      	adds	r4, #22
    7b48:	1e05      	subs	r5, r0, #0
    7b4a:	d0ee      	beq.n	7b2a <internal_at_ble_service_define.part.1+0x62>
    7b4c:	e181      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7b4e:	9f10      	ldr	r7, [sp, #64]	; 0x40
    7b50:	2300      	movs	r3, #0
    7b52:	3714      	adds	r7, #20
    7b54:	1c3c      	adds	r4, r7, #0
    7b56:	9302      	str	r3, [sp, #8]
    7b58:	9b02      	ldr	r3, [sp, #8]
    7b5a:	9a05      	ldr	r2, [sp, #20]
    7b5c:	4293      	cmp	r3, r2
    7b5e:	db00      	blt.n	7b62 <internal_at_ble_service_define.part.1+0x9a>
    7b60:	e0bf      	b.n	7ce2 <internal_at_ble_service_define.part.1+0x21a>
    7b62:	4bac      	ldr	r3, [pc, #688]	; (7e14 <internal_at_ble_service_define.part.1+0x34c>)
    7b64:	aa06      	add	r2, sp, #24
    7b66:	9300      	str	r3, [sp, #0]
    7b68:	230e      	movs	r3, #14
    7b6a:	189b      	adds	r3, r3, r2
    7b6c:	9301      	str	r3, [sp, #4]
    7b6e:	4da8      	ldr	r5, [pc, #672]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7b70:	1c30      	adds	r0, r6, #0
    7b72:	2104      	movs	r1, #4
    7b74:	2201      	movs	r2, #1
    7b76:	2302      	movs	r3, #2
    7b78:	47a8      	blx	r5
    7b7a:	1e05      	subs	r5, r0, #0
    7b7c:	d000      	beq.n	7b80 <internal_at_ble_service_define.part.1+0xb8>
    7b7e:	e168      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7b80:	1c23      	adds	r3, r4, #0
    7b82:	3b12      	subs	r3, #18
    7b84:	7b25      	ldrb	r5, [r4, #12]
    7b86:	781b      	ldrb	r3, [r3, #0]
    7b88:	1c29      	adds	r1, r5, #0
    7b8a:	1c1a      	adds	r2, r3, #0
    7b8c:	9303      	str	r3, [sp, #12]
    7b8e:	8820      	ldrh	r0, [r4, #0]
    7b90:	4ba1      	ldr	r3, [pc, #644]	; (7e18 <internal_at_ble_service_define.part.1+0x350>)
    7b92:	4798      	blx	r3
    7b94:	2303      	movs	r3, #3
    7b96:	402b      	ands	r3, r5
    7b98:	3b03      	subs	r3, #3
    7b9a:	4259      	negs	r1, r3
    7b9c:	4159      	adcs	r1, r3
    7b9e:	2301      	movs	r3, #1
    7ba0:	08ad      	lsrs	r5, r5, #2
    7ba2:	401d      	ands	r5, r3
    7ba4:	430d      	orrs	r5, r1
    7ba6:	8963      	ldrh	r3, [r4, #10]
    7ba8:	03ed      	lsls	r5, r5, #15
    7baa:	431d      	orrs	r5, r3
    7bac:	9007      	str	r0, [sp, #28]
    7bae:	4b95      	ldr	r3, [pc, #596]	; (7e04 <internal_at_ble_service_define.part.1+0x33c>)
    7bb0:	9803      	ldr	r0, [sp, #12]
    7bb2:	4798      	blx	r3
    7bb4:	1c22      	adds	r2, r4, #0
    7bb6:	3a11      	subs	r2, #17
    7bb8:	9200      	str	r2, [sp, #0]
    7bba:	3a03      	subs	r2, #3
    7bbc:	1c03      	adds	r3, r0, #0
    7bbe:	9201      	str	r2, [sp, #4]
    7bc0:	1c29      	adds	r1, r5, #0
    7bc2:	1c30      	adds	r0, r6, #0
    7bc4:	4d92      	ldr	r5, [pc, #584]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7bc6:	9a07      	ldr	r2, [sp, #28]
    7bc8:	47a8      	blx	r5
    7bca:	1e05      	subs	r5, r0, #0
    7bcc:	d000      	beq.n	7bd0 <internal_at_ble_service_define.part.1+0x108>
    7bce:	e140      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7bd0:	22c0      	movs	r2, #192	; 0xc0
    7bd2:	8823      	ldrh	r3, [r4, #0]
    7bd4:	0052      	lsls	r2, r2, #1
    7bd6:	4213      	tst	r3, r2
    7bd8:	d104      	bne.n	7be4 <internal_at_ble_service_define.part.1+0x11c>
    7bda:	8aa3      	ldrh	r3, [r4, #20]
    7bdc:	9303      	str	r3, [sp, #12]
    7bde:	2b00      	cmp	r3, #0
    7be0:	d116      	bne.n	7c10 <internal_at_ble_service_define.part.1+0x148>
    7be2:	e03a      	b.n	7c5a <internal_at_ble_service_define.part.1+0x192>
    7be4:	2201      	movs	r2, #1
    7be6:	09d9      	lsrs	r1, r3, #7
    7be8:	4011      	ands	r1, r2
    7bea:	05db      	lsls	r3, r3, #23
    7bec:	d501      	bpl.n	7bf2 <internal_at_ble_service_define.part.1+0x12a>
    7bee:	2302      	movs	r3, #2
    7bf0:	4319      	orrs	r1, r3
    7bf2:	4b8a      	ldr	r3, [pc, #552]	; (7e1c <internal_at_ble_service_define.part.1+0x354>)
    7bf4:	aa06      	add	r2, sp, #24
    7bf6:	9300      	str	r3, [sp, #0]
    7bf8:	230e      	movs	r3, #14
    7bfa:	189b      	adds	r3, r3, r2
    7bfc:	9301      	str	r3, [sp, #4]
    7bfe:	4d84      	ldr	r5, [pc, #528]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7c00:	0209      	lsls	r1, r1, #8
    7c02:	1c30      	adds	r0, r6, #0
    7c04:	2201      	movs	r2, #1
    7c06:	2302      	movs	r3, #2
    7c08:	47a8      	blx	r5
    7c0a:	1e05      	subs	r5, r0, #0
    7c0c:	d0e5      	beq.n	7bda <internal_at_ble_service_define.part.1+0x112>
    7c0e:	e120      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7c10:	2380      	movs	r3, #128	; 0x80
    7c12:	8822      	ldrh	r2, [r4, #0]
    7c14:	7f25      	ldrb	r5, [r4, #28]
    7c16:	005b      	lsls	r3, r3, #1
    7c18:	401a      	ands	r2, r3
    7c1a:	1c28      	adds	r0, r5, #0
    7c1c:	2101      	movs	r1, #1
    7c1e:	2a00      	cmp	r2, #0
    7c20:	d000      	beq.n	7c24 <internal_at_ble_service_define.part.1+0x15c>
    7c22:	1c0a      	adds	r2, r1, #0
    7c24:	4b7e      	ldr	r3, [pc, #504]	; (7e20 <internal_at_ble_service_define.part.1+0x358>)
    7c26:	4798      	blx	r3
    7c28:	2203      	movs	r2, #3
    7c2a:	402a      	ands	r2, r5
    7c2c:	3a03      	subs	r2, #3
    7c2e:	4251      	negs	r1, r2
    7c30:	4151      	adcs	r1, r2
    7c32:	4b7c      	ldr	r3, [pc, #496]	; (7e24 <internal_at_ble_service_define.part.1+0x35c>)
    7c34:	1c0a      	adds	r2, r1, #0
    7c36:	9300      	str	r3, [sp, #0]
    7c38:	1c23      	adds	r3, r4, #0
    7c3a:	076d      	lsls	r5, r5, #29
    7c3c:	0fed      	lsrs	r5, r5, #31
    7c3e:	432a      	orrs	r2, r5
    7c40:	03d2      	lsls	r2, r2, #15
    7c42:	4310      	orrs	r0, r2
    7c44:	3320      	adds	r3, #32
    7c46:	b282      	uxth	r2, r0
    7c48:	9301      	str	r3, [sp, #4]
    7c4a:	4d71      	ldr	r5, [pc, #452]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7c4c:	1c30      	adds	r0, r6, #0
    7c4e:	9903      	ldr	r1, [sp, #12]
    7c50:	2302      	movs	r3, #2
    7c52:	47a8      	blx	r5
    7c54:	1e05      	subs	r5, r0, #0
    7c56:	d000      	beq.n	7c5a <internal_at_ble_service_define.part.1+0x192>
    7c58:	e0fb      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7c5a:	2101      	movs	r1, #1
    7c5c:	8823      	ldrh	r3, [r4, #0]
    7c5e:	420b      	tst	r3, r1
    7c60:	d011      	beq.n	7c86 <internal_at_ble_service_define.part.1+0x1be>
    7c62:	7fa0      	ldrb	r0, [r4, #30]
    7c64:	4b6e      	ldr	r3, [pc, #440]	; (7e20 <internal_at_ble_service_define.part.1+0x358>)
    7c66:	2200      	movs	r2, #0
    7c68:	4798      	blx	r3
    7c6a:	4b6f      	ldr	r3, [pc, #444]	; (7e28 <internal_at_ble_service_define.part.1+0x360>)
    7c6c:	1c02      	adds	r2, r0, #0
    7c6e:	9300      	str	r3, [sp, #0]
    7c70:	1c23      	adds	r3, r4, #0
    7c72:	3324      	adds	r3, #36	; 0x24
    7c74:	9301      	str	r3, [sp, #4]
    7c76:	4d66      	ldr	r5, [pc, #408]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7c78:	1c30      	adds	r0, r6, #0
    7c7a:	496c      	ldr	r1, [pc, #432]	; (7e2c <internal_at_ble_service_define.part.1+0x364>)
    7c7c:	2302      	movs	r3, #2
    7c7e:	47a8      	blx	r5
    7c80:	1e05      	subs	r5, r0, #0
    7c82:	d000      	beq.n	7c86 <internal_at_ble_service_define.part.1+0x1be>
    7c84:	e0e5      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7c86:	2330      	movs	r3, #48	; 0x30
    7c88:	8822      	ldrh	r2, [r4, #0]
    7c8a:	421a      	tst	r2, r3
    7c8c:	d012      	beq.n	7cb4 <internal_at_ble_service_define.part.1+0x1ec>
    7c8e:	2101      	movs	r1, #1
    7c90:	7f60      	ldrb	r0, [r4, #29]
    7c92:	1c0a      	adds	r2, r1, #0
    7c94:	4b62      	ldr	r3, [pc, #392]	; (7e20 <internal_at_ble_service_define.part.1+0x358>)
    7c96:	4798      	blx	r3
    7c98:	4b65      	ldr	r3, [pc, #404]	; (7e30 <internal_at_ble_service_define.part.1+0x368>)
    7c9a:	1c02      	adds	r2, r0, #0
    7c9c:	9300      	str	r3, [sp, #0]
    7c9e:	1c23      	adds	r3, r4, #0
    7ca0:	3322      	adds	r3, #34	; 0x22
    7ca2:	9301      	str	r3, [sp, #4]
    7ca4:	4d5a      	ldr	r5, [pc, #360]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7ca6:	1c30      	adds	r0, r6, #0
    7ca8:	4960      	ldr	r1, [pc, #384]	; (7e2c <internal_at_ble_service_define.part.1+0x364>)
    7caa:	2302      	movs	r3, #2
    7cac:	47a8      	blx	r5
    7cae:	1e05      	subs	r5, r0, #0
    7cb0:	d000      	beq.n	7cb4 <internal_at_ble_service_define.part.1+0x1ec>
    7cb2:	e0ce      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7cb4:	69a3      	ldr	r3, [r4, #24]
    7cb6:	2b00      	cmp	r3, #0
    7cb8:	d00e      	beq.n	7cd8 <internal_at_ble_service_define.part.1+0x210>
    7cba:	4b5e      	ldr	r3, [pc, #376]	; (7e34 <internal_at_ble_service_define.part.1+0x36c>)
    7cbc:	aa06      	add	r2, sp, #24
    7cbe:	9300      	str	r3, [sp, #0]
    7cc0:	230e      	movs	r3, #14
    7cc2:	189b      	adds	r3, r3, r2
    7cc4:	9301      	str	r3, [sp, #4]
    7cc6:	4d52      	ldr	r5, [pc, #328]	; (7e10 <internal_at_ble_service_define.part.1+0x348>)
    7cc8:	1c30      	adds	r0, r6, #0
    7cca:	2107      	movs	r1, #7
    7ccc:	2201      	movs	r2, #1
    7cce:	2302      	movs	r3, #2
    7cd0:	47a8      	blx	r5
    7cd2:	1e05      	subs	r5, r0, #0
    7cd4:	d000      	beq.n	7cd8 <internal_at_ble_service_define.part.1+0x210>
    7cd6:	e0bc      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7cd8:	9b02      	ldr	r3, [sp, #8]
    7cda:	343c      	adds	r4, #60	; 0x3c
    7cdc:	3301      	adds	r3, #1
    7cde:	9302      	str	r3, [sp, #8]
    7ce0:	e73a      	b.n	7b58 <internal_at_ble_service_define.part.1+0x90>
    7ce2:	1c30      	adds	r0, r6, #0
    7ce4:	4b54      	ldr	r3, [pc, #336]	; (7e38 <internal_at_ble_service_define.part.1+0x370>)
    7ce6:	4798      	blx	r3
    7ce8:	1e05      	subs	r5, r0, #0
    7cea:	d000      	beq.n	7cee <internal_at_ble_service_define.part.1+0x226>
    7cec:	e0b1      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7cee:	8833      	ldrh	r3, [r6, #0]
    7cf0:	9a06      	ldr	r2, [sp, #24]
    7cf2:	8013      	strh	r3, [r2, #0]
    7cf4:	8836      	ldrh	r6, [r6, #0]
    7cf6:	9b04      	ldr	r3, [sp, #16]
    7cf8:	9a05      	ldr	r2, [sp, #20]
    7cfa:	18f6      	adds	r6, r6, r3
    7cfc:	b2b3      	uxth	r3, r6
    7cfe:	9302      	str	r3, [sp, #8]
    7d00:	233c      	movs	r3, #60	; 0x3c
    7d02:	4353      	muls	r3, r2
    7d04:	9a10      	ldr	r2, [sp, #64]	; 0x40
    7d06:	3314      	adds	r3, #20
    7d08:	18d3      	adds	r3, r2, r3
    7d0a:	9304      	str	r3, [sp, #16]
    7d0c:	9b04      	ldr	r3, [sp, #16]
    7d0e:	429f      	cmp	r7, r3
    7d10:	d100      	bne.n	7d14 <internal_at_ble_service_define.part.1+0x24c>
    7d12:	e09e      	b.n	7e52 <internal_at_ble_service_define.part.1+0x38a>
    7d14:	9b02      	ldr	r3, [sp, #8]
    7d16:	1c9c      	adds	r4, r3, #2
    7d18:	1c3b      	adds	r3, r7, #0
    7d1a:	b2a4      	uxth	r4, r4
    7d1c:	3b14      	subs	r3, #20
    7d1e:	801c      	strh	r4, [r3, #0]
    7d20:	9303      	str	r3, [sp, #12]
    7d22:	893b      	ldrh	r3, [r7, #8]
    7d24:	2b00      	cmp	r3, #0
    7d26:	d108      	bne.n	7d3a <internal_at_ble_service_define.part.1+0x272>
    7d28:	23c0      	movs	r3, #192	; 0xc0
    7d2a:	883a      	ldrh	r2, [r7, #0]
    7d2c:	005b      	lsls	r3, r3, #1
    7d2e:	421a      	tst	r2, r3
    7d30:	d026      	beq.n	7d80 <internal_at_ble_service_define.part.1+0x2b8>
    7d32:	9e02      	ldr	r6, [sp, #8]
    7d34:	3603      	adds	r6, #3
    7d36:	b2b4      	uxth	r4, r6
    7d38:	e022      	b.n	7d80 <internal_at_ble_service_define.part.1+0x2b8>
    7d3a:	2103      	movs	r1, #3
    7d3c:	7b3b      	ldrb	r3, [r7, #12]
    7d3e:	4019      	ands	r1, r3
    7d40:	3903      	subs	r1, #3
    7d42:	424a      	negs	r2, r1
    7d44:	414a      	adcs	r2, r1
    7d46:	0759      	lsls	r1, r3, #29
    7d48:	0fc9      	lsrs	r1, r1, #31
    7d4a:	4311      	orrs	r1, r2
    7d4c:	03c9      	lsls	r1, r1, #15
    7d4e:	897a      	ldrh	r2, [r7, #10]
    7d50:	2900      	cmp	r1, #0
    7d52:	d007      	beq.n	7d64 <internal_at_ble_service_define.part.1+0x29c>
    7d54:	6879      	ldr	r1, [r7, #4]
    7d56:	2900      	cmp	r1, #0
    7d58:	d100      	bne.n	7d5c <internal_at_ble_service_define.part.1+0x294>
    7d5a:	4938      	ldr	r1, [pc, #224]	; (7e3c <internal_at_ble_service_define.part.1+0x374>)
    7d5c:	1c20      	adds	r0, r4, #0
    7d5e:	4e38      	ldr	r6, [pc, #224]	; (7e40 <internal_at_ble_service_define.part.1+0x378>)
    7d60:	47b0      	blx	r6
    7d62:	e00a      	b.n	7d7a <internal_at_ble_service_define.part.1+0x2b2>
    7d64:	1c20      	adds	r0, r4, #0
    7d66:	4e36      	ldr	r6, [pc, #216]	; (7e40 <internal_at_ble_service_define.part.1+0x378>)
    7d68:	47b0      	blx	r6
    7d6a:	2800      	cmp	r0, #0
    7d6c:	d170      	bne.n	7e50 <internal_at_ble_service_define.part.1+0x388>
    7d6e:	9b03      	ldr	r3, [sp, #12]
    7d70:	8939      	ldrh	r1, [r7, #8]
    7d72:	8818      	ldrh	r0, [r3, #0]
    7d74:	687a      	ldr	r2, [r7, #4]
    7d76:	4b33      	ldr	r3, [pc, #204]	; (7e44 <internal_at_ble_service_define.part.1+0x37c>)
    7d78:	4798      	blx	r3
    7d7a:	2800      	cmp	r0, #0
    7d7c:	d0d4      	beq.n	7d28 <internal_at_ble_service_define.part.1+0x260>
    7d7e:	e067      	b.n	7e50 <internal_at_ble_service_define.part.1+0x388>
    7d80:	8abb      	ldrh	r3, [r7, #20]
    7d82:	2b00      	cmp	r3, #0
    7d84:	d00a      	beq.n	7d9c <internal_at_ble_service_define.part.1+0x2d4>
    7d86:	3401      	adds	r4, #1
    7d88:	b2a4      	uxth	r4, r4
    7d8a:	843c      	strh	r4, [r7, #32]
    7d8c:	7f39      	ldrb	r1, [r7, #28]
    7d8e:	8afb      	ldrh	r3, [r7, #22]
    7d90:	1c20      	adds	r0, r4, #0
    7d92:	693a      	ldr	r2, [r7, #16]
    7d94:	4e2c      	ldr	r6, [pc, #176]	; (7e48 <internal_at_ble_service_define.part.1+0x380>)
    7d96:	47b0      	blx	r6
    7d98:	2800      	cmp	r0, #0
    7d9a:	d159      	bne.n	7e50 <internal_at_ble_service_define.part.1+0x388>
    7d9c:	883b      	ldrh	r3, [r7, #0]
    7d9e:	07db      	lsls	r3, r3, #31
    7da0:	d50d      	bpl.n	7dbe <internal_at_ble_service_define.part.1+0x2f6>
    7da2:	2200      	movs	r2, #0
    7da4:	3401      	adds	r4, #1
    7da6:	b2a4      	uxth	r4, r4
    7da8:	a909      	add	r1, sp, #36	; 0x24
    7daa:	84bc      	strh	r4, [r7, #36]	; 0x24
    7dac:	7fbb      	ldrb	r3, [r7, #30]
    7dae:	1c20      	adds	r0, r4, #0
    7db0:	700a      	strb	r2, [r1, #0]
    7db2:	704a      	strb	r2, [r1, #1]
    7db4:	4e22      	ldr	r6, [pc, #136]	; (7e40 <internal_at_ble_service_define.part.1+0x378>)
    7db6:	3202      	adds	r2, #2
    7db8:	47b0      	blx	r6
    7dba:	2800      	cmp	r0, #0
    7dbc:	d148      	bne.n	7e50 <internal_at_ble_service_define.part.1+0x388>
    7dbe:	2330      	movs	r3, #48	; 0x30
    7dc0:	883a      	ldrh	r2, [r7, #0]
    7dc2:	421a      	tst	r2, r3
    7dc4:	d00d      	beq.n	7de2 <internal_at_ble_service_define.part.1+0x31a>
    7dc6:	2200      	movs	r2, #0
    7dc8:	3401      	adds	r4, #1
    7dca:	b2a4      	uxth	r4, r4
    7dcc:	a909      	add	r1, sp, #36	; 0x24
    7dce:	847c      	strh	r4, [r7, #34]	; 0x22
    7dd0:	7f7b      	ldrb	r3, [r7, #29]
    7dd2:	1c20      	adds	r0, r4, #0
    7dd4:	700a      	strb	r2, [r1, #0]
    7dd6:	704a      	strb	r2, [r1, #1]
    7dd8:	4e19      	ldr	r6, [pc, #100]	; (7e40 <internal_at_ble_service_define.part.1+0x378>)
    7dda:	3202      	adds	r2, #2
    7ddc:	47b0      	blx	r6
    7dde:	2800      	cmp	r0, #0
    7de0:	d136      	bne.n	7e50 <internal_at_ble_service_define.part.1+0x388>
    7de2:	69b9      	ldr	r1, [r7, #24]
    7de4:	2900      	cmp	r1, #0
    7de6:	d006      	beq.n	7df6 <internal_at_ble_service_define.part.1+0x32e>
    7de8:	3401      	adds	r4, #1
    7dea:	b2a4      	uxth	r4, r4
    7dec:	1c20      	adds	r0, r4, #0
    7dee:	4b17      	ldr	r3, [pc, #92]	; (7e4c <internal_at_ble_service_define.part.1+0x384>)
    7df0:	4798      	blx	r3
    7df2:	2800      	cmp	r0, #0
    7df4:	d12c      	bne.n	7e50 <internal_at_ble_service_define.part.1+0x388>
    7df6:	373c      	adds	r7, #60	; 0x3c
    7df8:	9402      	str	r4, [sp, #8]
    7dfa:	e787      	b.n	7d0c <internal_at_ble_service_define.part.1+0x244>
    7dfc:	20000398 	.word	0x20000398
    7e00:	0000d825 	.word	0x0000d825
    7e04:	000077dd 	.word	0x000077dd
    7e08:	0000d7eb 	.word	0x0000d7eb
    7e0c:	20000023 	.word	0x20000023
    7e10:	0000adf5 	.word	0x0000adf5
    7e14:	20000025 	.word	0x20000025
    7e18:	0000789d 	.word	0x0000789d
    7e1c:	2000002f 	.word	0x2000002f
    7e20:	00007845 	.word	0x00007845
    7e24:	2000002d 	.word	0x2000002d
    7e28:	2000002b 	.word	0x2000002b
    7e2c:	00008002 	.word	0x00008002
    7e30:	20000027 	.word	0x20000027
    7e34:	20000029 	.word	0x20000029
    7e38:	0000acad 	.word	0x0000acad
    7e3c:	20000388 	.word	0x20000388
    7e40:	00007965 	.word	0x00007965
    7e44:	0000ae8d 	.word	0x0000ae8d
    7e48:	00007a1d 	.word	0x00007a1d
    7e4c:	00007939 	.word	0x00007939
    7e50:	1c05      	adds	r5, r0, #0
    7e52:	1c28      	adds	r0, r5, #0
    7e54:	b00b      	add	sp, #44	; 0x2c
    7e56:	bdf0      	pop	{r4, r5, r6, r7, pc}

00007e58 <db_init>:
    7e58:	4b08      	ldr	r3, [pc, #32]	; (7e7c <db_init+0x24>)
    7e5a:	4a09      	ldr	r2, [pc, #36]	; (7e80 <db_init+0x28>)
    7e5c:	6018      	str	r0, [r3, #0]
    7e5e:	084b      	lsrs	r3, r1, #1
    7e60:	6013      	str	r3, [r2, #0]
    7e62:	4a08      	ldr	r2, [pc, #32]	; (7e84 <db_init+0x2c>)
    7e64:	18c3      	adds	r3, r0, r3
    7e66:	6013      	str	r3, [r2, #0]
    7e68:	4a07      	ldr	r2, [pc, #28]	; (7e88 <db_init+0x30>)
    7e6a:	1841      	adds	r1, r0, r1
    7e6c:	6013      	str	r3, [r2, #0]
    7e6e:	2303      	movs	r3, #3
    7e70:	3103      	adds	r1, #3
    7e72:	4399      	bics	r1, r3
    7e74:	4b05      	ldr	r3, [pc, #20]	; (7e8c <db_init+0x34>)
    7e76:	3904      	subs	r1, #4
    7e78:	6019      	str	r1, [r3, #0]
    7e7a:	4770      	bx	lr
    7e7c:	20000398 	.word	0x20000398
    7e80:	20000380 	.word	0x20000380
    7e84:	20000384 	.word	0x20000384
    7e88:	20000390 	.word	0x20000390
    7e8c:	2000038c 	.word	0x2000038c

00007e90 <at_ble_primary_service_define>:
    7e90:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    7e92:	ac08      	add	r4, sp, #32
    7e94:	cc40      	ldmia	r4!, {r6}
    7e96:	1c05      	adds	r5, r0, #0
    7e98:	8824      	ldrh	r4, [r4, #0]
    7e9a:	20cf      	movs	r0, #207	; 0xcf
    7e9c:	2d00      	cmp	r5, #0
    7e9e:	d00c      	beq.n	7eba <at_ble_primary_service_define+0x2a>
    7ea0:	2900      	cmp	r1, #0
    7ea2:	d00a      	beq.n	7eba <at_ble_primary_service_define+0x2a>
    7ea4:	2e00      	cmp	r6, #0
    7ea6:	d008      	beq.n	7eba <at_ble_primary_service_define+0x2a>
    7ea8:	2c00      	cmp	r4, #0
    7eaa:	d006      	beq.n	7eba <at_ble_primary_service_define+0x2a>
    7eac:	38ce      	subs	r0, #206	; 0xce
    7eae:	9401      	str	r4, [sp, #4]
    7eb0:	9002      	str	r0, [sp, #8]
    7eb2:	9600      	str	r6, [sp, #0]
    7eb4:	1c28      	adds	r0, r5, #0
    7eb6:	4c02      	ldr	r4, [pc, #8]	; (7ec0 <at_ble_primary_service_define+0x30>)
    7eb8:	47a0      	blx	r4
    7eba:	b004      	add	sp, #16
    7ebc:	bd70      	pop	{r4, r5, r6, pc}
    7ebe:	46c0      	nop			; (mov r8, r8)
    7ec0:	00007ac9 	.word	0x00007ac9

00007ec4 <at_ble_characteristic_value_set>:
    7ec4:	b570      	push	{r4, r5, r6, lr}
    7ec6:	4b0b      	ldr	r3, [pc, #44]	; (7ef4 <at_ble_characteristic_value_set+0x30>)
    7ec8:	1c06      	adds	r6, r0, #0
    7eca:	1c0c      	adds	r4, r1, #0
    7ecc:	1c15      	adds	r5, r2, #0
    7ece:	4798      	blx	r3
    7ed0:	2800      	cmp	r0, #0
    7ed2:	d008      	beq.n	7ee6 <at_ble_characteristic_value_set+0x22>
    7ed4:	6880      	ldr	r0, [r0, #8]
    7ed6:	2800      	cmp	r0, #0
    7ed8:	d005      	beq.n	7ee6 <at_ble_characteristic_value_set+0x22>
    7eda:	1c21      	adds	r1, r4, #0
    7edc:	1c2a      	adds	r2, r5, #0
    7ede:	4b06      	ldr	r3, [pc, #24]	; (7ef8 <at_ble_characteristic_value_set+0x34>)
    7ee0:	4798      	blx	r3
    7ee2:	2000      	movs	r0, #0
    7ee4:	e004      	b.n	7ef0 <at_ble_characteristic_value_set+0x2c>
    7ee6:	1c30      	adds	r0, r6, #0
    7ee8:	1c29      	adds	r1, r5, #0
    7eea:	1c22      	adds	r2, r4, #0
    7eec:	4b03      	ldr	r3, [pc, #12]	; (7efc <at_ble_characteristic_value_set+0x38>)
    7eee:	4798      	blx	r3
    7ef0:	bd70      	pop	{r4, r5, r6, pc}
    7ef2:	46c0      	nop			; (mov r8, r8)
    7ef4:	00007805 	.word	0x00007805
    7ef8:	0000d7eb 	.word	0x0000d7eb
    7efc:	0000ae8d 	.word	0x0000ae8d

00007f00 <at_ble_characteristic_value_get>:
    7f00:	b570      	push	{r4, r5, r6, lr}
    7f02:	4b0c      	ldr	r3, [pc, #48]	; (7f34 <at_ble_characteristic_value_get+0x34>)
    7f04:	1c06      	adds	r6, r0, #0
    7f06:	1c0c      	adds	r4, r1, #0
    7f08:	1c15      	adds	r5, r2, #0
    7f0a:	4798      	blx	r3
    7f0c:	2800      	cmp	r0, #0
    7f0e:	d00b      	beq.n	7f28 <at_ble_characteristic_value_get+0x28>
    7f10:	6883      	ldr	r3, [r0, #8]
    7f12:	2b00      	cmp	r3, #0
    7f14:	d008      	beq.n	7f28 <at_ble_characteristic_value_get+0x28>
    7f16:	8883      	ldrh	r3, [r0, #4]
    7f18:	802b      	strh	r3, [r5, #0]
    7f1a:	8882      	ldrh	r2, [r0, #4]
    7f1c:	6881      	ldr	r1, [r0, #8]
    7f1e:	4b06      	ldr	r3, [pc, #24]	; (7f38 <at_ble_characteristic_value_get+0x38>)
    7f20:	1c20      	adds	r0, r4, #0
    7f22:	4798      	blx	r3
    7f24:	2000      	movs	r0, #0
    7f26:	e004      	b.n	7f32 <at_ble_characteristic_value_get+0x32>
    7f28:	1c30      	adds	r0, r6, #0
    7f2a:	1c29      	adds	r1, r5, #0
    7f2c:	1c22      	adds	r2, r4, #0
    7f2e:	4b03      	ldr	r3, [pc, #12]	; (7f3c <at_ble_characteristic_value_get+0x3c>)
    7f30:	4798      	blx	r3
    7f32:	bd70      	pop	{r4, r5, r6, pc}
    7f34:	00007805 	.word	0x00007805
    7f38:	0000d7eb 	.word	0x0000d7eb
    7f3c:	0000af91 	.word	0x0000af91

00007f40 <at_ble_write_authorize_reply>:
    7f40:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f42:	b085      	sub	sp, #20
    7f44:	1c04      	adds	r4, r0, #0
    7f46:	9101      	str	r1, [sp, #4]
    7f48:	2900      	cmp	r1, #0
    7f4a:	d129      	bne.n	7fa0 <at_ble_write_authorize_reply+0x60>
    7f4c:	8847      	ldrh	r7, [r0, #2]
    7f4e:	4b18      	ldr	r3, [pc, #96]	; (7fb0 <at_ble_write_authorize_reply+0x70>)
    7f50:	1c38      	adds	r0, r7, #0
    7f52:	1c26      	adds	r6, r4, #0
    7f54:	4798      	blx	r3
    7f56:	3608      	adds	r6, #8
    7f58:	2800      	cmp	r0, #0
    7f5a:	d009      	beq.n	7f70 <at_ble_write_authorize_reply+0x30>
    7f5c:	6880      	ldr	r0, [r0, #8]
    7f5e:	2800      	cmp	r0, #0
    7f60:	d006      	beq.n	7f70 <at_ble_write_authorize_reply+0x30>
    7f62:	88a3      	ldrh	r3, [r4, #4]
    7f64:	88e2      	ldrh	r2, [r4, #6]
    7f66:	18c0      	adds	r0, r0, r3
    7f68:	1c31      	adds	r1, r6, #0
    7f6a:	4b12      	ldr	r3, [pc, #72]	; (7fb4 <at_ble_write_authorize_reply+0x74>)
    7f6c:	4798      	blx	r3
    7f6e:	e017      	b.n	7fa0 <at_ble_write_authorize_reply+0x60>
    7f70:	ab02      	add	r3, sp, #8
    7f72:	1d9d      	adds	r5, r3, #6
    7f74:	2300      	movs	r3, #0
    7f76:	802b      	strh	r3, [r5, #0]
    7f78:	4b0f      	ldr	r3, [pc, #60]	; (7fb8 <at_ble_write_authorize_reply+0x78>)
    7f7a:	1c2a      	adds	r2, r5, #0
    7f7c:	681b      	ldr	r3, [r3, #0]
    7f7e:	1c38      	adds	r0, r7, #0
    7f80:	1c19      	adds	r1, r3, #0
    7f82:	9300      	str	r3, [sp, #0]
    7f84:	4b0d      	ldr	r3, [pc, #52]	; (7fbc <at_ble_write_authorize_reply+0x7c>)
    7f86:	4798      	blx	r3
    7f88:	9b00      	ldr	r3, [sp, #0]
    7f8a:	88a0      	ldrh	r0, [r4, #4]
    7f8c:	88e2      	ldrh	r2, [r4, #6]
    7f8e:	1818      	adds	r0, r3, r0
    7f90:	1c31      	adds	r1, r6, #0
    7f92:	4b08      	ldr	r3, [pc, #32]	; (7fb4 <at_ble_write_authorize_reply+0x74>)
    7f94:	4798      	blx	r3
    7f96:	8860      	ldrh	r0, [r4, #2]
    7f98:	882a      	ldrh	r2, [r5, #0]
    7f9a:	9900      	ldr	r1, [sp, #0]
    7f9c:	4b08      	ldr	r3, [pc, #32]	; (7fc0 <at_ble_write_authorize_reply+0x80>)
    7f9e:	4798      	blx	r3
    7fa0:	8860      	ldrh	r0, [r4, #2]
    7fa2:	8821      	ldrh	r1, [r4, #0]
    7fa4:	9a01      	ldr	r2, [sp, #4]
    7fa6:	4b07      	ldr	r3, [pc, #28]	; (7fc4 <at_ble_write_authorize_reply+0x84>)
    7fa8:	4798      	blx	r3
    7faa:	2000      	movs	r0, #0
    7fac:	b005      	add	sp, #20
    7fae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7fb0:	00007805 	.word	0x00007805
    7fb4:	0000d7eb 	.word	0x0000d7eb
    7fb8:	00011144 	.word	0x00011144
    7fbc:	00007f01 	.word	0x00007f01
    7fc0:	00007ec5 	.word	0x00007ec5
    7fc4:	0000a759 	.word	0x0000a759

00007fc8 <gatts_handle_read_req>:
    7fc8:	b538      	push	{r3, r4, r5, lr}
    7fca:	1c0c      	adds	r4, r1, #0
    7fcc:	4b07      	ldr	r3, [pc, #28]	; (7fec <gatts_handle_read_req+0x24>)
    7fce:	4798      	blx	r3
    7fd0:	8865      	ldrh	r5, [r4, #2]
    7fd2:	4b07      	ldr	r3, [pc, #28]	; (7ff0 <gatts_handle_read_req+0x28>)
    7fd4:	1c28      	adds	r0, r5, #0
    7fd6:	4798      	blx	r3
    7fd8:	7883      	ldrb	r3, [r0, #2]
    7fda:	2026      	movs	r0, #38	; 0x26
    7fdc:	07db      	lsls	r3, r3, #31
    7fde:	d404      	bmi.n	7fea <gatts_handle_read_req+0x22>
    7fe0:	8820      	ldrh	r0, [r4, #0]
    7fe2:	1c29      	adds	r1, r5, #0
    7fe4:	4b03      	ldr	r3, [pc, #12]	; (7ff4 <gatts_handle_read_req+0x2c>)
    7fe6:	4798      	blx	r3
    7fe8:	203a      	movs	r0, #58	; 0x3a
    7fea:	bd38      	pop	{r3, r4, r5, pc}
    7fec:	0000a639 	.word	0x0000a639
    7ff0:	00007805 	.word	0x00007805
    7ff4:	00007a99 	.word	0x00007a99

00007ff8 <gatts_handle_att_info_req>:
    7ff8:	b538      	push	{r3, r4, r5, lr}
    7ffa:	1c0d      	adds	r5, r1, #0
    7ffc:	4b0a      	ldr	r3, [pc, #40]	; (8028 <gatts_handle_att_info_req+0x30>)
    7ffe:	1c14      	adds	r4, r2, #0
    8000:	4798      	blx	r3
    8002:	882d      	ldrh	r5, [r5, #0]
    8004:	4b09      	ldr	r3, [pc, #36]	; (802c <gatts_handle_att_info_req+0x34>)
    8006:	1c28      	adds	r0, r5, #0
    8008:	4798      	blx	r3
    800a:	0a22      	lsrs	r2, r4, #8
    800c:	1c03      	adds	r3, r0, #0
    800e:	4c08      	ldr	r4, [pc, #32]	; (8030 <gatts_handle_att_info_req+0x38>)
    8010:	b291      	uxth	r1, r2
    8012:	2800      	cmp	r0, #0
    8014:	d003      	beq.n	801e <gatts_handle_att_info_req+0x26>
    8016:	8882      	ldrh	r2, [r0, #4]
    8018:	2300      	movs	r3, #0
    801a:	1c28      	adds	r0, r5, #0
    801c:	e001      	b.n	8022 <gatts_handle_att_info_req+0x2a>
    801e:	1c28      	adds	r0, r5, #0
    8020:	2201      	movs	r2, #1
    8022:	47a0      	blx	r4
    8024:	203a      	movs	r0, #58	; 0x3a
    8026:	bd38      	pop	{r3, r4, r5, pc}
    8028:	0000a67d 	.word	0x0000a67d
    802c:	00007805 	.word	0x00007805
    8030:	0000a7f9 	.word	0x0000a7f9

00008034 <gatts_handle_write_req>:
    8034:	b510      	push	{r4, lr}
    8036:	1c14      	adds	r4, r2, #0
    8038:	4b07      	ldr	r3, [pc, #28]	; (8058 <gatts_handle_write_req+0x24>)
    803a:	4798      	blx	r3
    803c:	4b07      	ldr	r3, [pc, #28]	; (805c <gatts_handle_write_req+0x28>)
    803e:	8860      	ldrh	r0, [r4, #2]
    8040:	4798      	blx	r3
    8042:	2302      	movs	r3, #2
    8044:	7881      	ldrb	r1, [r0, #2]
    8046:	2022      	movs	r0, #34	; 0x22
    8048:	4019      	ands	r1, r3
    804a:	d103      	bne.n	8054 <gatts_handle_write_req+0x20>
    804c:	1c20      	adds	r0, r4, #0
    804e:	4b04      	ldr	r3, [pc, #16]	; (8060 <gatts_handle_write_req+0x2c>)
    8050:	4798      	blx	r3
    8052:	201f      	movs	r0, #31
    8054:	bd10      	pop	{r4, pc}
    8056:	46c0      	nop			; (mov r8, r8)
    8058:	0000a645 	.word	0x0000a645
    805c:	00007805 	.word	0x00007805
    8060:	00007f41 	.word	0x00007f41

00008064 <at_ble_notification_send>:
    8064:	b5f0      	push	{r4, r5, r6, r7, lr}
    8066:	4d17      	ldr	r5, [pc, #92]	; (80c4 <at_ble_notification_send+0x60>)
    8068:	4c17      	ldr	r4, [pc, #92]	; (80c8 <at_ble_notification_send+0x64>)
    806a:	682a      	ldr	r2, [r5, #0]
    806c:	44a5      	add	sp, r4
    806e:	23d2      	movs	r3, #210	; 0xd2
    8070:	2a04      	cmp	r2, #4
    8072:	d822      	bhi.n	80ba <at_ble_notification_send+0x56>
    8074:	1c06      	adds	r6, r0, #0
    8076:	4b15      	ldr	r3, [pc, #84]	; (80cc <at_ble_notification_send+0x68>)
    8078:	1c08      	adds	r0, r1, #0
    807a:	1c0c      	adds	r4, r1, #0
    807c:	4798      	blx	r3
    807e:	2800      	cmp	r0, #0
    8080:	d008      	beq.n	8094 <at_ble_notification_send+0x30>
    8082:	6883      	ldr	r3, [r0, #8]
    8084:	2b00      	cmp	r3, #0
    8086:	d005      	beq.n	8094 <at_ble_notification_send+0x30>
    8088:	8882      	ldrh	r2, [r0, #4]
    808a:	1c21      	adds	r1, r4, #0
    808c:	9200      	str	r2, [sp, #0]
    808e:	2012      	movs	r0, #18
    8090:	1c32      	adds	r2, r6, #0
    8092:	e00c      	b.n	80ae <at_ble_notification_send+0x4a>
    8094:	270e      	movs	r7, #14
    8096:	446f      	add	r7, sp
    8098:	1c39      	adds	r1, r7, #0
    809a:	aa04      	add	r2, sp, #16
    809c:	4b0c      	ldr	r3, [pc, #48]	; (80d0 <at_ble_notification_send+0x6c>)
    809e:	1c20      	adds	r0, r4, #0
    80a0:	4798      	blx	r3
    80a2:	2012      	movs	r0, #18
    80a4:	1c21      	adds	r1, r4, #0
    80a6:	1c32      	adds	r2, r6, #0
    80a8:	883b      	ldrh	r3, [r7, #0]
    80aa:	9300      	str	r3, [sp, #0]
    80ac:	ab04      	add	r3, sp, #16
    80ae:	4c09      	ldr	r4, [pc, #36]	; (80d4 <at_ble_notification_send+0x70>)
    80b0:	47a0      	blx	r4
    80b2:	682b      	ldr	r3, [r5, #0]
    80b4:	3301      	adds	r3, #1
    80b6:	602b      	str	r3, [r5, #0]
    80b8:	2300      	movs	r3, #0
    80ba:	1c18      	adds	r0, r3, #0
    80bc:	2385      	movs	r3, #133	; 0x85
    80be:	009b      	lsls	r3, r3, #2
    80c0:	449d      	add	sp, r3
    80c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    80c4:	2000069c 	.word	0x2000069c
    80c8:	fffffdec 	.word	0xfffffdec
    80cc:	00007805 	.word	0x00007805
    80d0:	0000af91 	.word	0x0000af91
    80d4:	0000a8a5 	.word	0x0000a8a5

000080d8 <l2cc_data_send_rsp_handler>:
    80d8:	b510      	push	{r4, lr}
    80da:	7802      	ldrb	r2, [r0, #0]
    80dc:	700a      	strb	r2, [r1, #0]
    80de:	7883      	ldrb	r3, [r0, #2]
    80e0:	7844      	ldrb	r4, [r0, #1]
    80e2:	021b      	lsls	r3, r3, #8
    80e4:	4323      	orrs	r3, r4
    80e6:	804b      	strh	r3, [r1, #2]
    80e8:	7903      	ldrb	r3, [r0, #4]
    80ea:	78c0      	ldrb	r0, [r0, #3]
    80ec:	021b      	lsls	r3, r3, #8
    80ee:	4303      	orrs	r3, r0
    80f0:	808b      	strh	r3, [r1, #4]
    80f2:	2a00      	cmp	r2, #0
    80f4:	d103      	bne.n	80fe <l2cc_data_send_rsp_handler+0x26>
    80f6:	4a02      	ldr	r2, [pc, #8]	; (8100 <l2cc_data_send_rsp_handler+0x28>)
    80f8:	7813      	ldrb	r3, [r2, #0]
    80fa:	3301      	adds	r3, #1
    80fc:	7013      	strb	r3, [r2, #0]
    80fe:	bd10      	pop	{r4, pc}
    8100:	20000031 	.word	0x20000031

00008104 <l2cc_data_received_handler>:
    8104:	b508      	push	{r3, lr}
    8106:	1c03      	adds	r3, r0, #0
    8108:	7842      	ldrb	r2, [r0, #1]
    810a:	7800      	ldrb	r0, [r0, #0]
    810c:	0212      	lsls	r2, r2, #8
    810e:	4302      	orrs	r2, r0
    8110:	800a      	strh	r2, [r1, #0]
    8112:	78da      	ldrb	r2, [r3, #3]
    8114:	7898      	ldrb	r0, [r3, #2]
    8116:	0212      	lsls	r2, r2, #8
    8118:	4302      	orrs	r2, r0
    811a:	804a      	strh	r2, [r1, #2]
    811c:	795a      	ldrb	r2, [r3, #5]
    811e:	7918      	ldrb	r0, [r3, #4]
    8120:	0212      	lsls	r2, r2, #8
    8122:	4302      	orrs	r2, r0
    8124:	808a      	strh	r2, [r1, #4]
    8126:	1d88      	adds	r0, r1, #6
    8128:	1d99      	adds	r1, r3, #6
    812a:	4b01      	ldr	r3, [pc, #4]	; (8130 <l2cc_data_received_handler+0x2c>)
    812c:	4798      	blx	r3
    812e:	bd08      	pop	{r3, pc}
    8130:	0000d7eb 	.word	0x0000d7eb

00008134 <check_enc_process.isra.0>:
    8134:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8136:	1c07      	adds	r7, r0, #0
    8138:	1c0e      	adds	r6, r1, #0
    813a:	1e15      	subs	r5, r2, #0
    813c:	9301      	str	r3, [sp, #4]
    813e:	2d05      	cmp	r5, #5
    8140:	d82e      	bhi.n	81a0 <check_enc_process.isra.0+0x6c>
    8142:	2401      	movs	r4, #1
    8144:	1c22      	adds	r2, r4, #0
    8146:	2333      	movs	r3, #51	; 0x33
    8148:	40aa      	lsls	r2, r5
    814a:	421a      	tst	r2, r3
    814c:	d028      	beq.n	81a0 <check_enc_process.isra.0+0x6c>
    814e:	780b      	ldrb	r3, [r1, #0]
    8150:	3b07      	subs	r3, #7
    8152:	2b09      	cmp	r3, #9
    8154:	d90a      	bls.n	816c <check_enc_process.isra.0+0x38>
    8156:	4c19      	ldr	r4, [pc, #100]	; (81bc <check_enc_process.isra.0+0x88>)
    8158:	4919      	ldr	r1, [pc, #100]	; (81c0 <check_enc_process.isra.0+0x8c>)
    815a:	4b1a      	ldr	r3, [pc, #104]	; (81c4 <check_enc_process.isra.0+0x90>)
    815c:	481a      	ldr	r0, [pc, #104]	; (81c8 <check_enc_process.isra.0+0x94>)
    815e:	22f3      	movs	r2, #243	; 0xf3
    8160:	6825      	ldr	r5, [r4, #0]
    8162:	47a8      	blx	r5
    8164:	7831      	ldrb	r1, [r6, #0]
    8166:	6823      	ldr	r3, [r4, #0]
    8168:	4818      	ldr	r0, [pc, #96]	; (81cc <check_enc_process.isra.0+0x98>)
    816a:	e023      	b.n	81b4 <check_enc_process.isra.0+0x80>
    816c:	9b01      	ldr	r3, [sp, #4]
    816e:	2b00      	cmp	r3, #0
    8170:	d101      	bne.n	8176 <check_enc_process.isra.0+0x42>
    8172:	2000      	movs	r0, #0
    8174:	e020      	b.n	81b8 <check_enc_process.isra.0+0x84>
    8176:	4b16      	ldr	r3, [pc, #88]	; (81d0 <check_enc_process.isra.0+0x9c>)
    8178:	1c38      	adds	r0, r7, #0
    817a:	2100      	movs	r1, #0
    817c:	4798      	blx	r3
    817e:	9b01      	ldr	r3, [sp, #4]
    8180:	7018      	strb	r0, [r3, #0]
    8182:	2807      	cmp	r0, #7
    8184:	d9f5      	bls.n	8172 <check_enc_process.isra.0+0x3e>
    8186:	4d0d      	ldr	r5, [pc, #52]	; (81bc <check_enc_process.isra.0+0x88>)
    8188:	490d      	ldr	r1, [pc, #52]	; (81c0 <check_enc_process.isra.0+0x8c>)
    818a:	22fc      	movs	r2, #252	; 0xfc
    818c:	4b0d      	ldr	r3, [pc, #52]	; (81c4 <check_enc_process.isra.0+0x90>)
    818e:	480e      	ldr	r0, [pc, #56]	; (81c8 <check_enc_process.isra.0+0x94>)
    8190:	682e      	ldr	r6, [r5, #0]
    8192:	47b0      	blx	r6
    8194:	682b      	ldr	r3, [r5, #0]
    8196:	480f      	ldr	r0, [pc, #60]	; (81d4 <check_enc_process.isra.0+0xa0>)
    8198:	1c39      	adds	r1, r7, #0
    819a:	4798      	blx	r3
    819c:	1c20      	adds	r0, r4, #0
    819e:	e00b      	b.n	81b8 <check_enc_process.isra.0+0x84>
    81a0:	4c06      	ldr	r4, [pc, #24]	; (81bc <check_enc_process.isra.0+0x88>)
    81a2:	4907      	ldr	r1, [pc, #28]	; (81c0 <check_enc_process.isra.0+0x8c>)
    81a4:	4b07      	ldr	r3, [pc, #28]	; (81c4 <check_enc_process.isra.0+0x90>)
    81a6:	4808      	ldr	r0, [pc, #32]	; (81c8 <check_enc_process.isra.0+0x94>)
    81a8:	22ee      	movs	r2, #238	; 0xee
    81aa:	6826      	ldr	r6, [r4, #0]
    81ac:	47b0      	blx	r6
    81ae:	1c29      	adds	r1, r5, #0
    81b0:	6823      	ldr	r3, [r4, #0]
    81b2:	4809      	ldr	r0, [pc, #36]	; (81d8 <check_enc_process.isra.0+0xa4>)
    81b4:	4798      	blx	r3
    81b6:	20cf      	movs	r0, #207	; 0xcf
    81b8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    81ba:	46c0      	nop			; (mov r8, r8)
    81bc:	20000038 	.word	0x20000038
    81c0:	0000f139 	.word	0x0000f139
    81c4:	0000f113 	.word	0x0000f113
    81c8:	0000ed34 	.word	0x0000ed34
    81cc:	0000f182 	.word	0x0000f182
    81d0:	00008d19 	.word	0x00008d19
    81d4:	0000f198 	.word	0x0000f198
    81d8:	0000f063 	.word	0x0000f063

000081dc <at_ble_authenticate>:
    81dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    81de:	1c0c      	adds	r4, r1, #0
    81e0:	211f      	movs	r1, #31
    81e2:	b08b      	sub	sp, #44	; 0x2c
    81e4:	9307      	str	r3, [sp, #28]
    81e6:	ab02      	add	r3, sp, #8
    81e8:	18c9      	adds	r1, r1, r3
    81ea:	230f      	movs	r3, #15
    81ec:	700b      	strb	r3, [r1, #0]
    81ee:	4b6b      	ldr	r3, [pc, #428]	; (839c <at_ble_authenticate+0x1c0>)
    81f0:	1c05      	adds	r5, r0, #0
    81f2:	1c16      	adds	r6, r2, #0
    81f4:	4798      	blx	r3
    81f6:	1e07      	subs	r7, r0, #0
    81f8:	2f07      	cmp	r7, #7
    81fa:	d90b      	bls.n	8214 <at_ble_authenticate+0x38>
    81fc:	4c68      	ldr	r4, [pc, #416]	; (83a0 <at_ble_authenticate+0x1c4>)
    81fe:	4969      	ldr	r1, [pc, #420]	; (83a4 <at_ble_authenticate+0x1c8>)
    8200:	221c      	movs	r2, #28
    8202:	4b69      	ldr	r3, [pc, #420]	; (83a8 <at_ble_authenticate+0x1cc>)
    8204:	4869      	ldr	r0, [pc, #420]	; (83ac <at_ble_authenticate+0x1d0>)
    8206:	6825      	ldr	r5, [r4, #0]
    8208:	47a8      	blx	r5
    820a:	6823      	ldr	r3, [r4, #0]
    820c:	4868      	ldr	r0, [pc, #416]	; (83b0 <at_ble_authenticate+0x1d4>)
    820e:	4798      	blx	r3
    8210:	2001      	movs	r0, #1
    8212:	e0c0      	b.n	8396 <at_ble_authenticate+0x1ba>
    8214:	2c00      	cmp	r4, #0
    8216:	d11b      	bne.n	8250 <at_ble_authenticate+0x74>
    8218:	2312      	movs	r3, #18
    821a:	435f      	muls	r7, r3
    821c:	4b65      	ldr	r3, [pc, #404]	; (83b4 <at_ble_authenticate+0x1d8>)
    821e:	5cfb      	ldrb	r3, [r7, r3]
    8220:	2b01      	cmp	r3, #1
    8222:	d10b      	bne.n	823c <at_ble_authenticate+0x60>
    8224:	9504      	str	r5, [sp, #16]
    8226:	9400      	str	r4, [sp, #0]
    8228:	9401      	str	r4, [sp, #4]
    822a:	9402      	str	r4, [sp, #8]
    822c:	9403      	str	r4, [sp, #12]
    822e:	1c20      	adds	r0, r4, #0
    8230:	1c21      	adds	r1, r4, #0
    8232:	1c22      	adds	r2, r4, #0
    8234:	1c23      	adds	r3, r4, #0
    8236:	4d60      	ldr	r5, [pc, #384]	; (83b8 <at_ble_authenticate+0x1dc>)
    8238:	47a8      	blx	r5
    823a:	e07b      	b.n	8334 <at_ble_authenticate+0x158>
    823c:	4c58      	ldr	r4, [pc, #352]	; (83a0 <at_ble_authenticate+0x1c4>)
    823e:	4b5a      	ldr	r3, [pc, #360]	; (83a8 <at_ble_authenticate+0x1cc>)
    8240:	485a      	ldr	r0, [pc, #360]	; (83ac <at_ble_authenticate+0x1d0>)
    8242:	4958      	ldr	r1, [pc, #352]	; (83a4 <at_ble_authenticate+0x1c8>)
    8244:	222b      	movs	r2, #43	; 0x2b
    8246:	6825      	ldr	r5, [r4, #0]
    8248:	47a8      	blx	r5
    824a:	6823      	ldr	r3, [r4, #0]
    824c:	485b      	ldr	r0, [pc, #364]	; (83bc <at_ble_authenticate+0x1e0>)
    824e:	e0a0      	b.n	8392 <at_ble_authenticate+0x1b6>
    8250:	7922      	ldrb	r2, [r4, #4]
    8252:	2a06      	cmp	r2, #6
    8254:	d904      	bls.n	8260 <at_ble_authenticate+0x84>
    8256:	7963      	ldrb	r3, [r4, #5]
    8258:	2b10      	cmp	r3, #16
    825a:	d801      	bhi.n	8260 <at_ble_authenticate+0x84>
    825c:	429a      	cmp	r2, r3
    825e:	d909      	bls.n	8274 <at_ble_authenticate+0x98>
    8260:	4c4f      	ldr	r4, [pc, #316]	; (83a0 <at_ble_authenticate+0x1c4>)
    8262:	4b51      	ldr	r3, [pc, #324]	; (83a8 <at_ble_authenticate+0x1cc>)
    8264:	4851      	ldr	r0, [pc, #324]	; (83ac <at_ble_authenticate+0x1d0>)
    8266:	494f      	ldr	r1, [pc, #316]	; (83a4 <at_ble_authenticate+0x1c8>)
    8268:	2234      	movs	r2, #52	; 0x34
    826a:	6825      	ldr	r5, [r4, #0]
    826c:	47a8      	blx	r5
    826e:	6823      	ldr	r3, [r4, #0]
    8270:	4853      	ldr	r0, [pc, #332]	; (83c0 <at_ble_authenticate+0x1e4>)
    8272:	e08e      	b.n	8392 <at_ble_authenticate+0x1b6>
    8274:	7a23      	ldrb	r3, [r4, #8]
    8276:	2b04      	cmp	r3, #4
    8278:	d909      	bls.n	828e <at_ble_authenticate+0xb2>
    827a:	4c49      	ldr	r4, [pc, #292]	; (83a0 <at_ble_authenticate+0x1c4>)
    827c:	4b4a      	ldr	r3, [pc, #296]	; (83a8 <at_ble_authenticate+0x1cc>)
    827e:	484b      	ldr	r0, [pc, #300]	; (83ac <at_ble_authenticate+0x1d0>)
    8280:	4948      	ldr	r1, [pc, #288]	; (83a4 <at_ble_authenticate+0x1c8>)
    8282:	223b      	movs	r2, #59	; 0x3b
    8284:	6825      	ldr	r5, [r4, #0]
    8286:	47a8      	blx	r5
    8288:	6823      	ldr	r3, [r4, #0]
    828a:	484e      	ldr	r0, [pc, #312]	; (83c4 <at_ble_authenticate+0x1e8>)
    828c:	e081      	b.n	8392 <at_ble_authenticate+0x1b6>
    828e:	79a3      	ldrb	r3, [r4, #6]
    8290:	2b07      	cmp	r3, #7
    8292:	d802      	bhi.n	829a <at_ble_authenticate+0xbe>
    8294:	79e3      	ldrb	r3, [r4, #7]
    8296:	2b07      	cmp	r3, #7
    8298:	d909      	bls.n	82ae <at_ble_authenticate+0xd2>
    829a:	4c41      	ldr	r4, [pc, #260]	; (83a0 <at_ble_authenticate+0x1c4>)
    829c:	4b42      	ldr	r3, [pc, #264]	; (83a8 <at_ble_authenticate+0x1cc>)
    829e:	4843      	ldr	r0, [pc, #268]	; (83ac <at_ble_authenticate+0x1d0>)
    82a0:	4940      	ldr	r1, [pc, #256]	; (83a4 <at_ble_authenticate+0x1c8>)
    82a2:	2243      	movs	r2, #67	; 0x43
    82a4:	6825      	ldr	r5, [r4, #0]
    82a6:	47a8      	blx	r5
    82a8:	6823      	ldr	r3, [r4, #0]
    82aa:	4847      	ldr	r0, [pc, #284]	; (83c8 <at_ble_authenticate+0x1ec>)
    82ac:	e071      	b.n	8392 <at_ble_authenticate+0x1b6>
    82ae:	78a3      	ldrb	r3, [r4, #2]
    82b0:	2b00      	cmp	r3, #0
    82b2:	d010      	beq.n	82d6 <at_ble_authenticate+0xfa>
    82b4:	2e00      	cmp	r6, #0
    82b6:	d109      	bne.n	82cc <at_ble_authenticate+0xf0>
    82b8:	4c39      	ldr	r4, [pc, #228]	; (83a0 <at_ble_authenticate+0x1c4>)
    82ba:	4b3b      	ldr	r3, [pc, #236]	; (83a8 <at_ble_authenticate+0x1cc>)
    82bc:	483b      	ldr	r0, [pc, #236]	; (83ac <at_ble_authenticate+0x1d0>)
    82be:	4939      	ldr	r1, [pc, #228]	; (83a4 <at_ble_authenticate+0x1c8>)
    82c0:	224b      	movs	r2, #75	; 0x4b
    82c2:	6825      	ldr	r5, [r4, #0]
    82c4:	47a8      	blx	r5
    82c6:	6823      	ldr	r3, [r4, #0]
    82c8:	4840      	ldr	r0, [pc, #256]	; (83cc <at_ble_authenticate+0x1f0>)
    82ca:	e062      	b.n	8392 <at_ble_authenticate+0x1b6>
    82cc:	4840      	ldr	r0, [pc, #256]	; (83d0 <at_ble_authenticate+0x1f4>)
    82ce:	1c31      	adds	r1, r6, #0
    82d0:	221c      	movs	r2, #28
    82d2:	4b40      	ldr	r3, [pc, #256]	; (83d4 <at_ble_authenticate+0x1f8>)
    82d4:	4798      	blx	r3
    82d6:	9b07      	ldr	r3, [sp, #28]
    82d8:	2b00      	cmp	r3, #0
    82da:	d005      	beq.n	82e8 <at_ble_authenticate+0x10c>
    82dc:	483e      	ldr	r0, [pc, #248]	; (83d8 <at_ble_authenticate+0x1fc>)
    82de:	1c19      	adds	r1, r3, #0
    82e0:	309a      	adds	r0, #154	; 0x9a
    82e2:	2210      	movs	r2, #16
    82e4:	4b3b      	ldr	r3, [pc, #236]	; (83d4 <at_ble_authenticate+0x1f8>)
    82e6:	4798      	blx	r3
    82e8:	7863      	ldrb	r3, [r4, #1]
    82ea:	78a2      	ldrb	r2, [r4, #2]
    82ec:	009b      	lsls	r3, r3, #2
    82ee:	4313      	orrs	r3, r2
    82f0:	2212      	movs	r2, #18
    82f2:	4357      	muls	r7, r2
    82f4:	4a2f      	ldr	r2, [pc, #188]	; (83b4 <at_ble_authenticate+0x1d8>)
    82f6:	b2db      	uxtb	r3, r3
    82f8:	5cba      	ldrb	r2, [r7, r2]
    82fa:	2a00      	cmp	r2, #0
    82fc:	d11c      	bne.n	8338 <at_ble_authenticate+0x15c>
    82fe:	79a0      	ldrb	r0, [r4, #6]
    8300:	0742      	lsls	r2, r0, #29
    8302:	d502      	bpl.n	830a <at_ble_authenticate+0x12e>
    8304:	9a07      	ldr	r2, [sp, #28]
    8306:	2a00      	cmp	r2, #0
    8308:	d003      	beq.n	8312 <at_ble_authenticate+0x136>
    830a:	07c2      	lsls	r2, r0, #31
    830c:	d506      	bpl.n	831c <at_ble_authenticate+0x140>
    830e:	2e00      	cmp	r6, #0
    8310:	d104      	bne.n	831c <at_ble_authenticate+0x140>
    8312:	4c23      	ldr	r4, [pc, #140]	; (83a0 <at_ble_authenticate+0x1c4>)
    8314:	4825      	ldr	r0, [pc, #148]	; (83ac <at_ble_authenticate+0x1d0>)
    8316:	4923      	ldr	r1, [pc, #140]	; (83a4 <at_ble_authenticate+0x1c8>)
    8318:	2262      	movs	r2, #98	; 0x62
    831a:	e01d      	b.n	8358 <at_ble_authenticate+0x17c>
    831c:	7966      	ldrb	r6, [r4, #5]
    831e:	7821      	ldrb	r1, [r4, #0]
    8320:	78e2      	ldrb	r2, [r4, #3]
    8322:	9600      	str	r6, [sp, #0]
    8324:	9001      	str	r0, [sp, #4]
    8326:	79e0      	ldrb	r0, [r4, #7]
    8328:	9002      	str	r0, [sp, #8]
    832a:	7a20      	ldrb	r0, [r4, #8]
    832c:	4c2b      	ldr	r4, [pc, #172]	; (83dc <at_ble_authenticate+0x200>)
    832e:	9003      	str	r0, [sp, #12]
    8330:	1c28      	adds	r0, r5, #0
    8332:	47a0      	blx	r4
    8334:	2000      	movs	r0, #0
    8336:	e02e      	b.n	8396 <at_ble_authenticate+0x1ba>
    8338:	2a01      	cmp	r2, #1
    833a:	d121      	bne.n	8380 <at_ble_authenticate+0x1a4>
    833c:	79e0      	ldrb	r0, [r4, #7]
    833e:	0742      	lsls	r2, r0, #29
    8340:	d502      	bpl.n	8348 <at_ble_authenticate+0x16c>
    8342:	9a07      	ldr	r2, [sp, #28]
    8344:	2a00      	cmp	r2, #0
    8346:	d003      	beq.n	8350 <at_ble_authenticate+0x174>
    8348:	07c2      	lsls	r2, r0, #31
    834a:	d50b      	bpl.n	8364 <at_ble_authenticate+0x188>
    834c:	2e00      	cmp	r6, #0
    834e:	d109      	bne.n	8364 <at_ble_authenticate+0x188>
    8350:	2270      	movs	r2, #112	; 0x70
    8352:	4c13      	ldr	r4, [pc, #76]	; (83a0 <at_ble_authenticate+0x1c4>)
    8354:	4815      	ldr	r0, [pc, #84]	; (83ac <at_ble_authenticate+0x1d0>)
    8356:	4913      	ldr	r1, [pc, #76]	; (83a4 <at_ble_authenticate+0x1c8>)
    8358:	4b13      	ldr	r3, [pc, #76]	; (83a8 <at_ble_authenticate+0x1cc>)
    835a:	6825      	ldr	r5, [r4, #0]
    835c:	47a8      	blx	r5
    835e:	6823      	ldr	r3, [r4, #0]
    8360:	481f      	ldr	r0, [pc, #124]	; (83e0 <at_ble_authenticate+0x204>)
    8362:	e016      	b.n	8392 <at_ble_authenticate+0x1b6>
    8364:	7966      	ldrb	r6, [r4, #5]
    8366:	7821      	ldrb	r1, [r4, #0]
    8368:	78e2      	ldrb	r2, [r4, #3]
    836a:	9600      	str	r6, [sp, #0]
    836c:	79a6      	ldrb	r6, [r4, #6]
    836e:	9002      	str	r0, [sp, #8]
    8370:	9601      	str	r6, [sp, #4]
    8372:	7a20      	ldrb	r0, [r4, #8]
    8374:	9504      	str	r5, [sp, #16]
    8376:	9003      	str	r0, [sp, #12]
    8378:	4c0f      	ldr	r4, [pc, #60]	; (83b8 <at_ble_authenticate+0x1dc>)
    837a:	2001      	movs	r0, #1
    837c:	47a0      	blx	r4
    837e:	e7d9      	b.n	8334 <at_ble_authenticate+0x158>
    8380:	4c07      	ldr	r4, [pc, #28]	; (83a0 <at_ble_authenticate+0x1c4>)
    8382:	4b09      	ldr	r3, [pc, #36]	; (83a8 <at_ble_authenticate+0x1cc>)
    8384:	4809      	ldr	r0, [pc, #36]	; (83ac <at_ble_authenticate+0x1d0>)
    8386:	4907      	ldr	r1, [pc, #28]	; (83a4 <at_ble_authenticate+0x1c8>)
    8388:	227b      	movs	r2, #123	; 0x7b
    838a:	6825      	ldr	r5, [r4, #0]
    838c:	47a8      	blx	r5
    838e:	6823      	ldr	r3, [r4, #0]
    8390:	4814      	ldr	r0, [pc, #80]	; (83e4 <at_ble_authenticate+0x208>)
    8392:	4798      	blx	r3
    8394:	20cf      	movs	r0, #207	; 0xcf
    8396:	b00b      	add	sp, #44	; 0x2c
    8398:	bdf0      	pop	{r4, r5, r6, r7, pc}
    839a:	46c0      	nop			; (mov r8, r8)
    839c:	00008d19 	.word	0x00008d19
    83a0:	20000038 	.word	0x20000038
    83a4:	0000f139 	.word	0x0000f139
    83a8:	0000f125 	.word	0x0000f125
    83ac:	0000ed34 	.word	0x0000ed34
    83b0:	0000f1a9 	.word	0x0000f1a9
    83b4:	20001808 	.word	0x20001808
    83b8:	000094ed 	.word	0x000094ed
    83bc:	0000f1bf 	.word	0x0000f1bf
    83c0:	0000f1d1 	.word	0x0000f1d1
    83c4:	0000f1e4 	.word	0x0000f1e4
    83c8:	0000f1fb 	.word	0x0000f1fb
    83cc:	0000f20f 	.word	0x0000f20f
    83d0:	20001916 	.word	0x20001916
    83d4:	0000d7eb 	.word	0x0000d7eb
    83d8:	20001898 	.word	0x20001898
    83dc:	000091d1 	.word	0x000091d1
    83e0:	0000f225 	.word	0x0000f225
    83e4:	0000f239 	.word	0x0000f239

000083e8 <at_ble_pair_key_reply>:
    83e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    83ea:	b085      	sub	sp, #20
    83ec:	1c05      	adds	r5, r0, #0
    83ee:	1c0c      	adds	r4, r1, #0
    83f0:	1c16      	adds	r6, r2, #0
    83f2:	2100      	movs	r1, #0
    83f4:	4668      	mov	r0, sp
    83f6:	2210      	movs	r2, #16
    83f8:	4b1e      	ldr	r3, [pc, #120]	; (8474 <at_ble_pair_key_reply+0x8c>)
    83fa:	4798      	blx	r3
    83fc:	2101      	movs	r1, #1
    83fe:	2e00      	cmp	r6, #0
    8400:	d101      	bne.n	8406 <at_ble_pair_key_reply+0x1e>
    8402:	1c31      	adds	r1, r6, #0
    8404:	466e      	mov	r6, sp
    8406:	2c00      	cmp	r4, #0
    8408:	d116      	bne.n	8438 <at_ble_pair_key_reply+0x50>
    840a:	2701      	movs	r7, #1
    840c:	1c23      	adds	r3, r4, #0
    840e:	1d70      	adds	r0, r6, #5
    8410:	3e01      	subs	r6, #1
    8412:	7802      	ldrb	r2, [r0, #0]
    8414:	3801      	subs	r0, #1
    8416:	3a30      	subs	r2, #48	; 0x30
    8418:	437a      	muls	r2, r7
    841a:	189b      	adds	r3, r3, r2
    841c:	220a      	movs	r2, #10
    841e:	4357      	muls	r7, r2
    8420:	42b0      	cmp	r0, r6
    8422:	d1f6      	bne.n	8412 <at_ble_pair_key_reply+0x2a>
    8424:	466a      	mov	r2, sp
    8426:	4668      	mov	r0, sp
    8428:	7013      	strb	r3, [r2, #0]
    842a:	0a1a      	lsrs	r2, r3, #8
    842c:	7042      	strb	r2, [r0, #1]
    842e:	0c1a      	lsrs	r2, r3, #16
    8430:	0e1b      	lsrs	r3, r3, #24
    8432:	7082      	strb	r2, [r0, #2]
    8434:	70c3      	strb	r3, [r0, #3]
    8436:	e015      	b.n	8464 <at_ble_pair_key_reply+0x7c>
    8438:	2c01      	cmp	r4, #1
    843a:	d107      	bne.n	844c <at_ble_pair_key_reply+0x64>
    843c:	2300      	movs	r3, #0
    843e:	4668      	mov	r0, sp
    8440:	5cf2      	ldrb	r2, [r6, r3]
    8442:	54c2      	strb	r2, [r0, r3]
    8444:	3301      	adds	r3, #1
    8446:	2b10      	cmp	r3, #16
    8448:	d1f9      	bne.n	843e <at_ble_pair_key_reply+0x56>
    844a:	e00b      	b.n	8464 <at_ble_pair_key_reply+0x7c>
    844c:	4c0a      	ldr	r4, [pc, #40]	; (8478 <at_ble_pair_key_reply+0x90>)
    844e:	490b      	ldr	r1, [pc, #44]	; (847c <at_ble_pair_key_reply+0x94>)
    8450:	22ae      	movs	r2, #174	; 0xae
    8452:	4b0b      	ldr	r3, [pc, #44]	; (8480 <at_ble_pair_key_reply+0x98>)
    8454:	480b      	ldr	r0, [pc, #44]	; (8484 <at_ble_pair_key_reply+0x9c>)
    8456:	6825      	ldr	r5, [r4, #0]
    8458:	47a8      	blx	r5
    845a:	6823      	ldr	r3, [r4, #0]
    845c:	480a      	ldr	r0, [pc, #40]	; (8488 <at_ble_pair_key_reply+0xa0>)
    845e:	4798      	blx	r3
    8460:	20cf      	movs	r0, #207	; 0xcf
    8462:	e005      	b.n	8470 <at_ble_pair_key_reply+0x88>
    8464:	2004      	movs	r0, #4
    8466:	466a      	mov	r2, sp
    8468:	1c2b      	adds	r3, r5, #0
    846a:	4c08      	ldr	r4, [pc, #32]	; (848c <at_ble_pair_key_reply+0xa4>)
    846c:	47a0      	blx	r4
    846e:	2000      	movs	r0, #0
    8470:	b005      	add	sp, #20
    8472:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8474:	0000d825 	.word	0x0000d825
    8478:	20000038 	.word	0x20000038
    847c:	0000f139 	.word	0x0000f139
    8480:	0000f2c2 	.word	0x0000f2c2
    8484:	0000ed34 	.word	0x0000ed34
    8488:	0000f24c 	.word	0x0000f24c
    848c:	000095ed 	.word	0x000095ed

00008490 <at_ble_send_slave_sec_request>:
    8490:	b570      	push	{r4, r5, r6, lr}
    8492:	4b17      	ldr	r3, [pc, #92]	; (84f0 <at_ble_send_slave_sec_request+0x60>)
    8494:	1c0e      	adds	r6, r1, #0
    8496:	2100      	movs	r1, #0
    8498:	1c05      	adds	r5, r0, #0
    849a:	1c14      	adds	r4, r2, #0
    849c:	4798      	blx	r3
    849e:	2807      	cmp	r0, #7
    84a0:	d90b      	bls.n	84ba <at_ble_send_slave_sec_request+0x2a>
    84a2:	4c14      	ldr	r4, [pc, #80]	; (84f4 <at_ble_send_slave_sec_request+0x64>)
    84a4:	4914      	ldr	r1, [pc, #80]	; (84f8 <at_ble_send_slave_sec_request+0x68>)
    84a6:	22c5      	movs	r2, #197	; 0xc5
    84a8:	4b14      	ldr	r3, [pc, #80]	; (84fc <at_ble_send_slave_sec_request+0x6c>)
    84aa:	4815      	ldr	r0, [pc, #84]	; (8500 <at_ble_send_slave_sec_request+0x70>)
    84ac:	6825      	ldr	r5, [r4, #0]
    84ae:	47a8      	blx	r5
    84b0:	6823      	ldr	r3, [r4, #0]
    84b2:	4814      	ldr	r0, [pc, #80]	; (8504 <at_ble_send_slave_sec_request+0x74>)
    84b4:	4798      	blx	r3
    84b6:	2001      	movs	r0, #1
    84b8:	e018      	b.n	84ec <at_ble_send_slave_sec_request+0x5c>
    84ba:	2312      	movs	r3, #18
    84bc:	4358      	muls	r0, r3
    84be:	4b12      	ldr	r3, [pc, #72]	; (8508 <at_ble_send_slave_sec_request+0x78>)
    84c0:	5cc3      	ldrb	r3, [r0, r3]
    84c2:	2b01      	cmp	r3, #1
    84c4:	d00b      	beq.n	84de <at_ble_send_slave_sec_request+0x4e>
    84c6:	4c0b      	ldr	r4, [pc, #44]	; (84f4 <at_ble_send_slave_sec_request+0x64>)
    84c8:	490b      	ldr	r1, [pc, #44]	; (84f8 <at_ble_send_slave_sec_request+0x68>)
    84ca:	22cb      	movs	r2, #203	; 0xcb
    84cc:	4b0b      	ldr	r3, [pc, #44]	; (84fc <at_ble_send_slave_sec_request+0x6c>)
    84ce:	480c      	ldr	r0, [pc, #48]	; (8500 <at_ble_send_slave_sec_request+0x70>)
    84d0:	6825      	ldr	r5, [r4, #0]
    84d2:	47a8      	blx	r5
    84d4:	6823      	ldr	r3, [r4, #0]
    84d6:	480d      	ldr	r0, [pc, #52]	; (850c <at_ble_send_slave_sec_request+0x7c>)
    84d8:	4798      	blx	r3
    84da:	20e0      	movs	r0, #224	; 0xe0
    84dc:	e006      	b.n	84ec <at_ble_send_slave_sec_request+0x5c>
    84de:	00b1      	lsls	r1, r6, #2
    84e0:	430c      	orrs	r4, r1
    84e2:	1c28      	adds	r0, r5, #0
    84e4:	b2e1      	uxtb	r1, r4
    84e6:	4b0a      	ldr	r3, [pc, #40]	; (8510 <at_ble_send_slave_sec_request+0x80>)
    84e8:	4798      	blx	r3
    84ea:	2000      	movs	r0, #0
    84ec:	bd70      	pop	{r4, r5, r6, pc}
    84ee:	46c0      	nop			; (mov r8, r8)
    84f0:	00008d19 	.word	0x00008d19
    84f4:	20000038 	.word	0x20000038
    84f8:	0000f139 	.word	0x0000f139
    84fc:	0000f2d8 	.word	0x0000f2d8
    8500:	0000ed34 	.word	0x0000ed34
    8504:	0000f25b 	.word	0x0000f25b
    8508:	20001808 	.word	0x20001808
    850c:	0000f26b 	.word	0x0000f26b
    8510:	0000969d 	.word	0x0000969d

00008514 <at_ble_encryption_start>:
    8514:	b5f0      	push	{r4, r5, r6, r7, lr}
    8516:	260f      	movs	r6, #15
    8518:	b087      	sub	sp, #28
    851a:	ab02      	add	r3, sp, #8
    851c:	18f6      	adds	r6, r6, r3
    851e:	2308      	movs	r3, #8
    8520:	1c07      	adds	r7, r0, #0
    8522:	1e0c      	subs	r4, r1, #0
    8524:	9203      	str	r2, [sp, #12]
    8526:	7033      	strb	r3, [r6, #0]
    8528:	d02f      	beq.n	858a <at_ble_encryption_start+0x76>
    852a:	4d20      	ldr	r5, [pc, #128]	; (85ac <at_ble_encryption_start+0x98>)
    852c:	311a      	adds	r1, #26
    852e:	1c33      	adds	r3, r6, #0
    8530:	47a8      	blx	r5
    8532:	1e05      	subs	r5, r0, #0
    8534:	d12a      	bne.n	858c <at_ble_encryption_start+0x78>
    8536:	2212      	movs	r2, #18
    8538:	7833      	ldrb	r3, [r6, #0]
    853a:	4353      	muls	r3, r2
    853c:	4a1c      	ldr	r2, [pc, #112]	; (85b0 <at_ble_encryption_start+0x9c>)
    853e:	5c9b      	ldrb	r3, [r3, r2]
    8540:	2b00      	cmp	r3, #0
    8542:	d011      	beq.n	8568 <at_ble_encryption_start+0x54>
    8544:	2218      	movs	r2, #24
    8546:	4c1b      	ldr	r4, [pc, #108]	; (85b4 <at_ble_encryption_start+0xa0>)
    8548:	491b      	ldr	r1, [pc, #108]	; (85b8 <at_ble_encryption_start+0xa4>)
    854a:	32ff      	adds	r2, #255	; 0xff
    854c:	4b1b      	ldr	r3, [pc, #108]	; (85bc <at_ble_encryption_start+0xa8>)
    854e:	6825      	ldr	r5, [r4, #0]
    8550:	481b      	ldr	r0, [pc, #108]	; (85c0 <at_ble_encryption_start+0xac>)
    8552:	47a8      	blx	r5
    8554:	2212      	movs	r2, #18
    8556:	7833      	ldrb	r3, [r6, #0]
    8558:	481a      	ldr	r0, [pc, #104]	; (85c4 <at_ble_encryption_start+0xb0>)
    855a:	4353      	muls	r3, r2
    855c:	4a14      	ldr	r2, [pc, #80]	; (85b0 <at_ble_encryption_start+0x9c>)
    855e:	25e0      	movs	r5, #224	; 0xe0
    8560:	5c99      	ldrb	r1, [r3, r2]
    8562:	6823      	ldr	r3, [r4, #0]
    8564:	4798      	blx	r3
    8566:	e011      	b.n	858c <at_ble_encryption_start+0x78>
    8568:	1c21      	adds	r1, r4, #0
    856a:	221c      	movs	r2, #28
    856c:	4b16      	ldr	r3, [pc, #88]	; (85c8 <at_ble_encryption_start+0xb4>)
    856e:	4817      	ldr	r0, [pc, #92]	; (85cc <at_ble_encryption_start+0xb8>)
    8570:	4798      	blx	r3
    8572:	1c23      	adds	r3, r4, #0
    8574:	7ea1      	ldrb	r1, [r4, #26]
    8576:	8a22      	ldrh	r2, [r4, #16]
    8578:	9100      	str	r1, [sp, #0]
    857a:	9903      	ldr	r1, [sp, #12]
    857c:	3312      	adds	r3, #18
    857e:	9101      	str	r1, [sp, #4]
    8580:	1c38      	adds	r0, r7, #0
    8582:	1c21      	adds	r1, r4, #0
    8584:	4c12      	ldr	r4, [pc, #72]	; (85d0 <at_ble_encryption_start+0xbc>)
    8586:	47a0      	blx	r4
    8588:	e00c      	b.n	85a4 <at_ble_encryption_start+0x90>
    858a:	25cf      	movs	r5, #207	; 0xcf
    858c:	2290      	movs	r2, #144	; 0x90
    858e:	4c09      	ldr	r4, [pc, #36]	; (85b4 <at_ble_encryption_start+0xa0>)
    8590:	4909      	ldr	r1, [pc, #36]	; (85b8 <at_ble_encryption_start+0xa4>)
    8592:	4b0a      	ldr	r3, [pc, #40]	; (85bc <at_ble_encryption_start+0xa8>)
    8594:	480a      	ldr	r0, [pc, #40]	; (85c0 <at_ble_encryption_start+0xac>)
    8596:	0052      	lsls	r2, r2, #1
    8598:	6826      	ldr	r6, [r4, #0]
    859a:	47b0      	blx	r6
    859c:	6823      	ldr	r3, [r4, #0]
    859e:	480d      	ldr	r0, [pc, #52]	; (85d4 <at_ble_encryption_start+0xc0>)
    85a0:	1c29      	adds	r1, r5, #0
    85a2:	4798      	blx	r3
    85a4:	1c28      	adds	r0, r5, #0
    85a6:	b007      	add	sp, #28
    85a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    85aa:	46c0      	nop			; (mov r8, r8)
    85ac:	00008135 	.word	0x00008135
    85b0:	20001808 	.word	0x20001808
    85b4:	20000038 	.word	0x20000038
    85b8:	0000f139 	.word	0x0000f139
    85bc:	0000f28a 	.word	0x0000f28a
    85c0:	0000ed34 	.word	0x0000ed34
    85c4:	0000f27a 	.word	0x0000f27a
    85c8:	0000d7eb 	.word	0x0000d7eb
    85cc:	20001916 	.word	0x20001916
    85d0:	00009741 	.word	0x00009741
    85d4:	0000ee69 	.word	0x0000ee69

000085d8 <at_ble_encryption_request_reply>:
    85d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    85da:	b085      	sub	sp, #20
    85dc:	1c06      	adds	r6, r0, #0
    85de:	9103      	str	r1, [sp, #12]
    85e0:	1c17      	adds	r7, r2, #0
    85e2:	1e1d      	subs	r5, r3, #0
    85e4:	d014      	beq.n	8610 <at_ble_encryption_request_reply+0x38>
    85e6:	2a00      	cmp	r2, #0
    85e8:	d109      	bne.n	85fe <at_ble_encryption_request_reply+0x26>
    85ea:	7eab      	ldrb	r3, [r5, #26]
    85ec:	4c10      	ldr	r4, [pc, #64]	; (8630 <at_ble_encryption_request_reply+0x58>)
    85ee:	9300      	str	r3, [sp, #0]
    85f0:	1c30      	adds	r0, r6, #0
    85f2:	9903      	ldr	r1, [sp, #12]
    85f4:	1c3a      	adds	r2, r7, #0
    85f6:	1c2b      	adds	r3, r5, #0
    85f8:	47a0      	blx	r4
    85fa:	2400      	movs	r4, #0
    85fc:	e015      	b.n	862a <at_ble_encryption_request_reply+0x52>
    85fe:	1c19      	adds	r1, r3, #0
    8600:	4c0c      	ldr	r4, [pc, #48]	; (8634 <at_ble_encryption_request_reply+0x5c>)
    8602:	311a      	adds	r1, #26
    8604:	9a03      	ldr	r2, [sp, #12]
    8606:	2300      	movs	r3, #0
    8608:	47a0      	blx	r4
    860a:	1e04      	subs	r4, r0, #0
    860c:	d0ed      	beq.n	85ea <at_ble_encryption_request_reply+0x12>
    860e:	e000      	b.n	8612 <at_ble_encryption_request_reply+0x3a>
    8610:	24cf      	movs	r4, #207	; 0xcf
    8612:	223a      	movs	r2, #58	; 0x3a
    8614:	4d08      	ldr	r5, [pc, #32]	; (8638 <at_ble_encryption_request_reply+0x60>)
    8616:	4909      	ldr	r1, [pc, #36]	; (863c <at_ble_encryption_request_reply+0x64>)
    8618:	4b09      	ldr	r3, [pc, #36]	; (8640 <at_ble_encryption_request_reply+0x68>)
    861a:	480a      	ldr	r0, [pc, #40]	; (8644 <at_ble_encryption_request_reply+0x6c>)
    861c:	32ff      	adds	r2, #255	; 0xff
    861e:	682e      	ldr	r6, [r5, #0]
    8620:	47b0      	blx	r6
    8622:	682b      	ldr	r3, [r5, #0]
    8624:	4808      	ldr	r0, [pc, #32]	; (8648 <at_ble_encryption_request_reply+0x70>)
    8626:	1c21      	adds	r1, r4, #0
    8628:	4798      	blx	r3
    862a:	1c20      	adds	r0, r4, #0
    862c:	b005      	add	sp, #20
    862e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8630:	00009871 	.word	0x00009871
    8634:	00008135 	.word	0x00008135
    8638:	20000038 	.word	0x20000038
    863c:	0000f139 	.word	0x0000f139
    8640:	0000f2a2 	.word	0x0000f2a2
    8644:	0000ed34 	.word	0x0000ed34
    8648:	0000ee69 	.word	0x0000ee69

0000864c <fw_patch_download_cb>:
    864c:	b530      	push	{r4, r5, lr}
    864e:	4a0b      	ldr	r2, [pc, #44]	; (867c <fw_patch_download_cb+0x30>)
    8650:	490b      	ldr	r1, [pc, #44]	; (8680 <fw_patch_download_cb+0x34>)
    8652:	6813      	ldr	r3, [r2, #0]
    8654:	2b04      	cmp	r3, #4
    8656:	d101      	bne.n	865c <fw_patch_download_cb+0x10>
    8658:	2400      	movs	r4, #0
    865a:	600c      	str	r4, [r1, #0]
    865c:	3b01      	subs	r3, #1
    865e:	7800      	ldrb	r0, [r0, #0]
    8660:	00dd      	lsls	r5, r3, #3
    8662:	40a8      	lsls	r0, r5
    8664:	680c      	ldr	r4, [r1, #0]
    8666:	6013      	str	r3, [r2, #0]
    8668:	4320      	orrs	r0, r4
    866a:	6008      	str	r0, [r1, #0]
    866c:	2b00      	cmp	r3, #0
    866e:	d104      	bne.n	867a <fw_patch_download_cb+0x2e>
    8670:	2101      	movs	r1, #1
    8672:	4b04      	ldr	r3, [pc, #16]	; (8684 <fw_patch_download_cb+0x38>)
    8674:	7019      	strb	r1, [r3, #0]
    8676:	2304      	movs	r3, #4
    8678:	6013      	str	r3, [r2, #0]
    867a:	bd30      	pop	{r4, r5, pc}
    867c:	20000034 	.word	0x20000034
    8680:	2000039c 	.word	0x2000039c
    8684:	200003a0 	.word	0x200003a0

00008688 <write_32_to_BTLC1000>:
    8688:	b570      	push	{r4, r5, r6, lr}
    868a:	1c0d      	adds	r5, r1, #0
    868c:	2400      	movs	r4, #0
    868e:	4911      	ldr	r1, [pc, #68]	; (86d4 <write_32_to_BTLC1000+0x4c>)
    8690:	2802      	cmp	r0, #2
    8692:	d106      	bne.n	86a2 <write_32_to_BTLC1000+0x1a>
    8694:	2352      	movs	r3, #82	; 0x52
    8696:	700b      	strb	r3, [r1, #0]
    8698:	3305      	adds	r3, #5
    869a:	704b      	strb	r3, [r1, #1]
    869c:	3b36      	subs	r3, #54	; 0x36
    869e:	708b      	strb	r3, [r1, #2]
    86a0:	3403      	adds	r4, #3
    86a2:	2306      	movs	r3, #6
    86a4:	0e2e      	lsrs	r6, r5, #24
    86a6:	550b      	strb	r3, [r1, r4]
    86a8:	190b      	adds	r3, r1, r4
    86aa:	705e      	strb	r6, [r3, #1]
    86ac:	0c2e      	lsrs	r6, r5, #16
    86ae:	709e      	strb	r6, [r3, #2]
    86b0:	711d      	strb	r5, [r3, #4]
    86b2:	0a2e      	lsrs	r6, r5, #8
    86b4:	0e15      	lsrs	r5, r2, #24
    86b6:	715d      	strb	r5, [r3, #5]
    86b8:	0c15      	lsrs	r5, r2, #16
    86ba:	719d      	strb	r5, [r3, #6]
    86bc:	721a      	strb	r2, [r3, #8]
    86be:	0a15      	lsrs	r5, r2, #8
    86c0:	1c22      	adds	r2, r4, #0
    86c2:	70de      	strb	r6, [r3, #3]
    86c4:	71dd      	strb	r5, [r3, #7]
    86c6:	3209      	adds	r2, #9
    86c8:	4b03      	ldr	r3, [pc, #12]	; (86d8 <write_32_to_BTLC1000+0x50>)
    86ca:	4798      	blx	r3
    86cc:	4b03      	ldr	r3, [pc, #12]	; (86dc <write_32_to_BTLC1000+0x54>)
    86ce:	2002      	movs	r0, #2
    86d0:	4798      	blx	r3
    86d2:	bd70      	pop	{r4, r5, r6, pc}
    86d4:	20001970 	.word	0x20001970
    86d8:	0000195d 	.word	0x0000195d
    86dc:	00001b59 	.word	0x00001b59

000086e0 <patch_init>:
    86e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    86e2:	b085      	sub	sp, #20
    86e4:	2202      	movs	r2, #2
    86e6:	a803      	add	r0, sp, #12
    86e8:	4938      	ldr	r1, [pc, #224]	; (87cc <patch_init+0xec>)
    86ea:	4b39      	ldr	r3, [pc, #228]	; (87d0 <patch_init+0xf0>)
    86ec:	4798      	blx	r3
    86ee:	4e39      	ldr	r6, [pc, #228]	; (87d4 <patch_init+0xf4>)
    86f0:	7832      	ldrb	r2, [r6, #0]
    86f2:	2a01      	cmp	r2, #1
    86f4:	d002      	beq.n	86fc <patch_init+0x1c>
    86f6:	24fa      	movs	r4, #250	; 0xfa
    86f8:	00e4      	lsls	r4, r4, #3
    86fa:	e00c      	b.n	8716 <patch_init+0x36>
    86fc:	1c10      	adds	r0, r2, #0
    86fe:	a903      	add	r1, sp, #12
    8700:	4b35      	ldr	r3, [pc, #212]	; (87d8 <patch_init+0xf8>)
    8702:	4798      	blx	r3
    8704:	2800      	cmp	r0, #0
    8706:	d15e      	bne.n	87c6 <patch_init+0xe6>
    8708:	e7f5      	b.n	86f6 <patch_init+0x16>
    870a:	2001      	movs	r0, #1
    870c:	4b33      	ldr	r3, [pc, #204]	; (87dc <patch_init+0xfc>)
    870e:	3c01      	subs	r4, #1
    8710:	4798      	blx	r3
    8712:	2c00      	cmp	r4, #0
    8714:	d004      	beq.n	8720 <patch_init+0x40>
    8716:	4b32      	ldr	r3, [pc, #200]	; (87e0 <patch_init+0x100>)
    8718:	781a      	ldrb	r2, [r3, #0]
    871a:	9301      	str	r3, [sp, #4]
    871c:	2a00      	cmp	r2, #0
    871e:	d0f4      	beq.n	870a <patch_init+0x2a>
    8720:	9b01      	ldr	r3, [sp, #4]
    8722:	781b      	ldrb	r3, [r3, #0]
    8724:	2b00      	cmp	r3, #0
    8726:	d103      	bne.n	8730 <patch_init+0x50>
    8728:	4b2e      	ldr	r3, [pc, #184]	; (87e4 <patch_init+0x104>)
    872a:	4798      	blx	r3
    872c:	20d1      	movs	r0, #209	; 0xd1
    872e:	e04a      	b.n	87c6 <patch_init+0xe6>
    8730:	4b2d      	ldr	r3, [pc, #180]	; (87e8 <patch_init+0x108>)
    8732:	4d2a      	ldr	r5, [pc, #168]	; (87dc <patch_init+0xfc>)
    8734:	781b      	ldrb	r3, [r3, #0]
    8736:	4c2d      	ldr	r4, [pc, #180]	; (87ec <patch_init+0x10c>)
    8738:	2b01      	cmp	r3, #1
    873a:	d115      	bne.n	8768 <patch_init+0x88>
    873c:	7830      	ldrb	r0, [r6, #0]
    873e:	2801      	cmp	r0, #1
    8740:	d112      	bne.n	8768 <patch_init+0x88>
    8742:	492b      	ldr	r1, [pc, #172]	; (87f0 <patch_init+0x110>)
    8744:	4a2b      	ldr	r2, [pc, #172]	; (87f4 <patch_init+0x114>)
    8746:	47a0      	blx	r4
    8748:	7830      	ldrb	r0, [r6, #0]
    874a:	492b      	ldr	r1, [pc, #172]	; (87f8 <patch_init+0x118>)
    874c:	4a2b      	ldr	r2, [pc, #172]	; (87fc <patch_init+0x11c>)
    874e:	47a0      	blx	r4
    8750:	7830      	ldrb	r0, [r6, #0]
    8752:	492b      	ldr	r1, [pc, #172]	; (8800 <patch_init+0x120>)
    8754:	4a2b      	ldr	r2, [pc, #172]	; (8804 <patch_init+0x124>)
    8756:	47a0      	blx	r4
    8758:	7830      	ldrb	r0, [r6, #0]
    875a:	492b      	ldr	r1, [pc, #172]	; (8808 <patch_init+0x128>)
    875c:	2222      	movs	r2, #34	; 0x22
    875e:	47a0      	blx	r4
    8760:	4b2a      	ldr	r3, [pc, #168]	; (880c <patch_init+0x12c>)
    8762:	4798      	blx	r3
    8764:	20c8      	movs	r0, #200	; 0xc8
    8766:	47a8      	blx	r5
    8768:	7836      	ldrb	r6, [r6, #0]
    876a:	4929      	ldr	r1, [pc, #164]	; (8810 <patch_init+0x130>)
    876c:	1c30      	adds	r0, r6, #0
    876e:	4a29      	ldr	r2, [pc, #164]	; (8814 <patch_init+0x134>)
    8770:	47a0      	blx	r4
    8772:	4929      	ldr	r1, [pc, #164]	; (8818 <patch_init+0x138>)
    8774:	2203      	movs	r2, #3
    8776:	4b18      	ldr	r3, [pc, #96]	; (87d8 <patch_init+0xf8>)
    8778:	1c30      	adds	r0, r6, #0
    877a:	4798      	blx	r3
    877c:	2002      	movs	r0, #2
    877e:	47a8      	blx	r5
    8780:	4d26      	ldr	r5, [pc, #152]	; (881c <patch_init+0x13c>)
    8782:	4f27      	ldr	r7, [pc, #156]	; (8820 <patch_init+0x140>)
    8784:	3501      	adds	r5, #1
    8786:	4b27      	ldr	r3, [pc, #156]	; (8824 <patch_init+0x144>)
    8788:	4924      	ldr	r1, [pc, #144]	; (881c <patch_init+0x13c>)
    878a:	782a      	ldrb	r2, [r5, #0]
    878c:	18fb      	adds	r3, r7, r3
    878e:	5ccb      	ldrb	r3, [r1, r3]
    8790:	0212      	lsls	r2, r2, #8
    8792:	431a      	orrs	r2, r3
    8794:	786b      	ldrb	r3, [r5, #1]
    8796:	1c39      	adds	r1, r7, #0
    8798:	041b      	lsls	r3, r3, #16
    879a:	431a      	orrs	r2, r3
    879c:	78ab      	ldrb	r3, [r5, #2]
    879e:	1c30      	adds	r0, r6, #0
    87a0:	061b      	lsls	r3, r3, #24
    87a2:	431a      	orrs	r2, r3
    87a4:	47a0      	blx	r4
    87a6:	4b20      	ldr	r3, [pc, #128]	; (8828 <patch_init+0x148>)
    87a8:	3704      	adds	r7, #4
    87aa:	3504      	adds	r5, #4
    87ac:	429f      	cmp	r7, r3
    87ae:	d1ea      	bne.n	8786 <patch_init+0xa6>
    87b0:	2278      	movs	r2, #120	; 0x78
    87b2:	1c30      	adds	r0, r6, #0
    87b4:	491d      	ldr	r1, [pc, #116]	; (882c <patch_init+0x14c>)
    87b6:	47a0      	blx	r4
    87b8:	1c30      	adds	r0, r6, #0
    87ba:	4b1d      	ldr	r3, [pc, #116]	; (8830 <patch_init+0x150>)
    87bc:	4798      	blx	r3
    87be:	2302      	movs	r3, #2
    87c0:	2000      	movs	r0, #0
    87c2:	9a01      	ldr	r2, [sp, #4]
    87c4:	7013      	strb	r3, [r2, #0]
    87c6:	b005      	add	sp, #20
    87c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    87ca:	46c0      	nop			; (mov r8, r8)
    87cc:	0000f2f6 	.word	0x0000f2f6
    87d0:	0000d7eb 	.word	0x0000d7eb
    87d4:	20000005 	.word	0x20000005
    87d8:	0000195d 	.word	0x0000195d
    87dc:	00001b59 	.word	0x00001b59
    87e0:	200003a1 	.word	0x200003a1
    87e4:	00001b85 	.word	0x00001b85
    87e8:	20000004 	.word	0x20000004
    87ec:	00008689 	.word	0x00008689
    87f0:	4000b1a8 	.word	0x4000b1a8
    87f4:	02033f3f 	.word	0x02033f3f
    87f8:	4000b1ac 	.word	0x4000b1ac
    87fc:	3f3f0001 	.word	0x3f3f0001
    8800:	4000b048 	.word	0x4000b048
    8804:	00111133 	.word	0x00111133
    8808:	4000b044 	.word	0x4000b044
    880c:	00001b95 	.word	0x00001b95
    8810:	4000f408 	.word	0x4000f408
    8814:	00000c06 	.word	0x00000c06
    8818:	0000f2f8 	.word	0x0000f2f8
    881c:	0000f2fc 	.word	0x0000f2fc
    8820:	10005184 	.word	0x10005184
    8824:	efffae7c 	.word	0xefffae7c
    8828:	10006fcc 	.word	0x10006fcc
    882c:	4000f044 	.word	0x4000f044
    8830:	00008a4d 	.word	0x00008a4d

00008834 <interface_transfer_complete>:
    8834:	4b03      	ldr	r3, [pc, #12]	; (8844 <interface_transfer_complete+0x10>)
    8836:	781a      	ldrb	r2, [r3, #0]
    8838:	2a00      	cmp	r2, #0
    883a:	d0fb      	beq.n	8834 <interface_transfer_complete>
    883c:	2200      	movs	r2, #0
    883e:	701a      	strb	r2, [r3, #0]
    8840:	4770      	bx	lr
    8842:	46c0      	nop			; (mov r8, r8)
    8844:	200000d8 	.word	0x200000d8

00008848 <platform_interface_callback>:
    8848:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    884a:	4b69      	ldr	r3, [pc, #420]	; (89f0 <platform_interface_callback+0x1a8>)
    884c:	781a      	ldrb	r2, [r3, #0]
    884e:	2a02      	cmp	r2, #2
    8850:	d000      	beq.n	8854 <platform_interface_callback+0xc>
    8852:	e0bc      	b.n	89ce <platform_interface_callback+0x186>
    8854:	1c04      	adds	r4, r0, #0
    8856:	1843      	adds	r3, r0, r1
    8858:	9301      	str	r3, [sp, #4]
    885a:	9b01      	ldr	r3, [sp, #4]
    885c:	429c      	cmp	r4, r3
    885e:	d100      	bne.n	8862 <platform_interface_callback+0x1a>
    8860:	e0c4      	b.n	89ec <platform_interface_callback+0x1a4>
    8862:	4d64      	ldr	r5, [pc, #400]	; (89f4 <platform_interface_callback+0x1ac>)
    8864:	682b      	ldr	r3, [r5, #0]
    8866:	2b00      	cmp	r3, #0
    8868:	d112      	bne.n	8890 <platform_interface_callback+0x48>
    886a:	7822      	ldrb	r2, [r4, #0]
    886c:	2a05      	cmp	r2, #5
    886e:	d104      	bne.n	887a <platform_interface_callback+0x32>
    8870:	4961      	ldr	r1, [pc, #388]	; (89f8 <platform_interface_callback+0x1b0>)
    8872:	3a04      	subs	r2, #4
    8874:	602a      	str	r2, [r5, #0]
    8876:	700a      	strb	r2, [r1, #0]
    8878:	e007      	b.n	888a <platform_interface_callback+0x42>
    887a:	2a04      	cmp	r2, #4
    887c:	d000      	beq.n	8880 <platform_interface_callback+0x38>
    887e:	e0a4      	b.n	89ca <platform_interface_callback+0x182>
    8880:	2101      	movs	r1, #1
    8882:	3a02      	subs	r2, #2
    8884:	602a      	str	r2, [r5, #0]
    8886:	4a5c      	ldr	r2, [pc, #368]	; (89f8 <platform_interface_callback+0x1b0>)
    8888:	7011      	strb	r1, [r2, #0]
    888a:	4a5c      	ldr	r2, [pc, #368]	; (89fc <platform_interface_callback+0x1b4>)
    888c:	6013      	str	r3, [r2, #0]
    888e:	e09c      	b.n	89ca <platform_interface_callback+0x182>
    8890:	682b      	ldr	r3, [r5, #0]
    8892:	2b01      	cmp	r3, #1
    8894:	d15f      	bne.n	8956 <platform_interface_callback+0x10e>
    8896:	4a58      	ldr	r2, [pc, #352]	; (89f8 <platform_interface_callback+0x1b0>)
    8898:	7813      	ldrb	r3, [r2, #0]
    889a:	2b01      	cmp	r3, #1
    889c:	d131      	bne.n	8902 <platform_interface_callback+0xba>
    889e:	4857      	ldr	r0, [pc, #348]	; (89fc <platform_interface_callback+0x1b4>)
    88a0:	4957      	ldr	r1, [pc, #348]	; (8a00 <platform_interface_callback+0x1b8>)
    88a2:	6803      	ldr	r3, [r0, #0]
    88a4:	7826      	ldrb	r6, [r4, #0]
    88a6:	54ce      	strb	r6, [r1, r3]
    88a8:	3301      	adds	r3, #1
    88aa:	6003      	str	r3, [r0, #0]
    88ac:	2b08      	cmp	r3, #8
    88ae:	d000      	beq.n	88b2 <platform_interface_callback+0x6a>
    88b0:	e08b      	b.n	89ca <platform_interface_callback+0x182>
    88b2:	7848      	ldrb	r0, [r1, #1]
    88b4:	3b06      	subs	r3, #6
    88b6:	7013      	strb	r3, [r2, #0]
    88b8:	780b      	ldrb	r3, [r1, #0]
    88ba:	0200      	lsls	r0, r0, #8
    88bc:	4318      	orrs	r0, r3
    88be:	794b      	ldrb	r3, [r1, #5]
    88c0:	790a      	ldrb	r2, [r1, #4]
    88c2:	021b      	lsls	r3, r3, #8
    88c4:	4313      	orrs	r3, r2
    88c6:	79ca      	ldrb	r2, [r1, #7]
    88c8:	7989      	ldrb	r1, [r1, #6]
    88ca:	0212      	lsls	r2, r2, #8
    88cc:	430a      	orrs	r2, r1
    88ce:	4f4d      	ldr	r7, [pc, #308]	; (8a04 <platform_interface_callback+0x1bc>)
    88d0:	4e4d      	ldr	r6, [pc, #308]	; (8a08 <platform_interface_callback+0x1c0>)
    88d2:	494e      	ldr	r1, [pc, #312]	; (8a0c <platform_interface_callback+0x1c4>)
    88d4:	8038      	strh	r0, [r7, #0]
    88d6:	8033      	strh	r3, [r6, #0]
    88d8:	800a      	strh	r2, [r1, #0]
    88da:	d10b      	bne.n	88f4 <platform_interface_callback+0xac>
    88dc:	1c19      	adds	r1, r3, #0
    88de:	4b4c      	ldr	r3, [pc, #304]	; (8a10 <platform_interface_callback+0x1c8>)
    88e0:	4798      	blx	r3
    88e2:	1e03      	subs	r3, r0, #0
    88e4:	d104      	bne.n	88f0 <platform_interface_callback+0xa8>
    88e6:	8831      	ldrh	r1, [r6, #0]
    88e8:	8838      	ldrh	r0, [r7, #0]
    88ea:	1c1a      	adds	r2, r3, #0
    88ec:	4e49      	ldr	r6, [pc, #292]	; (8a14 <platform_interface_callback+0x1cc>)
    88ee:	47b0      	blx	r6
    88f0:	2300      	movs	r3, #0
    88f2:	602b      	str	r3, [r5, #0]
    88f4:	2296      	movs	r2, #150	; 0x96
    88f6:	4b48      	ldr	r3, [pc, #288]	; (8a18 <platform_interface_callback+0x1d0>)
    88f8:	0092      	lsls	r2, r2, #2
    88fa:	6819      	ldr	r1, [r3, #0]
    88fc:	1a52      	subs	r2, r2, r1
    88fe:	4943      	ldr	r1, [pc, #268]	; (8a0c <platform_interface_callback+0x1c4>)
    8900:	e045      	b.n	898e <platform_interface_callback+0x146>
    8902:	2b02      	cmp	r3, #2
    8904:	d161      	bne.n	89ca <platform_interface_callback+0x182>
    8906:	4944      	ldr	r1, [pc, #272]	; (8a18 <platform_interface_callback+0x1d0>)
    8908:	7820      	ldrb	r0, [r4, #0]
    890a:	680b      	ldr	r3, [r1, #0]
    890c:	4a43      	ldr	r2, [pc, #268]	; (8a1c <platform_interface_callback+0x1d4>)
    890e:	4e3f      	ldr	r6, [pc, #252]	; (8a0c <platform_interface_callback+0x1c4>)
    8910:	54d0      	strb	r0, [r2, r3]
    8912:	4a43      	ldr	r2, [pc, #268]	; (8a20 <platform_interface_callback+0x1d8>)
    8914:	8836      	ldrh	r6, [r6, #0]
    8916:	6812      	ldr	r2, [r2, #0]
    8918:	1c58      	adds	r0, r3, #1
    891a:	6008      	str	r0, [r1, #0]
    891c:	1a87      	subs	r7, r0, r2
    891e:	42b7      	cmp	r7, r6
    8920:	d153      	bne.n	89ca <platform_interface_callback+0x182>
    8922:	2600      	movs	r6, #0
    8924:	602e      	str	r6, [r5, #0]
    8926:	2503      	movs	r5, #3
    8928:	4228      	tst	r0, r5
    892a:	d002      	beq.n	8932 <platform_interface_callback+0xea>
    892c:	3305      	adds	r3, #5
    892e:	43ab      	bics	r3, r5
    8930:	600b      	str	r3, [r1, #0]
    8932:	4f34      	ldr	r7, [pc, #208]	; (8a04 <platform_interface_callback+0x1bc>)
    8934:	4e34      	ldr	r6, [pc, #208]	; (8a08 <platform_interface_callback+0x1c0>)
    8936:	4d39      	ldr	r5, [pc, #228]	; (8a1c <platform_interface_callback+0x1d4>)
    8938:	8838      	ldrh	r0, [r7, #0]
    893a:	8831      	ldrh	r1, [r6, #0]
    893c:	18aa      	adds	r2, r5, r2
    893e:	4b34      	ldr	r3, [pc, #208]	; (8a10 <platform_interface_callback+0x1c8>)
    8940:	4798      	blx	r3
    8942:	2800      	cmp	r0, #0
    8944:	d141      	bne.n	89ca <platform_interface_callback+0x182>
    8946:	4b36      	ldr	r3, [pc, #216]	; (8a20 <platform_interface_callback+0x1d8>)
    8948:	8838      	ldrh	r0, [r7, #0]
    894a:	681a      	ldr	r2, [r3, #0]
    894c:	4b2f      	ldr	r3, [pc, #188]	; (8a0c <platform_interface_callback+0x1c4>)
    894e:	8831      	ldrh	r1, [r6, #0]
    8950:	18aa      	adds	r2, r5, r2
    8952:	881b      	ldrh	r3, [r3, #0]
    8954:	e037      	b.n	89c6 <platform_interface_callback+0x17e>
    8956:	682b      	ldr	r3, [r5, #0]
    8958:	2b02      	cmp	r3, #2
    895a:	d136      	bne.n	89ca <platform_interface_callback+0x182>
    895c:	4926      	ldr	r1, [pc, #152]	; (89f8 <platform_interface_callback+0x1b0>)
    895e:	780b      	ldrb	r3, [r1, #0]
    8960:	2b01      	cmp	r3, #1
    8962:	d002      	beq.n	896a <platform_interface_callback+0x122>
    8964:	2b02      	cmp	r3, #2
    8966:	d01b      	beq.n	89a0 <platform_interface_callback+0x158>
    8968:	e02f      	b.n	89ca <platform_interface_callback+0x182>
    896a:	4824      	ldr	r0, [pc, #144]	; (89fc <platform_interface_callback+0x1b4>)
    896c:	4a24      	ldr	r2, [pc, #144]	; (8a00 <platform_interface_callback+0x1b8>)
    896e:	6803      	ldr	r3, [r0, #0]
    8970:	7825      	ldrb	r5, [r4, #0]
    8972:	54d5      	strb	r5, [r2, r3]
    8974:	3301      	adds	r3, #1
    8976:	6003      	str	r3, [r0, #0]
    8978:	2b02      	cmp	r3, #2
    897a:	d126      	bne.n	89ca <platform_interface_callback+0x182>
    897c:	700b      	strb	r3, [r1, #0]
    897e:	7853      	ldrb	r3, [r2, #1]
    8980:	2296      	movs	r2, #150	; 0x96
    8982:	4922      	ldr	r1, [pc, #136]	; (8a0c <platform_interface_callback+0x1c4>)
    8984:	0092      	lsls	r2, r2, #2
    8986:	700b      	strb	r3, [r1, #0]
    8988:	4b23      	ldr	r3, [pc, #140]	; (8a18 <platform_interface_callback+0x1d0>)
    898a:	6818      	ldr	r0, [r3, #0]
    898c:	1a12      	subs	r2, r2, r0
    898e:	8809      	ldrh	r1, [r1, #0]
    8990:	428a      	cmp	r2, r1
    8992:	d201      	bcs.n	8998 <platform_interface_callback+0x150>
    8994:	2200      	movs	r2, #0
    8996:	601a      	str	r2, [r3, #0]
    8998:	681a      	ldr	r2, [r3, #0]
    899a:	4b21      	ldr	r3, [pc, #132]	; (8a20 <platform_interface_callback+0x1d8>)
    899c:	601a      	str	r2, [r3, #0]
    899e:	e014      	b.n	89ca <platform_interface_callback+0x182>
    89a0:	491d      	ldr	r1, [pc, #116]	; (8a18 <platform_interface_callback+0x1d0>)
    89a2:	7822      	ldrb	r2, [r4, #0]
    89a4:	680b      	ldr	r3, [r1, #0]
    89a6:	481d      	ldr	r0, [pc, #116]	; (8a1c <platform_interface_callback+0x1d4>)
    89a8:	54c2      	strb	r2, [r0, r3]
    89aa:	3301      	adds	r3, #1
    89ac:	600b      	str	r3, [r1, #0]
    89ae:	4a1c      	ldr	r2, [pc, #112]	; (8a20 <platform_interface_callback+0x1d8>)
    89b0:	4916      	ldr	r1, [pc, #88]	; (8a0c <platform_interface_callback+0x1c4>)
    89b2:	6812      	ldr	r2, [r2, #0]
    89b4:	8809      	ldrh	r1, [r1, #0]
    89b6:	1a9b      	subs	r3, r3, r2
    89b8:	428b      	cmp	r3, r1
    89ba:	d106      	bne.n	89ca <platform_interface_callback+0x182>
    89bc:	2100      	movs	r1, #0
    89be:	1882      	adds	r2, r0, r2
    89c0:	20bb      	movs	r0, #187	; 0xbb
    89c2:	6029      	str	r1, [r5, #0]
    89c4:	1c01      	adds	r1, r0, #0
    89c6:	4d13      	ldr	r5, [pc, #76]	; (8a14 <platform_interface_callback+0x1cc>)
    89c8:	47a8      	blx	r5
    89ca:	3401      	adds	r4, #1
    89cc:	e745      	b.n	885a <platform_interface_callback+0x12>
    89ce:	7819      	ldrb	r1, [r3, #0]
    89d0:	b2c9      	uxtb	r1, r1
    89d2:	2901      	cmp	r1, #1
    89d4:	d102      	bne.n	89dc <platform_interface_callback+0x194>
    89d6:	4b13      	ldr	r3, [pc, #76]	; (8a24 <platform_interface_callback+0x1dc>)
    89d8:	4798      	blx	r3
    89da:	e007      	b.n	89ec <platform_interface_callback+0x1a4>
    89dc:	781a      	ldrb	r2, [r3, #0]
    89de:	2a00      	cmp	r2, #0
    89e0:	d104      	bne.n	89ec <platform_interface_callback+0x1a4>
    89e2:	7802      	ldrb	r2, [r0, #0]
    89e4:	2a5a      	cmp	r2, #90	; 0x5a
    89e6:	d101      	bne.n	89ec <platform_interface_callback+0x1a4>
    89e8:	3a59      	subs	r2, #89	; 0x59
    89ea:	701a      	strb	r2, [r3, #0]
    89ec:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    89ee:	46c0      	nop			; (mov r8, r8)
    89f0:	200003a1 	.word	0x200003a1
    89f4:	200003a8 	.word	0x200003a8
    89f8:	200003a4 	.word	0x200003a4
    89fc:	2000061c 	.word	0x2000061c
    8a00:	2000060a 	.word	0x2000060a
    8a04:	200003b0 	.word	0x200003b0
    8a08:	200003a2 	.word	0x200003a2
    8a0c:	20000618 	.word	0x20000618
    8a10:	00006ae9 	.word	0x00006ae9
    8a14:	00006a7d 	.word	0x00006a7d
    8a18:	20000614 	.word	0x20000614
    8a1c:	200003b2 	.word	0x200003b2
    8a20:	200003ac 	.word	0x200003ac
    8a24:	0000864d 	.word	0x0000864d

00008a28 <interface_send>:
    8a28:	b538      	push	{r3, r4, r5, lr}
    8a2a:	1c05      	adds	r5, r0, #0
    8a2c:	1c0c      	adds	r4, r1, #0
    8a2e:	4b04      	ldr	r3, [pc, #16]	; (8a40 <interface_send+0x18>)
    8a30:	4798      	blx	r3
    8a32:	4b04      	ldr	r3, [pc, #16]	; (8a44 <interface_send+0x1c>)
    8a34:	1c29      	adds	r1, r5, #0
    8a36:	7818      	ldrb	r0, [r3, #0]
    8a38:	1c22      	adds	r2, r4, #0
    8a3a:	4b03      	ldr	r3, [pc, #12]	; (8a48 <interface_send+0x20>)
    8a3c:	4798      	blx	r3
    8a3e:	bd38      	pop	{r3, r4, r5, pc}
    8a40:	00001899 	.word	0x00001899
    8a44:	20000005 	.word	0x20000005
    8a48:	0000195d 	.word	0x0000195d

00008a4c <patchFuncAndVars>:
    8a4c:	b538      	push	{r3, r4, r5, lr}
    8a4e:	1c05      	adds	r5, r0, #0
    8a50:	4c32      	ldr	r4, [pc, #200]	; (8b1c <patchFuncAndVars+0xd0>)
    8a52:	4933      	ldr	r1, [pc, #204]	; (8b20 <patchFuncAndVars+0xd4>)
    8a54:	4a33      	ldr	r2, [pc, #204]	; (8b24 <patchFuncAndVars+0xd8>)
    8a56:	47a0      	blx	r4
    8a58:	1c28      	adds	r0, r5, #0
    8a5a:	4933      	ldr	r1, [pc, #204]	; (8b28 <patchFuncAndVars+0xdc>)
    8a5c:	4a33      	ldr	r2, [pc, #204]	; (8b2c <patchFuncAndVars+0xe0>)
    8a5e:	47a0      	blx	r4
    8a60:	1c28      	adds	r0, r5, #0
    8a62:	4933      	ldr	r1, [pc, #204]	; (8b30 <patchFuncAndVars+0xe4>)
    8a64:	4a33      	ldr	r2, [pc, #204]	; (8b34 <patchFuncAndVars+0xe8>)
    8a66:	47a0      	blx	r4
    8a68:	1c28      	adds	r0, r5, #0
    8a6a:	4933      	ldr	r1, [pc, #204]	; (8b38 <patchFuncAndVars+0xec>)
    8a6c:	4a33      	ldr	r2, [pc, #204]	; (8b3c <patchFuncAndVars+0xf0>)
    8a6e:	47a0      	blx	r4
    8a70:	1c28      	adds	r0, r5, #0
    8a72:	4933      	ldr	r1, [pc, #204]	; (8b40 <patchFuncAndVars+0xf4>)
    8a74:	4a33      	ldr	r2, [pc, #204]	; (8b44 <patchFuncAndVars+0xf8>)
    8a76:	47a0      	blx	r4
    8a78:	1c28      	adds	r0, r5, #0
    8a7a:	4933      	ldr	r1, [pc, #204]	; (8b48 <patchFuncAndVars+0xfc>)
    8a7c:	4a33      	ldr	r2, [pc, #204]	; (8b4c <patchFuncAndVars+0x100>)
    8a7e:	47a0      	blx	r4
    8a80:	1c28      	adds	r0, r5, #0
    8a82:	4933      	ldr	r1, [pc, #204]	; (8b50 <patchFuncAndVars+0x104>)
    8a84:	4a33      	ldr	r2, [pc, #204]	; (8b54 <patchFuncAndVars+0x108>)
    8a86:	47a0      	blx	r4
    8a88:	1c28      	adds	r0, r5, #0
    8a8a:	4933      	ldr	r1, [pc, #204]	; (8b58 <patchFuncAndVars+0x10c>)
    8a8c:	4a33      	ldr	r2, [pc, #204]	; (8b5c <patchFuncAndVars+0x110>)
    8a8e:	47a0      	blx	r4
    8a90:	1c28      	adds	r0, r5, #0
    8a92:	4933      	ldr	r1, [pc, #204]	; (8b60 <patchFuncAndVars+0x114>)
    8a94:	4a33      	ldr	r2, [pc, #204]	; (8b64 <patchFuncAndVars+0x118>)
    8a96:	47a0      	blx	r4
    8a98:	1c28      	adds	r0, r5, #0
    8a9a:	4933      	ldr	r1, [pc, #204]	; (8b68 <patchFuncAndVars+0x11c>)
    8a9c:	4a33      	ldr	r2, [pc, #204]	; (8b6c <patchFuncAndVars+0x120>)
    8a9e:	47a0      	blx	r4
    8aa0:	1c28      	adds	r0, r5, #0
    8aa2:	4933      	ldr	r1, [pc, #204]	; (8b70 <patchFuncAndVars+0x124>)
    8aa4:	4a33      	ldr	r2, [pc, #204]	; (8b74 <patchFuncAndVars+0x128>)
    8aa6:	47a0      	blx	r4
    8aa8:	1c28      	adds	r0, r5, #0
    8aaa:	4933      	ldr	r1, [pc, #204]	; (8b78 <patchFuncAndVars+0x12c>)
    8aac:	4a33      	ldr	r2, [pc, #204]	; (8b7c <patchFuncAndVars+0x130>)
    8aae:	47a0      	blx	r4
    8ab0:	1c28      	adds	r0, r5, #0
    8ab2:	4933      	ldr	r1, [pc, #204]	; (8b80 <patchFuncAndVars+0x134>)
    8ab4:	4a33      	ldr	r2, [pc, #204]	; (8b84 <patchFuncAndVars+0x138>)
    8ab6:	47a0      	blx	r4
    8ab8:	1c28      	adds	r0, r5, #0
    8aba:	4933      	ldr	r1, [pc, #204]	; (8b88 <patchFuncAndVars+0x13c>)
    8abc:	4a33      	ldr	r2, [pc, #204]	; (8b8c <patchFuncAndVars+0x140>)
    8abe:	47a0      	blx	r4
    8ac0:	1c28      	adds	r0, r5, #0
    8ac2:	4933      	ldr	r1, [pc, #204]	; (8b90 <patchFuncAndVars+0x144>)
    8ac4:	4a33      	ldr	r2, [pc, #204]	; (8b94 <patchFuncAndVars+0x148>)
    8ac6:	47a0      	blx	r4
    8ac8:	1c28      	adds	r0, r5, #0
    8aca:	4933      	ldr	r1, [pc, #204]	; (8b98 <patchFuncAndVars+0x14c>)
    8acc:	4a33      	ldr	r2, [pc, #204]	; (8b9c <patchFuncAndVars+0x150>)
    8ace:	47a0      	blx	r4
    8ad0:	1c28      	adds	r0, r5, #0
    8ad2:	4933      	ldr	r1, [pc, #204]	; (8ba0 <patchFuncAndVars+0x154>)
    8ad4:	4a33      	ldr	r2, [pc, #204]	; (8ba4 <patchFuncAndVars+0x158>)
    8ad6:	47a0      	blx	r4
    8ad8:	1c28      	adds	r0, r5, #0
    8ada:	4933      	ldr	r1, [pc, #204]	; (8ba8 <patchFuncAndVars+0x15c>)
    8adc:	4a33      	ldr	r2, [pc, #204]	; (8bac <patchFuncAndVars+0x160>)
    8ade:	47a0      	blx	r4
    8ae0:	4a33      	ldr	r2, [pc, #204]	; (8bb0 <patchFuncAndVars+0x164>)
    8ae2:	1c28      	adds	r0, r5, #0
    8ae4:	4933      	ldr	r1, [pc, #204]	; (8bb4 <patchFuncAndVars+0x168>)
    8ae6:	47a0      	blx	r4
    8ae8:	4b33      	ldr	r3, [pc, #204]	; (8bb8 <patchFuncAndVars+0x16c>)
    8aea:	781a      	ldrb	r2, [r3, #0]
    8aec:	2a01      	cmp	r2, #1
    8aee:	d102      	bne.n	8af6 <patchFuncAndVars+0xaa>
    8af0:	1c28      	adds	r0, r5, #0
    8af2:	4932      	ldr	r1, [pc, #200]	; (8bbc <patchFuncAndVars+0x170>)
    8af4:	47a0      	blx	r4
    8af6:	1c28      	adds	r0, r5, #0
    8af8:	4931      	ldr	r1, [pc, #196]	; (8bc0 <patchFuncAndVars+0x174>)
    8afa:	2201      	movs	r2, #1
    8afc:	47a0      	blx	r4
    8afe:	1c28      	adds	r0, r5, #0
    8b00:	4930      	ldr	r1, [pc, #192]	; (8bc4 <patchFuncAndVars+0x178>)
    8b02:	2201      	movs	r2, #1
    8b04:	47a0      	blx	r4
    8b06:	1c28      	adds	r0, r5, #0
    8b08:	492f      	ldr	r1, [pc, #188]	; (8bc8 <patchFuncAndVars+0x17c>)
    8b0a:	2204      	movs	r2, #4
    8b0c:	47a0      	blx	r4
    8b0e:	2202      	movs	r2, #2
    8b10:	1c28      	adds	r0, r5, #0
    8b12:	492e      	ldr	r1, [pc, #184]	; (8bcc <patchFuncAndVars+0x180>)
    8b14:	32ff      	adds	r2, #255	; 0xff
    8b16:	47a0      	blx	r4
    8b18:	bd38      	pop	{r3, r4, r5, pc}
    8b1a:	46c0      	nop			; (mov r8, r8)
    8b1c:	00008689 	.word	0x00008689
    8b20:	100401c0 	.word	0x100401c0
    8b24:	1000670b 	.word	0x1000670b
    8b28:	1004000c 	.word	0x1004000c
    8b2c:	100052e1 	.word	0x100052e1
    8b30:	10040010 	.word	0x10040010
    8b34:	100053ad 	.word	0x100053ad
    8b38:	1004004c 	.word	0x1004004c
    8b3c:	10005419 	.word	0x10005419
    8b40:	10040034 	.word	0x10040034
    8b44:	10005543 	.word	0x10005543
    8b48:	10040068 	.word	0x10040068
    8b4c:	1000582d 	.word	0x1000582d
    8b50:	10040088 	.word	0x10040088
    8b54:	10005935 	.word	0x10005935
    8b58:	100400bc 	.word	0x100400bc
    8b5c:	10005a39 	.word	0x10005a39
    8b60:	100400e4 	.word	0x100400e4
    8b64:	10005b59 	.word	0x10005b59
    8b68:	100400e8 	.word	0x100400e8
    8b6c:	10005d79 	.word	0x10005d79
    8b70:	100400ec 	.word	0x100400ec
    8b74:	10005e2d 	.word	0x10005e2d
    8b78:	1004010c 	.word	0x1004010c
    8b7c:	10005fbd 	.word	0x10005fbd
    8b80:	10040154 	.word	0x10040154
    8b84:	10006199 	.word	0x10006199
    8b88:	10040160 	.word	0x10040160
    8b8c:	10006249 	.word	0x10006249
    8b90:	10040174 	.word	0x10040174
    8b94:	100063d1 	.word	0x100063d1
    8b98:	10040210 	.word	0x10040210
    8b9c:	100069d9 	.word	0x100069d9
    8ba0:	10040038 	.word	0x10040038
    8ba4:	100056fb 	.word	0x100056fb
    8ba8:	10000004 	.word	0x10000004
    8bac:	10005767 	.word	0x10005767
    8bb0:	100056d7 	.word	0x100056d7
    8bb4:	1000003c 	.word	0x1000003c
    8bb8:	20000004 	.word	0x20000004
    8bbc:	10006f70 	.word	0x10006f70
    8bc0:	10040168 	.word	0x10040168
    8bc4:	10006f14 	.word	0x10006f14
    8bc8:	10006f18 	.word	0x10006f18
    8bcc:	10040000 	.word	0x10040000

00008bd0 <__printingNullFun>:
    8bd0:	b40f      	push	{r0, r1, r2, r3}
    8bd2:	2000      	movs	r0, #0
    8bd4:	b004      	add	sp, #16
    8bd6:	4770      	bx	lr

00008bd8 <gapc_get_dev_info_cfm.constprop.1>:
    8bd8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8bda:	4b47      	ldr	r3, [pc, #284]	; (8cf8 <gapc_get_dev_info_cfm.constprop.1+0x120>)
    8bdc:	4a47      	ldr	r2, [pc, #284]	; (8cfc <gapc_get_dev_info_cfm.constprop.1+0x124>)
    8bde:	781c      	ldrb	r4, [r3, #0]
    8be0:	2300      	movs	r3, #0
    8be2:	2c02      	cmp	r4, #2
    8be4:	d107      	bne.n	8bf6 <gapc_get_dev_info_cfm.constprop.1+0x1e>
    8be6:	6813      	ldr	r3, [r2, #0]
    8be8:	3450      	adds	r4, #80	; 0x50
    8bea:	701c      	strb	r4, [r3, #0]
    8bec:	3405      	adds	r4, #5
    8bee:	705c      	strb	r4, [r3, #1]
    8bf0:	3c36      	subs	r4, #54	; 0x36
    8bf2:	709c      	strb	r4, [r3, #2]
    8bf4:	2303      	movs	r3, #3
    8bf6:	6814      	ldr	r4, [r2, #0]
    8bf8:	2205      	movs	r2, #5
    8bfa:	250b      	movs	r5, #11
    8bfc:	54e2      	strb	r2, [r4, r3]
    8bfe:	1c5a      	adds	r2, r3, #1
    8c00:	54a5      	strb	r5, [r4, r2]
    8c02:	1c9a      	adds	r2, r3, #2
    8c04:	3503      	adds	r5, #3
    8c06:	54a5      	strb	r5, [r4, r2]
    8c08:	1cda      	adds	r2, r3, #3
    8c0a:	3529      	adds	r5, #41	; 0x29
    8c0c:	54a5      	strb	r5, [r4, r2]
    8c0e:	1d1a      	adds	r2, r3, #4
    8c10:	54a1      	strb	r1, [r4, r2]
    8c12:	2110      	movs	r1, #16
    8c14:	1d5a      	adds	r2, r3, #5
    8c16:	1c1e      	adds	r6, r3, #0
    8c18:	54a1      	strb	r1, [r4, r2]
    8c1a:	1c1d      	adds	r5, r3, #0
    8c1c:	2200      	movs	r2, #0
    8c1e:	1d99      	adds	r1, r3, #6
    8c20:	1ddf      	adds	r7, r3, #7
    8c22:	3608      	adds	r6, #8
    8c24:	5462      	strb	r2, [r4, r1]
    8c26:	19e7      	adds	r7, r4, r7
    8c28:	3103      	adds	r1, #3
    8c2a:	19a6      	adds	r6, r4, r6
    8c2c:	350a      	adds	r5, #10
    8c2e:	703a      	strb	r2, [r7, #0]
    8c30:	7032      	strb	r2, [r6, #0]
    8c32:	5460      	strb	r0, [r4, r1]
    8c34:	3102      	adds	r1, #2
    8c36:	5562      	strb	r2, [r4, r5]
    8c38:	2801      	cmp	r0, #1
    8c3a:	d03e      	beq.n	8cba <gapc_get_dev_info_cfm.constprop.1+0xe2>
    8c3c:	4290      	cmp	r0, r2
    8c3e:	d026      	beq.n	8c8e <gapc_get_dev_info_cfm.constprop.1+0xb6>
    8c40:	2802      	cmp	r0, #2
    8c42:	d144      	bne.n	8cce <gapc_get_dev_info_cfm.constprop.1+0xf6>
    8c44:	4a2e      	ldr	r2, [pc, #184]	; (8d00 <gapc_get_dev_info_cfm.constprop.1+0x128>)
    8c46:	1c10      	adds	r0, r2, #0
    8c48:	30ce      	adds	r0, #206	; 0xce
    8c4a:	8805      	ldrh	r5, [r0, #0]
    8c4c:	5465      	strb	r5, [r4, r1]
    8c4e:	1c1d      	adds	r5, r3, #0
    8c50:	8801      	ldrh	r1, [r0, #0]
    8c52:	350c      	adds	r5, #12
    8c54:	0a09      	lsrs	r1, r1, #8
    8c56:	5561      	strb	r1, [r4, r5]
    8c58:	1c11      	adds	r1, r2, #0
    8c5a:	1c18      	adds	r0, r3, #0
    8c5c:	31d0      	adds	r1, #208	; 0xd0
    8c5e:	880d      	ldrh	r5, [r1, #0]
    8c60:	300d      	adds	r0, #13
    8c62:	5425      	strb	r5, [r4, r0]
    8c64:	8809      	ldrh	r1, [r1, #0]
    8c66:	3001      	adds	r0, #1
    8c68:	0a09      	lsrs	r1, r1, #8
    8c6a:	5421      	strb	r1, [r4, r0]
    8c6c:	1c11      	adds	r1, r2, #0
    8c6e:	31d2      	adds	r1, #210	; 0xd2
    8c70:	880d      	ldrh	r5, [r1, #0]
    8c72:	3001      	adds	r0, #1
    8c74:	5425      	strb	r5, [r4, r0]
    8c76:	8809      	ldrh	r1, [r1, #0]
    8c78:	3001      	adds	r0, #1
    8c7a:	0a09      	lsrs	r1, r1, #8
    8c7c:	5421      	strb	r1, [r4, r0]
    8c7e:	1c19      	adds	r1, r3, #0
    8c80:	32d4      	adds	r2, #212	; 0xd4
    8c82:	8810      	ldrh	r0, [r2, #0]
    8c84:	3111      	adds	r1, #17
    8c86:	5460      	strb	r0, [r4, r1]
    8c88:	3312      	adds	r3, #18
    8c8a:	3102      	adds	r1, #2
    8c8c:	e01c      	b.n	8cc8 <gapc_get_dev_info_cfm.constprop.1+0xf0>
    8c8e:	4d1c      	ldr	r5, [pc, #112]	; (8d00 <gapc_get_dev_info_cfm.constprop.1+0x128>)
    8c90:	35aa      	adds	r5, #170	; 0xaa
    8c92:	882a      	ldrh	r2, [r5, #0]
    8c94:	5462      	strb	r2, [r4, r1]
    8c96:	1c1a      	adds	r2, r3, #0
    8c98:	320d      	adds	r2, #13
    8c9a:	9201      	str	r2, [sp, #4]
    8c9c:	882a      	ldrh	r2, [r5, #0]
    8c9e:	330c      	adds	r3, #12
    8ca0:	0a12      	lsrs	r2, r2, #8
    8ca2:	54e2      	strb	r2, [r4, r3]
    8ca4:	9b01      	ldr	r3, [sp, #4]
    8ca6:	4917      	ldr	r1, [pc, #92]	; (8d04 <gapc_get_dev_info_cfm.constprop.1+0x12c>)
    8ca8:	18e0      	adds	r0, r4, r3
    8caa:	882a      	ldrh	r2, [r5, #0]
    8cac:	4b16      	ldr	r3, [pc, #88]	; (8d08 <gapc_get_dev_info_cfm.constprop.1+0x130>)
    8cae:	4798      	blx	r3
    8cb0:	8829      	ldrh	r1, [r5, #0]
    8cb2:	9b01      	ldr	r3, [sp, #4]
    8cb4:	1859      	adds	r1, r3, r1
    8cb6:	b289      	uxth	r1, r1
    8cb8:	e009      	b.n	8cce <gapc_get_dev_info_cfm.constprop.1+0xf6>
    8cba:	4a11      	ldr	r2, [pc, #68]	; (8d00 <gapc_get_dev_info_cfm.constprop.1+0x128>)
    8cbc:	32cc      	adds	r2, #204	; 0xcc
    8cbe:	8810      	ldrh	r0, [r2, #0]
    8cc0:	5460      	strb	r0, [r4, r1]
    8cc2:	1c19      	adds	r1, r3, #0
    8cc4:	330c      	adds	r3, #12
    8cc6:	310d      	adds	r1, #13
    8cc8:	8812      	ldrh	r2, [r2, #0]
    8cca:	0a12      	lsrs	r2, r2, #8
    8ccc:	54e2      	strb	r2, [r4, r3]
    8cce:	4b0a      	ldr	r3, [pc, #40]	; (8cf8 <gapc_get_dev_info_cfm.constprop.1+0x120>)
    8cd0:	781b      	ldrb	r3, [r3, #0]
    8cd2:	2b02      	cmp	r3, #2
    8cd4:	d102      	bne.n	8cdc <gapc_get_dev_info_cfm.constprop.1+0x104>
    8cd6:	1c0b      	adds	r3, r1, #0
    8cd8:	3b0c      	subs	r3, #12
    8cda:	e001      	b.n	8ce0 <gapc_get_dev_info_cfm.constprop.1+0x108>
    8cdc:	1c0b      	adds	r3, r1, #0
    8cde:	3b09      	subs	r3, #9
    8ce0:	703b      	strb	r3, [r7, #0]
    8ce2:	121b      	asrs	r3, r3, #8
    8ce4:	7033      	strb	r3, [r6, #0]
    8ce6:	1c20      	adds	r0, r4, #0
    8ce8:	4b08      	ldr	r3, [pc, #32]	; (8d0c <gapc_get_dev_info_cfm.constprop.1+0x134>)
    8cea:	4798      	blx	r3
    8cec:	4b08      	ldr	r3, [pc, #32]	; (8d10 <gapc_get_dev_info_cfm.constprop.1+0x138>)
    8cee:	4798      	blx	r3
    8cf0:	4b08      	ldr	r3, [pc, #32]	; (8d14 <gapc_get_dev_info_cfm.constprop.1+0x13c>)
    8cf2:	4798      	blx	r3
    8cf4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    8cf6:	46c0      	nop			; (mov r8, r8)
    8cf8:	20000005 	.word	0x20000005
    8cfc:	00011148 	.word	0x00011148
    8d00:	20001898 	.word	0x20001898
    8d04:	20001944 	.word	0x20001944
    8d08:	0000d7eb 	.word	0x0000d7eb
    8d0c:	00008a29 	.word	0x00008a29
    8d10:	00008835 	.word	0x00008835
    8d14:	00001895 	.word	0x00001895

00008d18 <check_ConnData_idx_role>:
    8d18:	4b0c      	ldr	r3, [pc, #48]	; (8d4c <check_ConnData_idx_role+0x34>)
    8d1a:	b570      	push	{r4, r5, r6, lr}
    8d1c:	1c04      	adds	r4, r0, #0
    8d1e:	2008      	movs	r0, #8
    8d20:	429c      	cmp	r4, r3
    8d22:	d011      	beq.n	8d48 <check_ConnData_idx_role+0x30>
    8d24:	2300      	movs	r3, #0
    8d26:	2212      	movs	r2, #18
    8d28:	435a      	muls	r2, r3
    8d2a:	4d09      	ldr	r5, [pc, #36]	; (8d50 <check_ConnData_idx_role+0x38>)
    8d2c:	b2d8      	uxtb	r0, r3
    8d2e:	1956      	adds	r6, r2, r5
    8d30:	8976      	ldrh	r6, [r6, #10]
    8d32:	42a6      	cmp	r6, r4
    8d34:	d104      	bne.n	8d40 <check_ConnData_idx_role+0x28>
    8d36:	2900      	cmp	r1, #0
    8d38:	d006      	beq.n	8d48 <check_ConnData_idx_role+0x30>
    8d3a:	5d53      	ldrb	r3, [r2, r5]
    8d3c:	700b      	strb	r3, [r1, #0]
    8d3e:	e003      	b.n	8d48 <check_ConnData_idx_role+0x30>
    8d40:	3301      	adds	r3, #1
    8d42:	2b08      	cmp	r3, #8
    8d44:	d1ef      	bne.n	8d26 <check_ConnData_idx_role+0xe>
    8d46:	1c18      	adds	r0, r3, #0
    8d48:	bd70      	pop	{r4, r5, r6, pc}
    8d4a:	46c0      	nop			; (mov r8, r8)
    8d4c:	0000ffff 	.word	0x0000ffff
    8d50:	20001808 	.word	0x20001808

00008d54 <check_ConnData_emptyEntry>:
    8d54:	2300      	movs	r3, #0
    8d56:	2212      	movs	r2, #18
    8d58:	435a      	muls	r2, r3
    8d5a:	4906      	ldr	r1, [pc, #24]	; (8d74 <check_ConnData_emptyEntry+0x20>)
    8d5c:	b2d8      	uxtb	r0, r3
    8d5e:	1852      	adds	r2, r2, r1
    8d60:	8951      	ldrh	r1, [r2, #10]
    8d62:	4a05      	ldr	r2, [pc, #20]	; (8d78 <check_ConnData_emptyEntry+0x24>)
    8d64:	4291      	cmp	r1, r2
    8d66:	d003      	beq.n	8d70 <check_ConnData_emptyEntry+0x1c>
    8d68:	3301      	adds	r3, #1
    8d6a:	2b08      	cmp	r3, #8
    8d6c:	d1f3      	bne.n	8d56 <check_ConnData_emptyEntry+0x2>
    8d6e:	1c18      	adds	r0, r3, #0
    8d70:	4770      	bx	lr
    8d72:	46c0      	nop			; (mov r8, r8)
    8d74:	20001808 	.word	0x20001808
    8d78:	0000ffff 	.word	0x0000ffff

00008d7c <gapc_cmp_evt>:
    8d7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8d7e:	1c14      	adds	r4, r2, #0
    8d80:	780a      	ldrb	r2, [r1, #0]
    8d82:	b085      	sub	sp, #20
    8d84:	1c03      	adds	r3, r0, #0
    8d86:	1e50      	subs	r0, r2, #1
    8d88:	9201      	str	r2, [sp, #4]
    8d8a:	784d      	ldrb	r5, [r1, #1]
    8d8c:	280f      	cmp	r0, #15
    8d8e:	d900      	bls.n	8d92 <gapc_cmp_evt+0x16>
    8d90:	e083      	b.n	8e9a <gapc_cmp_evt+0x11e>
    8d92:	f003 f801 	bl	bd98 <__gnu_thumb1_case_uqi>
    8d96:	5608      	.short	0x5608
    8d98:	56568282 	.word	0x56568282
    8d9c:	112c6a82 	.word	0x112c6a82
    8da0:	82828f24 	.word	0x82828f24
    8da4:	4638      	.short	0x4638
    8da6:	203a      	movs	r0, #58	; 0x3a
    8da8:	2d00      	cmp	r5, #0
    8daa:	d100      	bne.n	8dae <gapc_cmp_evt+0x32>
    8dac:	e083      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8dae:	0a1b      	lsrs	r3, r3, #8
    8db0:	8023      	strh	r3, [r4, #0]
    8db2:	70a5      	strb	r5, [r4, #2]
    8db4:	3834      	subs	r0, #52	; 0x34
    8db6:	e07e      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8db8:	aa02      	add	r2, sp, #8
    8dba:	1dd6      	adds	r6, r2, #7
    8dbc:	2201      	movs	r2, #1
    8dbe:	0a1f      	lsrs	r7, r3, #8
    8dc0:	1c38      	adds	r0, r7, #0
    8dc2:	1c31      	adds	r1, r6, #0
    8dc4:	4b3d      	ldr	r3, [pc, #244]	; (8ebc <gapc_cmp_evt+0x140>)
    8dc6:	7032      	strb	r2, [r6, #0]
    8dc8:	4798      	blx	r3
    8dca:	2807      	cmp	r0, #7
    8dcc:	d803      	bhi.n	8dd6 <gapc_cmp_evt+0x5a>
    8dce:	7833      	ldrb	r3, [r6, #0]
    8dd0:	203a      	movs	r0, #58	; 0x3a
    8dd2:	2b00      	cmp	r3, #0
    8dd4:	d06f      	beq.n	8eb6 <gapc_cmp_evt+0x13a>
    8dd6:	8067      	strh	r7, [r4, #2]
    8dd8:	7125      	strb	r5, [r4, #4]
    8dda:	2009      	movs	r0, #9
    8ddc:	e06b      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8dde:	203a      	movs	r0, #58	; 0x3a
    8de0:	2d00      	cmp	r5, #0
    8de2:	d068      	beq.n	8eb6 <gapc_cmp_evt+0x13a>
    8de4:	0a1b      	lsrs	r3, r3, #8
    8de6:	8023      	strh	r3, [r4, #0]
    8de8:	70a5      	strb	r5, [r4, #2]
    8dea:	382c      	subs	r0, #44	; 0x2c
    8dec:	e063      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8dee:	203a      	movs	r0, #58	; 0x3a
    8df0:	2d00      	cmp	r5, #0
    8df2:	d060      	beq.n	8eb6 <gapc_cmp_evt+0x13a>
    8df4:	0a1b      	lsrs	r3, r3, #8
    8df6:	8023      	strh	r3, [r4, #0]
    8df8:	2300      	movs	r3, #0
    8dfa:	70a5      	strb	r5, [r4, #2]
    8dfc:	80a3      	strh	r3, [r4, #4]
    8dfe:	80e3      	strh	r3, [r4, #6]
    8e00:	8123      	strh	r3, [r4, #8]
    8e02:	3833      	subs	r0, #51	; 0x33
    8e04:	e057      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8e06:	203a      	movs	r0, #58	; 0x3a
    8e08:	2d00      	cmp	r5, #0
    8e0a:	d054      	beq.n	8eb6 <gapc_cmp_evt+0x13a>
    8e0c:	7225      	strb	r5, [r4, #8]
    8e0e:	4c2c      	ldr	r4, [pc, #176]	; (8ec0 <gapc_cmp_evt+0x144>)
    8e10:	4b2c      	ldr	r3, [pc, #176]	; (8ec4 <gapc_cmp_evt+0x148>)
    8e12:	482d      	ldr	r0, [pc, #180]	; (8ec8 <gapc_cmp_evt+0x14c>)
    8e14:	492d      	ldr	r1, [pc, #180]	; (8ecc <gapc_cmp_evt+0x150>)
    8e16:	228f      	movs	r2, #143	; 0x8f
    8e18:	6825      	ldr	r5, [r4, #0]
    8e1a:	47a8      	blx	r5
    8e1c:	6823      	ldr	r3, [r4, #0]
    8e1e:	482c      	ldr	r0, [pc, #176]	; (8ed0 <gapc_cmp_evt+0x154>)
    8e20:	e00c      	b.n	8e3c <gapc_cmp_evt+0xc0>
    8e22:	203a      	movs	r0, #58	; 0x3a
    8e24:	2d00      	cmp	r5, #0
    8e26:	d046      	beq.n	8eb6 <gapc_cmp_evt+0x13a>
    8e28:	7125      	strb	r5, [r4, #4]
    8e2a:	4c25      	ldr	r4, [pc, #148]	; (8ec0 <gapc_cmp_evt+0x144>)
    8e2c:	4b25      	ldr	r3, [pc, #148]	; (8ec4 <gapc_cmp_evt+0x148>)
    8e2e:	4826      	ldr	r0, [pc, #152]	; (8ec8 <gapc_cmp_evt+0x14c>)
    8e30:	4926      	ldr	r1, [pc, #152]	; (8ecc <gapc_cmp_evt+0x150>)
    8e32:	229f      	movs	r2, #159	; 0x9f
    8e34:	6825      	ldr	r5, [r4, #0]
    8e36:	47a8      	blx	r5
    8e38:	6823      	ldr	r3, [r4, #0]
    8e3a:	4826      	ldr	r0, [pc, #152]	; (8ed4 <gapc_cmp_evt+0x158>)
    8e3c:	4798      	blx	r3
    8e3e:	2029      	movs	r0, #41	; 0x29
    8e40:	e039      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8e42:	203a      	movs	r0, #58	; 0x3a
    8e44:	2d00      	cmp	r5, #0
    8e46:	d036      	beq.n	8eb6 <gapc_cmp_evt+0x13a>
    8e48:	4f1d      	ldr	r7, [pc, #116]	; (8ec0 <gapc_cmp_evt+0x144>)
    8e4a:	4920      	ldr	r1, [pc, #128]	; (8ecc <gapc_cmp_evt+0x150>)
    8e4c:	22b5      	movs	r2, #181	; 0xb5
    8e4e:	4b1d      	ldr	r3, [pc, #116]	; (8ec4 <gapc_cmp_evt+0x148>)
    8e50:	481d      	ldr	r0, [pc, #116]	; (8ec8 <gapc_cmp_evt+0x14c>)
    8e52:	683e      	ldr	r6, [r7, #0]
    8e54:	47b0      	blx	r6
    8e56:	683b      	ldr	r3, [r7, #0]
    8e58:	481f      	ldr	r0, [pc, #124]	; (8ed8 <gapc_cmp_evt+0x15c>)
    8e5a:	1c29      	adds	r1, r5, #0
    8e5c:	4798      	blx	r3
    8e5e:	466b      	mov	r3, sp
    8e60:	791b      	ldrb	r3, [r3, #4]
    8e62:	70e5      	strb	r5, [r4, #3]
    8e64:	70a3      	strb	r3, [r4, #2]
    8e66:	2011      	movs	r0, #17
    8e68:	e025      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8e6a:	203a      	movs	r0, #58	; 0x3a
    8e6c:	2d00      	cmp	r5, #0
    8e6e:	d022      	beq.n	8eb6 <gapc_cmp_evt+0x13a>
    8e70:	0a1b      	lsrs	r3, r3, #8
    8e72:	8063      	strh	r3, [r4, #2]
    8e74:	7025      	strb	r5, [r4, #0]
    8e76:	1d20      	adds	r0, r4, #4
    8e78:	2100      	movs	r1, #0
    8e7a:	2205      	movs	r2, #5
    8e7c:	4b17      	ldr	r3, [pc, #92]	; (8edc <gapc_cmp_evt+0x160>)
    8e7e:	4798      	blx	r3
    8e80:	4c0f      	ldr	r4, [pc, #60]	; (8ec0 <gapc_cmp_evt+0x144>)
    8e82:	4912      	ldr	r1, [pc, #72]	; (8ecc <gapc_cmp_evt+0x150>)
    8e84:	22c7      	movs	r2, #199	; 0xc7
    8e86:	4b0f      	ldr	r3, [pc, #60]	; (8ec4 <gapc_cmp_evt+0x148>)
    8e88:	480f      	ldr	r0, [pc, #60]	; (8ec8 <gapc_cmp_evt+0x14c>)
    8e8a:	6826      	ldr	r6, [r4, #0]
    8e8c:	47b0      	blx	r6
    8e8e:	6823      	ldr	r3, [r4, #0]
    8e90:	4813      	ldr	r0, [pc, #76]	; (8ee0 <gapc_cmp_evt+0x164>)
    8e92:	1c29      	adds	r1, r5, #0
    8e94:	4798      	blx	r3
    8e96:	2012      	movs	r0, #18
    8e98:	e00d      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8e9a:	4c09      	ldr	r4, [pc, #36]	; (8ec0 <gapc_cmp_evt+0x144>)
    8e9c:	490b      	ldr	r1, [pc, #44]	; (8ecc <gapc_cmp_evt+0x150>)
    8e9e:	22d1      	movs	r2, #209	; 0xd1
    8ea0:	4b08      	ldr	r3, [pc, #32]	; (8ec4 <gapc_cmp_evt+0x148>)
    8ea2:	4809      	ldr	r0, [pc, #36]	; (8ec8 <gapc_cmp_evt+0x14c>)
    8ea4:	6825      	ldr	r5, [r4, #0]
    8ea6:	47a8      	blx	r5
    8ea8:	6823      	ldr	r3, [r4, #0]
    8eaa:	480e      	ldr	r0, [pc, #56]	; (8ee4 <gapc_cmp_evt+0x168>)
    8eac:	9901      	ldr	r1, [sp, #4]
    8eae:	4798      	blx	r3
    8eb0:	2000      	movs	r0, #0
    8eb2:	e000      	b.n	8eb6 <gapc_cmp_evt+0x13a>
    8eb4:	203a      	movs	r0, #58	; 0x3a
    8eb6:	b005      	add	sp, #20
    8eb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8eba:	46c0      	nop			; (mov r8, r8)
    8ebc:	00008d19 	.word	0x00008d19
    8ec0:	20000038 	.word	0x20000038
    8ec4:	00011264 	.word	0x00011264
    8ec8:	0000ed34 	.word	0x0000ed34
    8ecc:	0001114c 	.word	0x0001114c
    8ed0:	000111a6 	.word	0x000111a6
    8ed4:	000111c8 	.word	0x000111c8
    8ed8:	000111ea 	.word	0x000111ea
    8edc:	0000d825 	.word	0x0000d825
    8ee0:	00011211 	.word	0x00011211
    8ee4:	0001123a 	.word	0x0001123a

00008ee8 <gapc_connection_cfm_handler>:
    8ee8:	b5f0      	push	{r4, r5, r6, r7, lr}
    8eea:	b087      	sub	sp, #28
    8eec:	9300      	str	r3, [sp, #0]
    8eee:	ab0c      	add	r3, sp, #48	; 0x30
    8ef0:	781b      	ldrb	r3, [r3, #0]
    8ef2:	9203      	str	r2, [sp, #12]
    8ef4:	9304      	str	r3, [sp, #16]
    8ef6:	ab0d      	add	r3, sp, #52	; 0x34
    8ef8:	781b      	ldrb	r3, [r3, #0]
    8efa:	4684      	mov	ip, r0
    8efc:	9305      	str	r3, [sp, #20]
    8efe:	ab0e      	add	r3, sp, #56	; 0x38
    8f00:	881a      	ldrh	r2, [r3, #0]
    8f02:	4b3f      	ldr	r3, [pc, #252]	; (9000 <gapc_connection_cfm_handler+0x118>)
    8f04:	1c0f      	adds	r7, r1, #0
    8f06:	781b      	ldrb	r3, [r3, #0]
    8f08:	2400      	movs	r4, #0
    8f0a:	2b02      	cmp	r3, #2
    8f0c:	d108      	bne.n	8f20 <gapc_connection_cfm_handler+0x38>
    8f0e:	2152      	movs	r1, #82	; 0x52
    8f10:	4b3c      	ldr	r3, [pc, #240]	; (9004 <gapc_connection_cfm_handler+0x11c>)
    8f12:	3403      	adds	r4, #3
    8f14:	681b      	ldr	r3, [r3, #0]
    8f16:	7019      	strb	r1, [r3, #0]
    8f18:	3105      	adds	r1, #5
    8f1a:	7059      	strb	r1, [r3, #1]
    8f1c:	3936      	subs	r1, #54	; 0x36
    8f1e:	7099      	strb	r1, [r3, #2]
    8f20:	4b38      	ldr	r3, [pc, #224]	; (9004 <gapc_connection_cfm_handler+0x11c>)
    8f22:	2102      	movs	r1, #2
    8f24:	681d      	ldr	r5, [r3, #0]
    8f26:	2305      	movs	r3, #5
    8f28:	552b      	strb	r3, [r5, r4]
    8f2a:	1c63      	adds	r3, r4, #1
    8f2c:	54e9      	strb	r1, [r5, r3]
    8f2e:	230e      	movs	r3, #14
    8f30:	1861      	adds	r1, r4, r1
    8f32:	546b      	strb	r3, [r5, r1]
    8f34:	1ce1      	adds	r1, r4, #3
    8f36:	546b      	strb	r3, [r5, r1]
    8f38:	1d23      	adds	r3, r4, #4
    8f3a:	54ea      	strb	r2, [r5, r3]
    8f3c:	2210      	movs	r2, #16
    8f3e:	2600      	movs	r6, #0
    8f40:	1d63      	adds	r3, r4, #5
    8f42:	54ea      	strb	r2, [r5, r3]
    8f44:	1da3      	adds	r3, r4, #6
    8f46:	54ee      	strb	r6, [r5, r3]
    8f48:	1de3      	adds	r3, r4, #7
    8f4a:	18eb      	adds	r3, r5, r3
    8f4c:	701e      	strb	r6, [r3, #0]
    8f4e:	9301      	str	r3, [sp, #4]
    8f50:	1c23      	adds	r3, r4, #0
    8f52:	1c20      	adds	r0, r4, #0
    8f54:	3308      	adds	r3, #8
    8f56:	18eb      	adds	r3, r5, r3
    8f58:	3009      	adds	r0, #9
    8f5a:	4661      	mov	r1, ip
    8f5c:	9302      	str	r3, [sp, #8]
    8f5e:	701e      	strb	r6, [r3, #0]
    8f60:	2210      	movs	r2, #16
    8f62:	4b29      	ldr	r3, [pc, #164]	; (9008 <gapc_connection_cfm_handler+0x120>)
    8f64:	1828      	adds	r0, r5, r0
    8f66:	4798      	blx	r3
    8f68:	1c23      	adds	r3, r4, #0
    8f6a:	1c20      	adds	r0, r4, #0
    8f6c:	3319      	adds	r3, #25
    8f6e:	54ef      	strb	r7, [r5, r3]
    8f70:	0a3a      	lsrs	r2, r7, #8
    8f72:	3301      	adds	r3, #1
    8f74:	54ea      	strb	r2, [r5, r3]
    8f76:	0c3a      	lsrs	r2, r7, #16
    8f78:	3301      	adds	r3, #1
    8f7a:	54ea      	strb	r2, [r5, r3]
    8f7c:	0e3f      	lsrs	r7, r7, #24
    8f7e:	3301      	adds	r3, #1
    8f80:	301d      	adds	r0, #29
    8f82:	54ef      	strb	r7, [r5, r3]
    8f84:	9903      	ldr	r1, [sp, #12]
    8f86:	2210      	movs	r2, #16
    8f88:	4b1f      	ldr	r3, [pc, #124]	; (9008 <gapc_connection_cfm_handler+0x120>)
    8f8a:	1828      	adds	r0, r5, r0
    8f8c:	4798      	blx	r3
    8f8e:	466a      	mov	r2, sp
    8f90:	1c23      	adds	r3, r4, #0
    8f92:	7812      	ldrb	r2, [r2, #0]
    8f94:	332d      	adds	r3, #45	; 0x2d
    8f96:	54ea      	strb	r2, [r5, r3]
    8f98:	9a00      	ldr	r2, [sp, #0]
    8f9a:	3301      	adds	r3, #1
    8f9c:	0a12      	lsrs	r2, r2, #8
    8f9e:	54ea      	strb	r2, [r5, r3]
    8fa0:	9a00      	ldr	r2, [sp, #0]
    8fa2:	3301      	adds	r3, #1
    8fa4:	0c12      	lsrs	r2, r2, #16
    8fa6:	54ea      	strb	r2, [r5, r3]
    8fa8:	1c22      	adds	r2, r4, #0
    8faa:	9b00      	ldr	r3, [sp, #0]
    8fac:	3230      	adds	r2, #48	; 0x30
    8fae:	0e1b      	lsrs	r3, r3, #24
    8fb0:	54ab      	strb	r3, [r5, r2]
    8fb2:	466a      	mov	r2, sp
    8fb4:	1c23      	adds	r3, r4, #0
    8fb6:	7c12      	ldrb	r2, [r2, #16]
    8fb8:	3331      	adds	r3, #49	; 0x31
    8fba:	54ea      	strb	r2, [r5, r3]
    8fbc:	466a      	mov	r2, sp
    8fbe:	1c21      	adds	r1, r4, #0
    8fc0:	3301      	adds	r3, #1
    8fc2:	7d12      	ldrb	r2, [r2, #20]
    8fc4:	54ee      	strb	r6, [r5, r3]
    8fc6:	3301      	adds	r3, #1
    8fc8:	54ea      	strb	r2, [r5, r3]
    8fca:	3434      	adds	r4, #52	; 0x34
    8fcc:	4b0c      	ldr	r3, [pc, #48]	; (9000 <gapc_connection_cfm_handler+0x118>)
    8fce:	552e      	strb	r6, [r5, r4]
    8fd0:	781b      	ldrb	r3, [r3, #0]
    8fd2:	3135      	adds	r1, #53	; 0x35
    8fd4:	2b02      	cmp	r3, #2
    8fd6:	d102      	bne.n	8fde <gapc_connection_cfm_handler+0xf6>
    8fd8:	1c0b      	adds	r3, r1, #0
    8fda:	3b0c      	subs	r3, #12
    8fdc:	e001      	b.n	8fe2 <gapc_connection_cfm_handler+0xfa>
    8fde:	1c0b      	adds	r3, r1, #0
    8fe0:	3b09      	subs	r3, #9
    8fe2:	9a01      	ldr	r2, [sp, #4]
    8fe4:	1c28      	adds	r0, r5, #0
    8fe6:	7013      	strb	r3, [r2, #0]
    8fe8:	9b02      	ldr	r3, [sp, #8]
    8fea:	701e      	strb	r6, [r3, #0]
    8fec:	4b07      	ldr	r3, [pc, #28]	; (900c <gapc_connection_cfm_handler+0x124>)
    8fee:	4798      	blx	r3
    8ff0:	4b07      	ldr	r3, [pc, #28]	; (9010 <gapc_connection_cfm_handler+0x128>)
    8ff2:	4798      	blx	r3
    8ff4:	4b07      	ldr	r3, [pc, #28]	; (9014 <gapc_connection_cfm_handler+0x12c>)
    8ff6:	4798      	blx	r3
    8ff8:	2000      	movs	r0, #0
    8ffa:	b007      	add	sp, #28
    8ffc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8ffe:	46c0      	nop			; (mov r8, r8)
    9000:	20000005 	.word	0x20000005
    9004:	00011148 	.word	0x00011148
    9008:	0000d7eb 	.word	0x0000d7eb
    900c:	00008a29 	.word	0x00008a29
    9010:	00008835 	.word	0x00008835
    9014:	00001895 	.word	0x00001895

00009018 <gapc_con_req_ind>:
    9018:	b5f0      	push	{r4, r5, r6, r7, lr}
    901a:	7845      	ldrb	r5, [r0, #1]
    901c:	7803      	ldrb	r3, [r0, #0]
    901e:	4c30      	ldr	r4, [pc, #192]	; (90e0 <gapc_con_req_ind+0xc8>)
    9020:	022d      	lsls	r5, r5, #8
    9022:	431d      	orrs	r5, r3
    9024:	85a5      	strh	r5, [r4, #44]	; 0x2c
    9026:	78c3      	ldrb	r3, [r0, #3]
    9028:	7882      	ldrb	r2, [r0, #2]
    902a:	b08b      	sub	sp, #44	; 0x2c
    902c:	021b      	lsls	r3, r3, #8
    902e:	431a      	orrs	r2, r3
    9030:	466b      	mov	r3, sp
    9032:	9205      	str	r2, [sp, #20]
    9034:	8a9b      	ldrh	r3, [r3, #20]
    9036:	2120      	movs	r1, #32
    9038:	85e3      	strh	r3, [r4, #46]	; 0x2e
    903a:	7943      	ldrb	r3, [r0, #5]
    903c:	7902      	ldrb	r2, [r0, #4]
    903e:	021b      	lsls	r3, r3, #8
    9040:	431a      	orrs	r2, r3
    9042:	466b      	mov	r3, sp
    9044:	9206      	str	r2, [sp, #24]
    9046:	8b1b      	ldrh	r3, [r3, #24]
    9048:	1c06      	adds	r6, r0, #0
    904a:	8623      	strh	r3, [r4, #48]	; 0x30
    904c:	79c3      	ldrb	r3, [r0, #7]
    904e:	7982      	ldrb	r2, [r0, #6]
    9050:	021b      	lsls	r3, r3, #8
    9052:	431a      	orrs	r2, r3
    9054:	466b      	mov	r3, sp
    9056:	9207      	str	r2, [sp, #28]
    9058:	466a      	mov	r2, sp
    905a:	8b9b      	ldrh	r3, [r3, #28]
    905c:	1852      	adds	r2, r2, r1
    905e:	8663      	strh	r3, [r4, #50]	; 0x32
    9060:	7a43      	ldrb	r3, [r0, #9]
    9062:	1c01      	adds	r1, r0, #0
    9064:	9308      	str	r3, [sp, #32]
    9066:	1c23      	adds	r3, r4, #0
    9068:	7812      	ldrb	r2, [r2, #0]
    906a:	3377      	adds	r3, #119	; 0x77
    906c:	3478      	adds	r4, #120	; 0x78
    906e:	701a      	strb	r2, [r3, #0]
    9070:	310a      	adds	r1, #10
    9072:	2206      	movs	r2, #6
    9074:	4b1b      	ldr	r3, [pc, #108]	; (90e4 <gapc_con_req_ind+0xcc>)
    9076:	1c20      	adds	r0, r4, #0
    9078:	4798      	blx	r3
    907a:	7c33      	ldrb	r3, [r6, #16]
    907c:	9309      	str	r3, [sp, #36]	; 0x24
    907e:	4b1a      	ldr	r3, [pc, #104]	; (90e8 <gapc_con_req_ind+0xd0>)
    9080:	4798      	blx	r3
    9082:	4e1a      	ldr	r6, [pc, #104]	; (90ec <gapc_con_req_ind+0xd4>)
    9084:	1e07      	subs	r7, r0, #0
    9086:	2f07      	cmp	r7, #7
    9088:	d81b      	bhi.n	90c2 <gapc_con_req_ind+0xaa>
    908a:	2312      	movs	r3, #18
    908c:	4343      	muls	r3, r0
    908e:	18f0      	adds	r0, r6, r3
    9090:	8145      	strh	r5, [r0, #10]
    9092:	4669      	mov	r1, sp
    9094:	2524      	movs	r5, #36	; 0x24
    9096:	1949      	adds	r1, r1, r5
    9098:	7809      	ldrb	r1, [r1, #0]
    909a:	2206      	movs	r2, #6
    909c:	54f1      	strb	r1, [r6, r3]
    909e:	2120      	movs	r1, #32
    90a0:	466b      	mov	r3, sp
    90a2:	185b      	adds	r3, r3, r1
    90a4:	781b      	ldrb	r3, [r3, #0]
    90a6:	1c21      	adds	r1, r4, #0
    90a8:	7043      	strb	r3, [r0, #1]
    90aa:	466b      	mov	r3, sp
    90ac:	8a9b      	ldrh	r3, [r3, #20]
    90ae:	3002      	adds	r0, #2
    90b0:	8143      	strh	r3, [r0, #10]
    90b2:	466b      	mov	r3, sp
    90b4:	8b1b      	ldrh	r3, [r3, #24]
    90b6:	8183      	strh	r3, [r0, #12]
    90b8:	466b      	mov	r3, sp
    90ba:	8b9b      	ldrh	r3, [r3, #28]
    90bc:	81c3      	strh	r3, [r0, #14]
    90be:	4b09      	ldr	r3, [pc, #36]	; (90e4 <gapc_con_req_ind+0xcc>)
    90c0:	4798      	blx	r3
    90c2:	2112      	movs	r1, #18
    90c4:	2300      	movs	r3, #0
    90c6:	434f      	muls	r7, r1
    90c8:	9300      	str	r3, [sp, #0]
    90ca:	9301      	str	r3, [sp, #4]
    90cc:	19f6      	adds	r6, r6, r7
    90ce:	8971      	ldrh	r1, [r6, #10]
    90d0:	4a07      	ldr	r2, [pc, #28]	; (90f0 <gapc_con_req_ind+0xd8>)
    90d2:	9102      	str	r1, [sp, #8]
    90d4:	1c10      	adds	r0, r2, #0
    90d6:	1c19      	adds	r1, r3, #0
    90d8:	4c06      	ldr	r4, [pc, #24]	; (90f4 <gapc_con_req_ind+0xdc>)
    90da:	47a0      	blx	r4
    90dc:	b00b      	add	sp, #44	; 0x2c
    90de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    90e0:	20001898 	.word	0x20001898
    90e4:	0000d7eb 	.word	0x0000d7eb
    90e8:	00008d55 	.word	0x00008d55
    90ec:	20001808 	.word	0x20001808
    90f0:	20000630 	.word	0x20000630
    90f4:	00008ee9 	.word	0x00008ee9

000090f8 <gapc_disconnect_cmd_handler>:
    90f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    90fa:	4f23      	ldr	r7, [pc, #140]	; (9188 <gapc_disconnect_cmd_handler+0x90>)
    90fc:	4a23      	ldr	r2, [pc, #140]	; (918c <gapc_disconnect_cmd_handler+0x94>)
    90fe:	783c      	ldrb	r4, [r7, #0]
    9100:	9701      	str	r7, [sp, #4]
    9102:	2300      	movs	r3, #0
    9104:	2c02      	cmp	r4, #2
    9106:	d107      	bne.n	9118 <gapc_disconnect_cmd_handler+0x20>
    9108:	6813      	ldr	r3, [r2, #0]
    910a:	3450      	adds	r4, #80	; 0x50
    910c:	701c      	strb	r4, [r3, #0]
    910e:	3405      	adds	r4, #5
    9110:	705c      	strb	r4, [r3, #1]
    9112:	3c36      	subs	r4, #54	; 0x36
    9114:	709c      	strb	r4, [r3, #2]
    9116:	2303      	movs	r3, #3
    9118:	2405      	movs	r4, #5
    911a:	2504      	movs	r5, #4
    911c:	6812      	ldr	r2, [r2, #0]
    911e:	2600      	movs	r6, #0
    9120:	54d4      	strb	r4, [r2, r3]
    9122:	1c5c      	adds	r4, r3, #1
    9124:	5515      	strb	r5, [r2, r4]
    9126:	240e      	movs	r4, #14
    9128:	1c9d      	adds	r5, r3, #2
    912a:	5554      	strb	r4, [r2, r5]
    912c:	1cdd      	adds	r5, r3, #3
    912e:	5554      	strb	r4, [r2, r5]
    9130:	1d1c      	adds	r4, r3, #4
    9132:	5511      	strb	r1, [r2, r4]
    9134:	2410      	movs	r4, #16
    9136:	1d59      	adds	r1, r3, #5
    9138:	5454      	strb	r4, [r2, r1]
    913a:	1c1c      	adds	r4, r3, #0
    913c:	2701      	movs	r7, #1
    913e:	1d99      	adds	r1, r3, #6
    9140:	1ddd      	adds	r5, r3, #7
    9142:	3408      	adds	r4, #8
    9144:	5456      	strb	r6, [r2, r1]
    9146:	330a      	adds	r3, #10
    9148:	3103      	adds	r1, #3
    914a:	1955      	adds	r5, r2, r5
    914c:	1914      	adds	r4, r2, r4
    914e:	702e      	strb	r6, [r5, #0]
    9150:	7026      	strb	r6, [r4, #0]
    9152:	5457      	strb	r7, [r2, r1]
    9154:	54d0      	strb	r0, [r2, r3]
    9156:	9b01      	ldr	r3, [sp, #4]
    9158:	3102      	adds	r1, #2
    915a:	781b      	ldrb	r3, [r3, #0]
    915c:	2b02      	cmp	r3, #2
    915e:	d105      	bne.n	916c <gapc_disconnect_cmd_handler+0x74>
    9160:	1c0b      	adds	r3, r1, #0
    9162:	3b0c      	subs	r3, #12
    9164:	702b      	strb	r3, [r5, #0]
    9166:	121b      	asrs	r3, r3, #8
    9168:	7023      	strb	r3, [r4, #0]
    916a:	e003      	b.n	9174 <gapc_disconnect_cmd_handler+0x7c>
    916c:	1c0b      	adds	r3, r1, #0
    916e:	3b09      	subs	r3, #9
    9170:	702b      	strb	r3, [r5, #0]
    9172:	7026      	strb	r6, [r4, #0]
    9174:	1c10      	adds	r0, r2, #0
    9176:	4b06      	ldr	r3, [pc, #24]	; (9190 <gapc_disconnect_cmd_handler+0x98>)
    9178:	4798      	blx	r3
    917a:	4b06      	ldr	r3, [pc, #24]	; (9194 <gapc_disconnect_cmd_handler+0x9c>)
    917c:	4798      	blx	r3
    917e:	4b06      	ldr	r3, [pc, #24]	; (9198 <gapc_disconnect_cmd_handler+0xa0>)
    9180:	4798      	blx	r3
    9182:	2000      	movs	r0, #0
    9184:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    9186:	46c0      	nop			; (mov r8, r8)
    9188:	20000005 	.word	0x20000005
    918c:	00011148 	.word	0x00011148
    9190:	00008a29 	.word	0x00008a29
    9194:	00008835 	.word	0x00008835
    9198:	00001895 	.word	0x00001895

0000919c <gapc_disconnect_ind>:
    919c:	1c02      	adds	r2, r0, #0
    919e:	b508      	push	{r3, lr}
    91a0:	7843      	ldrb	r3, [r0, #1]
    91a2:	7800      	ldrb	r0, [r0, #0]
    91a4:	021b      	lsls	r3, r3, #8
    91a6:	4318      	orrs	r0, r3
    91a8:	8008      	strh	r0, [r1, #0]
    91aa:	7893      	ldrb	r3, [r2, #2]
    91ac:	708b      	strb	r3, [r1, #2]
    91ae:	2100      	movs	r1, #0
    91b0:	4b05      	ldr	r3, [pc, #20]	; (91c8 <gapc_disconnect_ind+0x2c>)
    91b2:	4798      	blx	r3
    91b4:	2807      	cmp	r0, #7
    91b6:	d806      	bhi.n	91c6 <gapc_disconnect_ind+0x2a>
    91b8:	2312      	movs	r3, #18
    91ba:	4358      	muls	r0, r3
    91bc:	4b03      	ldr	r3, [pc, #12]	; (91cc <gapc_disconnect_ind+0x30>)
    91be:	1818      	adds	r0, r3, r0
    91c0:	2301      	movs	r3, #1
    91c2:	425b      	negs	r3, r3
    91c4:	8143      	strh	r3, [r0, #10]
    91c6:	bd08      	pop	{r3, pc}
    91c8:	00008d19 	.word	0x00008d19
    91cc:	20001808 	.word	0x20001808

000091d0 <gapc_bond_cmd_handler>:
    91d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    91d2:	b087      	sub	sp, #28
    91d4:	9301      	str	r3, [sp, #4]
    91d6:	ab0c      	add	r3, sp, #48	; 0x30
    91d8:	781b      	ldrb	r3, [r3, #0]
    91da:	1c04      	adds	r4, r0, #0
    91dc:	9302      	str	r3, [sp, #8]
    91de:	ab0d      	add	r3, sp, #52	; 0x34
    91e0:	781b      	ldrb	r3, [r3, #0]
    91e2:	9200      	str	r2, [sp, #0]
    91e4:	9303      	str	r3, [sp, #12]
    91e6:	ab0e      	add	r3, sp, #56	; 0x38
    91e8:	781b      	ldrb	r3, [r3, #0]
    91ea:	9304      	str	r3, [sp, #16]
    91ec:	ab0f      	add	r3, sp, #60	; 0x3c
    91ee:	781b      	ldrb	r3, [r3, #0]
    91f0:	9305      	str	r3, [sp, #20]
    91f2:	4b2f      	ldr	r3, [pc, #188]	; (92b0 <gapc_bond_cmd_handler+0xe0>)
    91f4:	7818      	ldrb	r0, [r3, #0]
    91f6:	2300      	movs	r3, #0
    91f8:	2802      	cmp	r0, #2
    91fa:	d108      	bne.n	920e <gapc_bond_cmd_handler+0x3e>
    91fc:	4b2d      	ldr	r3, [pc, #180]	; (92b4 <gapc_bond_cmd_handler+0xe4>)
    91fe:	3050      	adds	r0, #80	; 0x50
    9200:	681b      	ldr	r3, [r3, #0]
    9202:	7018      	strb	r0, [r3, #0]
    9204:	3005      	adds	r0, #5
    9206:	7058      	strb	r0, [r3, #1]
    9208:	3836      	subs	r0, #54	; 0x36
    920a:	7098      	strb	r0, [r3, #2]
    920c:	2303      	movs	r3, #3
    920e:	2505      	movs	r5, #5
    9210:	2612      	movs	r6, #18
    9212:	4828      	ldr	r0, [pc, #160]	; (92b4 <gapc_bond_cmd_handler+0xe4>)
    9214:	1c1f      	adds	r7, r3, #0
    9216:	6800      	ldr	r0, [r0, #0]
    9218:	220a      	movs	r2, #10
    921a:	54c5      	strb	r5, [r0, r3]
    921c:	1c5d      	adds	r5, r3, #1
    921e:	5546      	strb	r6, [r0, r5]
    9220:	250e      	movs	r5, #14
    9222:	1c9e      	adds	r6, r3, #2
    9224:	5585      	strb	r5, [r0, r6]
    9226:	1cde      	adds	r6, r3, #3
    9228:	5585      	strb	r5, [r0, r6]
    922a:	1d1d      	adds	r5, r3, #4
    922c:	5544      	strb	r4, [r0, r5]
    922e:	2510      	movs	r5, #16
    9230:	1d5c      	adds	r4, r3, #5
    9232:	5505      	strb	r5, [r0, r4]
    9234:	2500      	movs	r5, #0
    9236:	1d9c      	adds	r4, r3, #6
    9238:	5505      	strb	r5, [r0, r4]
    923a:	1dde      	adds	r6, r3, #7
    923c:	3402      	adds	r4, #2
    923e:	3709      	adds	r7, #9
    9240:	1986      	adds	r6, r0, r6
    9242:	1904      	adds	r4, r0, r4
    9244:	7035      	strb	r5, [r6, #0]
    9246:	4694      	mov	ip, r2
    9248:	7025      	strb	r5, [r4, #0]
    924a:	55c2      	strb	r2, [r0, r7]
    924c:	1c1f      	adds	r7, r3, #0
    924e:	466a      	mov	r2, sp
    9250:	4467      	add	r7, ip
    9252:	55c1      	strb	r1, [r0, r7]
    9254:	1c19      	adds	r1, r3, #0
    9256:	7812      	ldrb	r2, [r2, #0]
    9258:	310b      	adds	r1, #11
    925a:	5442      	strb	r2, [r0, r1]
    925c:	4669      	mov	r1, sp
    925e:	1c1a      	adds	r2, r3, #0
    9260:	7909      	ldrb	r1, [r1, #4]
    9262:	320c      	adds	r2, #12
    9264:	5481      	strb	r1, [r0, r2]
    9266:	4669      	mov	r1, sp
    9268:	7a09      	ldrb	r1, [r1, #8]
    926a:	3201      	adds	r2, #1
    926c:	5481      	strb	r1, [r0, r2]
    926e:	4669      	mov	r1, sp
    9270:	7b09      	ldrb	r1, [r1, #12]
    9272:	3201      	adds	r2, #1
    9274:	5481      	strb	r1, [r0, r2]
    9276:	4669      	mov	r1, sp
    9278:	7c09      	ldrb	r1, [r1, #16]
    927a:	3201      	adds	r2, #1
    927c:	5481      	strb	r1, [r0, r2]
    927e:	466a      	mov	r2, sp
    9280:	1c19      	adds	r1, r3, #0
    9282:	7d12      	ldrb	r2, [r2, #20]
    9284:	3310      	adds	r3, #16
    9286:	54c2      	strb	r2, [r0, r3]
    9288:	4b09      	ldr	r3, [pc, #36]	; (92b0 <gapc_bond_cmd_handler+0xe0>)
    928a:	3111      	adds	r1, #17
    928c:	781b      	ldrb	r3, [r3, #0]
    928e:	2b02      	cmp	r3, #2
    9290:	d102      	bne.n	9298 <gapc_bond_cmd_handler+0xc8>
    9292:	1c0b      	adds	r3, r1, #0
    9294:	3b0c      	subs	r3, #12
    9296:	e001      	b.n	929c <gapc_bond_cmd_handler+0xcc>
    9298:	1c0b      	adds	r3, r1, #0
    929a:	3b09      	subs	r3, #9
    929c:	7033      	strb	r3, [r6, #0]
    929e:	7025      	strb	r5, [r4, #0]
    92a0:	4b05      	ldr	r3, [pc, #20]	; (92b8 <gapc_bond_cmd_handler+0xe8>)
    92a2:	4798      	blx	r3
    92a4:	4b05      	ldr	r3, [pc, #20]	; (92bc <gapc_bond_cmd_handler+0xec>)
    92a6:	4798      	blx	r3
    92a8:	4b05      	ldr	r3, [pc, #20]	; (92c0 <gapc_bond_cmd_handler+0xf0>)
    92aa:	4798      	blx	r3
    92ac:	b007      	add	sp, #28
    92ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    92b0:	20000005 	.word	0x20000005
    92b4:	00011148 	.word	0x00011148
    92b8:	00008a29 	.word	0x00008a29
    92bc:	00008835 	.word	0x00008835
    92c0:	00001895 	.word	0x00001895

000092c4 <gapc_bond_ind>:
    92c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    92c6:	780e      	ldrb	r6, [r1, #0]
    92c8:	1c03      	adds	r3, r0, #0
    92ca:	1eb0      	subs	r0, r6, #2
    92cc:	2805      	cmp	r0, #5
    92ce:	d85d      	bhi.n	938c <gapc_bond_ind+0xc8>
    92d0:	1c15      	adds	r5, r2, #0
    92d2:	1c0c      	adds	r4, r1, #0
    92d4:	f002 fd60 	bl	bd98 <__gnu_thumb1_case_uqi>
    92d8:	2f5a030d 	.word	0x2f5a030d
    92dc:	4740      	.short	0x4740
    92de:	2009      	movs	r0, #9
    92e0:	2a00      	cmp	r2, #0
    92e2:	d054      	beq.n	938e <gapc_bond_ind+0xca>
    92e4:	0a1b      	lsrs	r3, r3, #8
    92e6:	8053      	strh	r3, [r2, #2]
    92e8:	788b      	ldrb	r3, [r1, #2]
    92ea:	4829      	ldr	r0, [pc, #164]	; (9390 <gapc_bond_ind+0xcc>)
    92ec:	7113      	strb	r3, [r2, #4]
    92ee:	2100      	movs	r1, #0
    92f0:	e01c      	b.n	932c <gapc_bond_ind+0x68>
    92f2:	2009      	movs	r0, #9
    92f4:	2a00      	cmp	r2, #0
    92f6:	d04a      	beq.n	938e <gapc_bond_ind+0xca>
    92f8:	4c25      	ldr	r4, [pc, #148]	; (9390 <gapc_bond_ind+0xcc>)
    92fa:	0a1b      	lsrs	r3, r3, #8
    92fc:	8053      	strh	r3, [r2, #2]
    92fe:	788b      	ldrb	r3, [r1, #2]
    9300:	2700      	movs	r7, #0
    9302:	1c10      	adds	r0, r2, #0
    9304:	1c21      	adds	r1, r4, #0
    9306:	7013      	strb	r3, [r2, #0]
    9308:	4e22      	ldr	r6, [pc, #136]	; (9394 <gapc_bond_ind+0xd0>)
    930a:	7117      	strb	r7, [r2, #4]
    930c:	312e      	adds	r1, #46	; 0x2e
    930e:	2217      	movs	r2, #23
    9310:	3032      	adds	r0, #50	; 0x32
    9312:	47b0      	blx	r6
    9314:	1c28      	adds	r0, r5, #0
    9316:	1c21      	adds	r1, r4, #0
    9318:	2210      	movs	r2, #16
    931a:	311e      	adds	r1, #30
    931c:	3022      	adds	r0, #34	; 0x22
    931e:	47b0      	blx	r6
    9320:	1ca1      	adds	r1, r4, #2
    9322:	1da8      	adds	r0, r5, #6
    9324:	221c      	movs	r2, #28
    9326:	47b0      	blx	r6
    9328:	1c20      	adds	r0, r4, #0
    932a:	1c39      	adds	r1, r7, #0
    932c:	2246      	movs	r2, #70	; 0x46
    932e:	4b1a      	ldr	r3, [pc, #104]	; (9398 <gapc_bond_ind+0xd4>)
    9330:	4798      	blx	r3
    9332:	2009      	movs	r0, #9
    9334:	e02b      	b.n	938e <gapc_bond_ind+0xca>
    9336:	4d16      	ldr	r5, [pc, #88]	; (9390 <gapc_bond_ind+0xcc>)
    9338:	3102      	adds	r1, #2
    933a:	1c28      	adds	r0, r5, #0
    933c:	2210      	movs	r2, #16
    933e:	4e15      	ldr	r6, [pc, #84]	; (9394 <gapc_bond_ind+0xd0>)
    9340:	302e      	adds	r0, #46	; 0x2e
    9342:	47b0      	blx	r6
    9344:	1c28      	adds	r0, r5, #0
    9346:	1c21      	adds	r1, r4, #0
    9348:	303f      	adds	r0, #63	; 0x3f
    934a:	3112      	adds	r1, #18
    934c:	2206      	movs	r2, #6
    934e:	47b0      	blx	r6
    9350:	7e23      	ldrb	r3, [r4, #24]
    9352:	353e      	adds	r5, #62	; 0x3e
    9354:	702b      	strb	r3, [r5, #0]
    9356:	e019      	b.n	938c <gapc_bond_ind+0xc8>
    9358:	480d      	ldr	r0, [pc, #52]	; (9390 <gapc_bond_ind+0xcc>)
    935a:	3102      	adds	r1, #2
    935c:	2210      	movs	r2, #16
    935e:	4b0d      	ldr	r3, [pc, #52]	; (9394 <gapc_bond_ind+0xd0>)
    9360:	301e      	adds	r0, #30
    9362:	4798      	blx	r3
    9364:	e012      	b.n	938c <gapc_bond_ind+0xc8>
    9366:	4d0a      	ldr	r5, [pc, #40]	; (9390 <gapc_bond_ind+0xcc>)
    9368:	3102      	adds	r1, #2
    936a:	2210      	movs	r2, #16
    936c:	4e09      	ldr	r6, [pc, #36]	; (9394 <gapc_bond_ind+0xd0>)
    936e:	1ca8      	adds	r0, r5, #2
    9370:	47b0      	blx	r6
    9372:	1c28      	adds	r0, r5, #0
    9374:	1c21      	adds	r1, r4, #0
    9376:	7ce3      	ldrb	r3, [r4, #19]
    9378:	7ca2      	ldrb	r2, [r4, #18]
    937a:	021b      	lsls	r3, r3, #8
    937c:	4313      	orrs	r3, r2
    937e:	3014      	adds	r0, #20
    9380:	3114      	adds	r1, #20
    9382:	2208      	movs	r2, #8
    9384:	826b      	strh	r3, [r5, #18]
    9386:	47b0      	blx	r6
    9388:	7f23      	ldrb	r3, [r4, #28]
    938a:	772b      	strb	r3, [r5, #28]
    938c:	2000      	movs	r0, #0
    938e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9390:	20000640 	.word	0x20000640
    9394:	0000d7eb 	.word	0x0000d7eb
    9398:	0000d825 	.word	0x0000d825

0000939c <gapc_bond_req_ind>:
    939c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    939e:	1c03      	adds	r3, r0, #0
    93a0:	1c08      	adds	r0, r1, #0
    93a2:	7809      	ldrb	r1, [r1, #0]
    93a4:	7844      	ldrb	r4, [r0, #1]
    93a6:	2907      	cmp	r1, #7
    93a8:	d900      	bls.n	93ac <gapc_bond_req_ind+0x10>
    93aa:	e08f      	b.n	94cc <gapc_bond_req_ind+0x130>
    93ac:	1c08      	adds	r0, r1, #0
    93ae:	f002 fcf3 	bl	bd98 <__gnu_thumb1_case_uqi>
    93b2:	8d04      	.short	0x8d04
    93b4:	8d0c8d8d 	.word	0x8d0c8d8d
    93b8:	2020      	.short	0x2020
    93ba:	200a      	movs	r0, #10
    93bc:	2a00      	cmp	r2, #0
    93be:	d100      	bne.n	93c2 <gapc_bond_req_ind+0x26>
    93c0:	e085      	b.n	94ce <gapc_bond_req_ind+0x132>
    93c2:	0a1b      	lsrs	r3, r3, #8
    93c4:	8013      	strh	r3, [r2, #0]
    93c6:	7094      	strb	r4, [r2, #2]
    93c8:	e081      	b.n	94ce <gapc_bond_req_ind+0x132>
    93ca:	2a00      	cmp	r2, #0
    93cc:	d00b      	beq.n	93e6 <gapc_bond_req_ind+0x4a>
    93ce:	0a1b      	lsrs	r3, r3, #8
    93d0:	8013      	strh	r3, [r2, #0]
    93d2:	2c00      	cmp	r4, #0
    93d4:	d102      	bne.n	93dc <gapc_bond_req_ind+0x40>
    93d6:	2301      	movs	r3, #1
    93d8:	7093      	strb	r3, [r2, #2]
    93da:	e004      	b.n	93e6 <gapc_bond_req_ind+0x4a>
    93dc:	2300      	movs	r3, #0
    93de:	7093      	strb	r3, [r2, #2]
    93e0:	2c02      	cmp	r4, #2
    93e2:	d102      	bne.n	93ea <gapc_bond_req_ind+0x4e>
    93e4:	70d3      	strb	r3, [r2, #3]
    93e6:	200c      	movs	r0, #12
    93e8:	e071      	b.n	94ce <gapc_bond_req_ind+0x132>
    93ea:	2c01      	cmp	r4, #1
    93ec:	d1fb      	bne.n	93e6 <gapc_bond_req_ind+0x4a>
    93ee:	70d4      	strb	r4, [r2, #3]
    93f0:	e7f9      	b.n	93e6 <gapc_bond_req_ind+0x4a>
    93f2:	4a37      	ldr	r2, [pc, #220]	; (94d0 <gapc_bond_req_ind+0x134>)
    93f4:	0a1b      	lsrs	r3, r3, #8
    93f6:	7812      	ldrb	r2, [r2, #0]
    93f8:	4836      	ldr	r0, [pc, #216]	; (94d4 <gapc_bond_req_ind+0x138>)
    93fa:	2400      	movs	r4, #0
    93fc:	2a02      	cmp	r2, #2
    93fe:	d107      	bne.n	9410 <gapc_bond_req_ind+0x74>
    9400:	6802      	ldr	r2, [r0, #0]
    9402:	3452      	adds	r4, #82	; 0x52
    9404:	7014      	strb	r4, [r2, #0]
    9406:	3405      	adds	r4, #5
    9408:	7054      	strb	r4, [r2, #1]
    940a:	3c36      	subs	r4, #54	; 0x36
    940c:	7094      	strb	r4, [r2, #2]
    940e:	3c1e      	subs	r4, #30
    9410:	2205      	movs	r2, #5
    9412:	6805      	ldr	r5, [r0, #0]
    9414:	2014      	movs	r0, #20
    9416:	552a      	strb	r2, [r5, r4]
    9418:	1c62      	adds	r2, r4, #1
    941a:	54a8      	strb	r0, [r5, r2]
    941c:	3806      	subs	r0, #6
    941e:	1ca2      	adds	r2, r4, #2
    9420:	54a8      	strb	r0, [r5, r2]
    9422:	1ce2      	adds	r2, r4, #3
    9424:	54a8      	strb	r0, [r5, r2]
    9426:	1d22      	adds	r2, r4, #4
    9428:	54ab      	strb	r3, [r5, r2]
    942a:	2210      	movs	r2, #16
    942c:	1d63      	adds	r3, r4, #5
    942e:	54ea      	strb	r2, [r5, r3]
    9430:	2300      	movs	r3, #0
    9432:	1da0      	adds	r0, r4, #6
    9434:	542b      	strb	r3, [r5, r0]
    9436:	1de7      	adds	r7, r4, #7
    9438:	3002      	adds	r0, #2
    943a:	1828      	adds	r0, r5, r0
    943c:	19ef      	adds	r7, r5, r7
    943e:	703b      	strb	r3, [r7, #0]
    9440:	7003      	strb	r3, [r0, #0]
    9442:	1c23      	adds	r3, r4, #0
    9444:	9001      	str	r0, [sp, #4]
    9446:	2001      	movs	r0, #1
    9448:	3309      	adds	r3, #9
    944a:	54e9      	strb	r1, [r5, r3]
    944c:	181b      	adds	r3, r3, r0
    944e:	54e8      	strb	r0, [r5, r3]
    9450:	1c20      	adds	r0, r4, #0
    9452:	300b      	adds	r0, #11
    9454:	4e20      	ldr	r6, [pc, #128]	; (94d8 <gapc_bond_req_ind+0x13c>)
    9456:	1828      	adds	r0, r5, r0
    9458:	2907      	cmp	r1, #7
    945a:	d11c      	bne.n	9496 <gapc_bond_req_ind+0xfa>
    945c:	1c31      	adds	r1, r6, #0
    945e:	4b1f      	ldr	r3, [pc, #124]	; (94dc <gapc_bond_req_ind+0x140>)
    9460:	317e      	adds	r1, #126	; 0x7e
    9462:	4798      	blx	r3
    9464:	1c33      	adds	r3, r6, #0
    9466:	1c22      	adds	r2, r4, #0
    9468:	338e      	adds	r3, #142	; 0x8e
    946a:	8819      	ldrh	r1, [r3, #0]
    946c:	321b      	adds	r2, #27
    946e:	1c20      	adds	r0, r4, #0
    9470:	54a9      	strb	r1, [r5, r2]
    9472:	1c31      	adds	r1, r6, #0
    9474:	881b      	ldrh	r3, [r3, #0]
    9476:	3201      	adds	r2, #1
    9478:	0a1b      	lsrs	r3, r3, #8
    947a:	301d      	adds	r0, #29
    947c:	54ab      	strb	r3, [r5, r2]
    947e:	3190      	adds	r1, #144	; 0x90
    9480:	4b16      	ldr	r3, [pc, #88]	; (94dc <gapc_bond_req_ind+0x140>)
    9482:	1828      	adds	r0, r5, r0
    9484:	2208      	movs	r2, #8
    9486:	4798      	blx	r3
    9488:	1c21      	adds	r1, r4, #0
    948a:	3698      	adds	r6, #152	; 0x98
    948c:	7833      	ldrb	r3, [r6, #0]
    948e:	3425      	adds	r4, #37	; 0x25
    9490:	3126      	adds	r1, #38	; 0x26
    9492:	552b      	strb	r3, [r5, r4]
    9494:	e005      	b.n	94a2 <gapc_bond_req_ind+0x106>
    9496:	1c31      	adds	r1, r6, #0
    9498:	4b10      	ldr	r3, [pc, #64]	; (94dc <gapc_bond_req_ind+0x140>)
    949a:	319a      	adds	r1, #154	; 0x9a
    949c:	4798      	blx	r3
    949e:	1c21      	adds	r1, r4, #0
    94a0:	311b      	adds	r1, #27
    94a2:	4b0b      	ldr	r3, [pc, #44]	; (94d0 <gapc_bond_req_ind+0x134>)
    94a4:	781a      	ldrb	r2, [r3, #0]
    94a6:	2300      	movs	r3, #0
    94a8:	2a02      	cmp	r2, #2
    94aa:	d102      	bne.n	94b2 <gapc_bond_req_ind+0x116>
    94ac:	1c0a      	adds	r2, r1, #0
    94ae:	3a0c      	subs	r2, #12
    94b0:	e001      	b.n	94b6 <gapc_bond_req_ind+0x11a>
    94b2:	1c0a      	adds	r2, r1, #0
    94b4:	3a09      	subs	r2, #9
    94b6:	703a      	strb	r2, [r7, #0]
    94b8:	9a01      	ldr	r2, [sp, #4]
    94ba:	7013      	strb	r3, [r2, #0]
    94bc:	4b05      	ldr	r3, [pc, #20]	; (94d4 <gapc_bond_req_ind+0x138>)
    94be:	6818      	ldr	r0, [r3, #0]
    94c0:	4b07      	ldr	r3, [pc, #28]	; (94e0 <gapc_bond_req_ind+0x144>)
    94c2:	4798      	blx	r3
    94c4:	4b07      	ldr	r3, [pc, #28]	; (94e4 <gapc_bond_req_ind+0x148>)
    94c6:	4798      	blx	r3
    94c8:	4b07      	ldr	r3, [pc, #28]	; (94e8 <gapc_bond_req_ind+0x14c>)
    94ca:	4798      	blx	r3
    94cc:	2000      	movs	r0, #0
    94ce:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    94d0:	20000005 	.word	0x20000005
    94d4:	00011148 	.word	0x00011148
    94d8:	20001898 	.word	0x20001898
    94dc:	0000d7eb 	.word	0x0000d7eb
    94e0:	00008a29 	.word	0x00008a29
    94e4:	00008835 	.word	0x00008835
    94e8:	00001895 	.word	0x00001895

000094ec <gapc_bond_cfm_handler_pair_resp>:
    94ec:	b5f0      	push	{r4, r5, r6, r7, lr}
    94ee:	b089      	sub	sp, #36	; 0x24
    94f0:	9303      	str	r3, [sp, #12]
    94f2:	ab0e      	add	r3, sp, #56	; 0x38
    94f4:	781b      	ldrb	r3, [r3, #0]
    94f6:	9202      	str	r2, [sp, #8]
    94f8:	9304      	str	r3, [sp, #16]
    94fa:	ab0f      	add	r3, sp, #60	; 0x3c
    94fc:	781b      	ldrb	r3, [r3, #0]
    94fe:	9101      	str	r1, [sp, #4]
    9500:	9305      	str	r3, [sp, #20]
    9502:	ab10      	add	r3, sp, #64	; 0x40
    9504:	781b      	ldrb	r3, [r3, #0]
    9506:	9306      	str	r3, [sp, #24]
    9508:	ab11      	add	r3, sp, #68	; 0x44
    950a:	781b      	ldrb	r3, [r3, #0]
    950c:	9307      	str	r3, [sp, #28]
    950e:	ab12      	add	r3, sp, #72	; 0x48
    9510:	881d      	ldrh	r5, [r3, #0]
    9512:	4b31      	ldr	r3, [pc, #196]	; (95d8 <gapc_bond_cfm_handler_pair_resp+0xec>)
    9514:	781a      	ldrb	r2, [r3, #0]
    9516:	2300      	movs	r3, #0
    9518:	2a02      	cmp	r2, #2
    951a:	d108      	bne.n	952e <gapc_bond_cfm_handler_pair_resp+0x42>
    951c:	4b2f      	ldr	r3, [pc, #188]	; (95dc <gapc_bond_cfm_handler_pair_resp+0xf0>)
    951e:	3250      	adds	r2, #80	; 0x50
    9520:	681b      	ldr	r3, [r3, #0]
    9522:	701a      	strb	r2, [r3, #0]
    9524:	3205      	adds	r2, #5
    9526:	705a      	strb	r2, [r3, #1]
    9528:	3a36      	subs	r2, #54	; 0x36
    952a:	709a      	strb	r2, [r3, #2]
    952c:	2303      	movs	r3, #3
    952e:	2405      	movs	r4, #5
    9530:	2614      	movs	r6, #20
    9532:	4a2a      	ldr	r2, [pc, #168]	; (95dc <gapc_bond_cfm_handler_pair_resp+0xf0>)
    9534:	2101      	movs	r1, #1
    9536:	6812      	ldr	r2, [r2, #0]
    9538:	1c1f      	adds	r7, r3, #0
    953a:	54d4      	strb	r4, [r2, r3]
    953c:	1c5c      	adds	r4, r3, #1
    953e:	5516      	strb	r6, [r2, r4]
    9540:	240e      	movs	r4, #14
    9542:	1c9e      	adds	r6, r3, #2
    9544:	5594      	strb	r4, [r2, r6]
    9546:	1cde      	adds	r6, r3, #3
    9548:	5594      	strb	r4, [r2, r6]
    954a:	1d1c      	adds	r4, r3, #4
    954c:	5515      	strb	r5, [r2, r4]
    954e:	2510      	movs	r5, #16
    9550:	1d5c      	adds	r4, r3, #5
    9552:	5515      	strb	r5, [r2, r4]
    9554:	2500      	movs	r5, #0
    9556:	468c      	mov	ip, r1
    9558:	1d9c      	adds	r4, r3, #6
    955a:	5515      	strb	r5, [r2, r4]
    955c:	1dde      	adds	r6, r3, #7
    955e:	3402      	adds	r4, #2
    9560:	3709      	adds	r7, #9
    9562:	1996      	adds	r6, r2, r6
    9564:	1914      	adds	r4, r2, r4
    9566:	7035      	strb	r5, [r6, #0]
    9568:	7025      	strb	r5, [r4, #0]
    956a:	55d1      	strb	r1, [r2, r7]
    956c:	4467      	add	r7, ip
    956e:	4669      	mov	r1, sp
    9570:	55d0      	strb	r0, [r2, r7]
    9572:	1c18      	adds	r0, r3, #0
    9574:	7909      	ldrb	r1, [r1, #4]
    9576:	300b      	adds	r0, #11
    9578:	5411      	strb	r1, [r2, r0]
    957a:	4668      	mov	r0, sp
    957c:	1c19      	adds	r1, r3, #0
    957e:	7a00      	ldrb	r0, [r0, #8]
    9580:	310c      	adds	r1, #12
    9582:	5450      	strb	r0, [r2, r1]
    9584:	4668      	mov	r0, sp
    9586:	7b00      	ldrb	r0, [r0, #12]
    9588:	4461      	add	r1, ip
    958a:	5450      	strb	r0, [r2, r1]
    958c:	4668      	mov	r0, sp
    958e:	7c00      	ldrb	r0, [r0, #16]
    9590:	4461      	add	r1, ip
    9592:	5450      	strb	r0, [r2, r1]
    9594:	4668      	mov	r0, sp
    9596:	7d00      	ldrb	r0, [r0, #20]
    9598:	4461      	add	r1, ip
    959a:	5450      	strb	r0, [r2, r1]
    959c:	4668      	mov	r0, sp
    959e:	7e00      	ldrb	r0, [r0, #24]
    95a0:	4461      	add	r1, ip
    95a2:	5450      	strb	r0, [r2, r1]
    95a4:	4668      	mov	r0, sp
    95a6:	7f00      	ldrb	r0, [r0, #28]
    95a8:	3311      	adds	r3, #17
    95aa:	54d0      	strb	r0, [r2, r3]
    95ac:	4b0a      	ldr	r3, [pc, #40]	; (95d8 <gapc_bond_cfm_handler_pair_resp+0xec>)
    95ae:	3102      	adds	r1, #2
    95b0:	781b      	ldrb	r3, [r3, #0]
    95b2:	2b02      	cmp	r3, #2
    95b4:	d102      	bne.n	95bc <gapc_bond_cfm_handler_pair_resp+0xd0>
    95b6:	1c0b      	adds	r3, r1, #0
    95b8:	3b0c      	subs	r3, #12
    95ba:	e001      	b.n	95c0 <gapc_bond_cfm_handler_pair_resp+0xd4>
    95bc:	1c0b      	adds	r3, r1, #0
    95be:	3b09      	subs	r3, #9
    95c0:	7033      	strb	r3, [r6, #0]
    95c2:	1c10      	adds	r0, r2, #0
    95c4:	7025      	strb	r5, [r4, #0]
    95c6:	4b06      	ldr	r3, [pc, #24]	; (95e0 <gapc_bond_cfm_handler_pair_resp+0xf4>)
    95c8:	4798      	blx	r3
    95ca:	4b06      	ldr	r3, [pc, #24]	; (95e4 <gapc_bond_cfm_handler_pair_resp+0xf8>)
    95cc:	4798      	blx	r3
    95ce:	4b06      	ldr	r3, [pc, #24]	; (95e8 <gapc_bond_cfm_handler_pair_resp+0xfc>)
    95d0:	4798      	blx	r3
    95d2:	b009      	add	sp, #36	; 0x24
    95d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    95d6:	46c0      	nop			; (mov r8, r8)
    95d8:	20000005 	.word	0x20000005
    95dc:	00011148 	.word	0x00011148
    95e0:	00008a29 	.word	0x00008a29
    95e4:	00008835 	.word	0x00008835
    95e8:	00001895 	.word	0x00001895

000095ec <gapc_bond_cfm_handler_key_exch>:
    95ec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    95ee:	4694      	mov	ip, r2
    95f0:	4a24      	ldr	r2, [pc, #144]	; (9684 <gapc_bond_cfm_handler_key_exch+0x98>)
    95f2:	4d25      	ldr	r5, [pc, #148]	; (9688 <gapc_bond_cfm_handler_key_exch+0x9c>)
    95f4:	7812      	ldrb	r2, [r2, #0]
    95f6:	2400      	movs	r4, #0
    95f8:	2a02      	cmp	r2, #2
    95fa:	d107      	bne.n	960c <gapc_bond_cfm_handler_key_exch+0x20>
    95fc:	682a      	ldr	r2, [r5, #0]
    95fe:	3452      	adds	r4, #82	; 0x52
    9600:	7014      	strb	r4, [r2, #0]
    9602:	3405      	adds	r4, #5
    9604:	7054      	strb	r4, [r2, #1]
    9606:	3c36      	subs	r4, #54	; 0x36
    9608:	7094      	strb	r4, [r2, #2]
    960a:	3c1e      	subs	r4, #30
    960c:	2205      	movs	r2, #5
    960e:	2614      	movs	r6, #20
    9610:	682d      	ldr	r5, [r5, #0]
    9612:	1de7      	adds	r7, r4, #7
    9614:	552a      	strb	r2, [r5, r4]
    9616:	1c62      	adds	r2, r4, #1
    9618:	54ae      	strb	r6, [r5, r2]
    961a:	220e      	movs	r2, #14
    961c:	1ca6      	adds	r6, r4, #2
    961e:	55aa      	strb	r2, [r5, r6]
    9620:	1ce6      	adds	r6, r4, #3
    9622:	55aa      	strb	r2, [r5, r6]
    9624:	1d22      	adds	r2, r4, #4
    9626:	54ab      	strb	r3, [r5, r2]
    9628:	2210      	movs	r2, #16
    962a:	2600      	movs	r6, #0
    962c:	1d63      	adds	r3, r4, #5
    962e:	54ea      	strb	r2, [r5, r3]
    9630:	1da3      	adds	r3, r4, #6
    9632:	54ee      	strb	r6, [r5, r3]
    9634:	3302      	adds	r3, #2
    9636:	18eb      	adds	r3, r5, r3
    9638:	19ef      	adds	r7, r5, r7
    963a:	703e      	strb	r6, [r7, #0]
    963c:	9301      	str	r3, [sp, #4]
    963e:	701e      	strb	r6, [r3, #0]
    9640:	1c23      	adds	r3, r4, #0
    9642:	3309      	adds	r3, #9
    9644:	54e8      	strb	r0, [r5, r3]
    9646:	1c20      	adds	r0, r4, #0
    9648:	3301      	adds	r3, #1
    964a:	300b      	adds	r0, #11
    964c:	54e9      	strb	r1, [r5, r3]
    964e:	1828      	adds	r0, r5, r0
    9650:	4661      	mov	r1, ip
    9652:	4b0e      	ldr	r3, [pc, #56]	; (968c <gapc_bond_cfm_handler_key_exch+0xa0>)
    9654:	4798      	blx	r3
    9656:	1c21      	adds	r1, r4, #0
    9658:	4b0a      	ldr	r3, [pc, #40]	; (9684 <gapc_bond_cfm_handler_key_exch+0x98>)
    965a:	311b      	adds	r1, #27
    965c:	781b      	ldrb	r3, [r3, #0]
    965e:	2b02      	cmp	r3, #2
    9660:	d102      	bne.n	9668 <gapc_bond_cfm_handler_key_exch+0x7c>
    9662:	1c0b      	adds	r3, r1, #0
    9664:	3b0c      	subs	r3, #12
    9666:	e001      	b.n	966c <gapc_bond_cfm_handler_key_exch+0x80>
    9668:	1c0b      	adds	r3, r1, #0
    966a:	3b09      	subs	r3, #9
    966c:	703b      	strb	r3, [r7, #0]
    966e:	9b01      	ldr	r3, [sp, #4]
    9670:	1c28      	adds	r0, r5, #0
    9672:	701e      	strb	r6, [r3, #0]
    9674:	4b06      	ldr	r3, [pc, #24]	; (9690 <gapc_bond_cfm_handler_key_exch+0xa4>)
    9676:	4798      	blx	r3
    9678:	4b06      	ldr	r3, [pc, #24]	; (9694 <gapc_bond_cfm_handler_key_exch+0xa8>)
    967a:	4798      	blx	r3
    967c:	4b06      	ldr	r3, [pc, #24]	; (9698 <gapc_bond_cfm_handler_key_exch+0xac>)
    967e:	4798      	blx	r3
    9680:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    9682:	46c0      	nop			; (mov r8, r8)
    9684:	20000005 	.word	0x20000005
    9688:	00011148 	.word	0x00011148
    968c:	0000d7eb 	.word	0x0000d7eb
    9690:	00008a29 	.word	0x00008a29
    9694:	00008835 	.word	0x00008835
    9698:	00001895 	.word	0x00001895

0000969c <gapc_security_cmd_handler>:
    969c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    969e:	4e23      	ldr	r6, [pc, #140]	; (972c <gapc_security_cmd_handler+0x90>)
    96a0:	1c0f      	adds	r7, r1, #0
    96a2:	7831      	ldrb	r1, [r6, #0]
    96a4:	9601      	str	r6, [sp, #4]
    96a6:	4a22      	ldr	r2, [pc, #136]	; (9730 <gapc_security_cmd_handler+0x94>)
    96a8:	2300      	movs	r3, #0
    96aa:	2902      	cmp	r1, #2
    96ac:	d107      	bne.n	96be <gapc_security_cmd_handler+0x22>
    96ae:	6813      	ldr	r3, [r2, #0]
    96b0:	3150      	adds	r1, #80	; 0x50
    96b2:	7019      	strb	r1, [r3, #0]
    96b4:	3105      	adds	r1, #5
    96b6:	7059      	strb	r1, [r3, #1]
    96b8:	3936      	subs	r1, #54	; 0x36
    96ba:	7099      	strb	r1, [r3, #2]
    96bc:	2303      	movs	r3, #3
    96be:	2105      	movs	r1, #5
    96c0:	241a      	movs	r4, #26
    96c2:	6812      	ldr	r2, [r2, #0]
    96c4:	2500      	movs	r5, #0
    96c6:	54d1      	strb	r1, [r2, r3]
    96c8:	1c59      	adds	r1, r3, #1
    96ca:	5454      	strb	r4, [r2, r1]
    96cc:	210e      	movs	r1, #14
    96ce:	1c9c      	adds	r4, r3, #2
    96d0:	5511      	strb	r1, [r2, r4]
    96d2:	1cdc      	adds	r4, r3, #3
    96d4:	5511      	strb	r1, [r2, r4]
    96d6:	1d19      	adds	r1, r3, #4
    96d8:	5450      	strb	r0, [r2, r1]
    96da:	2010      	movs	r0, #16
    96dc:	1d59      	adds	r1, r3, #5
    96de:	5450      	strb	r0, [r2, r1]
    96e0:	1c18      	adds	r0, r3, #0
    96e2:	260c      	movs	r6, #12
    96e4:	1d99      	adds	r1, r3, #6
    96e6:	1ddc      	adds	r4, r3, #7
    96e8:	3008      	adds	r0, #8
    96ea:	5455      	strb	r5, [r2, r1]
    96ec:	330a      	adds	r3, #10
    96ee:	3103      	adds	r1, #3
    96f0:	1914      	adds	r4, r2, r4
    96f2:	1810      	adds	r0, r2, r0
    96f4:	7025      	strb	r5, [r4, #0]
    96f6:	7005      	strb	r5, [r0, #0]
    96f8:	5456      	strb	r6, [r2, r1]
    96fa:	54d7      	strb	r7, [r2, r3]
    96fc:	9b01      	ldr	r3, [sp, #4]
    96fe:	3102      	adds	r1, #2
    9700:	781b      	ldrb	r3, [r3, #0]
    9702:	2b02      	cmp	r3, #2
    9704:	d105      	bne.n	9712 <gapc_security_cmd_handler+0x76>
    9706:	1c0b      	adds	r3, r1, #0
    9708:	3b0c      	subs	r3, #12
    970a:	7023      	strb	r3, [r4, #0]
    970c:	121b      	asrs	r3, r3, #8
    970e:	7003      	strb	r3, [r0, #0]
    9710:	e003      	b.n	971a <gapc_security_cmd_handler+0x7e>
    9712:	1c0b      	adds	r3, r1, #0
    9714:	3b09      	subs	r3, #9
    9716:	7023      	strb	r3, [r4, #0]
    9718:	7005      	strb	r5, [r0, #0]
    971a:	1c10      	adds	r0, r2, #0
    971c:	4b05      	ldr	r3, [pc, #20]	; (9734 <gapc_security_cmd_handler+0x98>)
    971e:	4798      	blx	r3
    9720:	4b05      	ldr	r3, [pc, #20]	; (9738 <gapc_security_cmd_handler+0x9c>)
    9722:	4798      	blx	r3
    9724:	4b05      	ldr	r3, [pc, #20]	; (973c <gapc_security_cmd_handler+0xa0>)
    9726:	4798      	blx	r3
    9728:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    972a:	46c0      	nop			; (mov r8, r8)
    972c:	20000005 	.word	0x20000005
    9730:	00011148 	.word	0x00011148
    9734:	00008a29 	.word	0x00008a29
    9738:	00008835 	.word	0x00008835
    973c:	00001895 	.word	0x00001895

00009740 <gapc_encrypt_cmd_handler>:
    9740:	b5f0      	push	{r4, r5, r6, r7, lr}
    9742:	2400      	movs	r4, #0
    9744:	b08b      	sub	sp, #44	; 0x2c
    9746:	9308      	str	r3, [sp, #32]
    9748:	ab10      	add	r3, sp, #64	; 0x40
    974a:	781b      	ldrb	r3, [r3, #0]
    974c:	9207      	str	r2, [sp, #28]
    974e:	9309      	str	r3, [sp, #36]	; 0x24
    9750:	ab11      	add	r3, sp, #68	; 0x44
    9752:	781b      	ldrb	r3, [r3, #0]
    9754:	4a36      	ldr	r2, [pc, #216]	; (9830 <gapc_encrypt_cmd_handler+0xf0>)
    9756:	9300      	str	r3, [sp, #0]
    9758:	9002      	str	r0, [sp, #8]
    975a:	1c23      	adds	r3, r4, #0
    975c:	1c06      	adds	r6, r0, #0
    975e:	1c0f      	adds	r7, r1, #0
    9760:	1c10      	adds	r0, r2, #0
    9762:	9401      	str	r4, [sp, #4]
    9764:	1c21      	adds	r1, r4, #0
    9766:	4d33      	ldr	r5, [pc, #204]	; (9834 <gapc_encrypt_cmd_handler+0xf4>)
    9768:	47a8      	blx	r5
    976a:	4b33      	ldr	r3, [pc, #204]	; (9838 <gapc_encrypt_cmd_handler+0xf8>)
    976c:	4a33      	ldr	r2, [pc, #204]	; (983c <gapc_encrypt_cmd_handler+0xfc>)
    976e:	781b      	ldrb	r3, [r3, #0]
    9770:	2b02      	cmp	r3, #2
    9772:	d107      	bne.n	9784 <gapc_encrypt_cmd_handler+0x44>
    9774:	2152      	movs	r1, #82	; 0x52
    9776:	6813      	ldr	r3, [r2, #0]
    9778:	3403      	adds	r4, #3
    977a:	7019      	strb	r1, [r3, #0]
    977c:	3105      	adds	r1, #5
    977e:	7059      	strb	r1, [r3, #1]
    9780:	3936      	subs	r1, #54	; 0x36
    9782:	7099      	strb	r1, [r3, #2]
    9784:	2305      	movs	r3, #5
    9786:	6815      	ldr	r5, [r2, #0]
    9788:	2216      	movs	r2, #22
    978a:	552b      	strb	r3, [r5, r4]
    978c:	1c63      	adds	r3, r4, #1
    978e:	54ea      	strb	r2, [r5, r3]
    9790:	230e      	movs	r3, #14
    9792:	1ca2      	adds	r2, r4, #2
    9794:	54ab      	strb	r3, [r5, r2]
    9796:	1ce2      	adds	r2, r4, #3
    9798:	54ab      	strb	r3, [r5, r2]
    979a:	1d23      	adds	r3, r4, #4
    979c:	2210      	movs	r2, #16
    979e:	54ee      	strb	r6, [r5, r3]
    97a0:	2600      	movs	r6, #0
    97a2:	1d63      	adds	r3, r4, #5
    97a4:	54ea      	strb	r2, [r5, r3]
    97a6:	1da3      	adds	r3, r4, #6
    97a8:	54ee      	strb	r6, [r5, r3]
    97aa:	1de3      	adds	r3, r4, #7
    97ac:	18eb      	adds	r3, r5, r3
    97ae:	701e      	strb	r6, [r3, #0]
    97b0:	9305      	str	r3, [sp, #20]
    97b2:	1c23      	adds	r3, r4, #0
    97b4:	3308      	adds	r3, #8
    97b6:	18eb      	adds	r3, r5, r3
    97b8:	701e      	strb	r6, [r3, #0]
    97ba:	9306      	str	r3, [sp, #24]
    97bc:	1c23      	adds	r3, r4, #0
    97be:	210b      	movs	r1, #11
    97c0:	3309      	adds	r3, #9
    97c2:	54e9      	strb	r1, [r5, r3]
    97c4:	1860      	adds	r0, r4, r1
    97c6:	3301      	adds	r3, #1
    97c8:	1c39      	adds	r1, r7, #0
    97ca:	54ee      	strb	r6, [r5, r3]
    97cc:	4f1c      	ldr	r7, [pc, #112]	; (9840 <gapc_encrypt_cmd_handler+0x100>)
    97ce:	1828      	adds	r0, r5, r0
    97d0:	47b8      	blx	r7
    97d2:	466a      	mov	r2, sp
    97d4:	1c23      	adds	r3, r4, #0
    97d6:	7f12      	ldrb	r2, [r2, #28]
    97d8:	331b      	adds	r3, #27
    97da:	54ea      	strb	r2, [r5, r3]
    97dc:	1c20      	adds	r0, r4, #0
    97de:	1c22      	adds	r2, r4, #0
    97e0:	9b07      	ldr	r3, [sp, #28]
    97e2:	321c      	adds	r2, #28
    97e4:	0a1b      	lsrs	r3, r3, #8
    97e6:	301d      	adds	r0, #29
    97e8:	54ab      	strb	r3, [r5, r2]
    97ea:	9908      	ldr	r1, [sp, #32]
    97ec:	2208      	movs	r2, #8
    97ee:	1828      	adds	r0, r5, r0
    97f0:	47b8      	blx	r7
    97f2:	466b      	mov	r3, sp
    97f4:	2224      	movs	r2, #36	; 0x24
    97f6:	1c21      	adds	r1, r4, #0
    97f8:	189b      	adds	r3, r3, r2
    97fa:	781b      	ldrb	r3, [r3, #0]
    97fc:	3425      	adds	r4, #37	; 0x25
    97fe:	552b      	strb	r3, [r5, r4]
    9800:	4b0d      	ldr	r3, [pc, #52]	; (9838 <gapc_encrypt_cmd_handler+0xf8>)
    9802:	3126      	adds	r1, #38	; 0x26
    9804:	781b      	ldrb	r3, [r3, #0]
    9806:	2b02      	cmp	r3, #2
    9808:	d102      	bne.n	9810 <gapc_encrypt_cmd_handler+0xd0>
    980a:	1c0b      	adds	r3, r1, #0
    980c:	3b0c      	subs	r3, #12
    980e:	e001      	b.n	9814 <gapc_encrypt_cmd_handler+0xd4>
    9810:	1c0b      	adds	r3, r1, #0
    9812:	3b09      	subs	r3, #9
    9814:	9a05      	ldr	r2, [sp, #20]
    9816:	1c28      	adds	r0, r5, #0
    9818:	7013      	strb	r3, [r2, #0]
    981a:	9b06      	ldr	r3, [sp, #24]
    981c:	701e      	strb	r6, [r3, #0]
    981e:	4b09      	ldr	r3, [pc, #36]	; (9844 <gapc_encrypt_cmd_handler+0x104>)
    9820:	4798      	blx	r3
    9822:	4b09      	ldr	r3, [pc, #36]	; (9848 <gapc_encrypt_cmd_handler+0x108>)
    9824:	4798      	blx	r3
    9826:	4b09      	ldr	r3, [pc, #36]	; (984c <gapc_encrypt_cmd_handler+0x10c>)
    9828:	4798      	blx	r3
    982a:	b00b      	add	sp, #44	; 0x2c
    982c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    982e:	46c0      	nop			; (mov r8, r8)
    9830:	20000620 	.word	0x20000620
    9834:	00008ee9 	.word	0x00008ee9
    9838:	20000005 	.word	0x20000005
    983c:	00011148 	.word	0x00011148
    9840:	0000d7eb 	.word	0x0000d7eb
    9844:	00008a29 	.word	0x00008a29
    9848:	00008835 	.word	0x00008835
    984c:	00001895 	.word	0x00001895

00009850 <gapc_encrypt_req_ind>:
    9850:	b508      	push	{r3, lr}
    9852:	0a00      	lsrs	r0, r0, #8
    9854:	8010      	strh	r0, [r2, #0]
    9856:	784b      	ldrb	r3, [r1, #1]
    9858:	7808      	ldrb	r0, [r1, #0]
    985a:	021b      	lsls	r3, r3, #8
    985c:	4303      	orrs	r3, r0
    985e:	8053      	strh	r3, [r2, #2]
    9860:	1d10      	adds	r0, r2, #4
    9862:	3102      	adds	r1, #2
    9864:	2208      	movs	r2, #8
    9866:	4b01      	ldr	r3, [pc, #4]	; (986c <gapc_encrypt_req_ind+0x1c>)
    9868:	4798      	blx	r3
    986a:	bd08      	pop	{r3, pc}
    986c:	0000d7eb 	.word	0x0000d7eb

00009870 <gapc_encrypt_cfm_handler>:
    9870:	b5f0      	push	{r4, r5, r6, r7, lr}
    9872:	2400      	movs	r4, #0
    9874:	b089      	sub	sp, #36	; 0x24
    9876:	9306      	str	r3, [sp, #24]
    9878:	ab0e      	add	r3, sp, #56	; 0x38
    987a:	781b      	ldrb	r3, [r3, #0]
    987c:	9205      	str	r2, [sp, #20]
    987e:	4a2c      	ldr	r2, [pc, #176]	; (9930 <gapc_encrypt_cfm_handler+0xc0>)
    9880:	9307      	str	r3, [sp, #28]
    9882:	9100      	str	r1, [sp, #0]
    9884:	9002      	str	r0, [sp, #8]
    9886:	1c23      	adds	r3, r4, #0
    9888:	1c06      	adds	r6, r0, #0
    988a:	9401      	str	r4, [sp, #4]
    988c:	1c10      	adds	r0, r2, #0
    988e:	1c21      	adds	r1, r4, #0
    9890:	4d28      	ldr	r5, [pc, #160]	; (9934 <gapc_encrypt_cfm_handler+0xc4>)
    9892:	47a8      	blx	r5
    9894:	4b28      	ldr	r3, [pc, #160]	; (9938 <gapc_encrypt_cfm_handler+0xc8>)
    9896:	4a29      	ldr	r2, [pc, #164]	; (993c <gapc_encrypt_cfm_handler+0xcc>)
    9898:	781b      	ldrb	r3, [r3, #0]
    989a:	2b02      	cmp	r3, #2
    989c:	d107      	bne.n	98ae <gapc_encrypt_cfm_handler+0x3e>
    989e:	2152      	movs	r1, #82	; 0x52
    98a0:	6813      	ldr	r3, [r2, #0]
    98a2:	3403      	adds	r4, #3
    98a4:	7019      	strb	r1, [r3, #0]
    98a6:	3105      	adds	r1, #5
    98a8:	7059      	strb	r1, [r3, #1]
    98aa:	3936      	subs	r1, #54	; 0x36
    98ac:	7099      	strb	r1, [r3, #2]
    98ae:	2305      	movs	r3, #5
    98b0:	6815      	ldr	r5, [r2, #0]
    98b2:	2218      	movs	r2, #24
    98b4:	552b      	strb	r3, [r5, r4]
    98b6:	1c63      	adds	r3, r4, #1
    98b8:	54ea      	strb	r2, [r5, r3]
    98ba:	230e      	movs	r3, #14
    98bc:	1ca2      	adds	r2, r4, #2
    98be:	54ab      	strb	r3, [r5, r2]
    98c0:	1ce2      	adds	r2, r4, #3
    98c2:	54ab      	strb	r3, [r5, r2]
    98c4:	1d23      	adds	r3, r4, #4
    98c6:	2210      	movs	r2, #16
    98c8:	54ee      	strb	r6, [r5, r3]
    98ca:	2600      	movs	r6, #0
    98cc:	1d63      	adds	r3, r4, #5
    98ce:	54ea      	strb	r2, [r5, r3]
    98d0:	1da3      	adds	r3, r4, #6
    98d2:	54ee      	strb	r6, [r5, r3]
    98d4:	1de7      	adds	r7, r4, #7
    98d6:	3302      	adds	r3, #2
    98d8:	18eb      	adds	r3, r5, r3
    98da:	19ef      	adds	r7, r5, r7
    98dc:	4669      	mov	r1, sp
    98de:	703e      	strb	r6, [r7, #0]
    98e0:	9304      	str	r3, [sp, #16]
    98e2:	701e      	strb	r6, [r3, #0]
    98e4:	1c20      	adds	r0, r4, #0
    98e6:	1c23      	adds	r3, r4, #0
    98e8:	7d09      	ldrb	r1, [r1, #20]
    98ea:	3309      	adds	r3, #9
    98ec:	300a      	adds	r0, #10
    98ee:	54e9      	strb	r1, [r5, r3]
    98f0:	1828      	adds	r0, r5, r0
    98f2:	9906      	ldr	r1, [sp, #24]
    98f4:	4b12      	ldr	r3, [pc, #72]	; (9940 <gapc_encrypt_cfm_handler+0xd0>)
    98f6:	4798      	blx	r3
    98f8:	466b      	mov	r3, sp
    98fa:	1c21      	adds	r1, r4, #0
    98fc:	7f1b      	ldrb	r3, [r3, #28]
    98fe:	341a      	adds	r4, #26
    9900:	552b      	strb	r3, [r5, r4]
    9902:	4b0d      	ldr	r3, [pc, #52]	; (9938 <gapc_encrypt_cfm_handler+0xc8>)
    9904:	311b      	adds	r1, #27
    9906:	781b      	ldrb	r3, [r3, #0]
    9908:	2b02      	cmp	r3, #2
    990a:	d102      	bne.n	9912 <gapc_encrypt_cfm_handler+0xa2>
    990c:	1c0b      	adds	r3, r1, #0
    990e:	3b0c      	subs	r3, #12
    9910:	e001      	b.n	9916 <gapc_encrypt_cfm_handler+0xa6>
    9912:	1c0b      	adds	r3, r1, #0
    9914:	3b09      	subs	r3, #9
    9916:	703b      	strb	r3, [r7, #0]
    9918:	9b04      	ldr	r3, [sp, #16]
    991a:	1c28      	adds	r0, r5, #0
    991c:	701e      	strb	r6, [r3, #0]
    991e:	4b09      	ldr	r3, [pc, #36]	; (9944 <gapc_encrypt_cfm_handler+0xd4>)
    9920:	4798      	blx	r3
    9922:	4b09      	ldr	r3, [pc, #36]	; (9948 <gapc_encrypt_cfm_handler+0xd8>)
    9924:	4798      	blx	r3
    9926:	4b09      	ldr	r3, [pc, #36]	; (994c <gapc_encrypt_cfm_handler+0xdc>)
    9928:	4798      	blx	r3
    992a:	b009      	add	sp, #36	; 0x24
    992c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    992e:	46c0      	nop			; (mov r8, r8)
    9930:	20000686 	.word	0x20000686
    9934:	00008ee9 	.word	0x00008ee9
    9938:	20000005 	.word	0x20000005
    993c:	00011148 	.word	0x00011148
    9940:	0000d7eb 	.word	0x0000d7eb
    9944:	00008a29 	.word	0x00008a29
    9948:	00008835 	.word	0x00008835
    994c:	00001895 	.word	0x00001895

00009950 <gapc_encrypt_ind>:
    9950:	780b      	ldrb	r3, [r1, #0]
    9952:	0a00      	lsrs	r0, r0, #8
    9954:	70d3      	strb	r3, [r2, #3]
    9956:	2300      	movs	r3, #0
    9958:	8010      	strh	r0, [r2, #0]
    995a:	7093      	strb	r3, [r2, #2]
    995c:	4770      	bx	lr
	...

00009960 <gapc_param_update_cfm_handler>:
    9960:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9962:	1c05      	adds	r5, r0, #0
    9964:	4829      	ldr	r0, [pc, #164]	; (9a0c <gapc_param_update_cfm_handler+0xac>)
    9966:	9101      	str	r1, [sp, #4]
    9968:	7800      	ldrb	r0, [r0, #0]
    996a:	9300      	str	r3, [sp, #0]
    996c:	4e28      	ldr	r6, [pc, #160]	; (9a10 <gapc_param_update_cfm_handler+0xb0>)
    996e:	2400      	movs	r4, #0
    9970:	2802      	cmp	r0, #2
    9972:	d107      	bne.n	9984 <gapc_param_update_cfm_handler+0x24>
    9974:	6830      	ldr	r0, [r6, #0]
    9976:	3452      	adds	r4, #82	; 0x52
    9978:	7004      	strb	r4, [r0, #0]
    997a:	3405      	adds	r4, #5
    997c:	7044      	strb	r4, [r0, #1]
    997e:	3c36      	subs	r4, #54	; 0x36
    9980:	7084      	strb	r4, [r0, #2]
    9982:	3c1e      	subs	r4, #30
    9984:	6830      	ldr	r0, [r6, #0]
    9986:	2605      	movs	r6, #5
    9988:	1c67      	adds	r7, r4, #1
    998a:	5506      	strb	r6, [r0, r4]
    998c:	360b      	adds	r6, #11
    998e:	55c6      	strb	r6, [r0, r7]
    9990:	1ca7      	adds	r7, r4, #2
    9992:	46bc      	mov	ip, r7
    9994:	270e      	movs	r7, #14
    9996:	4661      	mov	r1, ip
    9998:	5447      	strb	r7, [r0, r1]
    999a:	1ce1      	adds	r1, r4, #3
    999c:	5447      	strb	r7, [r0, r1]
    999e:	2109      	movs	r1, #9
    99a0:	468c      	mov	ip, r1
    99a2:	1d27      	adds	r7, r4, #4
    99a4:	55c5      	strb	r5, [r0, r7]
    99a6:	1d65      	adds	r5, r4, #5
    99a8:	5546      	strb	r6, [r0, r5]
    99aa:	466b      	mov	r3, sp
    99ac:	2600      	movs	r6, #0
    99ae:	44a4      	add	ip, r4
    99b0:	4661      	mov	r1, ip
    99b2:	1da5      	adds	r5, r4, #6
    99b4:	5546      	strb	r6, [r0, r5]
    99b6:	1de7      	adds	r7, r4, #7
    99b8:	791b      	ldrb	r3, [r3, #4]
    99ba:	3502      	adds	r5, #2
    99bc:	19c7      	adds	r7, r0, r7
    99be:	1945      	adds	r5, r0, r5
    99c0:	703e      	strb	r6, [r7, #0]
    99c2:	702e      	strb	r6, [r5, #0]
    99c4:	5443      	strb	r3, [r0, r1]
    99c6:	3101      	adds	r1, #1
    99c8:	5442      	strb	r2, [r0, r1]
    99ca:	466b      	mov	r3, sp
    99cc:	3101      	adds	r1, #1
    99ce:	0a12      	lsrs	r2, r2, #8
    99d0:	5442      	strb	r2, [r0, r1]
    99d2:	1c22      	adds	r2, r4, #0
    99d4:	781b      	ldrb	r3, [r3, #0]
    99d6:	320c      	adds	r2, #12
    99d8:	5483      	strb	r3, [r0, r2]
    99da:	9b00      	ldr	r3, [sp, #0]
    99dc:	340d      	adds	r4, #13
    99de:	0a1b      	lsrs	r3, r3, #8
    99e0:	5503      	strb	r3, [r0, r4]
    99e2:	4b0a      	ldr	r3, [pc, #40]	; (9a0c <gapc_param_update_cfm_handler+0xac>)
    99e4:	3103      	adds	r1, #3
    99e6:	781b      	ldrb	r3, [r3, #0]
    99e8:	2b02      	cmp	r3, #2
    99ea:	d102      	bne.n	99f2 <gapc_param_update_cfm_handler+0x92>
    99ec:	1c0b      	adds	r3, r1, #0
    99ee:	3b0c      	subs	r3, #12
    99f0:	e001      	b.n	99f6 <gapc_param_update_cfm_handler+0x96>
    99f2:	1c0b      	adds	r3, r1, #0
    99f4:	3b09      	subs	r3, #9
    99f6:	703b      	strb	r3, [r7, #0]
    99f8:	702e      	strb	r6, [r5, #0]
    99fa:	4b06      	ldr	r3, [pc, #24]	; (9a14 <gapc_param_update_cfm_handler+0xb4>)
    99fc:	4798      	blx	r3
    99fe:	4b06      	ldr	r3, [pc, #24]	; (9a18 <gapc_param_update_cfm_handler+0xb8>)
    9a00:	4798      	blx	r3
    9a02:	4b06      	ldr	r3, [pc, #24]	; (9a1c <gapc_param_update_cfm_handler+0xbc>)
    9a04:	4798      	blx	r3
    9a06:	2000      	movs	r0, #0
    9a08:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    9a0a:	46c0      	nop			; (mov r8, r8)
    9a0c:	20000005 	.word	0x20000005
    9a10:	00011148 	.word	0x00011148
    9a14:	00008a29 	.word	0x00008a29
    9a18:	00008835 	.word	0x00008835
    9a1c:	00001895 	.word	0x00001895

00009a20 <gapc_param_updated_ind>:
    9a20:	2300      	movs	r3, #0
    9a22:	0a00      	lsrs	r0, r0, #8
    9a24:	8010      	strh	r0, [r2, #0]
    9a26:	7093      	strb	r3, [r2, #2]
    9a28:	784b      	ldrb	r3, [r1, #1]
    9a2a:	7808      	ldrb	r0, [r1, #0]
    9a2c:	021b      	lsls	r3, r3, #8
    9a2e:	4303      	orrs	r3, r0
    9a30:	8093      	strh	r3, [r2, #4]
    9a32:	78cb      	ldrb	r3, [r1, #3]
    9a34:	7888      	ldrb	r0, [r1, #2]
    9a36:	021b      	lsls	r3, r3, #8
    9a38:	4303      	orrs	r3, r0
    9a3a:	80d3      	strh	r3, [r2, #6]
    9a3c:	794b      	ldrb	r3, [r1, #5]
    9a3e:	7909      	ldrb	r1, [r1, #4]
    9a40:	021b      	lsls	r3, r3, #8
    9a42:	430b      	orrs	r3, r1
    9a44:	2007      	movs	r0, #7
    9a46:	8113      	strh	r3, [r2, #8]
    9a48:	4770      	bx	lr

00009a4a <gapc_param_updated_req_ind>:
    9a4a:	0a00      	lsrs	r0, r0, #8
    9a4c:	8010      	strh	r0, [r2, #0]
    9a4e:	784b      	ldrb	r3, [r1, #1]
    9a50:	7808      	ldrb	r0, [r1, #0]
    9a52:	021b      	lsls	r3, r3, #8
    9a54:	4303      	orrs	r3, r0
    9a56:	8053      	strh	r3, [r2, #2]
    9a58:	78cb      	ldrb	r3, [r1, #3]
    9a5a:	7888      	ldrb	r0, [r1, #2]
    9a5c:	021b      	lsls	r3, r3, #8
    9a5e:	4303      	orrs	r3, r0
    9a60:	8093      	strh	r3, [r2, #4]
    9a62:	794b      	ldrb	r3, [r1, #5]
    9a64:	7908      	ldrb	r0, [r1, #4]
    9a66:	021b      	lsls	r3, r3, #8
    9a68:	4303      	orrs	r3, r0
    9a6a:	80d3      	strh	r3, [r2, #6]
    9a6c:	79cb      	ldrb	r3, [r1, #7]
    9a6e:	7989      	ldrb	r1, [r1, #6]
    9a70:	021b      	lsls	r3, r3, #8
    9a72:	430b      	orrs	r3, r1
    9a74:	2008      	movs	r0, #8
    9a76:	8113      	strh	r3, [r2, #8]
    9a78:	4770      	bx	lr
	...

00009a7c <gapc_dev_info_req_ind_handler>:
    9a7c:	b538      	push	{r3, r4, r5, lr}
    9a7e:	1c0b      	adds	r3, r1, #0
    9a80:	0a01      	lsrs	r1, r0, #8
    9a82:	8011      	strh	r1, [r2, #0]
    9a84:	7818      	ldrb	r0, [r3, #0]
    9a86:	7090      	strb	r0, [r2, #2]
    9a88:	2800      	cmp	r0, #0
    9a8a:	d10f      	bne.n	9aac <gapc_dev_info_req_ind_handler+0x30>
    9a8c:	4b09      	ldr	r3, [pc, #36]	; (9ab4 <gapc_dev_info_req_ind_handler+0x38>)
    9a8e:	33aa      	adds	r3, #170	; 0xaa
    9a90:	881b      	ldrh	r3, [r3, #0]
    9a92:	2b00      	cmp	r3, #0
    9a94:	d10a      	bne.n	9aac <gapc_dev_info_req_ind_handler+0x30>
    9a96:	4c08      	ldr	r4, [pc, #32]	; (9ab8 <gapc_dev_info_req_ind_handler+0x3c>)
    9a98:	4908      	ldr	r1, [pc, #32]	; (9abc <gapc_dev_info_req_ind_handler+0x40>)
    9a9a:	4a09      	ldr	r2, [pc, #36]	; (9ac0 <gapc_dev_info_req_ind_handler+0x44>)
    9a9c:	4b09      	ldr	r3, [pc, #36]	; (9ac4 <gapc_dev_info_req_ind_handler+0x48>)
    9a9e:	6825      	ldr	r5, [r4, #0]
    9aa0:	4809      	ldr	r0, [pc, #36]	; (9ac8 <gapc_dev_info_req_ind_handler+0x4c>)
    9aa2:	47a8      	blx	r5
    9aa4:	6823      	ldr	r3, [r4, #0]
    9aa6:	4809      	ldr	r0, [pc, #36]	; (9acc <gapc_dev_info_req_ind_handler+0x50>)
    9aa8:	4798      	blx	r3
    9aaa:	e001      	b.n	9ab0 <gapc_dev_info_req_ind_handler+0x34>
    9aac:	4b08      	ldr	r3, [pc, #32]	; (9ad0 <gapc_dev_info_req_ind_handler+0x54>)
    9aae:	4798      	blx	r3
    9ab0:	bd38      	pop	{r3, r4, r5, pc}
    9ab2:	46c0      	nop			; (mov r8, r8)
    9ab4:	20001898 	.word	0x20001898
    9ab8:	20000038 	.word	0x20000038
    9abc:	0001114c 	.word	0x0001114c
    9ac0:	000002b1 	.word	0x000002b1
    9ac4:	00011271 	.word	0x00011271
    9ac8:	0000ed34 	.word	0x0000ed34
    9acc:	00011250 	.word	0x00011250
    9ad0:	00008bd9 	.word	0x00008bd9

00009ad4 <gapc_sec_req_ind>:
    9ad4:	0a00      	lsrs	r0, r0, #8
    9ad6:	8010      	strh	r0, [r2, #0]
    9ad8:	7809      	ldrb	r1, [r1, #0]
    9ada:	2301      	movs	r3, #1
    9adc:	1c08      	adds	r0, r1, #0
    9ade:	0889      	lsrs	r1, r1, #2
    9ae0:	4018      	ands	r0, r3
    9ae2:	400b      	ands	r3, r1
    9ae4:	70d0      	strb	r0, [r2, #3]
    9ae6:	7113      	strb	r3, [r2, #4]
    9ae8:	4770      	bx	lr

00009aea <gapc_sign_counter_ind_handler>:
    9aea:	0a00      	lsrs	r0, r0, #8
    9aec:	8010      	strh	r0, [r2, #0]
    9aee:	784b      	ldrb	r3, [r1, #1]
    9af0:	0218      	lsls	r0, r3, #8
    9af2:	788b      	ldrb	r3, [r1, #2]
    9af4:	041b      	lsls	r3, r3, #16
    9af6:	4303      	orrs	r3, r0
    9af8:	7808      	ldrb	r0, [r1, #0]
    9afa:	4303      	orrs	r3, r0
    9afc:	78c8      	ldrb	r0, [r1, #3]
    9afe:	0600      	lsls	r0, r0, #24
    9b00:	4303      	orrs	r3, r0
    9b02:	6053      	str	r3, [r2, #4]
    9b04:	794b      	ldrb	r3, [r1, #5]
    9b06:	0218      	lsls	r0, r3, #8
    9b08:	798b      	ldrb	r3, [r1, #6]
    9b0a:	041b      	lsls	r3, r3, #16
    9b0c:	4303      	orrs	r3, r0
    9b0e:	7908      	ldrb	r0, [r1, #4]
    9b10:	79c9      	ldrb	r1, [r1, #7]
    9b12:	4303      	orrs	r3, r0
    9b14:	0609      	lsls	r1, r1, #24
    9b16:	430b      	orrs	r3, r1
    9b18:	2000      	movs	r0, #0
    9b1a:	6093      	str	r3, [r2, #8]
    9b1c:	4770      	bx	lr
	...

00009b20 <gapc_peer_att_info_ind_handler>:
    9b20:	b510      	push	{r4, lr}
    9b22:	0a00      	lsrs	r0, r0, #8
    9b24:	8010      	strh	r0, [r2, #0]
    9b26:	7808      	ldrb	r0, [r1, #0]
    9b28:	7090      	strb	r0, [r2, #2]
    9b2a:	788b      	ldrb	r3, [r1, #2]
    9b2c:	784c      	ldrb	r4, [r1, #1]
    9b2e:	021b      	lsls	r3, r3, #8
    9b30:	4323      	orrs	r3, r4
    9b32:	8093      	strh	r3, [r2, #4]
    9b34:	2801      	cmp	r0, #1
    9b36:	d027      	beq.n	9b88 <gapc_peer_att_info_ind_handler+0x68>
    9b38:	2800      	cmp	r0, #0
    9b3a:	d017      	beq.n	9b6c <gapc_peer_att_info_ind_handler+0x4c>
    9b3c:	2802      	cmp	r0, #2
    9b3e:	d12a      	bne.n	9b96 <gapc_peer_att_info_ind_handler+0x76>
    9b40:	790b      	ldrb	r3, [r1, #4]
    9b42:	78c8      	ldrb	r0, [r1, #3]
    9b44:	021b      	lsls	r3, r3, #8
    9b46:	4303      	orrs	r3, r0
    9b48:	8113      	strh	r3, [r2, #8]
    9b4a:	798b      	ldrb	r3, [r1, #6]
    9b4c:	7948      	ldrb	r0, [r1, #5]
    9b4e:	021b      	lsls	r3, r3, #8
    9b50:	4303      	orrs	r3, r0
    9b52:	80d3      	strh	r3, [r2, #6]
    9b54:	7a0b      	ldrb	r3, [r1, #8]
    9b56:	79c8      	ldrb	r0, [r1, #7]
    9b58:	021b      	lsls	r3, r3, #8
    9b5a:	4303      	orrs	r3, r0
    9b5c:	8193      	strh	r3, [r2, #12]
    9b5e:	7a8b      	ldrb	r3, [r1, #10]
    9b60:	7a49      	ldrb	r1, [r1, #9]
    9b62:	021b      	lsls	r3, r3, #8
    9b64:	430b      	orrs	r3, r1
    9b66:	8153      	strh	r3, [r2, #10]
    9b68:	2306      	movs	r3, #6
    9b6a:	e013      	b.n	9b94 <gapc_peer_att_info_ind_handler+0x74>
    9b6c:	1c14      	adds	r4, r2, #0
    9b6e:	1c20      	adds	r0, r4, #0
    9b70:	790a      	ldrb	r2, [r1, #4]
    9b72:	78cb      	ldrb	r3, [r1, #3]
    9b74:	0212      	lsls	r2, r2, #8
    9b76:	431a      	orrs	r2, r3
    9b78:	80e2      	strh	r2, [r4, #6]
    9b7a:	4b07      	ldr	r3, [pc, #28]	; (9b98 <gapc_peer_att_info_ind_handler+0x78>)
    9b7c:	3008      	adds	r0, #8
    9b7e:	3105      	adds	r1, #5
    9b80:	4798      	blx	r3
    9b82:	2302      	movs	r3, #2
    9b84:	70a3      	strb	r3, [r4, #2]
    9b86:	e006      	b.n	9b96 <gapc_peer_att_info_ind_handler+0x76>
    9b88:	790b      	ldrb	r3, [r1, #4]
    9b8a:	78c9      	ldrb	r1, [r1, #3]
    9b8c:	021b      	lsls	r3, r3, #8
    9b8e:	430b      	orrs	r3, r1
    9b90:	80d3      	strh	r3, [r2, #6]
    9b92:	2305      	movs	r3, #5
    9b94:	7093      	strb	r3, [r2, #2]
    9b96:	bd10      	pop	{r4, pc}
    9b98:	0000d7eb 	.word	0x0000d7eb

00009b9c <gapc_con_channel_map_ind_handler>:
    9b9c:	b508      	push	{r3, lr}
    9b9e:	2300      	movs	r3, #0
    9ba0:	0a00      	lsrs	r0, r0, #8
    9ba2:	7013      	strb	r3, [r2, #0]
    9ba4:	8050      	strh	r0, [r2, #2]
    9ba6:	4b02      	ldr	r3, [pc, #8]	; (9bb0 <gapc_con_channel_map_ind_handler+0x14>)
    9ba8:	1d10      	adds	r0, r2, #4
    9baa:	2205      	movs	r2, #5
    9bac:	4798      	blx	r3
    9bae:	bd08      	pop	{r3, pc}
    9bb0:	0000d7eb 	.word	0x0000d7eb

00009bb4 <gapc_lecb_connected>:
    9bb4:	7843      	ldrb	r3, [r0, #1]
    9bb6:	7802      	ldrb	r2, [r0, #0]
    9bb8:	021b      	lsls	r3, r3, #8
    9bba:	4313      	orrs	r3, r2
    9bbc:	800b      	strh	r3, [r1, #0]
    9bbe:	78c3      	ldrb	r3, [r0, #3]
    9bc0:	7882      	ldrb	r2, [r0, #2]
    9bc2:	021b      	lsls	r3, r3, #8
    9bc4:	4313      	orrs	r3, r2
    9bc6:	804b      	strh	r3, [r1, #2]
    9bc8:	7943      	ldrb	r3, [r0, #5]
    9bca:	7902      	ldrb	r2, [r0, #4]
    9bcc:	021b      	lsls	r3, r3, #8
    9bce:	4313      	orrs	r3, r2
    9bd0:	808b      	strh	r3, [r1, #4]
    9bd2:	79c3      	ldrb	r3, [r0, #7]
    9bd4:	7982      	ldrb	r2, [r0, #6]
    9bd6:	021b      	lsls	r3, r3, #8
    9bd8:	4313      	orrs	r3, r2
    9bda:	80cb      	strh	r3, [r1, #6]
    9bdc:	2300      	movs	r3, #0
    9bde:	720b      	strb	r3, [r1, #8]
    9be0:	4770      	bx	lr

00009be2 <gapc_lecb_disconnected>:
    9be2:	7843      	ldrb	r3, [r0, #1]
    9be4:	7802      	ldrb	r2, [r0, #0]
    9be6:	021b      	lsls	r3, r3, #8
    9be8:	4313      	orrs	r3, r2
    9bea:	800b      	strh	r3, [r1, #0]
    9bec:	78c3      	ldrb	r3, [r0, #3]
    9bee:	7882      	ldrb	r2, [r0, #2]
    9bf0:	021b      	lsls	r3, r3, #8
    9bf2:	4313      	orrs	r3, r2
    9bf4:	804b      	strh	r3, [r1, #2]
    9bf6:	4770      	bx	lr

00009bf8 <gapc_lecb_connect_req_ind>:
    9bf8:	7843      	ldrb	r3, [r0, #1]
    9bfa:	7802      	ldrb	r2, [r0, #0]
    9bfc:	021b      	lsls	r3, r3, #8
    9bfe:	4313      	orrs	r3, r2
    9c00:	800b      	strh	r3, [r1, #0]
    9c02:	78c3      	ldrb	r3, [r0, #3]
    9c04:	7882      	ldrb	r2, [r0, #2]
    9c06:	021b      	lsls	r3, r3, #8
    9c08:	4313      	orrs	r3, r2
    9c0a:	804b      	strh	r3, [r1, #2]
    9c0c:	7943      	ldrb	r3, [r0, #5]
    9c0e:	7902      	ldrb	r2, [r0, #4]
    9c10:	021b      	lsls	r3, r3, #8
    9c12:	4313      	orrs	r3, r2
    9c14:	808b      	strh	r3, [r1, #4]
    9c16:	79c3      	ldrb	r3, [r0, #7]
    9c18:	7982      	ldrb	r2, [r0, #6]
    9c1a:	021b      	lsls	r3, r3, #8
    9c1c:	4313      	orrs	r3, r2
    9c1e:	80cb      	strh	r3, [r1, #6]
    9c20:	4770      	bx	lr

00009c22 <gapc_lecb_add_credit_resp_handler>:
    9c22:	7843      	ldrb	r3, [r0, #1]
    9c24:	7802      	ldrb	r2, [r0, #0]
    9c26:	021b      	lsls	r3, r3, #8
    9c28:	4313      	orrs	r3, r2
    9c2a:	800b      	strh	r3, [r1, #0]
    9c2c:	78c3      	ldrb	r3, [r0, #3]
    9c2e:	7882      	ldrb	r2, [r0, #2]
    9c30:	021b      	lsls	r3, r3, #8
    9c32:	4313      	orrs	r3, r2
    9c34:	804b      	strh	r3, [r1, #2]
    9c36:	7943      	ldrb	r3, [r0, #5]
    9c38:	7902      	ldrb	r2, [r0, #4]
    9c3a:	021b      	lsls	r3, r3, #8
    9c3c:	4313      	orrs	r3, r2
    9c3e:	808b      	strh	r3, [r1, #4]
    9c40:	4770      	bx	lr
	...

00009c44 <gapm_reset_req_handler>:
    9c44:	b5f0      	push	{r4, r5, r6, r7, lr}
    9c46:	4f34      	ldr	r7, [pc, #208]	; (9d18 <gapm_reset_req_handler+0xd4>)
    9c48:	b085      	sub	sp, #20
    9c4a:	7839      	ldrb	r1, [r7, #0]
    9c4c:	9701      	str	r7, [sp, #4]
    9c4e:	4a33      	ldr	r2, [pc, #204]	; (9d1c <gapm_reset_req_handler+0xd8>)
    9c50:	2300      	movs	r3, #0
    9c52:	2902      	cmp	r1, #2
    9c54:	d107      	bne.n	9c66 <gapm_reset_req_handler+0x22>
    9c56:	6813      	ldr	r3, [r2, #0]
    9c58:	3150      	adds	r1, #80	; 0x50
    9c5a:	7019      	strb	r1, [r3, #0]
    9c5c:	3105      	adds	r1, #5
    9c5e:	7059      	strb	r1, [r3, #1]
    9c60:	3936      	subs	r1, #54	; 0x36
    9c62:	7099      	strb	r1, [r3, #2]
    9c64:	2303      	movs	r3, #3
    9c66:	6810      	ldr	r0, [r2, #0]
    9c68:	2205      	movs	r2, #5
    9c6a:	2102      	movs	r1, #2
    9c6c:	240d      	movs	r4, #13
    9c6e:	2500      	movs	r5, #0
    9c70:	2701      	movs	r7, #1
    9c72:	54c2      	strb	r2, [r0, r3]
    9c74:	1c5a      	adds	r2, r3, #1
    9c76:	5481      	strb	r1, [r0, r2]
    9c78:	185a      	adds	r2, r3, r1
    9c7a:	5484      	strb	r4, [r0, r2]
    9c7c:	1cda      	adds	r2, r3, #3
    9c7e:	5484      	strb	r4, [r0, r2]
    9c80:	1d1a      	adds	r2, r3, #4
    9c82:	5485      	strb	r5, [r0, r2]
    9c84:	310e      	adds	r1, #14
    9c86:	1d5a      	adds	r2, r3, #5
    9c88:	5481      	strb	r1, [r0, r2]
    9c8a:	1d9a      	adds	r2, r3, #6
    9c8c:	5485      	strb	r5, [r0, r2]
    9c8e:	1dde      	adds	r6, r3, #7
    9c90:	3202      	adds	r2, #2
    9c92:	1c19      	adds	r1, r3, #0
    9c94:	1986      	adds	r6, r0, r6
    9c96:	3309      	adds	r3, #9
    9c98:	1882      	adds	r2, r0, r2
    9c9a:	7035      	strb	r5, [r6, #0]
    9c9c:	7015      	strb	r5, [r2, #0]
    9c9e:	54c7      	strb	r7, [r0, r3]
    9ca0:	27d0      	movs	r7, #208	; 0xd0
    9ca2:	4b1f      	ldr	r3, [pc, #124]	; (9d20 <gapm_reset_req_handler+0xdc>)
    9ca4:	013f      	lsls	r7, r7, #4
    9ca6:	809c      	strh	r4, [r3, #4]
    9ca8:	9c01      	ldr	r4, [sp, #4]
    9caa:	801f      	strh	r7, [r3, #0]
    9cac:	7827      	ldrb	r7, [r4, #0]
    9cae:	310a      	adds	r1, #10
    9cb0:	1c1c      	adds	r4, r3, #0
    9cb2:	1c0b      	adds	r3, r1, #0
    9cb4:	2f02      	cmp	r7, #2
    9cb6:	d104      	bne.n	9cc2 <gapm_reset_req_handler+0x7e>
    9cb8:	3b0c      	subs	r3, #12
    9cba:	7033      	strb	r3, [r6, #0]
    9cbc:	121b      	asrs	r3, r3, #8
    9cbe:	7013      	strb	r3, [r2, #0]
    9cc0:	e002      	b.n	9cc8 <gapm_reset_req_handler+0x84>
    9cc2:	3b09      	subs	r3, #9
    9cc4:	7033      	strb	r3, [r6, #0]
    9cc6:	7015      	strb	r5, [r2, #0]
    9cc8:	4b16      	ldr	r3, [pc, #88]	; (9d24 <gapm_reset_req_handler+0xe0>)
    9cca:	4798      	blx	r3
    9ccc:	1c06      	adds	r6, r0, #0
    9cce:	20e1      	movs	r0, #225	; 0xe1
    9cd0:	2e00      	cmp	r6, #0
    9cd2:	d11f      	bne.n	9d14 <gapm_reset_req_handler+0xd0>
    9cd4:	4b14      	ldr	r3, [pc, #80]	; (9d28 <gapm_reset_req_handler+0xe4>)
    9cd6:	4798      	blx	r3
    9cd8:	ab02      	add	r3, sp, #8
    9cda:	1ddd      	adds	r5, r3, #7
    9cdc:	71de      	strb	r6, [r3, #7]
    9cde:	1c28      	adds	r0, r5, #0
    9ce0:	4b12      	ldr	r3, [pc, #72]	; (9d2c <gapm_reset_req_handler+0xe8>)
    9ce2:	4798      	blx	r3
    9ce4:	4b12      	ldr	r3, [pc, #72]	; (9d30 <gapm_reset_req_handler+0xec>)
    9ce6:	4798      	blx	r3
    9ce8:	782b      	ldrb	r3, [r5, #0]
    9cea:	20d0      	movs	r0, #208	; 0xd0
    9cec:	2b00      	cmp	r3, #0
    9cee:	d111      	bne.n	9d14 <gapm_reset_req_handler+0xd0>
    9cf0:	68a3      	ldr	r3, [r4, #8]
    9cf2:	781c      	ldrb	r4, [r3, #0]
    9cf4:	7858      	ldrb	r0, [r3, #1]
    9cf6:	2c01      	cmp	r4, #1
    9cf8:	d00c      	beq.n	9d14 <gapm_reset_req_handler+0xd0>
    9cfa:	4d0e      	ldr	r5, [pc, #56]	; (9d34 <gapm_reset_req_handler+0xf0>)
    9cfc:	490e      	ldr	r1, [pc, #56]	; (9d38 <gapm_reset_req_handler+0xf4>)
    9cfe:	224a      	movs	r2, #74	; 0x4a
    9d00:	4b0e      	ldr	r3, [pc, #56]	; (9d3c <gapm_reset_req_handler+0xf8>)
    9d02:	480f      	ldr	r0, [pc, #60]	; (9d40 <gapm_reset_req_handler+0xfc>)
    9d04:	682e      	ldr	r6, [r5, #0]
    9d06:	47b0      	blx	r6
    9d08:	682b      	ldr	r3, [r5, #0]
    9d0a:	480e      	ldr	r0, [pc, #56]	; (9d44 <gapm_reset_req_handler+0x100>)
    9d0c:	2101      	movs	r1, #1
    9d0e:	1c22      	adds	r2, r4, #0
    9d10:	4798      	blx	r3
    9d12:	20e2      	movs	r0, #226	; 0xe2
    9d14:	b005      	add	sp, #20
    9d16:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9d18:	20000005 	.word	0x20000005
    9d1c:	00011148 	.word	0x00011148
    9d20:	200017fc 	.word	0x200017fc
    9d24:	00008a29 	.word	0x00008a29
    9d28:	00008835 	.word	0x00008835
    9d2c:	00001a1d 	.word	0x00001a1d
    9d30:	00001895 	.word	0x00001895
    9d34:	20000038 	.word	0x20000038
    9d38:	000112a6 	.word	0x000112a6
    9d3c:	0001128f 	.word	0x0001128f
    9d40:	0000ed34 	.word	0x0000ed34
    9d44:	00011300 	.word	0x00011300

00009d48 <gapm_set_dev_config_cmd_handler>:
    9d48:	b5f0      	push	{r4, r5, r6, r7, lr}
    9d4a:	b08b      	sub	sp, #44	; 0x2c
    9d4c:	9305      	str	r3, [sp, #20]
    9d4e:	ab10      	add	r3, sp, #64	; 0x40
    9d50:	781b      	ldrb	r3, [r3, #0]
    9d52:	2400      	movs	r4, #0
    9d54:	9306      	str	r3, [sp, #24]
    9d56:	ab11      	add	r3, sp, #68	; 0x44
    9d58:	781b      	ldrb	r3, [r3, #0]
    9d5a:	9307      	str	r3, [sp, #28]
    9d5c:	ab12      	add	r3, sp, #72	; 0x48
    9d5e:	881b      	ldrh	r3, [r3, #0]
    9d60:	9302      	str	r3, [sp, #8]
    9d62:	ab13      	add	r3, sp, #76	; 0x4c
    9d64:	881b      	ldrh	r3, [r3, #0]
    9d66:	9303      	str	r3, [sp, #12]
    9d68:	ab14      	add	r3, sp, #80	; 0x50
    9d6a:	881b      	ldrh	r3, [r3, #0]
    9d6c:	9304      	str	r3, [sp, #16]
    9d6e:	4b53      	ldr	r3, [pc, #332]	; (9ebc <gapm_set_dev_config_cmd_handler+0x174>)
    9d70:	781b      	ldrb	r3, [r3, #0]
    9d72:	2b02      	cmp	r3, #2
    9d74:	d108      	bne.n	9d88 <gapm_set_dev_config_cmd_handler+0x40>
    9d76:	4b52      	ldr	r3, [pc, #328]	; (9ec0 <gapm_set_dev_config_cmd_handler+0x178>)
    9d78:	3452      	adds	r4, #82	; 0x52
    9d7a:	681b      	ldr	r3, [r3, #0]
    9d7c:	701c      	strb	r4, [r3, #0]
    9d7e:	3405      	adds	r4, #5
    9d80:	705c      	strb	r4, [r3, #1]
    9d82:	3c36      	subs	r4, #54	; 0x36
    9d84:	709c      	strb	r4, [r3, #2]
    9d86:	3c1e      	subs	r4, #30
    9d88:	4b4d      	ldr	r3, [pc, #308]	; (9ec0 <gapm_set_dev_config_cmd_handler+0x178>)
    9d8a:	2604      	movs	r6, #4
    9d8c:	681d      	ldr	r5, [r3, #0]
    9d8e:	2305      	movs	r3, #5
    9d90:	552b      	strb	r3, [r5, r4]
    9d92:	1c63      	adds	r3, r4, #1
    9d94:	54ee      	strb	r6, [r5, r3]
    9d96:	1ca3      	adds	r3, r4, #2
    9d98:	3609      	adds	r6, #9
    9d9a:	54ee      	strb	r6, [r5, r3]
    9d9c:	260d      	movs	r6, #13
    9d9e:	1ce3      	adds	r3, r4, #3
    9da0:	54ee      	strb	r6, [r5, r3]
    9da2:	2600      	movs	r6, #0
    9da4:	2710      	movs	r7, #16
    9da6:	1d23      	adds	r3, r4, #4
    9da8:	54ee      	strb	r6, [r5, r3]
    9daa:	1d63      	adds	r3, r4, #5
    9dac:	54ef      	strb	r7, [r5, r3]
    9dae:	1da3      	adds	r3, r4, #6
    9db0:	54ee      	strb	r6, [r5, r3]
    9db2:	1de3      	adds	r3, r4, #7
    9db4:	18eb      	adds	r3, r5, r3
    9db6:	701e      	strb	r6, [r3, #0]
    9db8:	9300      	str	r3, [sp, #0]
    9dba:	1c23      	adds	r3, r4, #0
    9dbc:	3308      	adds	r3, #8
    9dbe:	18eb      	adds	r3, r5, r3
    9dc0:	701e      	strb	r6, [r3, #0]
    9dc2:	9301      	str	r3, [sp, #4]
    9dc4:	1c23      	adds	r3, r4, #0
    9dc6:	2703      	movs	r7, #3
    9dc8:	3309      	adds	r3, #9
    9dca:	54ef      	strb	r7, [r5, r3]
    9dcc:	3301      	adds	r3, #1
    9dce:	54e8      	strb	r0, [r5, r3]
    9dd0:	1c20      	adds	r0, r4, #0
    9dd2:	3301      	adds	r3, #1
    9dd4:	54e9      	strb	r1, [r5, r3]
    9dd6:	300d      	adds	r0, #13
    9dd8:	3301      	adds	r3, #1
    9dda:	0a09      	lsrs	r1, r1, #8
    9ddc:	54e9      	strb	r1, [r5, r3]
    9dde:	4f39      	ldr	r7, [pc, #228]	; (9ec4 <gapm_set_dev_config_cmd_handler+0x17c>)
    9de0:	1c11      	adds	r1, r2, #0
    9de2:	1828      	adds	r0, r5, r0
    9de4:	2206      	movs	r2, #6
    9de6:	47b8      	blx	r7
    9de8:	1c20      	adds	r0, r4, #0
    9dea:	3013      	adds	r0, #19
    9dec:	9905      	ldr	r1, [sp, #20]
    9dee:	2210      	movs	r2, #16
    9df0:	1828      	adds	r0, r5, r0
    9df2:	47b8      	blx	r7
    9df4:	466a      	mov	r2, sp
    9df6:	1c23      	adds	r3, r4, #0
    9df8:	7e12      	ldrb	r2, [r2, #24]
    9dfa:	3323      	adds	r3, #35	; 0x23
    9dfc:	54ea      	strb	r2, [r5, r3]
    9dfe:	466a      	mov	r2, sp
    9e00:	7f12      	ldrb	r2, [r2, #28]
    9e02:	3301      	adds	r3, #1
    9e04:	54ea      	strb	r2, [r5, r3]
    9e06:	466a      	mov	r2, sp
    9e08:	7a12      	ldrb	r2, [r2, #8]
    9e0a:	3301      	adds	r3, #1
    9e0c:	54ea      	strb	r2, [r5, r3]
    9e0e:	1c22      	adds	r2, r4, #0
    9e10:	9b02      	ldr	r3, [sp, #8]
    9e12:	3226      	adds	r2, #38	; 0x26
    9e14:	0a1b      	lsrs	r3, r3, #8
    9e16:	54ab      	strb	r3, [r5, r2]
    9e18:	466a      	mov	r2, sp
    9e1a:	1c23      	adds	r3, r4, #0
    9e1c:	7b12      	ldrb	r2, [r2, #12]
    9e1e:	3327      	adds	r3, #39	; 0x27
    9e20:	54ea      	strb	r2, [r5, r3]
    9e22:	1c22      	adds	r2, r4, #0
    9e24:	9b03      	ldr	r3, [sp, #12]
    9e26:	3228      	adds	r2, #40	; 0x28
    9e28:	0a1b      	lsrs	r3, r3, #8
    9e2a:	54ab      	strb	r3, [r5, r2]
    9e2c:	466a      	mov	r2, sp
    9e2e:	1c23      	adds	r3, r4, #0
    9e30:	7c12      	ldrb	r2, [r2, #16]
    9e32:	3329      	adds	r3, #41	; 0x29
    9e34:	54ea      	strb	r2, [r5, r3]
    9e36:	9b04      	ldr	r3, [sp, #16]
    9e38:	1c21      	adds	r1, r4, #0
    9e3a:	0a1b      	lsrs	r3, r3, #8
    9e3c:	342a      	adds	r4, #42	; 0x2a
    9e3e:	552b      	strb	r3, [r5, r4]
    9e40:	23d0      	movs	r3, #208	; 0xd0
    9e42:	4c21      	ldr	r4, [pc, #132]	; (9ec8 <gapm_set_dev_config_cmd_handler+0x180>)
    9e44:	011b      	lsls	r3, r3, #4
    9e46:	8023      	strh	r3, [r4, #0]
    9e48:	230d      	movs	r3, #13
    9e4a:	80a3      	strh	r3, [r4, #4]
    9e4c:	4b1b      	ldr	r3, [pc, #108]	; (9ebc <gapm_set_dev_config_cmd_handler+0x174>)
    9e4e:	312b      	adds	r1, #43	; 0x2b
    9e50:	781b      	ldrb	r3, [r3, #0]
    9e52:	2b02      	cmp	r3, #2
    9e54:	d102      	bne.n	9e5c <gapm_set_dev_config_cmd_handler+0x114>
    9e56:	1c0b      	adds	r3, r1, #0
    9e58:	3b0c      	subs	r3, #12
    9e5a:	e001      	b.n	9e60 <gapm_set_dev_config_cmd_handler+0x118>
    9e5c:	1c0b      	adds	r3, r1, #0
    9e5e:	3b09      	subs	r3, #9
    9e60:	9a00      	ldr	r2, [sp, #0]
    9e62:	1c28      	adds	r0, r5, #0
    9e64:	7013      	strb	r3, [r2, #0]
    9e66:	9b01      	ldr	r3, [sp, #4]
    9e68:	701e      	strb	r6, [r3, #0]
    9e6a:	4b18      	ldr	r3, [pc, #96]	; (9ecc <gapm_set_dev_config_cmd_handler+0x184>)
    9e6c:	4798      	blx	r3
    9e6e:	1c06      	adds	r6, r0, #0
    9e70:	20e1      	movs	r0, #225	; 0xe1
    9e72:	2e00      	cmp	r6, #0
    9e74:	d11f      	bne.n	9eb6 <gapm_set_dev_config_cmd_handler+0x16e>
    9e76:	4b16      	ldr	r3, [pc, #88]	; (9ed0 <gapm_set_dev_config_cmd_handler+0x188>)
    9e78:	4798      	blx	r3
    9e7a:	ab08      	add	r3, sp, #32
    9e7c:	1ddd      	adds	r5, r3, #7
    9e7e:	71de      	strb	r6, [r3, #7]
    9e80:	1c28      	adds	r0, r5, #0
    9e82:	4b14      	ldr	r3, [pc, #80]	; (9ed4 <gapm_set_dev_config_cmd_handler+0x18c>)
    9e84:	4798      	blx	r3
    9e86:	4b14      	ldr	r3, [pc, #80]	; (9ed8 <gapm_set_dev_config_cmd_handler+0x190>)
    9e88:	4798      	blx	r3
    9e8a:	782b      	ldrb	r3, [r5, #0]
    9e8c:	20d0      	movs	r0, #208	; 0xd0
    9e8e:	2b00      	cmp	r3, #0
    9e90:	d111      	bne.n	9eb6 <gapm_set_dev_config_cmd_handler+0x16e>
    9e92:	68a3      	ldr	r3, [r4, #8]
    9e94:	781c      	ldrb	r4, [r3, #0]
    9e96:	7858      	ldrb	r0, [r3, #1]
    9e98:	2c03      	cmp	r4, #3
    9e9a:	d00c      	beq.n	9eb6 <gapm_set_dev_config_cmd_handler+0x16e>
    9e9c:	4d0f      	ldr	r5, [pc, #60]	; (9edc <gapm_set_dev_config_cmd_handler+0x194>)
    9e9e:	4910      	ldr	r1, [pc, #64]	; (9ee0 <gapm_set_dev_config_cmd_handler+0x198>)
    9ea0:	2266      	movs	r2, #102	; 0x66
    9ea2:	4b10      	ldr	r3, [pc, #64]	; (9ee4 <gapm_set_dev_config_cmd_handler+0x19c>)
    9ea4:	4810      	ldr	r0, [pc, #64]	; (9ee8 <gapm_set_dev_config_cmd_handler+0x1a0>)
    9ea6:	682e      	ldr	r6, [r5, #0]
    9ea8:	47b0      	blx	r6
    9eaa:	682b      	ldr	r3, [r5, #0]
    9eac:	480f      	ldr	r0, [pc, #60]	; (9eec <gapm_set_dev_config_cmd_handler+0x1a4>)
    9eae:	2103      	movs	r1, #3
    9eb0:	1c22      	adds	r2, r4, #0
    9eb2:	4798      	blx	r3
    9eb4:	20e2      	movs	r0, #226	; 0xe2
    9eb6:	b00b      	add	sp, #44	; 0x2c
    9eb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9eba:	46c0      	nop			; (mov r8, r8)
    9ebc:	20000005 	.word	0x20000005
    9ec0:	00011148 	.word	0x00011148
    9ec4:	0000d7eb 	.word	0x0000d7eb
    9ec8:	200017fc 	.word	0x200017fc
    9ecc:	00008a29 	.word	0x00008a29
    9ed0:	00008835 	.word	0x00008835
    9ed4:	00001a1d 	.word	0x00001a1d
    9ed8:	00001895 	.word	0x00001895
    9edc:	20000038 	.word	0x20000038
    9ee0:	000112a6 	.word	0x000112a6
    9ee4:	00011330 	.word	0x00011330
    9ee8:	0000ed34 	.word	0x0000ed34
    9eec:	00011300 	.word	0x00011300

00009ef0 <gapm_get_dev_config_cmd_handler>:
    9ef0:	b5f0      	push	{r4, r5, r6, r7, lr}
    9ef2:	1c07      	adds	r7, r0, #0
    9ef4:	b085      	sub	sp, #20
    9ef6:	20cf      	movs	r0, #207	; 0xcf
    9ef8:	2f01      	cmp	r7, #1
    9efa:	d900      	bls.n	9efe <gapm_get_dev_config_cmd_handler+0xe>
    9efc:	e096      	b.n	a02c <gapm_get_dev_config_cmd_handler+0x13c>
    9efe:	2900      	cmp	r1, #0
    9f00:	d100      	bne.n	9f04 <gapm_get_dev_config_cmd_handler+0x14>
    9f02:	e093      	b.n	a02c <gapm_get_dev_config_cmd_handler+0x13c>
    9f04:	4b4a      	ldr	r3, [pc, #296]	; (a030 <gapm_get_dev_config_cmd_handler+0x140>)
    9f06:	4a4b      	ldr	r2, [pc, #300]	; (a034 <gapm_get_dev_config_cmd_handler+0x144>)
    9f08:	7818      	ldrb	r0, [r3, #0]
    9f0a:	2300      	movs	r3, #0
    9f0c:	2802      	cmp	r0, #2
    9f0e:	d107      	bne.n	9f20 <gapm_get_dev_config_cmd_handler+0x30>
    9f10:	6813      	ldr	r3, [r2, #0]
    9f12:	3050      	adds	r0, #80	; 0x50
    9f14:	7018      	strb	r0, [r3, #0]
    9f16:	3005      	adds	r0, #5
    9f18:	7058      	strb	r0, [r3, #1]
    9f1a:	3836      	subs	r0, #54	; 0x36
    9f1c:	7098      	strb	r0, [r3, #2]
    9f1e:	2303      	movs	r3, #3
    9f20:	2005      	movs	r0, #5
    9f22:	2406      	movs	r4, #6
    9f24:	6812      	ldr	r2, [r2, #0]
    9f26:	2500      	movs	r5, #0
    9f28:	54d0      	strb	r0, [r2, r3]
    9f2a:	1c58      	adds	r0, r3, #1
    9f2c:	5414      	strb	r4, [r2, r0]
    9f2e:	200d      	movs	r0, #13
    9f30:	2610      	movs	r6, #16
    9f32:	46a4      	mov	ip, r4
    9f34:	1c9c      	adds	r4, r3, #2
    9f36:	5510      	strb	r0, [r2, r4]
    9f38:	1cdc      	adds	r4, r3, #3
    9f3a:	5510      	strb	r0, [r2, r4]
    9f3c:	1d1c      	adds	r4, r3, #4
    9f3e:	5515      	strb	r5, [r2, r4]
    9f40:	1d5c      	adds	r4, r3, #5
    9f42:	5516      	strb	r6, [r2, r4]
    9f44:	1d9c      	adds	r4, r3, #6
    9f46:	5515      	strb	r5, [r2, r4]
    9f48:	1dde      	adds	r6, r3, #7
    9f4a:	3402      	adds	r4, #2
    9f4c:	1914      	adds	r4, r2, r4
    9f4e:	1996      	adds	r6, r2, r6
    9f50:	7035      	strb	r5, [r6, #0]
    9f52:	9401      	str	r4, [sp, #4]
    9f54:	7025      	strb	r5, [r4, #0]
    9f56:	2f01      	cmp	r7, #1
    9f58:	d167      	bne.n	a02a <gapm_get_dev_config_cmd_handler+0x13a>
    9f5a:	4664      	mov	r4, ip
    9f5c:	1c1f      	adds	r7, r3, #0
    9f5e:	3309      	adds	r3, #9
    9f60:	54d4      	strb	r4, [r2, r3]
    9f62:	24d0      	movs	r4, #208	; 0xd0
    9f64:	4b34      	ldr	r3, [pc, #208]	; (a038 <gapm_get_dev_config_cmd_handler+0x148>)
    9f66:	0124      	lsls	r4, r4, #4
    9f68:	8098      	strh	r0, [r3, #4]
    9f6a:	4831      	ldr	r0, [pc, #196]	; (a030 <gapm_get_dev_config_cmd_handler+0x140>)
    9f6c:	805c      	strh	r4, [r3, #2]
    9f6e:	7800      	ldrb	r0, [r0, #0]
    9f70:	4c32      	ldr	r4, [pc, #200]	; (a03c <gapm_get_dev_config_cmd_handler+0x14c>)
    9f72:	370a      	adds	r7, #10
    9f74:	801c      	strh	r4, [r3, #0]
    9f76:	1c1c      	adds	r4, r3, #0
    9f78:	1c3b      	adds	r3, r7, #0
    9f7a:	2802      	cmp	r0, #2
    9f7c:	d105      	bne.n	9f8a <gapm_get_dev_config_cmd_handler+0x9a>
    9f7e:	3b0c      	subs	r3, #12
    9f80:	9801      	ldr	r0, [sp, #4]
    9f82:	7033      	strb	r3, [r6, #0]
    9f84:	121b      	asrs	r3, r3, #8
    9f86:	7003      	strb	r3, [r0, #0]
    9f88:	e003      	b.n	9f92 <gapm_get_dev_config_cmd_handler+0xa2>
    9f8a:	3b09      	subs	r3, #9
    9f8c:	7033      	strb	r3, [r6, #0]
    9f8e:	9b01      	ldr	r3, [sp, #4]
    9f90:	701d      	strb	r5, [r3, #0]
    9f92:	9101      	str	r1, [sp, #4]
    9f94:	1c10      	adds	r0, r2, #0
    9f96:	1c39      	adds	r1, r7, #0
    9f98:	4b29      	ldr	r3, [pc, #164]	; (a040 <gapm_get_dev_config_cmd_handler+0x150>)
    9f9a:	4798      	blx	r3
    9f9c:	1c06      	adds	r6, r0, #0
    9f9e:	20e1      	movs	r0, #225	; 0xe1
    9fa0:	2e00      	cmp	r6, #0
    9fa2:	d143      	bne.n	a02c <gapm_get_dev_config_cmd_handler+0x13c>
    9fa4:	4b27      	ldr	r3, [pc, #156]	; (a044 <gapm_get_dev_config_cmd_handler+0x154>)
    9fa6:	4798      	blx	r3
    9fa8:	ab02      	add	r3, sp, #8
    9faa:	1ddd      	adds	r5, r3, #7
    9fac:	1c28      	adds	r0, r5, #0
    9fae:	4b26      	ldr	r3, [pc, #152]	; (a048 <gapm_get_dev_config_cmd_handler+0x158>)
    9fb0:	702e      	strb	r6, [r5, #0]
    9fb2:	4798      	blx	r3
    9fb4:	4b25      	ldr	r3, [pc, #148]	; (a04c <gapm_get_dev_config_cmd_handler+0x15c>)
    9fb6:	4798      	blx	r3
    9fb8:	782f      	ldrb	r7, [r5, #0]
    9fba:	2f00      	cmp	r7, #0
    9fbc:	d120      	bne.n	a000 <gapm_get_dev_config_cmd_handler+0x110>
    9fbe:	2301      	movs	r3, #1
    9fc0:	8821      	ldrh	r1, [r4, #0]
    9fc2:	4a23      	ldr	r2, [pc, #140]	; (a050 <gapm_get_dev_config_cmd_handler+0x160>)
    9fc4:	68a6      	ldr	r6, [r4, #8]
    9fc6:	425b      	negs	r3, r3
    9fc8:	4291      	cmp	r1, r2
    9fca:	d001      	beq.n	9fd0 <gapm_get_dev_config_cmd_handler+0xe0>
    9fcc:	8023      	strh	r3, [r4, #0]
    9fce:	e01a      	b.n	a006 <gapm_get_dev_config_cmd_handler+0x116>
    9fd0:	8063      	strh	r3, [r4, #2]
    9fd2:	9b01      	ldr	r3, [sp, #4]
    9fd4:	1c31      	adds	r1, r6, #0
    9fd6:	1c58      	adds	r0, r3, #1
    9fd8:	2206      	movs	r2, #6
    9fda:	4b1e      	ldr	r3, [pc, #120]	; (a054 <gapm_get_dev_config_cmd_handler+0x164>)
    9fdc:	4798      	blx	r3
    9fde:	79b3      	ldrb	r3, [r6, #6]
    9fe0:	9a01      	ldr	r2, [sp, #4]
    9fe2:	1c28      	adds	r0, r5, #0
    9fe4:	7013      	strb	r3, [r2, #0]
    9fe6:	23d0      	movs	r3, #208	; 0xd0
    9fe8:	011b      	lsls	r3, r3, #4
    9fea:	8023      	strh	r3, [r4, #0]
    9fec:	230d      	movs	r3, #13
    9fee:	80a3      	strh	r3, [r4, #4]
    9ff0:	4b15      	ldr	r3, [pc, #84]	; (a048 <gapm_get_dev_config_cmd_handler+0x158>)
    9ff2:	702f      	strb	r7, [r5, #0]
    9ff4:	4798      	blx	r3
    9ff6:	4b15      	ldr	r3, [pc, #84]	; (a04c <gapm_get_dev_config_cmd_handler+0x15c>)
    9ff8:	4798      	blx	r3
    9ffa:	782b      	ldrb	r3, [r5, #0]
    9ffc:	2b00      	cmp	r3, #0
    9ffe:	d001      	beq.n	a004 <gapm_get_dev_config_cmd_handler+0x114>
    a000:	20d0      	movs	r0, #208	; 0xd0
    a002:	e013      	b.n	a02c <gapm_get_dev_config_cmd_handler+0x13c>
    a004:	68a6      	ldr	r6, [r4, #8]
    a006:	7834      	ldrb	r4, [r6, #0]
    a008:	7870      	ldrb	r0, [r6, #1]
    a00a:	2c06      	cmp	r4, #6
    a00c:	d00e      	beq.n	a02c <gapm_get_dev_config_cmd_handler+0x13c>
    a00e:	4d12      	ldr	r5, [pc, #72]	; (a058 <gapm_get_dev_config_cmd_handler+0x168>)
    a010:	4912      	ldr	r1, [pc, #72]	; (a05c <gapm_get_dev_config_cmd_handler+0x16c>)
    a012:	2287      	movs	r2, #135	; 0x87
    a014:	4b12      	ldr	r3, [pc, #72]	; (a060 <gapm_get_dev_config_cmd_handler+0x170>)
    a016:	4813      	ldr	r0, [pc, #76]	; (a064 <gapm_get_dev_config_cmd_handler+0x174>)
    a018:	682e      	ldr	r6, [r5, #0]
    a01a:	47b0      	blx	r6
    a01c:	682b      	ldr	r3, [r5, #0]
    a01e:	4812      	ldr	r0, [pc, #72]	; (a068 <gapm_get_dev_config_cmd_handler+0x178>)
    a020:	2106      	movs	r1, #6
    a022:	1c22      	adds	r2, r4, #0
    a024:	4798      	blx	r3
    a026:	20e2      	movs	r0, #226	; 0xe2
    a028:	e000      	b.n	a02c <gapm_get_dev_config_cmd_handler+0x13c>
    a02a:	20cf      	movs	r0, #207	; 0xcf
    a02c:	b005      	add	sp, #20
    a02e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a030:	20000005 	.word	0x20000005
    a034:	00011148 	.word	0x00011148
    a038:	200017fc 	.word	0x200017fc
    a03c:	00000d08 	.word	0x00000d08
    a040:	00008a29 	.word	0x00008a29
    a044:	00008835 	.word	0x00008835
    a048:	00001a1d 	.word	0x00001a1d
    a04c:	00001895 	.word	0x00001895
    a050:	0000ffff 	.word	0x0000ffff
    a054:	0000d7eb 	.word	0x0000d7eb
    a058:	20000038 	.word	0x20000038
    a05c:	000112a6 	.word	0x000112a6
    a060:	0001135d 	.word	0x0001135d
    a064:	0000ed34 	.word	0x0000ed34
    a068:	00011300 	.word	0x00011300

0000a06c <gapm_cancel_cmd_handler>:
    a06c:	b5f0      	push	{r4, r5, r6, r7, lr}
    a06e:	4f2f      	ldr	r7, [pc, #188]	; (a12c <gapm_cancel_cmd_handler+0xc0>)
    a070:	b085      	sub	sp, #20
    a072:	7839      	ldrb	r1, [r7, #0]
    a074:	9701      	str	r7, [sp, #4]
    a076:	4a2e      	ldr	r2, [pc, #184]	; (a130 <gapm_cancel_cmd_handler+0xc4>)
    a078:	2300      	movs	r3, #0
    a07a:	2902      	cmp	r1, #2
    a07c:	d107      	bne.n	a08e <gapm_cancel_cmd_handler+0x22>
    a07e:	6813      	ldr	r3, [r2, #0]
    a080:	3150      	adds	r1, #80	; 0x50
    a082:	7019      	strb	r1, [r3, #0]
    a084:	3105      	adds	r1, #5
    a086:	7059      	strb	r1, [r3, #1]
    a088:	3936      	subs	r1, #54	; 0x36
    a08a:	7099      	strb	r1, [r3, #2]
    a08c:	2303      	movs	r3, #3
    a08e:	6810      	ldr	r0, [r2, #0]
    a090:	2205      	movs	r2, #5
    a092:	2103      	movs	r1, #3
    a094:	250d      	movs	r5, #13
    a096:	2400      	movs	r4, #0
    a098:	2702      	movs	r7, #2
    a09a:	54c2      	strb	r2, [r0, r3]
    a09c:	1c5a      	adds	r2, r3, #1
    a09e:	5481      	strb	r1, [r0, r2]
    a0a0:	1c9a      	adds	r2, r3, #2
    a0a2:	5485      	strb	r5, [r0, r2]
    a0a4:	185a      	adds	r2, r3, r1
    a0a6:	5485      	strb	r5, [r0, r2]
    a0a8:	1d1a      	adds	r2, r3, #4
    a0aa:	5484      	strb	r4, [r0, r2]
    a0ac:	1949      	adds	r1, r1, r5
    a0ae:	1d5a      	adds	r2, r3, #5
    a0b0:	5481      	strb	r1, [r0, r2]
    a0b2:	1d9a      	adds	r2, r3, #6
    a0b4:	5484      	strb	r4, [r0, r2]
    a0b6:	1dde      	adds	r6, r3, #7
    a0b8:	3202      	adds	r2, #2
    a0ba:	1c19      	adds	r1, r3, #0
    a0bc:	1986      	adds	r6, r0, r6
    a0be:	3309      	adds	r3, #9
    a0c0:	1882      	adds	r2, r0, r2
    a0c2:	7034      	strb	r4, [r6, #0]
    a0c4:	7014      	strb	r4, [r2, #0]
    a0c6:	54c7      	strb	r7, [r0, r3]
    a0c8:	27d0      	movs	r7, #208	; 0xd0
    a0ca:	4b1a      	ldr	r3, [pc, #104]	; (a134 <gapm_cancel_cmd_handler+0xc8>)
    a0cc:	013f      	lsls	r7, r7, #4
    a0ce:	809d      	strh	r5, [r3, #4]
    a0d0:	9d01      	ldr	r5, [sp, #4]
    a0d2:	801f      	strh	r7, [r3, #0]
    a0d4:	782f      	ldrb	r7, [r5, #0]
    a0d6:	310a      	adds	r1, #10
    a0d8:	1c1d      	adds	r5, r3, #0
    a0da:	1c0b      	adds	r3, r1, #0
    a0dc:	2f02      	cmp	r7, #2
    a0de:	d104      	bne.n	a0ea <gapm_cancel_cmd_handler+0x7e>
    a0e0:	3b0c      	subs	r3, #12
    a0e2:	7033      	strb	r3, [r6, #0]
    a0e4:	121b      	asrs	r3, r3, #8
    a0e6:	7013      	strb	r3, [r2, #0]
    a0e8:	e002      	b.n	a0f0 <gapm_cancel_cmd_handler+0x84>
    a0ea:	3b09      	subs	r3, #9
    a0ec:	7033      	strb	r3, [r6, #0]
    a0ee:	7014      	strb	r4, [r2, #0]
    a0f0:	4b11      	ldr	r3, [pc, #68]	; (a138 <gapm_cancel_cmd_handler+0xcc>)
    a0f2:	4798      	blx	r3
    a0f4:	1e04      	subs	r4, r0, #0
    a0f6:	d114      	bne.n	a122 <gapm_cancel_cmd_handler+0xb6>
    a0f8:	4b10      	ldr	r3, [pc, #64]	; (a13c <gapm_cancel_cmd_handler+0xd0>)
    a0fa:	4798      	blx	r3
    a0fc:	ab02      	add	r3, sp, #8
    a0fe:	1dde      	adds	r6, r3, #7
    a100:	71dc      	strb	r4, [r3, #7]
    a102:	1c30      	adds	r0, r6, #0
    a104:	4b0e      	ldr	r3, [pc, #56]	; (a140 <gapm_cancel_cmd_handler+0xd4>)
    a106:	4798      	blx	r3
    a108:	4b0e      	ldr	r3, [pc, #56]	; (a144 <gapm_cancel_cmd_handler+0xd8>)
    a10a:	4798      	blx	r3
    a10c:	7833      	ldrb	r3, [r6, #0]
    a10e:	2b00      	cmp	r3, #0
    a110:	d001      	beq.n	a116 <gapm_cancel_cmd_handler+0xaa>
    a112:	34d0      	adds	r4, #208	; 0xd0
    a114:	e006      	b.n	a124 <gapm_cancel_cmd_handler+0xb8>
    a116:	68ab      	ldr	r3, [r5, #8]
    a118:	785b      	ldrb	r3, [r3, #1]
    a11a:	2b44      	cmp	r3, #68	; 0x44
    a11c:	d002      	beq.n	a124 <gapm_cancel_cmd_handler+0xb8>
    a11e:	1c1c      	adds	r4, r3, #0
    a120:	e000      	b.n	a124 <gapm_cancel_cmd_handler+0xb8>
    a122:	24e1      	movs	r4, #225	; 0xe1
    a124:	1c20      	adds	r0, r4, #0
    a126:	b005      	add	sp, #20
    a128:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a12a:	46c0      	nop			; (mov r8, r8)
    a12c:	20000005 	.word	0x20000005
    a130:	00011148 	.word	0x00011148
    a134:	200017fc 	.word	0x200017fc
    a138:	00008a29 	.word	0x00008a29
    a13c:	00008835 	.word	0x00008835
    a140:	00001a1d 	.word	0x00001a1d
    a144:	00001895 	.word	0x00001895

0000a148 <gapm_dev_bdaddr_ind_handler>:
    a148:	b538      	push	{r3, r4, r5, lr}
    a14a:	1c05      	adds	r5, r0, #0
    a14c:	1c0c      	adds	r4, r1, #0
    a14e:	1c48      	adds	r0, r1, #1
    a150:	2206      	movs	r2, #6
    a152:	1c29      	adds	r1, r5, #0
    a154:	4b02      	ldr	r3, [pc, #8]	; (a160 <gapm_dev_bdaddr_ind_handler+0x18>)
    a156:	4798      	blx	r3
    a158:	79ab      	ldrb	r3, [r5, #6]
    a15a:	2000      	movs	r0, #0
    a15c:	7023      	strb	r3, [r4, #0]
    a15e:	bd38      	pop	{r3, r4, r5, pc}
    a160:	0000d7eb 	.word	0x0000d7eb

0000a164 <gapm_cmp_evt>:
    a164:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a166:	7806      	ldrb	r6, [r0, #0]
    a168:	7845      	ldrb	r5, [r0, #1]
    a16a:	1c30      	adds	r0, r6, #0
    a16c:	380c      	subs	r0, #12
    a16e:	1c0c      	adds	r4, r1, #0
    a170:	280b      	cmp	r0, #11
    a172:	d900      	bls.n	a176 <gapm_cmp_evt+0x12>
    a174:	e08c      	b.n	a290 <gapm_cmp_evt+0x12c>
    a176:	f001 fe0f 	bl	bd98 <__gnu_thumb1_case_uqi>
    a17a:	1952      	.short	0x1952
    a17c:	068b1919 	.word	0x068b1919
    a180:	8b595906 	.word	0x8b595906
    a184:	0d8b      	.short	0x0d8b
    a186:	2300      	movs	r3, #0
    a188:	2d45      	cmp	r5, #69	; 0x45
    a18a:	d000      	beq.n	a18e <gapm_cmp_evt+0x2a>
    a18c:	1c2b      	adds	r3, r5, #0
    a18e:	7023      	strb	r3, [r4, #0]
    a190:	2002      	movs	r0, #2
    a192:	e08a      	b.n	a2aa <gapm_cmp_evt+0x146>
    a194:	203a      	movs	r0, #58	; 0x3a
    a196:	2d00      	cmp	r5, #0
    a198:	d100      	bne.n	a19c <gapm_cmp_evt+0x38>
    a19a:	e086      	b.n	a2aa <gapm_cmp_evt+0x146>
    a19c:	700d      	strb	r5, [r1, #0]
    a19e:	1c48      	adds	r0, r1, #1
    a1a0:	2210      	movs	r2, #16
    a1a2:	2100      	movs	r1, #0
    a1a4:	4b41      	ldr	r3, [pc, #260]	; (a2ac <gapm_cmp_evt+0x148>)
    a1a6:	4798      	blx	r3
    a1a8:	200f      	movs	r0, #15
    a1aa:	e07e      	b.n	a2aa <gapm_cmp_evt+0x146>
    a1ac:	2d00      	cmp	r5, #0
    a1ae:	d134      	bne.n	a21a <gapm_cmp_evt+0xb6>
    a1b0:	4b3f      	ldr	r3, [pc, #252]	; (a2b0 <gapm_cmp_evt+0x14c>)
    a1b2:	4798      	blx	r3
    a1b4:	1e43      	subs	r3, r0, #1
    a1b6:	b2db      	uxtb	r3, r3
    a1b8:	1c28      	adds	r0, r5, #0
    a1ba:	2b06      	cmp	r3, #6
    a1bc:	d875      	bhi.n	a2aa <gapm_cmp_evt+0x146>
    a1be:	466b      	mov	r3, sp
    a1c0:	4e3c      	ldr	r6, [pc, #240]	; (a2b4 <gapm_cmp_evt+0x150>)
    a1c2:	1dd9      	adds	r1, r3, #7
    a1c4:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
    a1c6:	4b3c      	ldr	r3, [pc, #240]	; (a2b8 <gapm_cmp_evt+0x154>)
    a1c8:	4798      	blx	r3
    a1ca:	2312      	movs	r3, #18
    a1cc:	4358      	muls	r0, r3
    a1ce:	493b      	ldr	r1, [pc, #236]	; (a2bc <gapm_cmp_evt+0x158>)
    a1d0:	1809      	adds	r1, r1, r0
    a1d2:	1c0b      	adds	r3, r1, #0
    a1d4:	894a      	ldrh	r2, [r1, #10]
    a1d6:	3308      	adds	r3, #8
    a1d8:	8122      	strh	r2, [r4, #8]
    a1da:	784f      	ldrb	r7, [r1, #1]
    a1dc:	72a5      	strb	r5, [r4, #10]
    a1de:	7027      	strb	r7, [r4, #0]
    a1e0:	898a      	ldrh	r2, [r1, #12]
    a1e2:	1c60      	adds	r0, r4, #1
    a1e4:	81a2      	strh	r2, [r4, #12]
    a1e6:	88db      	ldrh	r3, [r3, #6]
    a1e8:	3102      	adds	r1, #2
    a1ea:	81e3      	strh	r3, [r4, #14]
    a1ec:	89cb      	ldrh	r3, [r1, #14]
    a1ee:	2206      	movs	r2, #6
    a1f0:	8223      	strh	r3, [r4, #16]
    a1f2:	4b33      	ldr	r3, [pc, #204]	; (a2c0 <gapm_cmp_evt+0x15c>)
    a1f4:	4798      	blx	r3
    a1f6:	2f00      	cmp	r7, #0
    a1f8:	d00a      	beq.n	a210 <gapm_cmp_evt+0xac>
    a1fa:	79a3      	ldrb	r3, [r4, #6]
    a1fc:	223f      	movs	r2, #63	; 0x3f
    a1fe:	1c19      	adds	r1, r3, #0
    a200:	3501      	adds	r5, #1
    a202:	4391      	bics	r1, r2
    a204:	29c0      	cmp	r1, #192	; 0xc0
    a206:	d003      	beq.n	a210 <gapm_cmp_evt+0xac>
    a208:	065b      	lsls	r3, r3, #25
    a20a:	0fdb      	lsrs	r3, r3, #31
    a20c:	3502      	adds	r5, #2
    a20e:	1aed      	subs	r5, r5, r3
    a210:	2301      	movs	r3, #1
    a212:	425b      	negs	r3, r3
    a214:	7025      	strb	r5, [r4, #0]
    a216:	85b3      	strh	r3, [r6, #44]	; 0x2c
    a218:	e038      	b.n	a28c <gapm_cmp_evt+0x128>
    a21a:	700d      	strb	r5, [r1, #0]
    a21c:	e004      	b.n	a228 <gapm_cmp_evt+0xc4>
    a21e:	2300      	movs	r3, #0
    a220:	2d45      	cmp	r5, #69	; 0x45
    a222:	d000      	beq.n	a226 <gapm_cmp_evt+0xc2>
    a224:	1c2b      	adds	r3, r5, #0
    a226:	7023      	strb	r3, [r4, #0]
    a228:	2003      	movs	r0, #3
    a22a:	e03e      	b.n	a2aa <gapm_cmp_evt+0x146>
    a22c:	4e21      	ldr	r6, [pc, #132]	; (a2b4 <gapm_cmp_evt+0x150>)
    a22e:	2100      	movs	r1, #0
    a230:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
    a232:	4b21      	ldr	r3, [pc, #132]	; (a2b8 <gapm_cmp_evt+0x154>)
    a234:	4798      	blx	r3
    a236:	2807      	cmp	r0, #7
    a238:	d818      	bhi.n	a26c <gapm_cmp_evt+0x108>
    a23a:	2301      	movs	r3, #1
    a23c:	425b      	negs	r3, r3
    a23e:	85b3      	strh	r3, [r6, #44]	; 0x2c
    a240:	3313      	adds	r3, #19
    a242:	4358      	muls	r0, r3
    a244:	491d      	ldr	r1, [pc, #116]	; (a2bc <gapm_cmp_evt+0x158>)
    a246:	1809      	adds	r1, r1, r0
    a248:	1c0b      	adds	r3, r1, #0
    a24a:	894a      	ldrh	r2, [r1, #10]
    a24c:	3308      	adds	r3, #8
    a24e:	8122      	strh	r2, [r4, #8]
    a250:	784a      	ldrb	r2, [r1, #1]
    a252:	72a5      	strb	r5, [r4, #10]
    a254:	7022      	strb	r2, [r4, #0]
    a256:	898a      	ldrh	r2, [r1, #12]
    a258:	1c60      	adds	r0, r4, #1
    a25a:	81a2      	strh	r2, [r4, #12]
    a25c:	88db      	ldrh	r3, [r3, #6]
    a25e:	3102      	adds	r1, #2
    a260:	81e3      	strh	r3, [r4, #14]
    a262:	89cb      	ldrh	r3, [r1, #14]
    a264:	2206      	movs	r2, #6
    a266:	8223      	strh	r3, [r4, #16]
    a268:	4b15      	ldr	r3, [pc, #84]	; (a2c0 <gapm_cmp_evt+0x15c>)
    a26a:	4798      	blx	r3
    a26c:	2200      	movs	r2, #0
    a26e:	7823      	ldrb	r3, [r4, #0]
    a270:	4293      	cmp	r3, r2
    a272:	d00a      	beq.n	a28a <gapm_cmp_evt+0x126>
    a274:	79a3      	ldrb	r3, [r4, #6]
    a276:	323f      	adds	r2, #63	; 0x3f
    a278:	1c19      	adds	r1, r3, #0
    a27a:	4391      	bics	r1, r2
    a27c:	3a3e      	subs	r2, #62	; 0x3e
    a27e:	29c0      	cmp	r1, #192	; 0xc0
    a280:	d003      	beq.n	a28a <gapm_cmp_evt+0x126>
    a282:	065b      	lsls	r3, r3, #25
    a284:	0fdb      	lsrs	r3, r3, #31
    a286:	3202      	adds	r2, #2
    a288:	1ad2      	subs	r2, r2, r3
    a28a:	7022      	strb	r2, [r4, #0]
    a28c:	2005      	movs	r0, #5
    a28e:	e00c      	b.n	a2aa <gapm_cmp_evt+0x146>
    a290:	2226      	movs	r2, #38	; 0x26
    a292:	4c0c      	ldr	r4, [pc, #48]	; (a2c4 <gapm_cmp_evt+0x160>)
    a294:	490c      	ldr	r1, [pc, #48]	; (a2c8 <gapm_cmp_evt+0x164>)
    a296:	32ff      	adds	r2, #255	; 0xff
    a298:	4b0c      	ldr	r3, [pc, #48]	; (a2cc <gapm_cmp_evt+0x168>)
    a29a:	480d      	ldr	r0, [pc, #52]	; (a2d0 <gapm_cmp_evt+0x16c>)
    a29c:	6825      	ldr	r5, [r4, #0]
    a29e:	47a8      	blx	r5
    a2a0:	6823      	ldr	r3, [r4, #0]
    a2a2:	480c      	ldr	r0, [pc, #48]	; (a2d4 <gapm_cmp_evt+0x170>)
    a2a4:	1c31      	adds	r1, r6, #0
    a2a6:	4798      	blx	r3
    a2a8:	2000      	movs	r0, #0
    a2aa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    a2ac:	0000d825 	.word	0x0000d825
    a2b0:	00008d55 	.word	0x00008d55
    a2b4:	20001898 	.word	0x20001898
    a2b8:	00008d19 	.word	0x00008d19
    a2bc:	20001808 	.word	0x20001808
    a2c0:	0000d7eb 	.word	0x0000d7eb
    a2c4:	20000038 	.word	0x20000038
    a2c8:	000112a6 	.word	0x000112a6
    a2cc:	00011350 	.word	0x00011350
    a2d0:	0000ed34 	.word	0x0000ed34
    a2d4:	00011318 	.word	0x00011318

0000a2d8 <gapm_start_adv_cmd_handler>:
    a2d8:	b5f0      	push	{r4, r5, r6, r7, lr}
    a2da:	b08b      	sub	sp, #44	; 0x2c
    a2dc:	9305      	str	r3, [sp, #20]
    a2de:	ab10      	add	r3, sp, #64	; 0x40
    a2e0:	cb04      	ldmia	r3!, {r2}
    a2e2:	ac0a      	add	r4, sp, #40	; 0x28
    a2e4:	881b      	ldrh	r3, [r3, #0]
    a2e6:	9301      	str	r3, [sp, #4]
    a2e8:	ab12      	add	r3, sp, #72	; 0x48
    a2ea:	881b      	ldrh	r3, [r3, #0]
    a2ec:	9302      	str	r3, [sp, #8]
    a2ee:	ab13      	add	r3, sp, #76	; 0x4c
    a2f0:	781b      	ldrb	r3, [r3, #0]
    a2f2:	9306      	str	r3, [sp, #24]
    a2f4:	ab14      	add	r3, sp, #80	; 0x50
    a2f6:	781b      	ldrb	r3, [r3, #0]
    a2f8:	9307      	str	r3, [sp, #28]
    a2fa:	ab15      	add	r3, sp, #84	; 0x54
    a2fc:	781b      	ldrb	r3, [r3, #0]
    a2fe:	9308      	str	r3, [sp, #32]
    a300:	ab16      	add	r3, sp, #88	; 0x58
    a302:	781b      	ldrb	r3, [r3, #0]
    a304:	469c      	mov	ip, r3
    a306:	2319      	movs	r3, #25
    a308:	191b      	adds	r3, r3, r4
    a30a:	7fdb      	ldrb	r3, [r3, #31]
    a30c:	2400      	movs	r4, #0
    a30e:	9303      	str	r3, [sp, #12]
    a310:	ab1a      	add	r3, sp, #104	; 0x68
    a312:	881b      	ldrh	r3, [r3, #0]
    a314:	9304      	str	r3, [sp, #16]
    a316:	ab1b      	add	r3, sp, #108	; 0x6c
    a318:	781b      	ldrb	r3, [r3, #0]
    a31a:	9309      	str	r3, [sp, #36]	; 0x24
    a31c:	4b56      	ldr	r3, [pc, #344]	; (a478 <gapm_start_adv_cmd_handler+0x1a0>)
    a31e:	781b      	ldrb	r3, [r3, #0]
    a320:	2b02      	cmp	r3, #2
    a322:	d108      	bne.n	a336 <gapm_start_adv_cmd_handler+0x5e>
    a324:	4b55      	ldr	r3, [pc, #340]	; (a47c <gapm_start_adv_cmd_handler+0x1a4>)
    a326:	3452      	adds	r4, #82	; 0x52
    a328:	681b      	ldr	r3, [r3, #0]
    a32a:	701c      	strb	r4, [r3, #0]
    a32c:	3405      	adds	r4, #5
    a32e:	705c      	strb	r4, [r3, #1]
    a330:	3c36      	subs	r4, #54	; 0x36
    a332:	709c      	strb	r4, [r3, #2]
    a334:	3c1e      	subs	r4, #30
    a336:	4b51      	ldr	r3, [pc, #324]	; (a47c <gapm_start_adv_cmd_handler+0x1a4>)
    a338:	260d      	movs	r6, #13
    a33a:	681d      	ldr	r5, [r3, #0]
    a33c:	2305      	movs	r3, #5
    a33e:	552b      	strb	r3, [r5, r4]
    a340:	1c63      	adds	r3, r4, #1
    a342:	54ee      	strb	r6, [r5, r3]
    a344:	1ca3      	adds	r3, r4, #2
    a346:	54ee      	strb	r6, [r5, r3]
    a348:	1ce3      	adds	r3, r4, #3
    a34a:	54ee      	strb	r6, [r5, r3]
    a34c:	2300      	movs	r3, #0
    a34e:	2710      	movs	r7, #16
    a350:	1d26      	adds	r6, r4, #4
    a352:	55ab      	strb	r3, [r5, r6]
    a354:	1d66      	adds	r6, r4, #5
    a356:	55af      	strb	r7, [r5, r6]
    a358:	1da6      	adds	r6, r4, #6
    a35a:	55ab      	strb	r3, [r5, r6]
    a35c:	1de6      	adds	r6, r4, #7
    a35e:	19ae      	adds	r6, r5, r6
    a360:	7033      	strb	r3, [r6, #0]
    a362:	9600      	str	r6, [sp, #0]
    a364:	1c26      	adds	r6, r4, #0
    a366:	1c27      	adds	r7, r4, #0
    a368:	3608      	adds	r6, #8
    a36a:	3709      	adds	r7, #9
    a36c:	19ae      	adds	r6, r5, r6
    a36e:	7033      	strb	r3, [r6, #0]
    a370:	55e8      	strb	r0, [r5, r7]
    a372:	3701      	adds	r7, #1
    a374:	55e9      	strb	r1, [r5, r7]
    a376:	1c21      	adds	r1, r4, #0
    a378:	310b      	adds	r1, #11
    a37a:	546b      	strb	r3, [r5, r1]
    a37c:	3101      	adds	r1, #1
    a37e:	546b      	strb	r3, [r5, r1]
    a380:	4669      	mov	r1, sp
    a382:	1c23      	adds	r3, r4, #0
    a384:	7909      	ldrb	r1, [r1, #4]
    a386:	330d      	adds	r3, #13
    a388:	54e9      	strb	r1, [r5, r3]
    a38a:	1c21      	adds	r1, r4, #0
    a38c:	9b01      	ldr	r3, [sp, #4]
    a38e:	310e      	adds	r1, #14
    a390:	0a1b      	lsrs	r3, r3, #8
    a392:	546b      	strb	r3, [r5, r1]
    a394:	4669      	mov	r1, sp
    a396:	1c23      	adds	r3, r4, #0
    a398:	7a09      	ldrb	r1, [r1, #8]
    a39a:	330f      	adds	r3, #15
    a39c:	54e9      	strb	r1, [r5, r3]
    a39e:	1c21      	adds	r1, r4, #0
    a3a0:	9b02      	ldr	r3, [sp, #8]
    a3a2:	466f      	mov	r7, sp
    a3a4:	0a1b      	lsrs	r3, r3, #8
    a3a6:	3110      	adds	r1, #16
    a3a8:	546b      	strb	r3, [r5, r1]
    a3aa:	1c23      	adds	r3, r4, #0
    a3ac:	7e3f      	ldrb	r7, [r7, #24]
    a3ae:	3101      	adds	r1, #1
    a3b0:	380e      	subs	r0, #14
    a3b2:	3312      	adds	r3, #18
    a3b4:	546f      	strb	r7, [r5, r1]
    a3b6:	2801      	cmp	r0, #1
    a3b8:	d80f      	bhi.n	a3da <gapm_start_adv_cmd_handler+0x102>
    a3ba:	3418      	adds	r4, #24
    a3bc:	b2a1      	uxth	r1, r4
    a3be:	2a00      	cmp	r2, #0
    a3c0:	d005      	beq.n	a3ce <gapm_start_adv_cmd_handler+0xf6>
    a3c2:	1c11      	adds	r1, r2, #0
    a3c4:	18e8      	adds	r0, r5, r3
    a3c6:	2206      	movs	r2, #6
    a3c8:	4b2d      	ldr	r3, [pc, #180]	; (a480 <gapm_start_adv_cmd_handler+0x1a8>)
    a3ca:	4798      	blx	r3
    a3cc:	b2a1      	uxth	r1, r4
    a3ce:	466b      	mov	r3, sp
    a3d0:	7d1b      	ldrb	r3, [r3, #20]
    a3d2:	546b      	strb	r3, [r5, r1]
    a3d4:	3139      	adds	r1, #57	; 0x39
    a3d6:	b28c      	uxth	r4, r1
    a3d8:	e01f      	b.n	a41a <gapm_start_adv_cmd_handler+0x142>
    a3da:	466a      	mov	r2, sp
    a3dc:	7f12      	ldrb	r2, [r2, #28]
    a3de:	2120      	movs	r1, #32
    a3e0:	54ea      	strb	r2, [r5, r3]
    a3e2:	466a      	mov	r2, sp
    a3e4:	1c23      	adds	r3, r4, #0
    a3e6:	1852      	adds	r2, r2, r1
    a3e8:	7812      	ldrb	r2, [r2, #0]
    a3ea:	3313      	adds	r3, #19
    a3ec:	1c20      	adds	r0, r4, #0
    a3ee:	54ea      	strb	r2, [r5, r3]
    a3f0:	4662      	mov	r2, ip
    a3f2:	3301      	adds	r3, #1
    a3f4:	3015      	adds	r0, #21
    a3f6:	54ea      	strb	r2, [r5, r3]
    a3f8:	9917      	ldr	r1, [sp, #92]	; 0x5c
    a3fa:	4662      	mov	r2, ip
    a3fc:	4f20      	ldr	r7, [pc, #128]	; (a480 <gapm_start_adv_cmd_handler+0x1a8>)
    a3fe:	1828      	adds	r0, r5, r0
    a400:	47b8      	blx	r7
    a402:	466a      	mov	r2, sp
    a404:	1c23      	adds	r3, r4, #0
    a406:	1c20      	adds	r0, r4, #0
    a408:	7b12      	ldrb	r2, [r2, #12]
    a40a:	3331      	adds	r3, #49	; 0x31
    a40c:	3032      	adds	r0, #50	; 0x32
    a40e:	54ea      	strb	r2, [r5, r3]
    a410:	1828      	adds	r0, r5, r0
    a412:	9919      	ldr	r1, [sp, #100]	; 0x64
    a414:	9a03      	ldr	r2, [sp, #12]
    a416:	47b8      	blx	r7
    a418:	3451      	adds	r4, #81	; 0x51
    a41a:	22a5      	movs	r2, #165	; 0xa5
    a41c:	1c63      	adds	r3, r4, #1
    a41e:	b29b      	uxth	r3, r3
    a420:	552a      	strb	r2, [r5, r4]
    a422:	54ea      	strb	r2, [r5, r3]
    a424:	466a      	mov	r2, sp
    a426:	1ca3      	adds	r3, r4, #2
    a428:	7c12      	ldrb	r2, [r2, #16]
    a42a:	b29b      	uxth	r3, r3
    a42c:	54ea      	strb	r2, [r5, r3]
    a42e:	9b04      	ldr	r3, [sp, #16]
    a430:	1ce2      	adds	r2, r4, #3
    a432:	b292      	uxth	r2, r2
    a434:	0a1b      	lsrs	r3, r3, #8
    a436:	54ab      	strb	r3, [r5, r2]
    a438:	2224      	movs	r2, #36	; 0x24
    a43a:	466b      	mov	r3, sp
    a43c:	189b      	adds	r3, r3, r2
    a43e:	1d61      	adds	r1, r4, #5
    a440:	781b      	ldrb	r3, [r3, #0]
    a442:	3404      	adds	r4, #4
    a444:	b2a4      	uxth	r4, r4
    a446:	552b      	strb	r3, [r5, r4]
    a448:	4b0b      	ldr	r3, [pc, #44]	; (a478 <gapm_start_adv_cmd_handler+0x1a0>)
    a44a:	b289      	uxth	r1, r1
    a44c:	781a      	ldrb	r2, [r3, #0]
    a44e:	2300      	movs	r3, #0
    a450:	2a02      	cmp	r2, #2
    a452:	d102      	bne.n	a45a <gapm_start_adv_cmd_handler+0x182>
    a454:	1c0a      	adds	r2, r1, #0
    a456:	3a0c      	subs	r2, #12
    a458:	e001      	b.n	a45e <gapm_start_adv_cmd_handler+0x186>
    a45a:	1c0a      	adds	r2, r1, #0
    a45c:	3a09      	subs	r2, #9
    a45e:	9800      	ldr	r0, [sp, #0]
    a460:	7002      	strb	r2, [r0, #0]
    a462:	7033      	strb	r3, [r6, #0]
    a464:	1c28      	adds	r0, r5, #0
    a466:	4b07      	ldr	r3, [pc, #28]	; (a484 <gapm_start_adv_cmd_handler+0x1ac>)
    a468:	4798      	blx	r3
    a46a:	4b07      	ldr	r3, [pc, #28]	; (a488 <gapm_start_adv_cmd_handler+0x1b0>)
    a46c:	4798      	blx	r3
    a46e:	4b07      	ldr	r3, [pc, #28]	; (a48c <gapm_start_adv_cmd_handler+0x1b4>)
    a470:	4798      	blx	r3
    a472:	2000      	movs	r0, #0
    a474:	b00b      	add	sp, #44	; 0x2c
    a476:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a478:	20000005 	.word	0x20000005
    a47c:	00011148 	.word	0x00011148
    a480:	0000d7eb 	.word	0x0000d7eb
    a484:	00008a29 	.word	0x00008a29
    a488:	00008835 	.word	0x00008835
    a48c:	00001895 	.word	0x00001895

0000a490 <get_gap_local_addr_type>:
    a490:	4b04      	ldr	r3, [pc, #16]	; (a4a4 <get_gap_local_addr_type+0x14>)
    a492:	2001      	movs	r0, #1
    a494:	791b      	ldrb	r3, [r3, #4]
    a496:	2b02      	cmp	r3, #2
    a498:	d003      	beq.n	a4a2 <get_gap_local_addr_type+0x12>
    a49a:	3b03      	subs	r3, #3
    a49c:	4258      	negs	r0, r3
    a49e:	4158      	adcs	r0, r3
    a4a0:	0040      	lsls	r0, r0, #1
    a4a2:	4770      	bx	lr
    a4a4:	20001898 	.word	0x20001898

0000a4a8 <gapm_adv_report_evt_handler>:
    a4a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a4aa:	7843      	ldrb	r3, [r0, #1]
    a4ac:	1c05      	adds	r5, r0, #0
    a4ae:	9301      	str	r3, [sp, #4]
    a4b0:	466b      	mov	r3, sp
    a4b2:	1c0c      	adds	r4, r1, #0
    a4b4:	791b      	ldrb	r3, [r3, #4]
    a4b6:	7806      	ldrb	r6, [r0, #0]
    a4b8:	2206      	movs	r2, #6
    a4ba:	704b      	strb	r3, [r1, #1]
    a4bc:	1c88      	adds	r0, r1, #2
    a4be:	4f1b      	ldr	r7, [pc, #108]	; (a52c <gapm_adv_report_evt_handler+0x84>)
    a4c0:	1ca9      	adds	r1, r5, #2
    a4c2:	47b8      	blx	r7
    a4c4:	1c20      	adds	r0, r4, #0
    a4c6:	1c29      	adds	r1, r5, #0
    a4c8:	7a2a      	ldrb	r2, [r5, #8]
    a4ca:	3008      	adds	r0, #8
    a4cc:	77c2      	strb	r2, [r0, #31]
    a4ce:	3109      	adds	r1, #9
    a4d0:	3528      	adds	r5, #40	; 0x28
    a4d2:	47b8      	blx	r7
    a4d4:	782b      	ldrb	r3, [r5, #0]
    a4d6:	b25a      	sxtb	r2, r3
    a4d8:	2a00      	cmp	r2, #0
    a4da:	da01      	bge.n	a4e0 <gapm_adv_report_evt_handler+0x38>
    a4dc:	3301      	adds	r3, #1
    a4de:	b2db      	uxtb	r3, r3
    a4e0:	1c22      	adds	r2, r4, #0
    a4e2:	3228      	adds	r2, #40	; 0x28
    a4e4:	7013      	strb	r3, [r2, #0]
    a4e6:	2200      	movs	r2, #0
    a4e8:	9b01      	ldr	r3, [sp, #4]
    a4ea:	4293      	cmp	r3, r2
    a4ec:	d00a      	beq.n	a504 <gapm_adv_report_evt_handler+0x5c>
    a4ee:	79e3      	ldrb	r3, [r4, #7]
    a4f0:	323f      	adds	r2, #63	; 0x3f
    a4f2:	1c19      	adds	r1, r3, #0
    a4f4:	4391      	bics	r1, r2
    a4f6:	3a3e      	subs	r2, #62	; 0x3e
    a4f8:	29c0      	cmp	r1, #192	; 0xc0
    a4fa:	d003      	beq.n	a504 <gapm_adv_report_evt_handler+0x5c>
    a4fc:	065b      	lsls	r3, r3, #25
    a4fe:	0fdb      	lsrs	r3, r3, #31
    a500:	3202      	adds	r2, #2
    a502:	1ad2      	subs	r2, r2, r3
    a504:	7062      	strb	r2, [r4, #1]
    a506:	2e04      	cmp	r6, #4
    a508:	d80f      	bhi.n	a52a <gapm_adv_report_evt_handler+0x82>
    a50a:	1c30      	adds	r0, r6, #0
    a50c:	f001 fc44 	bl	bd98 <__gnu_thumb1_case_uqi>
    a510:	09070503 	.word	0x09070503
    a514:	0b          	.byte	0x0b
    a515:	00          	.byte	0x00
    a516:	2300      	movs	r3, #0
    a518:	e006      	b.n	a528 <gapm_adv_report_evt_handler+0x80>
    a51a:	2301      	movs	r3, #1
    a51c:	e004      	b.n	a528 <gapm_adv_report_evt_handler+0x80>
    a51e:	2302      	movs	r3, #2
    a520:	e002      	b.n	a528 <gapm_adv_report_evt_handler+0x80>
    a522:	2303      	movs	r3, #3
    a524:	e000      	b.n	a528 <gapm_adv_report_evt_handler+0x80>
    a526:	2305      	movs	r3, #5
    a528:	7023      	strb	r3, [r4, #0]
    a52a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    a52c:	0000d7eb 	.word	0x0000d7eb

0000a530 <gapm_resolv_addr_cmd_handler>:
    a530:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a532:	4b2a      	ldr	r3, [pc, #168]	; (a5dc <gapm_resolv_addr_cmd_handler+0xac>)
    a534:	9201      	str	r2, [sp, #4]
    a536:	781b      	ldrb	r3, [r3, #0]
    a538:	1c06      	adds	r6, r0, #0
    a53a:	4a29      	ldr	r2, [pc, #164]	; (a5e0 <gapm_resolv_addr_cmd_handler+0xb0>)
    a53c:	2400      	movs	r4, #0
    a53e:	2b02      	cmp	r3, #2
    a540:	d107      	bne.n	a552 <gapm_resolv_addr_cmd_handler+0x22>
    a542:	2052      	movs	r0, #82	; 0x52
    a544:	6813      	ldr	r3, [r2, #0]
    a546:	3403      	adds	r4, #3
    a548:	7018      	strb	r0, [r3, #0]
    a54a:	3005      	adds	r0, #5
    a54c:	7058      	strb	r0, [r3, #1]
    a54e:	3836      	subs	r0, #54	; 0x36
    a550:	7098      	strb	r0, [r3, #2]
    a552:	2305      	movs	r3, #5
    a554:	6815      	ldr	r5, [r2, #0]
    a556:	2214      	movs	r2, #20
    a558:	552b      	strb	r3, [r5, r4]
    a55a:	1c63      	adds	r3, r4, #1
    a55c:	54ea      	strb	r2, [r5, r3]
    a55e:	230d      	movs	r3, #13
    a560:	1ca2      	adds	r2, r4, #2
    a562:	54ab      	strb	r3, [r5, r2]
    a564:	1ce2      	adds	r2, r4, #3
    a566:	54ab      	strb	r3, [r5, r2]
    a568:	2300      	movs	r3, #0
    a56a:	2010      	movs	r0, #16
    a56c:	1d22      	adds	r2, r4, #4
    a56e:	54ab      	strb	r3, [r5, r2]
    a570:	1d62      	adds	r2, r4, #5
    a572:	54a8      	strb	r0, [r5, r2]
    a574:	1da2      	adds	r2, r4, #6
    a576:	54ab      	strb	r3, [r5, r2]
    a578:	1de7      	adds	r7, r4, #7
    a57a:	3202      	adds	r2, #2
    a57c:	18aa      	adds	r2, r5, r2
    a57e:	19ef      	adds	r7, r5, r7
    a580:	703b      	strb	r3, [r7, #0]
    a582:	7013      	strb	r3, [r2, #0]
    a584:	1c23      	adds	r3, r4, #0
    a586:	9200      	str	r2, [sp, #0]
    a588:	1c20      	adds	r0, r4, #0
    a58a:	2217      	movs	r2, #23
    a58c:	3309      	adds	r3, #9
    a58e:	54ea      	strb	r2, [r5, r3]
    a590:	300b      	adds	r0, #11
    a592:	3301      	adds	r3, #1
    a594:	54ee      	strb	r6, [r5, r3]
    a596:	3a11      	subs	r2, #17
    a598:	4b12      	ldr	r3, [pc, #72]	; (a5e4 <gapm_resolv_addr_cmd_handler+0xb4>)
    a59a:	3411      	adds	r4, #17
    a59c:	0136      	lsls	r6, r6, #4
    a59e:	1828      	adds	r0, r5, r0
    a5a0:	4798      	blx	r3
    a5a2:	1928      	adds	r0, r5, r4
    a5a4:	9901      	ldr	r1, [sp, #4]
    a5a6:	4b0f      	ldr	r3, [pc, #60]	; (a5e4 <gapm_resolv_addr_cmd_handler+0xb4>)
    a5a8:	1c32      	adds	r2, r6, #0
    a5aa:	4798      	blx	r3
    a5ac:	4b0b      	ldr	r3, [pc, #44]	; (a5dc <gapm_resolv_addr_cmd_handler+0xac>)
    a5ae:	19a4      	adds	r4, r4, r6
    a5b0:	781b      	ldrb	r3, [r3, #0]
    a5b2:	b2a1      	uxth	r1, r4
    a5b4:	2b02      	cmp	r3, #2
    a5b6:	d102      	bne.n	a5be <gapm_resolv_addr_cmd_handler+0x8e>
    a5b8:	1c0b      	adds	r3, r1, #0
    a5ba:	3b0c      	subs	r3, #12
    a5bc:	e001      	b.n	a5c2 <gapm_resolv_addr_cmd_handler+0x92>
    a5be:	1c0b      	adds	r3, r1, #0
    a5c0:	3b09      	subs	r3, #9
    a5c2:	9a00      	ldr	r2, [sp, #0]
    a5c4:	703b      	strb	r3, [r7, #0]
    a5c6:	121b      	asrs	r3, r3, #8
    a5c8:	7013      	strb	r3, [r2, #0]
    a5ca:	1c28      	adds	r0, r5, #0
    a5cc:	4b06      	ldr	r3, [pc, #24]	; (a5e8 <gapm_resolv_addr_cmd_handler+0xb8>)
    a5ce:	4798      	blx	r3
    a5d0:	4b06      	ldr	r3, [pc, #24]	; (a5ec <gapm_resolv_addr_cmd_handler+0xbc>)
    a5d2:	4798      	blx	r3
    a5d4:	4b06      	ldr	r3, [pc, #24]	; (a5f0 <gapm_resolv_addr_cmd_handler+0xc0>)
    a5d6:	4798      	blx	r3
    a5d8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    a5da:	46c0      	nop			; (mov r8, r8)
    a5dc:	20000005 	.word	0x20000005
    a5e0:	00011148 	.word	0x00011148
    a5e4:	0000d7eb 	.word	0x0000d7eb
    a5e8:	00008a29 	.word	0x00008a29
    a5ec:	00008835 	.word	0x00008835
    a5f0:	00001895 	.word	0x00001895

0000a5f4 <gapm_addr_solved_ind_handler>:
    a5f4:	b570      	push	{r4, r5, r6, lr}
    a5f6:	1c04      	adds	r4, r0, #0
    a5f8:	1c08      	adds	r0, r1, #0
    a5fa:	1c0d      	adds	r5, r1, #0
    a5fc:	4e05      	ldr	r6, [pc, #20]	; (a614 <gapm_addr_solved_ind_handler+0x20>)
    a5fe:	1c21      	adds	r1, r4, #0
    a600:	2206      	movs	r2, #6
    a602:	3011      	adds	r0, #17
    a604:	47b0      	blx	r6
    a606:	1c68      	adds	r0, r5, #1
    a608:	1da1      	adds	r1, r4, #6
    a60a:	2210      	movs	r2, #16
    a60c:	47b0      	blx	r6
    a60e:	2300      	movs	r3, #0
    a610:	702b      	strb	r3, [r5, #0]
    a612:	bd70      	pop	{r4, r5, r6, pc}
    a614:	0000d7eb 	.word	0x0000d7eb

0000a618 <gapm_profile_added_ind_handler>:
    a618:	b510      	push	{r4, lr}
    a61a:	7843      	ldrb	r3, [r0, #1]
    a61c:	7902      	ldrb	r2, [r0, #4]
    a61e:	7944      	ldrb	r4, [r0, #5]
    a620:	7800      	ldrb	r0, [r0, #0]
    a622:	021b      	lsls	r3, r3, #8
    a624:	4303      	orrs	r3, r0
    a626:	2b1b      	cmp	r3, #27
    a628:	d104      	bne.n	a634 <gapm_profile_added_ind_handler+0x1c>
    a62a:	2300      	movs	r3, #0
    a62c:	700b      	strb	r3, [r1, #0]
    a62e:	0223      	lsls	r3, r4, #8
    a630:	4313      	orrs	r3, r2
    a632:	804b      	strh	r3, [r1, #2]
    a634:	203a      	movs	r0, #58	; 0x3a
    a636:	bd10      	pop	{r4, pc}

0000a638 <gattc_read_req_ind_parser>:
    a638:	7843      	ldrb	r3, [r0, #1]
    a63a:	7802      	ldrb	r2, [r0, #0]
    a63c:	021b      	lsls	r3, r3, #8
    a63e:	4313      	orrs	r3, r2
    a640:	804b      	strh	r3, [r1, #2]
    a642:	4770      	bx	lr

0000a644 <gattc_write_req_ind_parser>:
    a644:	b508      	push	{r3, lr}
    a646:	1c13      	adds	r3, r2, #0
    a648:	0a00      	lsrs	r0, r0, #8
    a64a:	8010      	strh	r0, [r2, #0]
    a64c:	784a      	ldrb	r2, [r1, #1]
    a64e:	7808      	ldrb	r0, [r1, #0]
    a650:	0212      	lsls	r2, r2, #8
    a652:	4302      	orrs	r2, r0
    a654:	805a      	strh	r2, [r3, #2]
    a656:	78ca      	ldrb	r2, [r1, #3]
    a658:	7888      	ldrb	r0, [r1, #2]
    a65a:	0212      	lsls	r2, r2, #8
    a65c:	4302      	orrs	r2, r0
    a65e:	809a      	strh	r2, [r3, #4]
    a660:	794a      	ldrb	r2, [r1, #5]
    a662:	7908      	ldrb	r0, [r1, #4]
    a664:	0212      	lsls	r2, r2, #8
    a666:	4302      	orrs	r2, r0
    a668:	80da      	strh	r2, [r3, #6]
    a66a:	3308      	adds	r3, #8
    a66c:	1c18      	adds	r0, r3, #0
    a66e:	3106      	adds	r1, #6
    a670:	4b01      	ldr	r3, [pc, #4]	; (a678 <gattc_write_req_ind_parser+0x34>)
    a672:	4798      	blx	r3
    a674:	bd08      	pop	{r3, pc}
    a676:	46c0      	nop			; (mov r8, r8)
    a678:	0000d7eb 	.word	0x0000d7eb

0000a67c <gattc_att_info_req_parser>:
    a67c:	7843      	ldrb	r3, [r0, #1]
    a67e:	7802      	ldrb	r2, [r0, #0]
    a680:	021b      	lsls	r3, r3, #8
    a682:	4313      	orrs	r3, r2
    a684:	800b      	strh	r3, [r1, #0]
    a686:	4770      	bx	lr

0000a688 <gattc_read_cfm>:
    a688:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a68a:	1c1d      	adds	r5, r3, #0
    a68c:	4b2c      	ldr	r3, [pc, #176]	; (a740 <gattc_read_cfm+0xb8>)
    a68e:	4c2d      	ldr	r4, [pc, #180]	; (a744 <gattc_read_cfm+0xbc>)
    a690:	781e      	ldrb	r6, [r3, #0]
    a692:	2300      	movs	r3, #0
    a694:	2e02      	cmp	r6, #2
    a696:	d107      	bne.n	a6a8 <gattc_read_cfm+0x20>
    a698:	6823      	ldr	r3, [r4, #0]
    a69a:	3650      	adds	r6, #80	; 0x50
    a69c:	701e      	strb	r6, [r3, #0]
    a69e:	3605      	adds	r6, #5
    a6a0:	705e      	strb	r6, [r3, #1]
    a6a2:	3e36      	subs	r6, #54	; 0x36
    a6a4:	709e      	strb	r6, [r3, #2]
    a6a6:	2303      	movs	r3, #3
    a6a8:	2605      	movs	r6, #5
    a6aa:	2714      	movs	r7, #20
    a6ac:	6824      	ldr	r4, [r4, #0]
    a6ae:	54e6      	strb	r6, [r4, r3]
    a6b0:	1c5e      	adds	r6, r3, #1
    a6b2:	55a7      	strb	r7, [r4, r6]
    a6b4:	3f08      	subs	r7, #8
    a6b6:	1c9e      	adds	r6, r3, #2
    a6b8:	55a7      	strb	r7, [r4, r6]
    a6ba:	1cde      	adds	r6, r3, #3
    a6bc:	55a7      	strb	r7, [r4, r6]
    a6be:	1d1e      	adds	r6, r3, #4
    a6c0:	55a1      	strb	r1, [r4, r6]
    a6c2:	2610      	movs	r6, #16
    a6c4:	1d59      	adds	r1, r3, #5
    a6c6:	5466      	strb	r6, [r4, r1]
    a6c8:	1c1f      	adds	r7, r3, #0
    a6ca:	2100      	movs	r1, #0
    a6cc:	1d9e      	adds	r6, r3, #6
    a6ce:	55a1      	strb	r1, [r4, r6]
    a6d0:	3708      	adds	r7, #8
    a6d2:	1dde      	adds	r6, r3, #7
    a6d4:	19e7      	adds	r7, r4, r7
    a6d6:	19a6      	adds	r6, r4, r6
    a6d8:	7031      	strb	r1, [r6, #0]
    a6da:	7039      	strb	r1, [r7, #0]
    a6dc:	1c19      	adds	r1, r3, #0
    a6de:	9701      	str	r7, [sp, #4]
    a6e0:	1c1f      	adds	r7, r3, #0
    a6e2:	3109      	adds	r1, #9
    a6e4:	5460      	strb	r0, [r4, r1]
    a6e6:	0a00      	lsrs	r0, r0, #8
    a6e8:	3101      	adds	r1, #1
    a6ea:	5460      	strb	r0, [r4, r1]
    a6ec:	3101      	adds	r1, #1
    a6ee:	5465      	strb	r5, [r4, r1]
    a6f0:	0a28      	lsrs	r0, r5, #8
    a6f2:	3101      	adds	r1, #1
    a6f4:	5460      	strb	r0, [r4, r1]
    a6f6:	3101      	adds	r1, #1
    a6f8:	370e      	adds	r7, #14
    a6fa:	5462      	strb	r2, [r4, r1]
    a6fc:	2d00      	cmp	r5, #0
    a6fe:	d007      	beq.n	a710 <gattc_read_cfm+0x88>
    a700:	9908      	ldr	r1, [sp, #32]
    a702:	1c2a      	adds	r2, r5, #0
    a704:	19e0      	adds	r0, r4, r7
    a706:	4b10      	ldr	r3, [pc, #64]	; (a748 <gattc_read_cfm+0xc0>)
    a708:	197d      	adds	r5, r7, r5
    a70a:	4798      	blx	r3
    a70c:	b2a9      	uxth	r1, r5
    a70e:	e002      	b.n	a716 <gattc_read_cfm+0x8e>
    a710:	330f      	adds	r3, #15
    a712:	1c19      	adds	r1, r3, #0
    a714:	55e5      	strb	r5, [r4, r7]
    a716:	4b0a      	ldr	r3, [pc, #40]	; (a740 <gattc_read_cfm+0xb8>)
    a718:	781b      	ldrb	r3, [r3, #0]
    a71a:	2b02      	cmp	r3, #2
    a71c:	d102      	bne.n	a724 <gattc_read_cfm+0x9c>
    a71e:	1c0b      	adds	r3, r1, #0
    a720:	3b0c      	subs	r3, #12
    a722:	e001      	b.n	a728 <gattc_read_cfm+0xa0>
    a724:	1c0b      	adds	r3, r1, #0
    a726:	3b09      	subs	r3, #9
    a728:	9a01      	ldr	r2, [sp, #4]
    a72a:	7033      	strb	r3, [r6, #0]
    a72c:	121b      	asrs	r3, r3, #8
    a72e:	7013      	strb	r3, [r2, #0]
    a730:	1c20      	adds	r0, r4, #0
    a732:	4b06      	ldr	r3, [pc, #24]	; (a74c <gattc_read_cfm+0xc4>)
    a734:	4798      	blx	r3
    a736:	4b06      	ldr	r3, [pc, #24]	; (a750 <gattc_read_cfm+0xc8>)
    a738:	4798      	blx	r3
    a73a:	4b06      	ldr	r3, [pc, #24]	; (a754 <gattc_read_cfm+0xcc>)
    a73c:	4798      	blx	r3
    a73e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    a740:	20000005 	.word	0x20000005
    a744:	00011148 	.word	0x00011148
    a748:	0000d7eb 	.word	0x0000d7eb
    a74c:	00008a29 	.word	0x00008a29
    a750:	00008835 	.word	0x00008835
    a754:	00001895 	.word	0x00001895

0000a758 <gattc_write_cfm>:
    a758:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a75a:	4694      	mov	ip, r2
    a75c:	4a21      	ldr	r2, [pc, #132]	; (a7e4 <gattc_write_cfm+0x8c>)
    a75e:	4c22      	ldr	r4, [pc, #136]	; (a7e8 <gattc_write_cfm+0x90>)
    a760:	7815      	ldrb	r5, [r2, #0]
    a762:	2300      	movs	r3, #0
    a764:	2d02      	cmp	r5, #2
    a766:	d107      	bne.n	a778 <gattc_write_cfm+0x20>
    a768:	6823      	ldr	r3, [r4, #0]
    a76a:	3550      	adds	r5, #80	; 0x50
    a76c:	701d      	strb	r5, [r3, #0]
    a76e:	3505      	adds	r5, #5
    a770:	705d      	strb	r5, [r3, #1]
    a772:	3d36      	subs	r5, #54	; 0x36
    a774:	709d      	strb	r5, [r3, #2]
    a776:	2303      	movs	r3, #3
    a778:	2505      	movs	r5, #5
    a77a:	2616      	movs	r6, #22
    a77c:	6824      	ldr	r4, [r4, #0]
    a77e:	1ddf      	adds	r7, r3, #7
    a780:	54e5      	strb	r5, [r4, r3]
    a782:	1c5d      	adds	r5, r3, #1
    a784:	5566      	strb	r6, [r4, r5]
    a786:	250c      	movs	r5, #12
    a788:	1c9e      	adds	r6, r3, #2
    a78a:	55a5      	strb	r5, [r4, r6]
    a78c:	1cde      	adds	r6, r3, #3
    a78e:	55a5      	strb	r5, [r4, r6]
    a790:	1d1d      	adds	r5, r3, #4
    a792:	5561      	strb	r1, [r4, r5]
    a794:	2510      	movs	r5, #16
    a796:	1d59      	adds	r1, r3, #5
    a798:	5465      	strb	r5, [r4, r1]
    a79a:	1c1d      	adds	r5, r3, #0
    a79c:	2600      	movs	r6, #0
    a79e:	1d99      	adds	r1, r3, #6
    a7a0:	3508      	adds	r5, #8
    a7a2:	5466      	strb	r6, [r4, r1]
    a7a4:	19e7      	adds	r7, r4, r7
    a7a6:	3103      	adds	r1, #3
    a7a8:	1965      	adds	r5, r4, r5
    a7aa:	703e      	strb	r6, [r7, #0]
    a7ac:	702e      	strb	r6, [r5, #0]
    a7ae:	5460      	strb	r0, [r4, r1]
    a7b0:	3101      	adds	r1, #1
    a7b2:	0a00      	lsrs	r0, r0, #8
    a7b4:	5460      	strb	r0, [r4, r1]
    a7b6:	4660      	mov	r0, ip
    a7b8:	330b      	adds	r3, #11
    a7ba:	54e0      	strb	r0, [r4, r3]
    a7bc:	7813      	ldrb	r3, [r2, #0]
    a7be:	3102      	adds	r1, #2
    a7c0:	2b02      	cmp	r3, #2
    a7c2:	d102      	bne.n	a7ca <gattc_write_cfm+0x72>
    a7c4:	1c0b      	adds	r3, r1, #0
    a7c6:	3b0c      	subs	r3, #12
    a7c8:	e001      	b.n	a7ce <gattc_write_cfm+0x76>
    a7ca:	1c0b      	adds	r3, r1, #0
    a7cc:	3b09      	subs	r3, #9
    a7ce:	703b      	strb	r3, [r7, #0]
    a7d0:	1c20      	adds	r0, r4, #0
    a7d2:	702e      	strb	r6, [r5, #0]
    a7d4:	4b05      	ldr	r3, [pc, #20]	; (a7ec <gattc_write_cfm+0x94>)
    a7d6:	4798      	blx	r3
    a7d8:	4b05      	ldr	r3, [pc, #20]	; (a7f0 <gattc_write_cfm+0x98>)
    a7da:	4798      	blx	r3
    a7dc:	4b05      	ldr	r3, [pc, #20]	; (a7f4 <gattc_write_cfm+0x9c>)
    a7de:	4798      	blx	r3
    a7e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a7e2:	46c0      	nop			; (mov r8, r8)
    a7e4:	20000005 	.word	0x20000005
    a7e8:	00011148 	.word	0x00011148
    a7ec:	00008a29 	.word	0x00008a29
    a7f0:	00008835 	.word	0x00008835
    a7f4:	00001895 	.word	0x00001895

0000a7f8 <gattc_att_info_cfm>:
    a7f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a7fa:	469c      	mov	ip, r3
    a7fc:	4b24      	ldr	r3, [pc, #144]	; (a890 <gattc_att_info_cfm+0x98>)
    a7fe:	4d25      	ldr	r5, [pc, #148]	; (a894 <gattc_att_info_cfm+0x9c>)
    a800:	781b      	ldrb	r3, [r3, #0]
    a802:	2400      	movs	r4, #0
    a804:	2b02      	cmp	r3, #2
    a806:	d107      	bne.n	a818 <gattc_att_info_cfm+0x20>
    a808:	682b      	ldr	r3, [r5, #0]
    a80a:	3452      	adds	r4, #82	; 0x52
    a80c:	701c      	strb	r4, [r3, #0]
    a80e:	3405      	adds	r4, #5
    a810:	705c      	strb	r4, [r3, #1]
    a812:	3c36      	subs	r4, #54	; 0x36
    a814:	709c      	strb	r4, [r3, #2]
    a816:	3c1e      	subs	r4, #30
    a818:	2305      	movs	r3, #5
    a81a:	2618      	movs	r6, #24
    a81c:	682d      	ldr	r5, [r5, #0]
    a81e:	2700      	movs	r7, #0
    a820:	552b      	strb	r3, [r5, r4]
    a822:	1c63      	adds	r3, r4, #1
    a824:	54ee      	strb	r6, [r5, r3]
    a826:	230c      	movs	r3, #12
    a828:	1ca6      	adds	r6, r4, #2
    a82a:	55ab      	strb	r3, [r5, r6]
    a82c:	1ce6      	adds	r6, r4, #3
    a82e:	55ab      	strb	r3, [r5, r6]
    a830:	1d23      	adds	r3, r4, #4
    a832:	54e9      	strb	r1, [r5, r3]
    a834:	2110      	movs	r1, #16
    a836:	1d63      	adds	r3, r4, #5
    a838:	54e9      	strb	r1, [r5, r3]
    a83a:	1c21      	adds	r1, r4, #0
    a83c:	1da3      	adds	r3, r4, #6
    a83e:	54ef      	strb	r7, [r5, r3]
    a840:	3605      	adds	r6, #5
    a842:	1de3      	adds	r3, r4, #7
    a844:	3109      	adds	r1, #9
    a846:	18eb      	adds	r3, r5, r3
    a848:	19ae      	adds	r6, r5, r6
    a84a:	701f      	strb	r7, [r3, #0]
    a84c:	7037      	strb	r7, [r6, #0]
    a84e:	5468      	strb	r0, [r5, r1]
    a850:	3101      	adds	r1, #1
    a852:	0a00      	lsrs	r0, r0, #8
    a854:	5468      	strb	r0, [r5, r1]
    a856:	3101      	adds	r1, #1
    a858:	546a      	strb	r2, [r5, r1]
    a85a:	3101      	adds	r1, #1
    a85c:	0a12      	lsrs	r2, r2, #8
    a85e:	546a      	strb	r2, [r5, r1]
    a860:	4662      	mov	r2, ip
    a862:	340d      	adds	r4, #13
    a864:	552a      	strb	r2, [r5, r4]
    a866:	4a0a      	ldr	r2, [pc, #40]	; (a890 <gattc_att_info_cfm+0x98>)
    a868:	3102      	adds	r1, #2
    a86a:	7812      	ldrb	r2, [r2, #0]
    a86c:	2a02      	cmp	r2, #2
    a86e:	d102      	bne.n	a876 <gattc_att_info_cfm+0x7e>
    a870:	1c0a      	adds	r2, r1, #0
    a872:	3a0c      	subs	r2, #12
    a874:	e001      	b.n	a87a <gattc_att_info_cfm+0x82>
    a876:	1c0a      	adds	r2, r1, #0
    a878:	3a09      	subs	r2, #9
    a87a:	701a      	strb	r2, [r3, #0]
    a87c:	1c28      	adds	r0, r5, #0
    a87e:	7037      	strb	r7, [r6, #0]
    a880:	4b05      	ldr	r3, [pc, #20]	; (a898 <gattc_att_info_cfm+0xa0>)
    a882:	4798      	blx	r3
    a884:	4b05      	ldr	r3, [pc, #20]	; (a89c <gattc_att_info_cfm+0xa4>)
    a886:	4798      	blx	r3
    a888:	4b05      	ldr	r3, [pc, #20]	; (a8a0 <gattc_att_info_cfm+0xa8>)
    a88a:	4798      	blx	r3
    a88c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a88e:	46c0      	nop			; (mov r8, r8)
    a890:	20000005 	.word	0x20000005
    a894:	00011148 	.word	0x00011148
    a898:	00008a29 	.word	0x00008a29
    a89c:	00008835 	.word	0x00008835
    a8a0:	00001895 	.word	0x00001895

0000a8a4 <gattc_send_evt_cmd_handler>:
    a8a4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a8a6:	9301      	str	r3, [sp, #4]
    a8a8:	ab08      	add	r3, sp, #32
    a8aa:	881d      	ldrh	r5, [r3, #0]
    a8ac:	4b30      	ldr	r3, [pc, #192]	; (a970 <gattc_send_evt_cmd_handler+0xcc>)
    a8ae:	468c      	mov	ip, r1
    a8b0:	781c      	ldrb	r4, [r3, #0]
    a8b2:	4930      	ldr	r1, [pc, #192]	; (a974 <gattc_send_evt_cmd_handler+0xd0>)
    a8b4:	2300      	movs	r3, #0
    a8b6:	2c02      	cmp	r4, #2
    a8b8:	d107      	bne.n	a8ca <gattc_send_evt_cmd_handler+0x26>
    a8ba:	680b      	ldr	r3, [r1, #0]
    a8bc:	3450      	adds	r4, #80	; 0x50
    a8be:	701c      	strb	r4, [r3, #0]
    a8c0:	3405      	adds	r4, #5
    a8c2:	705c      	strb	r4, [r3, #1]
    a8c4:	3c36      	subs	r4, #54	; 0x36
    a8c6:	709c      	strb	r4, [r3, #2]
    a8c8:	2303      	movs	r3, #3
    a8ca:	680c      	ldr	r4, [r1, #0]
    a8cc:	2105      	movs	r1, #5
    a8ce:	1c5e      	adds	r6, r3, #1
    a8d0:	54e1      	strb	r1, [r4, r3]
    a8d2:	310b      	adds	r1, #11
    a8d4:	55a1      	strb	r1, [r4, r6]
    a8d6:	260c      	movs	r6, #12
    a8d8:	1c9f      	adds	r7, r3, #2
    a8da:	55e6      	strb	r6, [r4, r7]
    a8dc:	1cdf      	adds	r7, r3, #3
    a8de:	55e6      	strb	r6, [r4, r7]
    a8e0:	1d1e      	adds	r6, r3, #4
    a8e2:	55a2      	strb	r2, [r4, r6]
    a8e4:	1d5a      	adds	r2, r3, #5
    a8e6:	54a1      	strb	r1, [r4, r2]
    a8e8:	2200      	movs	r2, #0
    a8ea:	1d99      	adds	r1, r3, #6
    a8ec:	5462      	strb	r2, [r4, r1]
    a8ee:	1dde      	adds	r6, r3, #7
    a8f0:	3102      	adds	r1, #2
    a8f2:	1861      	adds	r1, r4, r1
    a8f4:	19a6      	adds	r6, r4, r6
    a8f6:	7032      	strb	r2, [r6, #0]
    a8f8:	9100      	str	r1, [sp, #0]
    a8fa:	700a      	strb	r2, [r1, #0]
    a8fc:	1c19      	adds	r1, r3, #0
    a8fe:	3109      	adds	r1, #9
    a900:	5460      	strb	r0, [r4, r1]
    a902:	481d      	ldr	r0, [pc, #116]	; (a978 <gattc_send_evt_cmd_handler+0xd4>)
    a904:	3707      	adds	r7, #7
    a906:	8801      	ldrh	r1, [r0, #0]
    a908:	3101      	adds	r1, #1
    a90a:	55e1      	strb	r1, [r4, r7]
    a90c:	1c19      	adds	r1, r3, #0
    a90e:	8800      	ldrh	r0, [r0, #0]
    a910:	310b      	adds	r1, #11
    a912:	3001      	adds	r0, #1
    a914:	1200      	asrs	r0, r0, #8
    a916:	5460      	strb	r0, [r4, r1]
    a918:	3101      	adds	r1, #1
    a91a:	5462      	strb	r2, [r4, r1]
    a91c:	1c1a      	adds	r2, r3, #0
    a91e:	4661      	mov	r1, ip
    a920:	320d      	adds	r2, #13
    a922:	54a1      	strb	r1, [r4, r2]
    a924:	4661      	mov	r1, ip
    a926:	3201      	adds	r2, #1
    a928:	0a09      	lsrs	r1, r1, #8
    a92a:	54a1      	strb	r1, [r4, r2]
    a92c:	3201      	adds	r2, #1
    a92e:	54a5      	strb	r5, [r4, r2]
    a930:	3707      	adds	r7, #7
    a932:	0a2a      	lsrs	r2, r5, #8
    a934:	3310      	adds	r3, #16
    a936:	54e2      	strb	r2, [r4, r3]
    a938:	9901      	ldr	r1, [sp, #4]
    a93a:	1c2a      	adds	r2, r5, #0
    a93c:	4b0f      	ldr	r3, [pc, #60]	; (a97c <gattc_send_evt_cmd_handler+0xd8>)
    a93e:	19e0      	adds	r0, r4, r7
    a940:	4798      	blx	r3
    a942:	4b0b      	ldr	r3, [pc, #44]	; (a970 <gattc_send_evt_cmd_handler+0xcc>)
    a944:	197d      	adds	r5, r7, r5
    a946:	781b      	ldrb	r3, [r3, #0]
    a948:	b2a9      	uxth	r1, r5
    a94a:	2b02      	cmp	r3, #2
    a94c:	d102      	bne.n	a954 <gattc_send_evt_cmd_handler+0xb0>
    a94e:	1c0b      	adds	r3, r1, #0
    a950:	3b0c      	subs	r3, #12
    a952:	e001      	b.n	a958 <gattc_send_evt_cmd_handler+0xb4>
    a954:	1c0b      	adds	r3, r1, #0
    a956:	3b09      	subs	r3, #9
    a958:	9a00      	ldr	r2, [sp, #0]
    a95a:	7033      	strb	r3, [r6, #0]
    a95c:	121b      	asrs	r3, r3, #8
    a95e:	7013      	strb	r3, [r2, #0]
    a960:	1c20      	adds	r0, r4, #0
    a962:	4b07      	ldr	r3, [pc, #28]	; (a980 <gattc_send_evt_cmd_handler+0xdc>)
    a964:	4798      	blx	r3
    a966:	4b07      	ldr	r3, [pc, #28]	; (a984 <gattc_send_evt_cmd_handler+0xe0>)
    a968:	4798      	blx	r3
    a96a:	4b07      	ldr	r3, [pc, #28]	; (a988 <gattc_send_evt_cmd_handler+0xe4>)
    a96c:	4798      	blx	r3
    a96e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    a970:	20000005 	.word	0x20000005
    a974:	00011148 	.word	0x00011148
    a978:	20000696 	.word	0x20000696
    a97c:	0000d7eb 	.word	0x0000d7eb
    a980:	00008a29 	.word	0x00008a29
    a984:	00008835 	.word	0x00008835
    a988:	00001895 	.word	0x00001895

0000a98c <gattc_event_cfm_handler>:
    a98c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a98e:	4f22      	ldr	r7, [pc, #136]	; (aa18 <gattc_event_cfm_handler+0x8c>)
    a990:	4a22      	ldr	r2, [pc, #136]	; (aa1c <gattc_event_cfm_handler+0x90>)
    a992:	783c      	ldrb	r4, [r7, #0]
    a994:	2300      	movs	r3, #0
    a996:	2c02      	cmp	r4, #2
    a998:	d107      	bne.n	a9aa <gattc_event_cfm_handler+0x1e>
    a99a:	6813      	ldr	r3, [r2, #0]
    a99c:	3450      	adds	r4, #80	; 0x50
    a99e:	701c      	strb	r4, [r3, #0]
    a9a0:	3405      	adds	r4, #5
    a9a2:	705c      	strb	r4, [r3, #1]
    a9a4:	3c36      	subs	r4, #54	; 0x36
    a9a6:	709c      	strb	r4, [r3, #2]
    a9a8:	2303      	movs	r3, #3
    a9aa:	2405      	movs	r4, #5
    a9ac:	250e      	movs	r5, #14
    a9ae:	6812      	ldr	r2, [r2, #0]
    a9b0:	1c1e      	adds	r6, r3, #0
    a9b2:	54d4      	strb	r4, [r2, r3]
    a9b4:	1c5c      	adds	r4, r3, #1
    a9b6:	5515      	strb	r5, [r2, r4]
    a9b8:	240c      	movs	r4, #12
    a9ba:	1c9d      	adds	r5, r3, #2
    a9bc:	5554      	strb	r4, [r2, r5]
    a9be:	1cdd      	adds	r5, r3, #3
    a9c0:	5554      	strb	r4, [r2, r5]
    a9c2:	1d1c      	adds	r4, r3, #4
    a9c4:	5510      	strb	r0, [r2, r4]
    a9c6:	2410      	movs	r4, #16
    a9c8:	2500      	movs	r5, #0
    a9ca:	1d58      	adds	r0, r3, #5
    a9cc:	5414      	strb	r4, [r2, r0]
    a9ce:	1d98      	adds	r0, r3, #6
    a9d0:	5415      	strb	r5, [r2, r0]
    a9d2:	1ddc      	adds	r4, r3, #7
    a9d4:	3002      	adds	r0, #2
    a9d6:	3609      	adds	r6, #9
    a9d8:	1914      	adds	r4, r2, r4
    a9da:	1810      	adds	r0, r2, r0
    a9dc:	7025      	strb	r5, [r4, #0]
    a9de:	330a      	adds	r3, #10
    a9e0:	7005      	strb	r5, [r0, #0]
    a9e2:	5591      	strb	r1, [r2, r6]
    a9e4:	0a09      	lsrs	r1, r1, #8
    a9e6:	54d1      	strb	r1, [r2, r3]
    a9e8:	783b      	ldrb	r3, [r7, #0]
    a9ea:	3602      	adds	r6, #2
    a9ec:	2b02      	cmp	r3, #2
    a9ee:	d105      	bne.n	a9fc <gattc_event_cfm_handler+0x70>
    a9f0:	1c33      	adds	r3, r6, #0
    a9f2:	3b0c      	subs	r3, #12
    a9f4:	7023      	strb	r3, [r4, #0]
    a9f6:	121b      	asrs	r3, r3, #8
    a9f8:	7003      	strb	r3, [r0, #0]
    a9fa:	e003      	b.n	aa04 <gattc_event_cfm_handler+0x78>
    a9fc:	1c33      	adds	r3, r6, #0
    a9fe:	3b09      	subs	r3, #9
    aa00:	7023      	strb	r3, [r4, #0]
    aa02:	7005      	strb	r5, [r0, #0]
    aa04:	1c31      	adds	r1, r6, #0
    aa06:	1c10      	adds	r0, r2, #0
    aa08:	4b05      	ldr	r3, [pc, #20]	; (aa20 <gattc_event_cfm_handler+0x94>)
    aa0a:	4798      	blx	r3
    aa0c:	4b05      	ldr	r3, [pc, #20]	; (aa24 <gattc_event_cfm_handler+0x98>)
    aa0e:	4798      	blx	r3
    aa10:	4b05      	ldr	r3, [pc, #20]	; (aa28 <gattc_event_cfm_handler+0x9c>)
    aa12:	4798      	blx	r3
    aa14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aa16:	46c0      	nop			; (mov r8, r8)
    aa18:	20000005 	.word	0x20000005
    aa1c:	00011148 	.word	0x00011148
    aa20:	00008a29 	.word	0x00008a29
    aa24:	00008835 	.word	0x00008835
    aa28:	00001895 	.word	0x00001895

0000aa2c <gattc_disc_svc_ind_parser>:
    aa2c:	b570      	push	{r4, r5, r6, lr}
    aa2e:	1c15      	adds	r5, r2, #0
    aa30:	0a00      	lsrs	r0, r0, #8
    aa32:	8010      	strh	r0, [r2, #0]
    aa34:	784b      	ldrb	r3, [r1, #1]
    aa36:	780a      	ldrb	r2, [r1, #0]
    aa38:	021b      	lsls	r3, r3, #8
    aa3a:	4313      	orrs	r3, r2
    aa3c:	806b      	strh	r3, [r5, #2]
    aa3e:	78cb      	ldrb	r3, [r1, #3]
    aa40:	788a      	ldrb	r2, [r1, #2]
    aa42:	021b      	lsls	r3, r3, #8
    aa44:	4313      	orrs	r3, r2
    aa46:	80ab      	strh	r3, [r5, #4]
    aa48:	790e      	ldrb	r6, [r1, #4]
    aa4a:	4b05      	ldr	r3, [pc, #20]	; (aa60 <gattc_disc_svc_ind_parser+0x34>)
    aa4c:	1c30      	adds	r0, r6, #0
    aa4e:	1c0c      	adds	r4, r1, #0
    aa50:	4798      	blx	r3
    aa52:	1c32      	adds	r2, r6, #0
    aa54:	71a8      	strb	r0, [r5, #6]
    aa56:	1d61      	adds	r1, r4, #5
    aa58:	1de8      	adds	r0, r5, #7
    aa5a:	4b02      	ldr	r3, [pc, #8]	; (aa64 <gattc_disc_svc_ind_parser+0x38>)
    aa5c:	4798      	blx	r3
    aa5e:	bd70      	pop	{r4, r5, r6, pc}
    aa60:	000077f1 	.word	0x000077f1
    aa64:	0000d7eb 	.word	0x0000d7eb

0000aa68 <gattc_disc_svc_incl_ind_parser>:
    aa68:	b570      	push	{r4, r5, r6, lr}
    aa6a:	1c15      	adds	r5, r2, #0
    aa6c:	0a00      	lsrs	r0, r0, #8
    aa6e:	8010      	strh	r0, [r2, #0]
    aa70:	784b      	ldrb	r3, [r1, #1]
    aa72:	780a      	ldrb	r2, [r1, #0]
    aa74:	021b      	lsls	r3, r3, #8
    aa76:	4313      	orrs	r3, r2
    aa78:	806b      	strh	r3, [r5, #2]
    aa7a:	78cb      	ldrb	r3, [r1, #3]
    aa7c:	788a      	ldrb	r2, [r1, #2]
    aa7e:	021b      	lsls	r3, r3, #8
    aa80:	4313      	orrs	r3, r2
    aa82:	80ab      	strh	r3, [r5, #4]
    aa84:	794b      	ldrb	r3, [r1, #5]
    aa86:	790a      	ldrb	r2, [r1, #4]
    aa88:	021b      	lsls	r3, r3, #8
    aa8a:	4313      	orrs	r3, r2
    aa8c:	80eb      	strh	r3, [r5, #6]
    aa8e:	798e      	ldrb	r6, [r1, #6]
    aa90:	4b05      	ldr	r3, [pc, #20]	; (aaa8 <gattc_disc_svc_incl_ind_parser+0x40>)
    aa92:	1c30      	adds	r0, r6, #0
    aa94:	1c0c      	adds	r4, r1, #0
    aa96:	4798      	blx	r3
    aa98:	7228      	strb	r0, [r5, #8]
    aa9a:	1c28      	adds	r0, r5, #0
    aa9c:	1c32      	adds	r2, r6, #0
    aa9e:	1de1      	adds	r1, r4, #7
    aaa0:	4b02      	ldr	r3, [pc, #8]	; (aaac <gattc_disc_svc_incl_ind_parser+0x44>)
    aaa2:	3009      	adds	r0, #9
    aaa4:	4798      	blx	r3
    aaa6:	bd70      	pop	{r4, r5, r6, pc}
    aaa8:	000077f1 	.word	0x000077f1
    aaac:	0000d7eb 	.word	0x0000d7eb

0000aab0 <gattc_disc_char_ind_parser>:
    aab0:	b570      	push	{r4, r5, r6, lr}
    aab2:	1c15      	adds	r5, r2, #0
    aab4:	0a00      	lsrs	r0, r0, #8
    aab6:	8010      	strh	r0, [r2, #0]
    aab8:	784b      	ldrb	r3, [r1, #1]
    aaba:	780a      	ldrb	r2, [r1, #0]
    aabc:	021b      	lsls	r3, r3, #8
    aabe:	4313      	orrs	r3, r2
    aac0:	806b      	strh	r3, [r5, #2]
    aac2:	78cb      	ldrb	r3, [r1, #3]
    aac4:	788a      	ldrb	r2, [r1, #2]
    aac6:	021b      	lsls	r3, r3, #8
    aac8:	4313      	orrs	r3, r2
    aaca:	80ab      	strh	r3, [r5, #4]
    aacc:	790b      	ldrb	r3, [r1, #4]
    aace:	1c0c      	adds	r4, r1, #0
    aad0:	71ab      	strb	r3, [r5, #6]
    aad2:	794e      	ldrb	r6, [r1, #5]
    aad4:	4b05      	ldr	r3, [pc, #20]	; (aaec <gattc_disc_char_ind_parser+0x3c>)
    aad6:	1c30      	adds	r0, r6, #0
    aad8:	4798      	blx	r3
    aada:	71e8      	strb	r0, [r5, #7]
    aadc:	1c28      	adds	r0, r5, #0
    aade:	1c32      	adds	r2, r6, #0
    aae0:	1da1      	adds	r1, r4, #6
    aae2:	4b03      	ldr	r3, [pc, #12]	; (aaf0 <gattc_disc_char_ind_parser+0x40>)
    aae4:	3008      	adds	r0, #8
    aae6:	4798      	blx	r3
    aae8:	bd70      	pop	{r4, r5, r6, pc}
    aaea:	46c0      	nop			; (mov r8, r8)
    aaec:	000077f1 	.word	0x000077f1
    aaf0:	0000d7eb 	.word	0x0000d7eb

0000aaf4 <gattc_disc_char_desc_ind_parser>:
    aaf4:	b570      	push	{r4, r5, r6, lr}
    aaf6:	1c15      	adds	r5, r2, #0
    aaf8:	0a00      	lsrs	r0, r0, #8
    aafa:	8010      	strh	r0, [r2, #0]
    aafc:	784b      	ldrb	r3, [r1, #1]
    aafe:	780a      	ldrb	r2, [r1, #0]
    ab00:	021b      	lsls	r3, r3, #8
    ab02:	4313      	orrs	r3, r2
    ab04:	806b      	strh	r3, [r5, #2]
    ab06:	788e      	ldrb	r6, [r1, #2]
    ab08:	4b05      	ldr	r3, [pc, #20]	; (ab20 <gattc_disc_char_desc_ind_parser+0x2c>)
    ab0a:	1c30      	adds	r0, r6, #0
    ab0c:	1c0c      	adds	r4, r1, #0
    ab0e:	4798      	blx	r3
    ab10:	1c32      	adds	r2, r6, #0
    ab12:	7128      	strb	r0, [r5, #4]
    ab14:	1ce1      	adds	r1, r4, #3
    ab16:	1d68      	adds	r0, r5, #5
    ab18:	4b02      	ldr	r3, [pc, #8]	; (ab24 <gattc_disc_char_desc_ind_parser+0x30>)
    ab1a:	4798      	blx	r3
    ab1c:	bd70      	pop	{r4, r5, r6, pc}
    ab1e:	46c0      	nop			; (mov r8, r8)
    ab20:	000077f1 	.word	0x000077f1
    ab24:	0000d7eb 	.word	0x0000d7eb

0000ab28 <gattc_event_ind_and_notification_parser>:
    ab28:	b510      	push	{r4, lr}
    ab2a:	780c      	ldrb	r4, [r1, #0]
    ab2c:	1c13      	adds	r3, r2, #0
    ab2e:	2c12      	cmp	r4, #18
    ab30:	d10e      	bne.n	ab50 <gattc_event_ind_and_notification_parser+0x28>
    ab32:	0a00      	lsrs	r0, r0, #8
    ab34:	8010      	strh	r0, [r2, #0]
    ab36:	788a      	ldrb	r2, [r1, #2]
    ab38:	709a      	strb	r2, [r3, #2]
    ab3a:	7948      	ldrb	r0, [r1, #5]
    ab3c:	790c      	ldrb	r4, [r1, #4]
    ab3e:	0200      	lsls	r0, r0, #8
    ab40:	4320      	orrs	r0, r4
    ab42:	8098      	strh	r0, [r3, #4]
    ab44:	3106      	adds	r1, #6
    ab46:	1d98      	adds	r0, r3, #6
    ab48:	4b0b      	ldr	r3, [pc, #44]	; (ab78 <gattc_event_ind_and_notification_parser+0x50>)
    ab4a:	4798      	blx	r3
    ab4c:	221b      	movs	r2, #27
    ab4e:	e010      	b.n	ab72 <gattc_event_ind_and_notification_parser+0x4a>
    ab50:	2200      	movs	r2, #0
    ab52:	2c13      	cmp	r4, #19
    ab54:	d10d      	bne.n	ab72 <gattc_event_ind_and_notification_parser+0x4a>
    ab56:	0a00      	lsrs	r0, r0, #8
    ab58:	8018      	strh	r0, [r3, #0]
    ab5a:	788a      	ldrb	r2, [r1, #2]
    ab5c:	709a      	strb	r2, [r3, #2]
    ab5e:	7908      	ldrb	r0, [r1, #4]
    ab60:	78cc      	ldrb	r4, [r1, #3]
    ab62:	0200      	lsls	r0, r0, #8
    ab64:	4320      	orrs	r0, r4
    ab66:	8098      	strh	r0, [r3, #4]
    ab68:	3106      	adds	r1, #6
    ab6a:	1d98      	adds	r0, r3, #6
    ab6c:	4b02      	ldr	r3, [pc, #8]	; (ab78 <gattc_event_ind_and_notification_parser+0x50>)
    ab6e:	4798      	blx	r3
    ab70:	221c      	movs	r2, #28
    ab72:	1c10      	adds	r0, r2, #0
    ab74:	bd10      	pop	{r4, pc}
    ab76:	46c0      	nop			; (mov r8, r8)
    ab78:	0000d7eb 	.word	0x0000d7eb

0000ab7c <gattc_complete_evt_handler>:
    ab7c:	b570      	push	{r4, r5, r6, lr}
    ab7e:	1c14      	adds	r4, r2, #0
    ab80:	0a00      	lsrs	r0, r0, #8
    ab82:	8010      	strh	r0, [r2, #0]
    ab84:	7808      	ldrb	r0, [r1, #0]
    ab86:	7090      	strb	r0, [r2, #2]
    ab88:	78cb      	ldrb	r3, [r1, #3]
    ab8a:	784a      	ldrb	r2, [r1, #1]
    ab8c:	7889      	ldrb	r1, [r1, #2]
    ab8e:	021b      	lsls	r3, r3, #8
    ab90:	430b      	orrs	r3, r1
    ab92:	4926      	ldr	r1, [pc, #152]	; (ac2c <gattc_complete_evt_handler+0xb0>)
    ab94:	3801      	subs	r0, #1
    ab96:	800b      	strh	r3, [r1, #0]
    ab98:	70e2      	strb	r2, [r4, #3]
    ab9a:	2813      	cmp	r0, #19
    ab9c:	d835      	bhi.n	ac0a <gattc_complete_evt_handler+0x8e>
    ab9e:	f001 f8fb 	bl	bd98 <__gnu_thumb1_case_uqi>
    aba2:	420c      	.short	0x420c
    aba4:	42424242 	.word	0x42424242
    aba8:	1f1f1f42 	.word	0x1f1f1f42
    abac:	0a0a0a1d 	.word	0x0a0a0a1d
    abb0:	1134340a 	.word	0x1134340a
    abb4:	3217      	.short	0x3217
    abb6:	2025      	movs	r0, #37	; 0x25
    abb8:	e036      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    abba:	2024      	movs	r0, #36	; 0x24
    abbc:	2a00      	cmp	r2, #0
    abbe:	d133      	bne.n	ac28 <gattc_complete_evt_handler+0xac>
    abc0:	3016      	adds	r0, #22
    abc2:	e031      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    abc4:	4a1a      	ldr	r2, [pc, #104]	; (ac30 <gattc_complete_evt_handler+0xb4>)
    abc6:	201d      	movs	r0, #29
    abc8:	6813      	ldr	r3, [r2, #0]
    abca:	3b01      	subs	r3, #1
    abcc:	6013      	str	r3, [r2, #0]
    abce:	e02b      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    abd0:	4a17      	ldr	r2, [pc, #92]	; (ac30 <gattc_complete_evt_handler+0xb4>)
    abd2:	201e      	movs	r0, #30
    abd4:	6813      	ldr	r3, [r2, #0]
    abd6:	3b01      	subs	r3, #1
    abd8:	6013      	str	r3, [r2, #0]
    abda:	e025      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    abdc:	2019      	movs	r0, #25
    abde:	e023      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    abe0:	203a      	movs	r0, #58	; 0x3a
    abe2:	2a00      	cmp	r2, #0
    abe4:	d020      	beq.n	ac28 <gattc_complete_evt_handler+0xac>
    abe6:	2382      	movs	r3, #130	; 0x82
    abe8:	009b      	lsls	r3, r3, #2
    abea:	54e2      	strb	r2, [r4, r3]
    abec:	22e4      	movs	r2, #228	; 0xe4
    abee:	4c11      	ldr	r4, [pc, #68]	; (ac34 <gattc_complete_evt_handler+0xb8>)
    abf0:	4911      	ldr	r1, [pc, #68]	; (ac38 <gattc_complete_evt_handler+0xbc>)
    abf2:	0052      	lsls	r2, r2, #1
    abf4:	4b11      	ldr	r3, [pc, #68]	; (ac3c <gattc_complete_evt_handler+0xc0>)
    abf6:	4812      	ldr	r0, [pc, #72]	; (ac40 <gattc_complete_evt_handler+0xc4>)
    abf8:	6825      	ldr	r5, [r4, #0]
    abfa:	47a8      	blx	r5
    abfc:	6823      	ldr	r3, [r4, #0]
    abfe:	4811      	ldr	r0, [pc, #68]	; (ac44 <gattc_complete_evt_handler+0xc8>)
    ac00:	4798      	blx	r3
    ac02:	2018      	movs	r0, #24
    ac04:	e010      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    ac06:	2021      	movs	r0, #33	; 0x21
    ac08:	e00e      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    ac0a:	22ec      	movs	r2, #236	; 0xec
    ac0c:	4d09      	ldr	r5, [pc, #36]	; (ac34 <gattc_complete_evt_handler+0xb8>)
    ac0e:	490a      	ldr	r1, [pc, #40]	; (ac38 <gattc_complete_evt_handler+0xbc>)
    ac10:	0052      	lsls	r2, r2, #1
    ac12:	4b0a      	ldr	r3, [pc, #40]	; (ac3c <gattc_complete_evt_handler+0xc0>)
    ac14:	480a      	ldr	r0, [pc, #40]	; (ac40 <gattc_complete_evt_handler+0xc4>)
    ac16:	682e      	ldr	r6, [r5, #0]
    ac18:	47b0      	blx	r6
    ac1a:	78a1      	ldrb	r1, [r4, #2]
    ac1c:	682b      	ldr	r3, [r5, #0]
    ac1e:	480a      	ldr	r0, [pc, #40]	; (ac48 <gattc_complete_evt_handler+0xcc>)
    ac20:	4798      	blx	r3
    ac22:	2000      	movs	r0, #0
    ac24:	e000      	b.n	ac28 <gattc_complete_evt_handler+0xac>
    ac26:	2017      	movs	r0, #23
    ac28:	bd70      	pop	{r4, r5, r6, pc}
    ac2a:	46c0      	nop			; (mov r8, r8)
    ac2c:	20000698 	.word	0x20000698
    ac30:	2000069c 	.word	0x2000069c
    ac34:	20000038 	.word	0x20000038
    ac38:	0001137d 	.word	0x0001137d
    ac3c:	000113f8 	.word	0x000113f8
    ac40:	0000ed34 	.word	0x0000ed34
    ac44:	000113d8 	.word	0x000113d8
    ac48:	0001123a 	.word	0x0001123a

0000ac4c <gattc_event_mtu_changed_ind_parser>:
    ac4c:	0a00      	lsrs	r0, r0, #8
    ac4e:	8010      	strh	r0, [r2, #0]
    ac50:	784b      	ldrb	r3, [r1, #1]
    ac52:	7809      	ldrb	r1, [r1, #0]
    ac54:	021b      	lsls	r3, r3, #8
    ac56:	430b      	orrs	r3, r1
    ac58:	8053      	strh	r3, [r2, #2]
    ac5a:	4770      	bx	lr

0000ac5c <gattc_read_ind_parser>:
    ac5c:	0a00      	lsrs	r0, r0, #8
    ac5e:	b508      	push	{r3, lr}
    ac60:	8010      	strh	r0, [r2, #0]
    ac62:	1c13      	adds	r3, r2, #0
    ac64:	2282      	movs	r2, #130	; 0x82
    ac66:	2000      	movs	r0, #0
    ac68:	0092      	lsls	r2, r2, #2
    ac6a:	5498      	strb	r0, [r3, r2]
    ac6c:	784a      	ldrb	r2, [r1, #1]
    ac6e:	7808      	ldrb	r0, [r1, #0]
    ac70:	0212      	lsls	r2, r2, #8
    ac72:	4302      	orrs	r2, r0
    ac74:	805a      	strh	r2, [r3, #2]
    ac76:	78ca      	ldrb	r2, [r1, #3]
    ac78:	7888      	ldrb	r0, [r1, #2]
    ac7a:	0212      	lsls	r2, r2, #8
    ac7c:	4302      	orrs	r2, r0
    ac7e:	80da      	strh	r2, [r3, #6]
    ac80:	794a      	ldrb	r2, [r1, #5]
    ac82:	7908      	ldrb	r0, [r1, #4]
    ac84:	0212      	lsls	r2, r2, #8
    ac86:	4302      	orrs	r2, r0
    ac88:	809a      	strh	r2, [r3, #4]
    ac8a:	3308      	adds	r3, #8
    ac8c:	1c18      	adds	r0, r3, #0
    ac8e:	3106      	adds	r1, #6
    ac90:	4b01      	ldr	r3, [pc, #4]	; (ac98 <gattc_read_ind_parser+0x3c>)
    ac92:	4798      	blx	r3
    ac94:	bd08      	pop	{r3, pc}
    ac96:	46c0      	nop			; (mov r8, r8)
    ac98:	0000d7eb 	.word	0x0000d7eb

0000ac9c <gattc_svc_changed_cfg_ind_parser>:
    ac9c:	0a00      	lsrs	r0, r0, #8
    ac9e:	8010      	strh	r0, [r2, #0]
    aca0:	784b      	ldrb	r3, [r1, #1]
    aca2:	7809      	ldrb	r1, [r1, #0]
    aca4:	021b      	lsls	r3, r3, #8
    aca6:	430b      	orrs	r3, r1
    aca8:	8053      	strh	r3, [r2, #2]
    acaa:	4770      	bx	lr

0000acac <gattm_add_svc_req_handler>:
    acac:	b5f0      	push	{r4, r5, r6, r7, lr}
    acae:	7943      	ldrb	r3, [r0, #5]
    acb0:	b085      	sub	sp, #20
    acb2:	9301      	str	r3, [sp, #4]
    acb4:	4b46      	ldr	r3, [pc, #280]	; (add0 <gattm_add_svc_req_handler+0x124>)
    acb6:	1c05      	adds	r5, r0, #0
    acb8:	781b      	ldrb	r3, [r3, #0]
    acba:	4a46      	ldr	r2, [pc, #280]	; (add4 <gattm_add_svc_req_handler+0x128>)
    acbc:	2100      	movs	r1, #0
    acbe:	2b02      	cmp	r3, #2
    acc0:	d107      	bne.n	acd2 <gattm_add_svc_req_handler+0x26>
    acc2:	6813      	ldr	r3, [r2, #0]
    acc4:	3152      	adds	r1, #82	; 0x52
    acc6:	7019      	strb	r1, [r3, #0]
    acc8:	3105      	adds	r1, #5
    acca:	7059      	strb	r1, [r3, #1]
    accc:	3936      	subs	r1, #54	; 0x36
    acce:	7099      	strb	r1, [r3, #2]
    acd0:	391e      	subs	r1, #30
    acd2:	2305      	movs	r3, #5
    acd4:	2600      	movs	r6, #0
    acd6:	6814      	ldr	r4, [r2, #0]
    acd8:	1c8a      	adds	r2, r1, #2
    acda:	5463      	strb	r3, [r4, r1]
    acdc:	1c4b      	adds	r3, r1, #1
    acde:	54e6      	strb	r6, [r4, r3]
    ace0:	230b      	movs	r3, #11
    ace2:	54a3      	strb	r3, [r4, r2]
    ace4:	1cca      	adds	r2, r1, #3
    ace6:	54a3      	strb	r3, [r4, r2]
    ace8:	2210      	movs	r2, #16
    acea:	1d0b      	adds	r3, r1, #4
    acec:	54e6      	strb	r6, [r4, r3]
    acee:	1d4b      	adds	r3, r1, #5
    acf0:	54e2      	strb	r2, [r4, r3]
    acf2:	1d8b      	adds	r3, r1, #6
    acf4:	54e6      	strb	r6, [r4, r3]
    acf6:	2314      	movs	r3, #20
    acf8:	1c0a      	adds	r2, r1, #0
    acfa:	9f01      	ldr	r7, [sp, #4]
    acfc:	1dc8      	adds	r0, r1, #7
    acfe:	437b      	muls	r3, r7
    ad00:	1820      	adds	r0, r4, r0
    ad02:	3316      	adds	r3, #22
    ad04:	3208      	adds	r2, #8
    ad06:	18a2      	adds	r2, r4, r2
    ad08:	7003      	strb	r3, [r0, #0]
    ad0a:	121b      	asrs	r3, r3, #8
    ad0c:	7013      	strb	r3, [r2, #0]
    ad0e:	3109      	adds	r1, #9
    ad10:	4b31      	ldr	r3, [pc, #196]	; (add8 <gattm_add_svc_req_handler+0x12c>)
    ad12:	1c20      	adds	r0, r4, #0
    ad14:	4798      	blx	r3
    ad16:	4b31      	ldr	r3, [pc, #196]	; (addc <gattm_add_svc_req_handler+0x130>)
    ad18:	4798      	blx	r3
    ad1a:	4b31      	ldr	r3, [pc, #196]	; (ade0 <gattm_add_svc_req_handler+0x134>)
    ad1c:	4798      	blx	r3
    ad1e:	882b      	ldrh	r3, [r5, #0]
    ad20:	7023      	strb	r3, [r4, #0]
    ad22:	882b      	ldrh	r3, [r5, #0]
    ad24:	0a1b      	lsrs	r3, r3, #8
    ad26:	7063      	strb	r3, [r4, #1]
    ad28:	886b      	ldrh	r3, [r5, #2]
    ad2a:	70a3      	strb	r3, [r4, #2]
    ad2c:	886b      	ldrh	r3, [r5, #2]
    ad2e:	0a1b      	lsrs	r3, r3, #8
    ad30:	70e3      	strb	r3, [r4, #3]
    ad32:	792b      	ldrb	r3, [r5, #4]
    ad34:	7123      	strb	r3, [r4, #4]
    ad36:	466b      	mov	r3, sp
    ad38:	791b      	ldrb	r3, [r3, #4]
    ad3a:	7163      	strb	r3, [r4, #5]
    ad3c:	19ab      	adds	r3, r5, r6
    ad3e:	799a      	ldrb	r2, [r3, #6]
    ad40:	19a3      	adds	r3, r4, r6
    ad42:	3601      	adds	r6, #1
    ad44:	719a      	strb	r2, [r3, #6]
    ad46:	2e10      	cmp	r6, #16
    ad48:	d1f8      	bne.n	ad3c <gattm_add_svc_req_handler+0x90>
    ad4a:	1c2e      	adds	r6, r5, #0
    ad4c:	2116      	movs	r1, #22
    ad4e:	2700      	movs	r7, #0
    ad50:	3616      	adds	r6, #22
    ad52:	9a01      	ldr	r2, [sp, #4]
    ad54:	4b20      	ldr	r3, [pc, #128]	; (add8 <gattm_add_svc_req_handler+0x12c>)
    ad56:	4297      	cmp	r7, r2
    ad58:	da18      	bge.n	ad8c <gattm_add_svc_req_handler+0xe0>
    ad5a:	1c20      	adds	r0, r4, #0
    ad5c:	4798      	blx	r3
    ad5e:	4b1f      	ldr	r3, [pc, #124]	; (addc <gattm_add_svc_req_handler+0x130>)
    ad60:	4798      	blx	r3
    ad62:	4b1f      	ldr	r3, [pc, #124]	; (ade0 <gattm_add_svc_req_handler+0x134>)
    ad64:	4798      	blx	r3
    ad66:	1c31      	adds	r1, r6, #0
    ad68:	4b1e      	ldr	r3, [pc, #120]	; (ade4 <gattm_add_svc_req_handler+0x138>)
    ad6a:	1c20      	adds	r0, r4, #0
    ad6c:	2210      	movs	r2, #16
    ad6e:	4798      	blx	r3
    ad70:	8a33      	ldrh	r3, [r6, #16]
    ad72:	3701      	adds	r7, #1
    ad74:	7423      	strb	r3, [r4, #16]
    ad76:	8a33      	ldrh	r3, [r6, #16]
    ad78:	2114      	movs	r1, #20
    ad7a:	0a1b      	lsrs	r3, r3, #8
    ad7c:	7463      	strb	r3, [r4, #17]
    ad7e:	8a73      	ldrh	r3, [r6, #18]
    ad80:	74a3      	strb	r3, [r4, #18]
    ad82:	8a73      	ldrh	r3, [r6, #18]
    ad84:	3614      	adds	r6, #20
    ad86:	0a1b      	lsrs	r3, r3, #8
    ad88:	74e3      	strb	r3, [r4, #19]
    ad8a:	e7e2      	b.n	ad52 <gattm_add_svc_req_handler+0xa6>
    ad8c:	4e16      	ldr	r6, [pc, #88]	; (ade8 <gattm_add_svc_req_handler+0x13c>)
    ad8e:	4a17      	ldr	r2, [pc, #92]	; (adec <gattm_add_svc_req_handler+0x140>)
    ad90:	1c20      	adds	r0, r4, #0
    ad92:	8032      	strh	r2, [r6, #0]
    ad94:	220b      	movs	r2, #11
    ad96:	80b2      	strh	r2, [r6, #4]
    ad98:	4798      	blx	r3
    ad9a:	1c04      	adds	r4, r0, #0
    ad9c:	20e1      	movs	r0, #225	; 0xe1
    ad9e:	2c00      	cmp	r4, #0
    ada0:	d114      	bne.n	adcc <gattm_add_svc_req_handler+0x120>
    ada2:	4b0e      	ldr	r3, [pc, #56]	; (addc <gattm_add_svc_req_handler+0x130>)
    ada4:	4798      	blx	r3
    ada6:	ab02      	add	r3, sp, #8
    ada8:	1ddf      	adds	r7, r3, #7
    adaa:	71dc      	strb	r4, [r3, #7]
    adac:	1c38      	adds	r0, r7, #0
    adae:	4b10      	ldr	r3, [pc, #64]	; (adf0 <gattm_add_svc_req_handler+0x144>)
    adb0:	4798      	blx	r3
    adb2:	4b0b      	ldr	r3, [pc, #44]	; (ade0 <gattm_add_svc_req_handler+0x134>)
    adb4:	4798      	blx	r3
    adb6:	783b      	ldrb	r3, [r7, #0]
    adb8:	20d0      	movs	r0, #208	; 0xd0
    adba:	2b00      	cmp	r3, #0
    adbc:	d106      	bne.n	adcc <gattm_add_svc_req_handler+0x120>
    adbe:	68b2      	ldr	r2, [r6, #8]
    adc0:	7853      	ldrb	r3, [r2, #1]
    adc2:	7811      	ldrb	r1, [r2, #0]
    adc4:	021b      	lsls	r3, r3, #8
    adc6:	430b      	orrs	r3, r1
    adc8:	802b      	strh	r3, [r5, #0]
    adca:	7890      	ldrb	r0, [r2, #2]
    adcc:	b005      	add	sp, #20
    adce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    add0:	20000005 	.word	0x20000005
    add4:	00011148 	.word	0x00011148
    add8:	00008a29 	.word	0x00008a29
    addc:	00008835 	.word	0x00008835
    ade0:	00001895 	.word	0x00001895
    ade4:	0000d7eb 	.word	0x0000d7eb
    ade8:	200017fc 	.word	0x200017fc
    adec:	00000b01 	.word	0x00000b01
    adf0:	00001a1d 	.word	0x00001a1d

0000adf4 <gattm_add_attribute_req_handler>:
    adf4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    adf6:	1c1f      	adds	r7, r3, #0
    adf8:	4b1b      	ldr	r3, [pc, #108]	; (ae68 <gattm_add_attribute_req_handler+0x74>)
    adfa:	9100      	str	r1, [sp, #0]
    adfc:	9201      	str	r2, [sp, #4]
    adfe:	7946      	ldrb	r6, [r0, #5]
    ae00:	1c05      	adds	r5, r0, #0
    ae02:	6818      	ldr	r0, [r3, #0]
    ae04:	2114      	movs	r1, #20
    ae06:	382a      	subs	r0, #42	; 0x2a
    ae08:	4b18      	ldr	r3, [pc, #96]	; (ae6c <gattm_add_attribute_req_handler+0x78>)
    ae0a:	4798      	blx	r3
    ae0c:	4286      	cmp	r6, r0
    ae0e:	d30b      	bcc.n	ae28 <gattm_add_attribute_req_handler+0x34>
    ae10:	4c17      	ldr	r4, [pc, #92]	; (ae70 <gattm_add_attribute_req_handler+0x7c>)
    ae12:	4918      	ldr	r1, [pc, #96]	; (ae74 <gattm_add_attribute_req_handler+0x80>)
    ae14:	222f      	movs	r2, #47	; 0x2f
    ae16:	4b18      	ldr	r3, [pc, #96]	; (ae78 <gattm_add_attribute_req_handler+0x84>)
    ae18:	4818      	ldr	r0, [pc, #96]	; (ae7c <gattm_add_attribute_req_handler+0x88>)
    ae1a:	6825      	ldr	r5, [r4, #0]
    ae1c:	47a8      	blx	r5
    ae1e:	6823      	ldr	r3, [r4, #0]
    ae20:	4817      	ldr	r0, [pc, #92]	; (ae80 <gattm_add_attribute_req_handler+0x8c>)
    ae22:	4798      	blx	r3
    ae24:	2011      	movs	r0, #17
    ae26:	e01e      	b.n	ae66 <gattm_add_attribute_req_handler+0x72>
    ae28:	2414      	movs	r4, #20
    ae2a:	4366      	muls	r6, r4
    ae2c:	19a8      	adds	r0, r5, r6
    ae2e:	2100      	movs	r1, #0
    ae30:	2210      	movs	r2, #16
    ae32:	4b14      	ldr	r3, [pc, #80]	; (ae84 <gattm_add_attribute_req_handler+0x90>)
    ae34:	3016      	adds	r0, #22
    ae36:	4798      	blx	r3
    ae38:	7968      	ldrb	r0, [r5, #5]
    ae3a:	1c3a      	adds	r2, r7, #0
    ae3c:	4360      	muls	r0, r4
    ae3e:	1828      	adds	r0, r5, r0
    ae40:	4b11      	ldr	r3, [pc, #68]	; (ae88 <gattm_add_attribute_req_handler+0x94>)
    ae42:	3016      	adds	r0, #22
    ae44:	9908      	ldr	r1, [sp, #32]
    ae46:	4798      	blx	r3
    ae48:	466a      	mov	r2, sp
    ae4a:	796b      	ldrb	r3, [r5, #5]
    ae4c:	8812      	ldrh	r2, [r2, #0]
    ae4e:	435c      	muls	r4, r3
    ae50:	192c      	adds	r4, r5, r4
    ae52:	8522      	strh	r2, [r4, #40]	; 0x28
    ae54:	466a      	mov	r2, sp
    ae56:	2000      	movs	r0, #0
    ae58:	8892      	ldrh	r2, [r2, #4]
    ae5a:	84e2      	strh	r2, [r4, #38]	; 0x26
    ae5c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    ae5e:	8013      	strh	r3, [r2, #0]
    ae60:	796b      	ldrb	r3, [r5, #5]
    ae62:	3301      	adds	r3, #1
    ae64:	716b      	strb	r3, [r5, #5]
    ae66:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    ae68:	20000380 	.word	0x20000380
    ae6c:	0000bdad 	.word	0x0000bdad
    ae70:	20000038 	.word	0x20000038
    ae74:	00011433 	.word	0x00011433
    ae78:	00011413 	.word	0x00011413
    ae7c:	0000ed34 	.word	0x0000ed34
    ae80:	0000eef0 	.word	0x0000eef0
    ae84:	0000d825 	.word	0x0000d825
    ae88:	0000d7eb 	.word	0x0000d7eb

0000ae8c <gattm_att_set_value_req_handler>:
    ae8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    ae8e:	4b37      	ldr	r3, [pc, #220]	; (af6c <gattm_att_set_value_req_handler+0xe0>)
    ae90:	b087      	sub	sp, #28
    ae92:	781c      	ldrb	r4, [r3, #0]
    ae94:	1c0d      	adds	r5, r1, #0
    ae96:	9203      	str	r2, [sp, #12]
    ae98:	4935      	ldr	r1, [pc, #212]	; (af70 <gattm_att_set_value_req_handler+0xe4>)
    ae9a:	2300      	movs	r3, #0
    ae9c:	2c02      	cmp	r4, #2
    ae9e:	d107      	bne.n	aeb0 <gattm_att_set_value_req_handler+0x24>
    aea0:	680b      	ldr	r3, [r1, #0]
    aea2:	3450      	adds	r4, #80	; 0x50
    aea4:	701c      	strb	r4, [r3, #0]
    aea6:	3405      	adds	r4, #5
    aea8:	705c      	strb	r4, [r3, #1]
    aeaa:	3c36      	subs	r4, #54	; 0x36
    aeac:	709c      	strb	r4, [r3, #2]
    aeae:	2303      	movs	r3, #3
    aeb0:	680c      	ldr	r4, [r1, #0]
    aeb2:	2105      	movs	r1, #5
    aeb4:	260c      	movs	r6, #12
    aeb6:	270b      	movs	r7, #11
    aeb8:	54e1      	strb	r1, [r4, r3]
    aeba:	1c59      	adds	r1, r3, #1
    aebc:	5466      	strb	r6, [r4, r1]
    aebe:	1c99      	adds	r1, r3, #2
    aec0:	5467      	strb	r7, [r4, r1]
    aec2:	1cd9      	adds	r1, r3, #3
    aec4:	5467      	strb	r7, [r4, r1]
    aec6:	2100      	movs	r1, #0
    aec8:	2210      	movs	r2, #16
    aeca:	1d1e      	adds	r6, r3, #4
    aecc:	55a1      	strb	r1, [r4, r6]
    aece:	1d5e      	adds	r6, r3, #5
    aed0:	55a2      	strb	r2, [r4, r6]
    aed2:	2208      	movs	r2, #8
    aed4:	4694      	mov	ip, r2
    aed6:	449c      	add	ip, r3
    aed8:	44a4      	add	ip, r4
    aeda:	4662      	mov	r2, ip
    aedc:	1d9e      	adds	r6, r3, #6
    aede:	55a1      	strb	r1, [r4, r6]
    aee0:	1dde      	adds	r6, r3, #7
    aee2:	19a6      	adds	r6, r4, r6
    aee4:	7031      	strb	r1, [r6, #0]
    aee6:	7011      	strb	r1, [r2, #0]
    aee8:	1c19      	adds	r1, r3, #0
    aeea:	3109      	adds	r1, #9
    aeec:	5460      	strb	r0, [r4, r1]
    aeee:	3101      	adds	r1, #1
    aef0:	0a00      	lsrs	r0, r0, #8
    aef2:	5460      	strb	r0, [r4, r1]
    aef4:	19d9      	adds	r1, r3, r7
    aef6:	5465      	strb	r5, [r4, r1]
    aef8:	3102      	adds	r1, #2
    aefa:	9102      	str	r1, [sp, #8]
    aefc:	330c      	adds	r3, #12
    aefe:	0a29      	lsrs	r1, r5, #8
    af00:	54e1      	strb	r1, [r4, r3]
    af02:	9b02      	ldr	r3, [sp, #8]
    af04:	9201      	str	r2, [sp, #4]
    af06:	18e0      	adds	r0, r4, r3
    af08:	1c2a      	adds	r2, r5, #0
    af0a:	9903      	ldr	r1, [sp, #12]
    af0c:	4b19      	ldr	r3, [pc, #100]	; (af74 <gattm_att_set_value_req_handler+0xe8>)
    af0e:	4798      	blx	r3
    af10:	9b02      	ldr	r3, [sp, #8]
    af12:	4a19      	ldr	r2, [pc, #100]	; (af78 <gattm_att_set_value_req_handler+0xec>)
    af14:	195d      	adds	r5, r3, r5
    af16:	4b19      	ldr	r3, [pc, #100]	; (af7c <gattm_att_set_value_req_handler+0xf0>)
    af18:	b2a9      	uxth	r1, r5
    af1a:	801a      	strh	r2, [r3, #0]
    af1c:	4a13      	ldr	r2, [pc, #76]	; (af6c <gattm_att_set_value_req_handler+0xe0>)
    af1e:	809f      	strh	r7, [r3, #4]
    af20:	7812      	ldrb	r2, [r2, #0]
    af22:	1c1f      	adds	r7, r3, #0
    af24:	1c0b      	adds	r3, r1, #0
    af26:	2a02      	cmp	r2, #2
    af28:	d101      	bne.n	af2e <gattm_att_set_value_req_handler+0xa2>
    af2a:	3b0c      	subs	r3, #12
    af2c:	e000      	b.n	af30 <gattm_att_set_value_req_handler+0xa4>
    af2e:	3b09      	subs	r3, #9
    af30:	9a01      	ldr	r2, [sp, #4]
    af32:	7033      	strb	r3, [r6, #0]
    af34:	121b      	asrs	r3, r3, #8
    af36:	7013      	strb	r3, [r2, #0]
    af38:	1c20      	adds	r0, r4, #0
    af3a:	4b11      	ldr	r3, [pc, #68]	; (af80 <gattm_att_set_value_req_handler+0xf4>)
    af3c:	4798      	blx	r3
    af3e:	1c05      	adds	r5, r0, #0
    af40:	20e1      	movs	r0, #225	; 0xe1
    af42:	2d00      	cmp	r5, #0
    af44:	d10f      	bne.n	af66 <gattm_att_set_value_req_handler+0xda>
    af46:	4b0f      	ldr	r3, [pc, #60]	; (af84 <gattm_att_set_value_req_handler+0xf8>)
    af48:	4798      	blx	r3
    af4a:	ab04      	add	r3, sp, #16
    af4c:	1ddc      	adds	r4, r3, #7
    af4e:	71dd      	strb	r5, [r3, #7]
    af50:	1c20      	adds	r0, r4, #0
    af52:	4b0d      	ldr	r3, [pc, #52]	; (af88 <gattm_att_set_value_req_handler+0xfc>)
    af54:	4798      	blx	r3
    af56:	4b0d      	ldr	r3, [pc, #52]	; (af8c <gattm_att_set_value_req_handler+0x100>)
    af58:	4798      	blx	r3
    af5a:	7823      	ldrb	r3, [r4, #0]
    af5c:	20d0      	movs	r0, #208	; 0xd0
    af5e:	2b00      	cmp	r3, #0
    af60:	d101      	bne.n	af66 <gattm_att_set_value_req_handler+0xda>
    af62:	68bb      	ldr	r3, [r7, #8]
    af64:	7898      	ldrb	r0, [r3, #2]
    af66:	b007      	add	sp, #28
    af68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    af6a:	46c0      	nop			; (mov r8, r8)
    af6c:	20000005 	.word	0x20000005
    af70:	00011148 	.word	0x00011148
    af74:	0000d7eb 	.word	0x0000d7eb
    af78:	00000b0d 	.word	0x00000b0d
    af7c:	200017fc 	.word	0x200017fc
    af80:	00008a29 	.word	0x00008a29
    af84:	00008835 	.word	0x00008835
    af88:	00001a1d 	.word	0x00001a1d
    af8c:	00001895 	.word	0x00001895

0000af90 <gattm_att_get_value_req_handler>:
    af90:	b5f0      	push	{r4, r5, r6, r7, lr}
    af92:	4b38      	ldr	r3, [pc, #224]	; (b074 <gattm_att_get_value_req_handler+0xe4>)
    af94:	b085      	sub	sp, #20
    af96:	9100      	str	r1, [sp, #0]
    af98:	7819      	ldrb	r1, [r3, #0]
    af9a:	9201      	str	r2, [sp, #4]
    af9c:	1c05      	adds	r5, r0, #0
    af9e:	4a36      	ldr	r2, [pc, #216]	; (b078 <gattm_att_get_value_req_handler+0xe8>)
    afa0:	2300      	movs	r3, #0
    afa2:	2902      	cmp	r1, #2
    afa4:	d107      	bne.n	afb6 <gattm_att_get_value_req_handler+0x26>
    afa6:	6813      	ldr	r3, [r2, #0]
    afa8:	3150      	adds	r1, #80	; 0x50
    afaa:	7019      	strb	r1, [r3, #0]
    afac:	3105      	adds	r1, #5
    afae:	7059      	strb	r1, [r3, #1]
    afb0:	3936      	subs	r1, #54	; 0x36
    afb2:	7099      	strb	r1, [r3, #2]
    afb4:	2303      	movs	r3, #3
    afb6:	6810      	ldr	r0, [r2, #0]
    afb8:	2205      	movs	r2, #5
    afba:	210a      	movs	r1, #10
    afbc:	54c2      	strb	r2, [r0, r3]
    afbe:	1c5a      	adds	r2, r3, #1
    afc0:	5481      	strb	r1, [r0, r2]
    afc2:	3101      	adds	r1, #1
    afc4:	1c9a      	adds	r2, r3, #2
    afc6:	5481      	strb	r1, [r0, r2]
    afc8:	2600      	movs	r6, #0
    afca:	1cda      	adds	r2, r3, #3
    afcc:	5481      	strb	r1, [r0, r2]
    afce:	468c      	mov	ip, r1
    afd0:	2110      	movs	r1, #16
    afd2:	1d1a      	adds	r2, r3, #4
    afd4:	5486      	strb	r6, [r0, r2]
    afd6:	1d5a      	adds	r2, r3, #5
    afd8:	5481      	strb	r1, [r0, r2]
    afda:	1c19      	adds	r1, r3, #0
    afdc:	1d9a      	adds	r2, r3, #6
    afde:	5486      	strb	r6, [r0, r2]
    afe0:	1ddf      	adds	r7, r3, #7
    afe2:	3202      	adds	r2, #2
    afe4:	3109      	adds	r1, #9
    afe6:	19c7      	adds	r7, r0, r7
    afe8:	1882      	adds	r2, r0, r2
    afea:	703e      	strb	r6, [r7, #0]
    afec:	0a2c      	lsrs	r4, r5, #8
    afee:	7016      	strb	r6, [r2, #0]
    aff0:	5445      	strb	r5, [r0, r1]
    aff2:	1c19      	adds	r1, r3, #0
    aff4:	330a      	adds	r3, #10
    aff6:	54c4      	strb	r4, [r0, r3]
    aff8:	4c20      	ldr	r4, [pc, #128]	; (b07c <gattm_att_get_value_req_handler+0xec>)
    affa:	4b21      	ldr	r3, [pc, #132]	; (b080 <gattm_att_get_value_req_handler+0xf0>)
    affc:	4461      	add	r1, ip
    affe:	8023      	strh	r3, [r4, #0]
    b000:	4663      	mov	r3, ip
    b002:	80a3      	strh	r3, [r4, #4]
    b004:	4b1b      	ldr	r3, [pc, #108]	; (b074 <gattm_att_get_value_req_handler+0xe4>)
    b006:	781b      	ldrb	r3, [r3, #0]
    b008:	2b02      	cmp	r3, #2
    b00a:	d105      	bne.n	b018 <gattm_att_get_value_req_handler+0x88>
    b00c:	1c0b      	adds	r3, r1, #0
    b00e:	3b0c      	subs	r3, #12
    b010:	703b      	strb	r3, [r7, #0]
    b012:	121b      	asrs	r3, r3, #8
    b014:	7013      	strb	r3, [r2, #0]
    b016:	e003      	b.n	b020 <gattm_att_get_value_req_handler+0x90>
    b018:	1c0b      	adds	r3, r1, #0
    b01a:	3b09      	subs	r3, #9
    b01c:	703b      	strb	r3, [r7, #0]
    b01e:	7016      	strb	r6, [r2, #0]
    b020:	4b18      	ldr	r3, [pc, #96]	; (b084 <gattm_att_get_value_req_handler+0xf4>)
    b022:	4798      	blx	r3
    b024:	26e1      	movs	r6, #225	; 0xe1
    b026:	1e07      	subs	r7, r0, #0
    b028:	d120      	bne.n	b06c <gattm_att_get_value_req_handler+0xdc>
    b02a:	4b17      	ldr	r3, [pc, #92]	; (b088 <gattm_att_get_value_req_handler+0xf8>)
    b02c:	4798      	blx	r3
    b02e:	ab02      	add	r3, sp, #8
    b030:	1dde      	adds	r6, r3, #7
    b032:	1c30      	adds	r0, r6, #0
    b034:	71df      	strb	r7, [r3, #7]
    b036:	4b15      	ldr	r3, [pc, #84]	; (b08c <gattm_att_get_value_req_handler+0xfc>)
    b038:	4798      	blx	r3
    b03a:	4b15      	ldr	r3, [pc, #84]	; (b090 <gattm_att_get_value_req_handler+0x100>)
    b03c:	4798      	blx	r3
    b03e:	7833      	ldrb	r3, [r6, #0]
    b040:	26d0      	movs	r6, #208	; 0xd0
    b042:	2b00      	cmp	r3, #0
    b044:	d112      	bne.n	b06c <gattm_att_get_value_req_handler+0xdc>
    b046:	68a1      	ldr	r1, [r4, #8]
    b048:	9801      	ldr	r0, [sp, #4]
    b04a:	784c      	ldrb	r4, [r1, #1]
    b04c:	780b      	ldrb	r3, [r1, #0]
    b04e:	78ca      	ldrb	r2, [r1, #3]
    b050:	0224      	lsls	r4, r4, #8
    b052:	431c      	orrs	r4, r3
    b054:	788b      	ldrb	r3, [r1, #2]
    b056:	0212      	lsls	r2, r2, #8
    b058:	431a      	orrs	r2, r3
    b05a:	9b00      	ldr	r3, [sp, #0]
    b05c:	801a      	strh	r2, [r3, #0]
    b05e:	790e      	ldrb	r6, [r1, #4]
    b060:	4b0c      	ldr	r3, [pc, #48]	; (b094 <gattm_att_get_value_req_handler+0x104>)
    b062:	3105      	adds	r1, #5
    b064:	4798      	blx	r3
    b066:	42a5      	cmp	r5, r4
    b068:	d000      	beq.n	b06c <gattm_att_get_value_req_handler+0xdc>
    b06a:	26e2      	movs	r6, #226	; 0xe2
    b06c:	1c30      	adds	r0, r6, #0
    b06e:	b005      	add	sp, #20
    b070:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b072:	46c0      	nop			; (mov r8, r8)
    b074:	20000005 	.word	0x20000005
    b078:	00011148 	.word	0x00011148
    b07c:	200017fc 	.word	0x200017fc
    b080:	00000b0b 	.word	0x00000b0b
    b084:	00008a29 	.word	0x00008a29
    b088:	00008835 	.word	0x00008835
    b08c:	00001a1d 	.word	0x00001a1d
    b090:	00001895 	.word	0x00001895
    b094:	0000d7eb 	.word	0x0000d7eb

0000b098 <htpt_enable_rsp_handler>:
    b098:	780b      	ldrb	r3, [r1, #0]
    b09a:	7013      	strb	r3, [r2, #0]
    b09c:	784b      	ldrb	r3, [r1, #1]
    b09e:	7053      	strb	r3, [r2, #1]
    b0a0:	4770      	bx	lr

0000b0a2 <htpt_temp_send_rsp_handler>:
    b0a2:	780b      	ldrb	r3, [r1, #0]
    b0a4:	7013      	strb	r3, [r2, #0]
    b0a6:	4770      	bx	lr

0000b0a8 <htpt_meas_intv_upd_rsp_handler>:
    b0a8:	780b      	ldrb	r3, [r1, #0]
    b0aa:	7013      	strb	r3, [r2, #0]
    b0ac:	4770      	bx	lr

0000b0ae <htpt_meas_intv_chg_req_ind_handler>:
    b0ae:	78cb      	ldrb	r3, [r1, #3]
    b0b0:	7889      	ldrb	r1, [r1, #2]
    b0b2:	021b      	lsls	r3, r3, #8
    b0b4:	430b      	orrs	r3, r1
    b0b6:	8013      	strh	r3, [r2, #0]
    b0b8:	4770      	bx	lr

0000b0ba <htpt_cfg_indntf_ind_handler>:
    b0ba:	780b      	ldrb	r3, [r1, #0]
    b0bc:	7013      	strb	r3, [r2, #0]
    b0be:	784b      	ldrb	r3, [r1, #1]
    b0c0:	7053      	strb	r3, [r2, #1]
    b0c2:	4770      	bx	lr

0000b0c4 <_hwerr_to_stderr>:
    b0c4:	1c03      	adds	r3, r0, #0
    b0c6:	300e      	adds	r0, #14
    b0c8:	b500      	push	{lr}
    b0ca:	280e      	cmp	r0, #14
    b0cc:	d819      	bhi.n	b102 <_hwerr_to_stderr+0x3e>
    b0ce:	f000 fe63 	bl	bd98 <__gnu_thumb1_case_uqi>
    b0d2:	1416      	.short	0x1416
    b0d4:	1b181012 	.word	0x1b181012
    b0d8:	180c0e18 	.word	0x180c0e18
    b0dc:	1d0a0e0e 	.word	0x1d0a0e0e
    b0e0:	08          	.byte	0x08
    b0e1:	00          	.byte	0x00
    b0e2:	2000      	movs	r0, #0
    b0e4:	e014      	b.n	b110 <_hwerr_to_stderr+0x4c>
    b0e6:	2070      	movs	r0, #112	; 0x70
    b0e8:	e011      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b0ea:	2016      	movs	r0, #22
    b0ec:	e00f      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b0ee:	200c      	movs	r0, #12
    b0f0:	e00d      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b0f2:	2079      	movs	r0, #121	; 0x79
    b0f4:	e00b      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b0f6:	2068      	movs	r0, #104	; 0x68
    b0f8:	e009      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b0fa:	200b      	movs	r0, #11
    b0fc:	e007      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b0fe:	2010      	movs	r0, #16
    b100:	e005      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b102:	2000      	movs	r0, #0
    b104:	4283      	cmp	r3, r0
    b106:	da03      	bge.n	b110 <_hwerr_to_stderr+0x4c>
    b108:	2005      	movs	r0, #5
    b10a:	e000      	b.n	b10e <_hwerr_to_stderr+0x4a>
    b10c:	2002      	movs	r0, #2
    b10e:	4240      	negs	r0, r0
    b110:	bd00      	pop	{pc}
	...

0000b114 <_mqtt_send_wait>:
    b114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b116:	1c04      	adds	r4, r0, #0
    b118:	3443      	adds	r4, #67	; 0x43
    b11a:	7823      	ldrb	r3, [r4, #0]
    b11c:	1c05      	adds	r5, r0, #0
    b11e:	07d8      	lsls	r0, r3, #31
    b120:	d51c      	bpl.n	b15c <_mqtt_send_wait+0x48>
    b122:	2604      	movs	r6, #4
    b124:	4333      	orrs	r3, r6
    b126:	7023      	strb	r3, [r4, #0]
    b128:	2002      	movs	r0, #2
    b12a:	5628      	ldrsb	r0, [r5, r0]
    b12c:	b292      	uxth	r2, r2
    b12e:	2300      	movs	r3, #0
    b130:	4f0c      	ldr	r7, [pc, #48]	; (b164 <_mqtt_send_wait+0x50>)
    b132:	47b8      	blx	r7
    b134:	2800      	cmp	r0, #0
    b136:	da05      	bge.n	b144 <_mqtt_send_wait+0x30>
    b138:	7823      	ldrb	r3, [r4, #0]
    b13a:	43b3      	bics	r3, r6
    b13c:	7023      	strb	r3, [r4, #0]
    b13e:	4b0a      	ldr	r3, [pc, #40]	; (b168 <_mqtt_send_wait+0x54>)
    b140:	4798      	blx	r3
    b142:	e00d      	b.n	b160 <_mqtt_send_wait+0x4c>
    b144:	7822      	ldrb	r2, [r4, #0]
    b146:	2314      	movs	r3, #20
    b148:	4013      	ands	r3, r2
    b14a:	2000      	movs	r0, #0
    b14c:	2b04      	cmp	r3, #4
    b14e:	d107      	bne.n	b160 <_mqtt_send_wait+0x4c>
    b150:	4b06      	ldr	r3, [pc, #24]	; (b16c <_mqtt_send_wait+0x58>)
    b152:	4798      	blx	r3
    b154:	6de8      	ldr	r0, [r5, #92]	; 0x5c
    b156:	4b06      	ldr	r3, [pc, #24]	; (b170 <_mqtt_send_wait+0x5c>)
    b158:	4798      	blx	r3
    b15a:	e7f3      	b.n	b144 <_mqtt_send_wait+0x30>
    b15c:	2001      	movs	r0, #1
    b15e:	4240      	negs	r0, r0
    b160:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    b162:	46c0      	nop			; (mov r8, r8)
    b164:	00003e55 	.word	0x00003e55
    b168:	0000b0c5 	.word	0x0000b0c5
    b16c:	00002ac9 	.word	0x00002ac9
    b170:	000065a5 	.word	0x000065a5

0000b174 <mqtt_get_config_defaults>:
    b174:	4b07      	ldr	r3, [pc, #28]	; (b194 <mqtt_get_config_defaults+0x20>)
    b176:	2240      	movs	r2, #64	; 0x40
    b178:	8003      	strh	r3, [r0, #0]
    b17a:	2396      	movs	r3, #150	; 0x96
    b17c:	009b      	lsls	r3, r3, #2
    b17e:	8103      	strh	r3, [r0, #8]
    b180:	6102      	str	r2, [r0, #16]
    b182:	2300      	movs	r3, #0
    b184:	2220      	movs	r2, #32
    b186:	7083      	strb	r3, [r0, #2]
    b188:	6043      	str	r3, [r0, #4]
    b18a:	60c3      	str	r3, [r0, #12]
    b18c:	6142      	str	r2, [r0, #20]
    b18e:	7603      	strb	r3, [r0, #24]
    b190:	4770      	bx	lr
    b192:	46c0      	nop			; (mov r8, r8)
    b194:	0000075b 	.word	0x0000075b

0000b198 <mqtt_init>:
    b198:	b538      	push	{r3, r4, r5, lr}
    b19a:	1c04      	adds	r4, r0, #0
    b19c:	1c0d      	adds	r5, r1, #0
    b19e:	2800      	cmp	r0, #0
    b1a0:	d030      	beq.n	b204 <mqtt_init+0x6c>
    b1a2:	2900      	cmp	r1, #0
    b1a4:	d02e      	beq.n	b204 <mqtt_init+0x6c>
    b1a6:	690b      	ldr	r3, [r1, #16]
    b1a8:	2b00      	cmp	r3, #0
    b1aa:	d02b      	beq.n	b204 <mqtt_init+0x6c>
    b1ac:	684b      	ldr	r3, [r1, #4]
    b1ae:	2b00      	cmp	r3, #0
    b1b0:	d028      	beq.n	b204 <mqtt_init+0x6c>
    b1b2:	2100      	movs	r1, #0
    b1b4:	2274      	movs	r2, #116	; 0x74
    b1b6:	4b16      	ldr	r3, [pc, #88]	; (b210 <mqtt_init+0x78>)
    b1b8:	4798      	blx	r3
    b1ba:	1c20      	adds	r0, r4, #0
    b1bc:	4b15      	ldr	r3, [pc, #84]	; (b214 <mqtt_init+0x7c>)
    b1be:	3058      	adds	r0, #88	; 0x58
    b1c0:	1c29      	adds	r1, r5, #0
    b1c2:	221c      	movs	r2, #28
    b1c4:	4798      	blx	r3
    b1c6:	6e63      	ldr	r3, [r4, #100]	; 0x64
    b1c8:	2b00      	cmp	r3, #0
    b1ca:	d10b      	bne.n	b1e4 <mqtt_init+0x4c>
    b1cc:	6928      	ldr	r0, [r5, #16]
    b1ce:	4b12      	ldr	r3, [pc, #72]	; (b218 <mqtt_init+0x80>)
    b1d0:	4798      	blx	r3
    b1d2:	6660      	str	r0, [r4, #100]	; 0x64
    b1d4:	2800      	cmp	r0, #0
    b1d6:	d017      	beq.n	b208 <mqtt_init+0x70>
    b1d8:	1c23      	adds	r3, r4, #0
    b1da:	3343      	adds	r3, #67	; 0x43
    b1dc:	781a      	ldrb	r2, [r3, #0]
    b1de:	2120      	movs	r1, #32
    b1e0:	430a      	orrs	r2, r1
    b1e2:	701a      	strb	r2, [r3, #0]
    b1e4:	892a      	ldrh	r2, [r5, #8]
    b1e6:	23fa      	movs	r3, #250	; 0xfa
    b1e8:	005b      	lsls	r3, r3, #1
    b1ea:	4353      	muls	r3, r2
    b1ec:	6868      	ldr	r0, [r5, #4]
    b1ee:	490b      	ldr	r1, [pc, #44]	; (b21c <mqtt_init+0x84>)
    b1f0:	1c22      	adds	r2, r4, #0
    b1f2:	4d0b      	ldr	r5, [pc, #44]	; (b220 <mqtt_init+0x88>)
    b1f4:	47a8      	blx	r5
    b1f6:	1c03      	adds	r3, r0, #0
    b1f8:	6520      	str	r0, [r4, #80]	; 0x50
    b1fa:	2000      	movs	r0, #0
    b1fc:	4283      	cmp	r3, r0
    b1fe:	da05      	bge.n	b20c <mqtt_init+0x74>
    b200:	201c      	movs	r0, #28
    b202:	e002      	b.n	b20a <mqtt_init+0x72>
    b204:	2016      	movs	r0, #22
    b206:	e000      	b.n	b20a <mqtt_init+0x72>
    b208:	200c      	movs	r0, #12
    b20a:	4240      	negs	r0, r0
    b20c:	bd38      	pop	{r3, r4, r5, pc}
    b20e:	46c0      	nop			; (mov r8, r8)
    b210:	0000d825 	.word	0x0000d825
    b214:	0000d7eb 	.word	0x0000d7eb
    b218:	0000d7b9 	.word	0x0000d7b9
    b21c:	0000b851 	.word	0x0000b851
    b220:	0000652d 	.word	0x0000652d

0000b224 <mqtt_register_callback>:
    b224:	2800      	cmp	r0, #0
    b226:	d002      	beq.n	b22e <mqtt_register_callback+0xa>
    b228:	6541      	str	r1, [r0, #84]	; 0x54
    b22a:	2000      	movs	r0, #0
    b22c:	e001      	b.n	b232 <mqtt_register_callback+0xe>
    b22e:	2016      	movs	r0, #22
    b230:	4240      	negs	r0, r0
    b232:	4770      	bx	lr

0000b234 <mqtt_socket_resolve_handler>:
    b234:	b5f0      	push	{r4, r5, r6, r7, lr}
    b236:	1c06      	adds	r6, r0, #0
    b238:	b085      	sub	sp, #20
    b23a:	1c0f      	adds	r7, r1, #0
    b23c:	2400      	movs	r4, #0
    b23e:	4b0f      	ldr	r3, [pc, #60]	; (b27c <mqtt_socket_resolve_handler+0x48>)
    b240:	58e5      	ldr	r5, [r4, r3]
    b242:	2d00      	cmp	r5, #0
    b244:	d015      	beq.n	b272 <mqtt_socket_resolve_handler+0x3e>
    b246:	1ce9      	adds	r1, r5, #3
    b248:	1c30      	adds	r0, r6, #0
    b24a:	4b0d      	ldr	r3, [pc, #52]	; (b280 <mqtt_socket_resolve_handler+0x4c>)
    b24c:	4798      	blx	r3
    b24e:	2800      	cmp	r0, #0
    b250:	d10f      	bne.n	b272 <mqtt_socket_resolve_handler+0x3e>
    b252:	466a      	mov	r2, sp
    b254:	2302      	movs	r3, #2
    b256:	8013      	strh	r3, [r2, #0]
    b258:	1c2b      	adds	r3, r5, #0
    b25a:	3358      	adds	r3, #88	; 0x58
    b25c:	881b      	ldrh	r3, [r3, #0]
    b25e:	9701      	str	r7, [sp, #4]
    b260:	ba5b      	rev16	r3, r3
    b262:	8053      	strh	r3, [r2, #2]
    b264:	2002      	movs	r0, #2
    b266:	5628      	ldrsb	r0, [r5, r0]
    b268:	4669      	mov	r1, sp
    b26a:	2210      	movs	r2, #16
    b26c:	4b05      	ldr	r3, [pc, #20]	; (b284 <mqtt_socket_resolve_handler+0x50>)
    b26e:	4798      	blx	r3
    b270:	e002      	b.n	b278 <mqtt_socket_resolve_handler+0x44>
    b272:	3404      	adds	r4, #4
    b274:	2c1c      	cmp	r4, #28
    b276:	d1e2      	bne.n	b23e <mqtt_socket_resolve_handler+0xa>
    b278:	b005      	add	sp, #20
    b27a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b27c:	200006a0 	.word	0x200006a0
    b280:	0000da79 	.word	0x0000da79
    b284:	00003dc9 	.word	0x00003dc9

0000b288 <mqtt_connect>:
    b288:	b5f0      	push	{r4, r5, r6, r7, lr}
    b28a:	1c04      	adds	r4, r0, #0
    b28c:	b089      	sub	sp, #36	; 0x24
    b28e:	1c0d      	adds	r5, r1, #0
    b290:	2800      	cmp	r0, #0
    b292:	d051      	beq.n	b338 <mqtt_connect+0xb0>
    b294:	2900      	cmp	r1, #0
    b296:	d04f      	beq.n	b338 <mqtt_connect+0xb0>
    b298:	1c08      	adds	r0, r1, #0
    b29a:	4b39      	ldr	r3, [pc, #228]	; (b380 <mqtt_connect+0xf8>)
    b29c:	4798      	blx	r3
    b29e:	2840      	cmp	r0, #64	; 0x40
    b2a0:	d84c      	bhi.n	b33c <mqtt_connect+0xb4>
    b2a2:	1c21      	adds	r1, r4, #0
    b2a4:	3143      	adds	r1, #67	; 0x43
    b2a6:	780b      	ldrb	r3, [r1, #0]
    b2a8:	9101      	str	r1, [sp, #4]
    b2aa:	07db      	lsls	r3, r3, #31
    b2ac:	0fd9      	lsrs	r1, r3, #31
    b2ae:	466a      	mov	r2, sp
    b2b0:	b2ce      	uxtb	r6, r1
    b2b2:	1ce0      	adds	r0, r4, #3
    b2b4:	7211      	strb	r1, [r2, #8]
    b2b6:	2e00      	cmp	r6, #0
    b2b8:	d142      	bne.n	b340 <mqtt_connect+0xb8>
    b2ba:	2701      	movs	r7, #1
    b2bc:	1c29      	adds	r1, r5, #0
    b2be:	4b31      	ldr	r3, [pc, #196]	; (b384 <mqtt_connect+0xfc>)
    b2c0:	8027      	strh	r7, [r4, #0]
    b2c2:	4798      	blx	r3
    b2c4:	9a01      	ldr	r2, [sp, #4]
    b2c6:	2002      	movs	r0, #2
    b2c8:	7813      	ldrb	r3, [r2, #0]
    b2ca:	9901      	ldr	r1, [sp, #4]
    b2cc:	43bb      	bics	r3, r7
    b2ce:	4383      	bics	r3, r0
    b2d0:	22e3      	movs	r2, #227	; 0xe3
    b2d2:	4013      	ands	r3, r2
    b2d4:	466a      	mov	r2, sp
    b2d6:	700b      	strb	r3, [r1, #0]
    b2d8:	7a12      	ldrb	r2, [r2, #8]
    b2da:	1c23      	adds	r3, r4, #0
    b2dc:	3348      	adds	r3, #72	; 0x48
    b2de:	6466      	str	r6, [r4, #68]	; 0x44
    b2e0:	701a      	strb	r2, [r3, #0]
    b2e2:	7c9a      	ldrb	r2, [r3, #18]
    b2e4:	805e      	strh	r6, [r3, #2]
    b2e6:	1e53      	subs	r3, r2, #1
    b2e8:	419a      	sbcs	r2, r3
    b2ea:	b2d2      	uxtb	r2, r2
    b2ec:	1c39      	adds	r1, r7, #0
    b2ee:	4b26      	ldr	r3, [pc, #152]	; (b388 <mqtt_connect+0x100>)
    b2f0:	4798      	blx	r3
    b2f2:	70a0      	strb	r0, [r4, #2]
    b2f4:	2800      	cmp	r0, #0
    b2f6:	db25      	blt.n	b344 <mqtt_connect+0xbc>
    b2f8:	4b24      	ldr	r3, [pc, #144]	; (b38c <mqtt_connect+0x104>)
    b2fa:	0080      	lsls	r0, r0, #2
    b2fc:	50c4      	str	r4, [r0, r3]
    b2fe:	1c2b      	adds	r3, r5, #0
    b300:	781f      	ldrb	r7, [r3, #0]
    b302:	2f00      	cmp	r7, #0
    b304:	d026      	beq.n	b354 <mqtt_connect+0xcc>
    b306:	2220      	movs	r2, #32
    b308:	1c39      	adds	r1, r7, #0
    b30a:	4391      	bics	r1, r2
    b30c:	1c0a      	adds	r2, r1, #0
    b30e:	3a41      	subs	r2, #65	; 0x41
    b310:	b2d2      	uxtb	r2, r2
    b312:	3301      	adds	r3, #1
    b314:	2a05      	cmp	r2, #5
    b316:	d90d      	bls.n	b334 <mqtt_connect+0xac>
    b318:	2f3a      	cmp	r7, #58	; 0x3a
    b31a:	d00b      	beq.n	b334 <mqtt_connect+0xac>
    b31c:	2f2f      	cmp	r7, #47	; 0x2f
    b31e:	d009      	beq.n	b334 <mqtt_connect+0xac>
    b320:	2f2e      	cmp	r7, #46	; 0x2e
    b322:	d102      	bne.n	b32a <mqtt_connect+0xa2>
    b324:	2e00      	cmp	r6, #0
    b326:	d0eb      	beq.n	b300 <mqtt_connect+0x78>
    b328:	e00f      	b.n	b34a <mqtt_connect+0xc2>
    b32a:	2230      	movs	r2, #48	; 0x30
    b32c:	4017      	ands	r7, r2
    b32e:	4297      	cmp	r7, r2
    b330:	d0e6      	beq.n	b300 <mqtt_connect+0x78>
    b332:	e00a      	b.n	b34a <mqtt_connect+0xc2>
    b334:	2601      	movs	r6, #1
    b336:	e7e3      	b.n	b300 <mqtt_connect+0x78>
    b338:	2016      	movs	r0, #22
    b33a:	e004      	b.n	b346 <mqtt_connect+0xbe>
    b33c:	205b      	movs	r0, #91	; 0x5b
    b33e:	e002      	b.n	b346 <mqtt_connect+0xbe>
    b340:	2078      	movs	r0, #120	; 0x78
    b342:	e000      	b.n	b346 <mqtt_connect+0xbe>
    b344:	201c      	movs	r0, #28
    b346:	4240      	negs	r0, r0
    b348:	e017      	b.n	b37a <mqtt_connect+0xf2>
    b34a:	1c28      	adds	r0, r5, #0
    b34c:	4b10      	ldr	r3, [pc, #64]	; (b390 <mqtt_connect+0x108>)
    b34e:	4798      	blx	r3
    b350:	2000      	movs	r0, #0
    b352:	e012      	b.n	b37a <mqtt_connect+0xf2>
    b354:	466a      	mov	r2, sp
    b356:	2302      	movs	r3, #2
    b358:	8213      	strh	r3, [r2, #16]
    b35a:	1c23      	adds	r3, r4, #0
    b35c:	3358      	adds	r3, #88	; 0x58
    b35e:	881b      	ldrh	r3, [r3, #0]
    b360:	1c28      	adds	r0, r5, #0
    b362:	ba5b      	rev16	r3, r3
    b364:	8253      	strh	r3, [r2, #18]
    b366:	4b0b      	ldr	r3, [pc, #44]	; (b394 <mqtt_connect+0x10c>)
    b368:	4798      	blx	r3
    b36a:	9005      	str	r0, [sp, #20]
    b36c:	2002      	movs	r0, #2
    b36e:	5620      	ldrsb	r0, [r4, r0]
    b370:	a904      	add	r1, sp, #16
    b372:	2210      	movs	r2, #16
    b374:	4b08      	ldr	r3, [pc, #32]	; (b398 <mqtt_connect+0x110>)
    b376:	4798      	blx	r3
    b378:	1c38      	adds	r0, r7, #0
    b37a:	b009      	add	sp, #36	; 0x24
    b37c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b37e:	46c0      	nop			; (mov r8, r8)
    b380:	0000da9d 	.word	0x0000da9d
    b384:	0000da8d 	.word	0x0000da8d
    b388:	00003cf9 	.word	0x00003cf9
    b38c:	200006a0 	.word	0x200006a0
    b390:	0000406d 	.word	0x0000406d
    b394:	00004001 	.word	0x00004001
    b398:	00003dc9 	.word	0x00003dc9

0000b39c <mqtt_connect_broker>:
    b39c:	b5f0      	push	{r4, r5, r6, r7, lr}
    b39e:	b095      	sub	sp, #84	; 0x54
    b3a0:	af02      	add	r7, sp, #8
    b3a2:	617b      	str	r3, [r7, #20]
    b3a4:	1c3b      	adds	r3, r7, #0
    b3a6:	3370      	adds	r3, #112	; 0x70
    b3a8:	781b      	ldrb	r3, [r3, #0]
    b3aa:	1c05      	adds	r5, r0, #0
    b3ac:	60fb      	str	r3, [r7, #12]
    b3ae:	1c3b      	adds	r3, r7, #0
    b3b0:	3374      	adds	r3, #116	; 0x74
    b3b2:	781b      	ldrb	r3, [r3, #0]
    b3b4:	6139      	str	r1, [r7, #16]
    b3b6:	61fa      	str	r2, [r7, #28]
    b3b8:	60bb      	str	r3, [r7, #8]
    b3ba:	2800      	cmp	r0, #0
    b3bc:	d101      	bne.n	b3c2 <mqtt_connect_broker+0x26>
    b3be:	2016      	movs	r0, #22
    b3c0:	e129      	b.n	b616 <mqtt_connect_broker+0x27a>
    b3c2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    b3c4:	4668      	mov	r0, sp
    b3c6:	3307      	adds	r3, #7
    b3c8:	08db      	lsrs	r3, r3, #3
    b3ca:	00db      	lsls	r3, r3, #3
    b3cc:	1ac0      	subs	r0, r0, r3
    b3ce:	4685      	mov	sp, r0
    b3d0:	ac02      	add	r4, sp, #8
    b3d2:	607c      	str	r4, [r7, #4]
    b3d4:	6e3c      	ldr	r4, [r7, #96]	; 0x60
    b3d6:	2c00      	cmp	r4, #0
    b3d8:	d0f1      	beq.n	b3be <mqtt_connect_broker+0x22>
    b3da:	1c2b      	adds	r3, r5, #0
    b3dc:	3343      	adds	r3, #67	; 0x43
    b3de:	781b      	ldrb	r3, [r3, #0]
    b3e0:	07d8      	lsls	r0, r3, #31
    b3e2:	d400      	bmi.n	b3e6 <mqtt_connect_broker+0x4a>
    b3e4:	e112      	b.n	b60c <mqtt_connect_broker+0x270>
    b3e6:	079a      	lsls	r2, r3, #30
    b3e8:	d500      	bpl.n	b3ec <mqtt_connect_broker+0x50>
    b3ea:	e111      	b.n	b610 <mqtt_connect_broker+0x274>
    b3ec:	071c      	lsls	r4, r3, #28
    b3ee:	d40b      	bmi.n	b408 <mqtt_connect_broker+0x6c>
    b3f0:	4e8b      	ldr	r6, [pc, #556]	; (b620 <mqtt_connect_broker+0x284>)
    b3f2:	6e38      	ldr	r0, [r7, #96]	; 0x60
    b3f4:	47b0      	blx	r6
    b3f6:	1c03      	adds	r3, r0, #0
    b3f8:	61b8      	str	r0, [r7, #24]
    b3fa:	69f8      	ldr	r0, [r7, #28]
    b3fc:	330e      	adds	r3, #14
    b3fe:	1c34      	adds	r4, r6, #0
    b400:	2800      	cmp	r0, #0
    b402:	d113      	bne.n	b42c <mqtt_connect_broker+0x90>
    b404:	1c1e      	adds	r6, r3, #0
    b406:	e01d      	b.n	b444 <mqtt_connect_broker+0xa8>
    b408:	1c2b      	adds	r3, r5, #0
    b40a:	3370      	adds	r3, #112	; 0x70
    b40c:	781b      	ldrb	r3, [r3, #0]
    b40e:	2b00      	cmp	r3, #0
    b410:	d000      	beq.n	b414 <mqtt_connect_broker+0x78>
    b412:	e0ff      	b.n	b614 <mqtt_connect_broker+0x278>
    b414:	1c2b      	adds	r3, r5, #0
    b416:	3343      	adds	r3, #67	; 0x43
    b418:	781b      	ldrb	r3, [r3, #0]
    b41a:	071a      	lsls	r2, r3, #28
    b41c:	d5e8      	bpl.n	b3f0 <mqtt_connect_broker+0x54>
    b41e:	4b81      	ldr	r3, [pc, #516]	; (b624 <mqtt_connect_broker+0x288>)
    b420:	2000      	movs	r0, #0
    b422:	4798      	blx	r3
    b424:	6de8      	ldr	r0, [r5, #92]	; 0x5c
    b426:	4b80      	ldr	r3, [pc, #512]	; (b628 <mqtt_connect_broker+0x28c>)
    b428:	4798      	blx	r3
    b42a:	e7f3      	b.n	b414 <mqtt_connect_broker+0x78>
    b42c:	69f8      	ldr	r0, [r7, #28]
    b42e:	47b0      	blx	r6
    b430:	69be      	ldr	r6, [r7, #24]
    b432:	697b      	ldr	r3, [r7, #20]
    b434:	3610      	adds	r6, #16
    b436:	1836      	adds	r6, r6, r0
    b438:	2b00      	cmp	r3, #0
    b43a:	d003      	beq.n	b444 <mqtt_connect_broker+0xa8>
    b43c:	1c18      	adds	r0, r3, #0
    b43e:	47a0      	blx	r4
    b440:	3602      	adds	r6, #2
    b442:	1836      	adds	r6, r6, r0
    b444:	6e78      	ldr	r0, [r7, #100]	; 0x64
    b446:	2800      	cmp	r0, #0
    b448:	d007      	beq.n	b45a <mqtt_connect_broker+0xbe>
    b44a:	47a0      	blx	r4
    b44c:	3602      	adds	r6, #2
    b44e:	6efc      	ldr	r4, [r7, #108]	; 0x6c
    b450:	1830      	adds	r0, r6, r0
    b452:	1906      	adds	r6, r0, r4
    b454:	2c00      	cmp	r4, #0
    b456:	d100      	bne.n	b45a <mqtt_connect_broker+0xbe>
    b458:	1c06      	adds	r6, r0, #0
    b45a:	69fc      	ldr	r4, [r7, #28]
    b45c:	2c00      	cmp	r4, #0
    b45e:	d006      	beq.n	b46e <mqtt_connect_broker+0xd2>
    b460:	24c0      	movs	r4, #192	; 0xc0
    b462:	61bc      	str	r4, [r7, #24]
    b464:	697c      	ldr	r4, [r7, #20]
    b466:	2c00      	cmp	r4, #0
    b468:	d103      	bne.n	b472 <mqtt_connect_broker+0xd6>
    b46a:	2480      	movs	r4, #128	; 0x80
    b46c:	e000      	b.n	b470 <mqtt_connect_broker+0xd4>
    b46e:	69fc      	ldr	r4, [r7, #28]
    b470:	61bc      	str	r4, [r7, #24]
    b472:	6e7c      	ldr	r4, [r7, #100]	; 0x64
    b474:	2c00      	cmp	r4, #0
    b476:	d00f      	beq.n	b498 <mqtt_connect_broker+0xfc>
    b478:	68bc      	ldr	r4, [r7, #8]
    b47a:	2c00      	cmp	r4, #0
    b47c:	d003      	beq.n	b486 <mqtt_connect_broker+0xea>
    b47e:	69bc      	ldr	r4, [r7, #24]
    b480:	2320      	movs	r3, #32
    b482:	431c      	orrs	r4, r3
    b484:	61bc      	str	r4, [r7, #24]
    b486:	68fc      	ldr	r4, [r7, #12]
    b488:	2303      	movs	r3, #3
    b48a:	4023      	ands	r3, r4
    b48c:	00db      	lsls	r3, r3, #3
    b48e:	69bc      	ldr	r4, [r7, #24]
    b490:	2204      	movs	r2, #4
    b492:	4313      	orrs	r3, r2
    b494:	431c      	orrs	r4, r3
    b496:	61bc      	str	r4, [r7, #24]
    b498:	693c      	ldr	r4, [r7, #16]
    b49a:	2c00      	cmp	r4, #0
    b49c:	d003      	beq.n	b4a6 <mqtt_connect_broker+0x10a>
    b49e:	69bc      	ldr	r4, [r7, #24]
    b4a0:	2302      	movs	r3, #2
    b4a2:	431c      	orrs	r4, r3
    b4a4:	61bc      	str	r4, [r7, #24]
    b4a6:	1c2b      	adds	r3, r5, #0
    b4a8:	3343      	adds	r3, #67	; 0x43
    b4aa:	781a      	ldrb	r2, [r3, #0]
    b4ac:	2108      	movs	r1, #8
    b4ae:	430a      	orrs	r2, r1
    b4b0:	701a      	strb	r2, [r3, #0]
    b4b2:	1c38      	adds	r0, r7, #0
    b4b4:	9500      	str	r5, [sp, #0]
    b4b6:	3020      	adds	r0, #32
    b4b8:	6879      	ldr	r1, [r7, #4]
    b4ba:	4b5c      	ldr	r3, [pc, #368]	; (b62c <mqtt_connect_broker+0x290>)
    b4bc:	6eea      	ldr	r2, [r5, #108]	; 0x6c
    b4be:	4c5c      	ldr	r4, [pc, #368]	; (b630 <mqtt_connect_broker+0x294>)
    b4c0:	47a0      	blx	r4
    b4c2:	1c38      	adds	r0, r7, #0
    b4c4:	3020      	adds	r0, #32
    b4c6:	2110      	movs	r1, #16
    b4c8:	4b5a      	ldr	r3, [pc, #360]	; (b634 <mqtt_connect_broker+0x298>)
    b4ca:	4798      	blx	r3
    b4cc:	2e80      	cmp	r6, #128	; 0x80
    b4ce:	dd09      	ble.n	b4e4 <mqtt_connect_broker+0x148>
    b4d0:	2180      	movs	r1, #128	; 0x80
    b4d2:	4249      	negs	r1, r1
    b4d4:	4331      	orrs	r1, r6
    b4d6:	1c38      	adds	r0, r7, #0
    b4d8:	b249      	sxtb	r1, r1
    b4da:	3020      	adds	r0, #32
    b4dc:	4c55      	ldr	r4, [pc, #340]	; (b634 <mqtt_connect_broker+0x298>)
    b4de:	47a0      	blx	r4
    b4e0:	11f6      	asrs	r6, r6, #7
    b4e2:	e7f3      	b.n	b4cc <mqtt_connect_broker+0x130>
    b4e4:	4b54      	ldr	r3, [pc, #336]	; (b638 <mqtt_connect_broker+0x29c>)
    b4e6:	401e      	ands	r6, r3
    b4e8:	d504      	bpl.n	b4f4 <mqtt_connect_broker+0x158>
    b4ea:	2380      	movs	r3, #128	; 0x80
    b4ec:	3e01      	subs	r6, #1
    b4ee:	425b      	negs	r3, r3
    b4f0:	431e      	orrs	r6, r3
    b4f2:	3601      	adds	r6, #1
    b4f4:	1c38      	adds	r0, r7, #0
    b4f6:	b271      	sxtb	r1, r6
    b4f8:	3020      	adds	r0, #32
    b4fa:	4c4e      	ldr	r4, [pc, #312]	; (b634 <mqtt_connect_broker+0x298>)
    b4fc:	47a0      	blx	r4
    b4fe:	1c38      	adds	r0, r7, #0
    b500:	4c4e      	ldr	r4, [pc, #312]	; (b63c <mqtt_connect_broker+0x2a0>)
    b502:	3020      	adds	r0, #32
    b504:	2106      	movs	r1, #6
    b506:	47a0      	blx	r4
    b508:	1c38      	adds	r0, r7, #0
    b50a:	4b4d      	ldr	r3, [pc, #308]	; (b640 <mqtt_connect_broker+0x2a4>)
    b50c:	3020      	adds	r0, #32
    b50e:	494d      	ldr	r1, [pc, #308]	; (b644 <mqtt_connect_broker+0x2a8>)
    b510:	2206      	movs	r2, #6
    b512:	4798      	blx	r3
    b514:	1c38      	adds	r0, r7, #0
    b516:	3020      	adds	r0, #32
    b518:	2103      	movs	r1, #3
    b51a:	4a46      	ldr	r2, [pc, #280]	; (b634 <mqtt_connect_broker+0x298>)
    b51c:	4790      	blx	r2
    b51e:	69bb      	ldr	r3, [r7, #24]
    b520:	1c38      	adds	r0, r7, #0
    b522:	4a44      	ldr	r2, [pc, #272]	; (b634 <mqtt_connect_broker+0x298>)
    b524:	b259      	sxtb	r1, r3
    b526:	3020      	adds	r0, #32
    b528:	4790      	blx	r2
    b52a:	1c2b      	adds	r3, r5, #0
    b52c:	3360      	adds	r3, #96	; 0x60
    b52e:	2000      	movs	r0, #0
    b530:	5e19      	ldrsh	r1, [r3, r0]
    b532:	1c38      	adds	r0, r7, #0
    b534:	3020      	adds	r0, #32
    b536:	47a0      	blx	r4
    b538:	4e39      	ldr	r6, [pc, #228]	; (b620 <mqtt_connect_broker+0x284>)
    b53a:	6e38      	ldr	r0, [r7, #96]	; 0x60
    b53c:	47b0      	blx	r6
    b53e:	b201      	sxth	r1, r0
    b540:	1c38      	adds	r0, r7, #0
    b542:	3020      	adds	r0, #32
    b544:	47a0      	blx	r4
    b546:	6e38      	ldr	r0, [r7, #96]	; 0x60
    b548:	47b0      	blx	r6
    b54a:	1c02      	adds	r2, r0, #0
    b54c:	1c38      	adds	r0, r7, #0
    b54e:	3020      	adds	r0, #32
    b550:	6e39      	ldr	r1, [r7, #96]	; 0x60
    b552:	4b3b      	ldr	r3, [pc, #236]	; (b640 <mqtt_connect_broker+0x2a4>)
    b554:	4798      	blx	r3
    b556:	6e78      	ldr	r0, [r7, #100]	; 0x64
    b558:	2800      	cmp	r0, #0
    b55a:	d015      	beq.n	b588 <mqtt_connect_broker+0x1ec>
    b55c:	47b0      	blx	r6
    b55e:	b201      	sxth	r1, r0
    b560:	1c38      	adds	r0, r7, #0
    b562:	3020      	adds	r0, #32
    b564:	47a0      	blx	r4
    b566:	6e78      	ldr	r0, [r7, #100]	; 0x64
    b568:	47b0      	blx	r6
    b56a:	1c02      	adds	r2, r0, #0
    b56c:	1c38      	adds	r0, r7, #0
    b56e:	4c34      	ldr	r4, [pc, #208]	; (b640 <mqtt_connect_broker+0x2a4>)
    b570:	3020      	adds	r0, #32
    b572:	6e79      	ldr	r1, [r7, #100]	; 0x64
    b574:	47a0      	blx	r4
    b576:	6ebc      	ldr	r4, [r7, #104]	; 0x68
    b578:	2c00      	cmp	r4, #0
    b57a:	d005      	beq.n	b588 <mqtt_connect_broker+0x1ec>
    b57c:	1c38      	adds	r0, r7, #0
    b57e:	1c21      	adds	r1, r4, #0
    b580:	3020      	adds	r0, #32
    b582:	6efa      	ldr	r2, [r7, #108]	; 0x6c
    b584:	4c2e      	ldr	r4, [pc, #184]	; (b640 <mqtt_connect_broker+0x2a4>)
    b586:	47a0      	blx	r4
    b588:	69fc      	ldr	r4, [r7, #28]
    b58a:	2c00      	cmp	r4, #0
    b58c:	d01f      	beq.n	b5ce <mqtt_connect_broker+0x232>
    b58e:	4e24      	ldr	r6, [pc, #144]	; (b620 <mqtt_connect_broker+0x284>)
    b590:	1c20      	adds	r0, r4, #0
    b592:	47b0      	blx	r6
    b594:	b201      	sxth	r1, r0
    b596:	1c38      	adds	r0, r7, #0
    b598:	3020      	adds	r0, #32
    b59a:	4c28      	ldr	r4, [pc, #160]	; (b63c <mqtt_connect_broker+0x2a0>)
    b59c:	47a0      	blx	r4
    b59e:	69f8      	ldr	r0, [r7, #28]
    b5a0:	47b0      	blx	r6
    b5a2:	1c02      	adds	r2, r0, #0
    b5a4:	1c38      	adds	r0, r7, #0
    b5a6:	3020      	adds	r0, #32
    b5a8:	69f9      	ldr	r1, [r7, #28]
    b5aa:	4c25      	ldr	r4, [pc, #148]	; (b640 <mqtt_connect_broker+0x2a4>)
    b5ac:	47a0      	blx	r4
    b5ae:	6978      	ldr	r0, [r7, #20]
    b5b0:	2800      	cmp	r0, #0
    b5b2:	d00c      	beq.n	b5ce <mqtt_connect_broker+0x232>
    b5b4:	47b0      	blx	r6
    b5b6:	b201      	sxth	r1, r0
    b5b8:	1c38      	adds	r0, r7, #0
    b5ba:	4a20      	ldr	r2, [pc, #128]	; (b63c <mqtt_connect_broker+0x2a0>)
    b5bc:	3020      	adds	r0, #32
    b5be:	4790      	blx	r2
    b5c0:	6978      	ldr	r0, [r7, #20]
    b5c2:	47b0      	blx	r6
    b5c4:	1c02      	adds	r2, r0, #0
    b5c6:	1c38      	adds	r0, r7, #0
    b5c8:	3020      	adds	r0, #32
    b5ca:	6979      	ldr	r1, [r7, #20]
    b5cc:	47a0      	blx	r4
    b5ce:	1c38      	adds	r0, r7, #0
    b5d0:	1c2c      	adds	r4, r5, #0
    b5d2:	3020      	adds	r0, #32
    b5d4:	4b1c      	ldr	r3, [pc, #112]	; (b648 <mqtt_connect_broker+0x2ac>)
    b5d6:	3443      	adds	r4, #67	; 0x43
    b5d8:	4798      	blx	r3
    b5da:	7821      	ldrb	r1, [r4, #0]
    b5dc:	0789      	lsls	r1, r1, #30
    b5de:	0fc9      	lsrs	r1, r1, #31
    b5e0:	2901      	cmp	r1, #1
    b5e2:	d10b      	bne.n	b5fc <mqtt_connect_broker+0x260>
    b5e4:	6cea      	ldr	r2, [r5, #76]	; 0x4c
    b5e6:	2a00      	cmp	r2, #0
    b5e8:	d108      	bne.n	b5fc <mqtt_connect_broker+0x260>
    b5ea:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    b5ec:	2b00      	cmp	r3, #0
    b5ee:	d005      	beq.n	b5fc <mqtt_connect_broker+0x260>
    b5f0:	2034      	movs	r0, #52	; 0x34
    b5f2:	55c2      	strb	r2, [r0, r7]
    b5f4:	1c3a      	adds	r2, r7, #0
    b5f6:	1c28      	adds	r0, r5, #0
    b5f8:	3234      	adds	r2, #52	; 0x34
    b5fa:	4798      	blx	r3
    b5fc:	7823      	ldrb	r3, [r4, #0]
    b5fe:	2202      	movs	r2, #2
    b600:	4313      	orrs	r3, r2
    b602:	2208      	movs	r2, #8
    b604:	4393      	bics	r3, r2
    b606:	7023      	strb	r3, [r4, #0]
    b608:	2000      	movs	r0, #0
    b60a:	e005      	b.n	b618 <mqtt_connect_broker+0x27c>
    b60c:	2080      	movs	r0, #128	; 0x80
    b60e:	e002      	b.n	b616 <mqtt_connect_broker+0x27a>
    b610:	2078      	movs	r0, #120	; 0x78
    b612:	e000      	b.n	b616 <mqtt_connect_broker+0x27a>
    b614:	200b      	movs	r0, #11
    b616:	4240      	negs	r0, r0
    b618:	46bd      	mov	sp, r7
    b61a:	b013      	add	sp, #76	; 0x4c
    b61c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b61e:	46c0      	nop			; (mov r8, r8)
    b620:	0000da9d 	.word	0x0000da9d
    b624:	00002ac9 	.word	0x00002ac9
    b628:	000065a5 	.word	0x000065a5
    b62c:	0000b115 	.word	0x0000b115
    b630:	000063c9 	.word	0x000063c9
    b634:	000063f1 	.word	0x000063f1
    b638:	8000007f 	.word	0x8000007f
    b63c:	00006415 	.word	0x00006415
    b640:	0000642d 	.word	0x0000642d
    b644:	0001148e 	.word	0x0001148e
    b648:	000063d9 	.word	0x000063d9

0000b64c <mqtt_publish>:
    b64c:	b5f0      	push	{r4, r5, r6, r7, lr}
    b64e:	b093      	sub	sp, #76	; 0x4c
    b650:	af02      	add	r7, sp, #8
    b652:	60fb      	str	r3, [r7, #12]
    b654:	1c3b      	adds	r3, r7, #0
    b656:	3358      	adds	r3, #88	; 0x58
    b658:	781b      	ldrb	r3, [r3, #0]
    b65a:	1c04      	adds	r4, r0, #0
    b65c:	613b      	str	r3, [r7, #16]
    b65e:	1c3b      	adds	r3, r7, #0
    b660:	335c      	adds	r3, #92	; 0x5c
    b662:	781b      	ldrb	r3, [r3, #0]
    b664:	6179      	str	r1, [r7, #20]
    b666:	60ba      	str	r2, [r7, #8]
    b668:	607b      	str	r3, [r7, #4]
    b66a:	2800      	cmp	r0, #0
    b66c:	d101      	bne.n	b672 <mqtt_publish+0x26>
    b66e:	2516      	movs	r5, #22
    b670:	e0a7      	b.n	b7c2 <mqtt_publish+0x176>
    b672:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    b674:	466a      	mov	r2, sp
    b676:	3307      	adds	r3, #7
    b678:	08db      	lsrs	r3, r3, #3
    b67a:	00db      	lsls	r3, r3, #3
    b67c:	1ad2      	subs	r2, r2, r3
    b67e:	697b      	ldr	r3, [r7, #20]
    b680:	4695      	mov	sp, r2
    b682:	ae02      	add	r6, sp, #8
    b684:	2b00      	cmp	r3, #0
    b686:	d0f2      	beq.n	b66e <mqtt_publish+0x22>
    b688:	693a      	ldr	r2, [r7, #16]
    b68a:	2a02      	cmp	r2, #2
    b68c:	d8ef      	bhi.n	b66e <mqtt_publish+0x22>
    b68e:	1c05      	adds	r5, r0, #0
    b690:	3543      	adds	r5, #67	; 0x43
    b692:	782b      	ldrb	r3, [r5, #0]
    b694:	079a      	lsls	r2, r3, #30
    b696:	d400      	bmi.n	b69a <mqtt_publish+0x4e>
    b698:	e090      	b.n	b7bc <mqtt_publish+0x170>
    b69a:	071a      	lsls	r2, r3, #28
    b69c:	d40a      	bmi.n	b6b4 <mqtt_publish+0x68>
    b69e:	4b4b      	ldr	r3, [pc, #300]	; (b7cc <mqtt_publish+0x180>)
    b6a0:	6978      	ldr	r0, [r7, #20]
    b6a2:	4798      	blx	r3
    b6a4:	68fd      	ldr	r5, [r7, #12]
    b6a6:	693b      	ldr	r3, [r7, #16]
    b6a8:	3502      	adds	r5, #2
    b6aa:	182d      	adds	r5, r5, r0
    b6ac:	2b00      	cmp	r3, #0
    b6ae:	d011      	beq.n	b6d4 <mqtt_publish+0x88>
    b6b0:	3502      	adds	r5, #2
    b6b2:	e00f      	b.n	b6d4 <mqtt_publish+0x88>
    b6b4:	1c03      	adds	r3, r0, #0
    b6b6:	3370      	adds	r3, #112	; 0x70
    b6b8:	781b      	ldrb	r3, [r3, #0]
    b6ba:	2b00      	cmp	r3, #0
    b6bc:	d000      	beq.n	b6c0 <mqtt_publish+0x74>
    b6be:	e07f      	b.n	b7c0 <mqtt_publish+0x174>
    b6c0:	782b      	ldrb	r3, [r5, #0]
    b6c2:	071a      	lsls	r2, r3, #28
    b6c4:	d5eb      	bpl.n	b69e <mqtt_publish+0x52>
    b6c6:	4b42      	ldr	r3, [pc, #264]	; (b7d0 <mqtt_publish+0x184>)
    b6c8:	2000      	movs	r0, #0
    b6ca:	4798      	blx	r3
    b6cc:	6de0      	ldr	r0, [r4, #92]	; 0x5c
    b6ce:	4b41      	ldr	r3, [pc, #260]	; (b7d4 <mqtt_publish+0x188>)
    b6d0:	4798      	blx	r3
    b6d2:	e7f5      	b.n	b6c0 <mqtt_publish+0x74>
    b6d4:	1c23      	adds	r3, r4, #0
    b6d6:	3343      	adds	r3, #67	; 0x43
    b6d8:	781a      	ldrb	r2, [r3, #0]
    b6da:	2108      	movs	r1, #8
    b6dc:	430a      	orrs	r2, r1
    b6de:	701a      	strb	r2, [r3, #0]
    b6e0:	1c38      	adds	r0, r7, #0
    b6e2:	9400      	str	r4, [sp, #0]
    b6e4:	1c31      	adds	r1, r6, #0
    b6e6:	302c      	adds	r0, #44	; 0x2c
    b6e8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    b6ea:	4b3b      	ldr	r3, [pc, #236]	; (b7d8 <mqtt_publish+0x18c>)
    b6ec:	4e3b      	ldr	r6, [pc, #236]	; (b7dc <mqtt_publish+0x190>)
    b6ee:	47b0      	blx	r6
    b6f0:	687b      	ldr	r3, [r7, #4]
    b6f2:	2101      	movs	r1, #1
    b6f4:	4019      	ands	r1, r3
    b6f6:	2330      	movs	r3, #48	; 0x30
    b6f8:	4319      	orrs	r1, r3
    b6fa:	693b      	ldr	r3, [r7, #16]
    b6fc:	1c38      	adds	r0, r7, #0
    b6fe:	005a      	lsls	r2, r3, #1
    b700:	2306      	movs	r3, #6
    b702:	4013      	ands	r3, r2
    b704:	4319      	orrs	r1, r3
    b706:	302c      	adds	r0, #44	; 0x2c
    b708:	4b35      	ldr	r3, [pc, #212]	; (b7e0 <mqtt_publish+0x194>)
    b70a:	4798      	blx	r3
    b70c:	4b34      	ldr	r3, [pc, #208]	; (b7e0 <mqtt_publish+0x194>)
    b70e:	2d80      	cmp	r5, #128	; 0x80
    b710:	dd08      	ble.n	b724 <mqtt_publish+0xd8>
    b712:	2180      	movs	r1, #128	; 0x80
    b714:	4249      	negs	r1, r1
    b716:	4329      	orrs	r1, r5
    b718:	1c38      	adds	r0, r7, #0
    b71a:	b249      	sxtb	r1, r1
    b71c:	302c      	adds	r0, #44	; 0x2c
    b71e:	4798      	blx	r3
    b720:	11ed      	asrs	r5, r5, #7
    b722:	e7f3      	b.n	b70c <mqtt_publish+0xc0>
    b724:	4a2f      	ldr	r2, [pc, #188]	; (b7e4 <mqtt_publish+0x198>)
    b726:	4015      	ands	r5, r2
    b728:	d504      	bpl.n	b734 <mqtt_publish+0xe8>
    b72a:	2280      	movs	r2, #128	; 0x80
    b72c:	3d01      	subs	r5, #1
    b72e:	4252      	negs	r2, r2
    b730:	4315      	orrs	r5, r2
    b732:	3501      	adds	r5, #1
    b734:	1c38      	adds	r0, r7, #0
    b736:	b269      	sxtb	r1, r5
    b738:	302c      	adds	r0, #44	; 0x2c
    b73a:	4798      	blx	r3
    b73c:	4e23      	ldr	r6, [pc, #140]	; (b7cc <mqtt_publish+0x180>)
    b73e:	6978      	ldr	r0, [r7, #20]
    b740:	47b0      	blx	r6
    b742:	b201      	sxth	r1, r0
    b744:	1c38      	adds	r0, r7, #0
    b746:	302c      	adds	r0, #44	; 0x2c
    b748:	4d27      	ldr	r5, [pc, #156]	; (b7e8 <mqtt_publish+0x19c>)
    b74a:	47a8      	blx	r5
    b74c:	6978      	ldr	r0, [r7, #20]
    b74e:	47b0      	blx	r6
    b750:	1c02      	adds	r2, r0, #0
    b752:	1c38      	adds	r0, r7, #0
    b754:	302c      	adds	r0, #44	; 0x2c
    b756:	6979      	ldr	r1, [r7, #20]
    b758:	4e24      	ldr	r6, [pc, #144]	; (b7ec <mqtt_publish+0x1a0>)
    b75a:	47b0      	blx	r6
    b75c:	693a      	ldr	r2, [r7, #16]
    b75e:	2a00      	cmp	r2, #0
    b760:	d006      	beq.n	b770 <mqtt_publish+0x124>
    b762:	8821      	ldrh	r1, [r4, #0]
    b764:	1c38      	adds	r0, r7, #0
    b766:	1c4b      	adds	r3, r1, #1
    b768:	8023      	strh	r3, [r4, #0]
    b76a:	b209      	sxth	r1, r1
    b76c:	302c      	adds	r0, #44	; 0x2c
    b76e:	47a8      	blx	r5
    b770:	8823      	ldrh	r3, [r4, #0]
    b772:	2b00      	cmp	r3, #0
    b774:	d101      	bne.n	b77a <mqtt_publish+0x12e>
    b776:	2301      	movs	r3, #1
    b778:	8023      	strh	r3, [r4, #0]
    b77a:	68bb      	ldr	r3, [r7, #8]
    b77c:	2b00      	cmp	r3, #0
    b77e:	d006      	beq.n	b78e <mqtt_publish+0x142>
    b780:	68fa      	ldr	r2, [r7, #12]
    b782:	2a00      	cmp	r2, #0
    b784:	d003      	beq.n	b78e <mqtt_publish+0x142>
    b786:	1c38      	adds	r0, r7, #0
    b788:	302c      	adds	r0, #44	; 0x2c
    b78a:	1c19      	adds	r1, r3, #0
    b78c:	47b0      	blx	r6
    b78e:	1c38      	adds	r0, r7, #0
    b790:	4b17      	ldr	r3, [pc, #92]	; (b7f0 <mqtt_publish+0x1a4>)
    b792:	302c      	adds	r0, #44	; 0x2c
    b794:	4798      	blx	r3
    b796:	1c23      	adds	r3, r4, #0
    b798:	3343      	adds	r3, #67	; 0x43
    b79a:	781a      	ldrb	r2, [r3, #0]
    b79c:	2108      	movs	r1, #8
    b79e:	438a      	bics	r2, r1
    b7a0:	701a      	strb	r2, [r3, #0]
    b7a2:	693b      	ldr	r3, [r7, #16]
    b7a4:	2500      	movs	r5, #0
    b7a6:	42ab      	cmp	r3, r5
    b7a8:	d10c      	bne.n	b7c4 <mqtt_publish+0x178>
    b7aa:	6d63      	ldr	r3, [r4, #84]	; 0x54
    b7ac:	42ab      	cmp	r3, r5
    b7ae:	d009      	beq.n	b7c4 <mqtt_publish+0x178>
    b7b0:	1c3a      	adds	r2, r7, #0
    b7b2:	1c20      	adds	r0, r4, #0
    b7b4:	2102      	movs	r1, #2
    b7b6:	3218      	adds	r2, #24
    b7b8:	4798      	blx	r3
    b7ba:	e003      	b.n	b7c4 <mqtt_publish+0x178>
    b7bc:	2580      	movs	r5, #128	; 0x80
    b7be:	e000      	b.n	b7c2 <mqtt_publish+0x176>
    b7c0:	250b      	movs	r5, #11
    b7c2:	426d      	negs	r5, r5
    b7c4:	1c28      	adds	r0, r5, #0
    b7c6:	46bd      	mov	sp, r7
    b7c8:	b011      	add	sp, #68	; 0x44
    b7ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b7cc:	0000da9d 	.word	0x0000da9d
    b7d0:	00002ac9 	.word	0x00002ac9
    b7d4:	000065a5 	.word	0x000065a5
    b7d8:	0000b115 	.word	0x0000b115
    b7dc:	000063c9 	.word	0x000063c9
    b7e0:	000063f1 	.word	0x000063f1
    b7e4:	8000007f 	.word	0x8000007f
    b7e8:	00006415 	.word	0x00006415
    b7ec:	0000642d 	.word	0x0000642d
    b7f0:	000063d9 	.word	0x000063d9

0000b7f4 <_mqtt_ping>:
    b7f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b7f6:	23c0      	movs	r3, #192	; 0xc0
    b7f8:	a901      	add	r1, sp, #4
    b7fa:	2500      	movs	r5, #0
    b7fc:	700b      	strb	r3, [r1, #0]
    b7fe:	704d      	strb	r5, [r1, #1]
    b800:	42a8      	cmp	r0, r5
    b802:	d019      	beq.n	b838 <_mqtt_ping+0x44>
    b804:	1c04      	adds	r4, r0, #0
    b806:	3443      	adds	r4, #67	; 0x43
    b808:	7823      	ldrb	r3, [r4, #0]
    b80a:	079a      	lsls	r2, r3, #30
    b80c:	d516      	bpl.n	b83c <_mqtt_ping+0x48>
    b80e:	071a      	lsls	r2, r3, #28
    b810:	d416      	bmi.n	b840 <_mqtt_ping+0x4c>
    b812:	2608      	movs	r6, #8
    b814:	4333      	orrs	r3, r6
    b816:	7023      	strb	r3, [r4, #0]
    b818:	7880      	ldrb	r0, [r0, #2]
    b81a:	1c2b      	adds	r3, r5, #0
    b81c:	b240      	sxtb	r0, r0
    b81e:	2202      	movs	r2, #2
    b820:	4f09      	ldr	r7, [pc, #36]	; (b848 <_mqtt_ping+0x54>)
    b822:	47b8      	blx	r7
    b824:	1c2b      	adds	r3, r5, #0
    b826:	42a8      	cmp	r0, r5
    b828:	da0c      	bge.n	b844 <_mqtt_ping+0x50>
    b82a:	7823      	ldrb	r3, [r4, #0]
    b82c:	43b3      	bics	r3, r6
    b82e:	7023      	strb	r3, [r4, #0]
    b830:	4b06      	ldr	r3, [pc, #24]	; (b84c <_mqtt_ping+0x58>)
    b832:	4798      	blx	r3
    b834:	1c03      	adds	r3, r0, #0
    b836:	e005      	b.n	b844 <_mqtt_ping+0x50>
    b838:	2316      	movs	r3, #22
    b83a:	e002      	b.n	b842 <_mqtt_ping+0x4e>
    b83c:	2380      	movs	r3, #128	; 0x80
    b83e:	e000      	b.n	b842 <_mqtt_ping+0x4e>
    b840:	230b      	movs	r3, #11
    b842:	425b      	negs	r3, r3
    b844:	1c18      	adds	r0, r3, #0
    b846:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    b848:	00003e55 	.word	0x00003e55
    b84c:	0000b0c5 	.word	0x0000b0c5

0000b850 <mqtt_timer_callback>:
    b850:	b570      	push	{r4, r5, r6, lr}
    b852:	1c05      	adds	r5, r0, #0
    b854:	b086      	sub	sp, #24
    b856:	1c0e      	adds	r6, r1, #0
    b858:	1c14      	adds	r4, r2, #0
    b85a:	2800      	cmp	r0, #0
    b85c:	d012      	beq.n	b884 <mqtt_timer_callback+0x34>
    b85e:	2a00      	cmp	r2, #0
    b860:	d010      	beq.n	b884 <mqtt_timer_callback+0x34>
    b862:	1c10      	adds	r0, r2, #0
    b864:	4b08      	ldr	r3, [pc, #32]	; (b888 <mqtt_timer_callback+0x38>)
    b866:	4798      	blx	r3
    b868:	2800      	cmp	r0, #0
    b86a:	da04      	bge.n	b876 <mqtt_timer_callback+0x26>
    b86c:	1c28      	adds	r0, r5, #0
    b86e:	1c31      	adds	r1, r6, #0
    b870:	2200      	movs	r2, #0
    b872:	4b06      	ldr	r3, [pc, #24]	; (b88c <mqtt_timer_callback+0x3c>)
    b874:	e005      	b.n	b882 <mqtt_timer_callback+0x32>
    b876:	6d63      	ldr	r3, [r4, #84]	; 0x54
    b878:	2b00      	cmp	r3, #0
    b87a:	d003      	beq.n	b884 <mqtt_timer_callback+0x34>
    b87c:	1c20      	adds	r0, r4, #0
    b87e:	2107      	movs	r1, #7
    b880:	aa01      	add	r2, sp, #4
    b882:	4798      	blx	r3
    b884:	b006      	add	sp, #24
    b886:	bd70      	pop	{r4, r5, r6, pc}
    b888:	0000b7f5 	.word	0x0000b7f5
    b88c:	00006565 	.word	0x00006565

0000b890 <_mqtt_puback>:
    b890:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b892:	2302      	movs	r3, #2
    b894:	ac01      	add	r4, sp, #4
    b896:	2700      	movs	r7, #0
    b898:	7063      	strb	r3, [r4, #1]
    b89a:	42b8      	cmp	r0, r7
    b89c:	d01e      	beq.n	b8dc <_mqtt_puback+0x4c>
    b89e:	1c05      	adds	r5, r0, #0
    b8a0:	3543      	adds	r5, #67	; 0x43
    b8a2:	782b      	ldrb	r3, [r5, #0]
    b8a4:	079e      	lsls	r6, r3, #30
    b8a6:	d51b      	bpl.n	b8e0 <_mqtt_puback+0x50>
    b8a8:	071e      	lsls	r6, r3, #28
    b8aa:	d41b      	bmi.n	b8e4 <_mqtt_puback+0x54>
    b8ac:	2608      	movs	r6, #8
    b8ae:	4333      	orrs	r3, r6
    b8b0:	702b      	strb	r3, [r5, #0]
    b8b2:	7880      	ldrb	r0, [r0, #2]
    b8b4:	7021      	strb	r1, [r4, #0]
    b8b6:	0a11      	lsrs	r1, r2, #8
    b8b8:	70a1      	strb	r1, [r4, #2]
    b8ba:	70e2      	strb	r2, [r4, #3]
    b8bc:	1c21      	adds	r1, r4, #0
    b8be:	1c3b      	adds	r3, r7, #0
    b8c0:	b240      	sxtb	r0, r0
    b8c2:	2204      	movs	r2, #4
    b8c4:	4c09      	ldr	r4, [pc, #36]	; (b8ec <_mqtt_puback+0x5c>)
    b8c6:	47a0      	blx	r4
    b8c8:	1c3b      	adds	r3, r7, #0
    b8ca:	42b8      	cmp	r0, r7
    b8cc:	da0c      	bge.n	b8e8 <_mqtt_puback+0x58>
    b8ce:	782b      	ldrb	r3, [r5, #0]
    b8d0:	43b3      	bics	r3, r6
    b8d2:	702b      	strb	r3, [r5, #0]
    b8d4:	4b06      	ldr	r3, [pc, #24]	; (b8f0 <_mqtt_puback+0x60>)
    b8d6:	4798      	blx	r3
    b8d8:	1c03      	adds	r3, r0, #0
    b8da:	e005      	b.n	b8e8 <_mqtt_puback+0x58>
    b8dc:	2316      	movs	r3, #22
    b8de:	e002      	b.n	b8e6 <_mqtt_puback+0x56>
    b8e0:	2380      	movs	r3, #128	; 0x80
    b8e2:	e000      	b.n	b8e6 <_mqtt_puback+0x56>
    b8e4:	230b      	movs	r3, #11
    b8e6:	425b      	negs	r3, r3
    b8e8:	1c18      	adds	r0, r3, #0
    b8ea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    b8ec:	00003e55 	.word	0x00003e55
    b8f0:	0000b0c5 	.word	0x0000b0c5

0000b8f4 <mqtt_clear_conn>:
    b8f4:	b530      	push	{r4, r5, lr}
    b8f6:	1c04      	adds	r4, r0, #0
    b8f8:	b087      	sub	sp, #28
    b8fa:	2800      	cmp	r0, #0
    b8fc:	d01c      	beq.n	b938 <mqtt_clear_conn+0x44>
    b8fe:	2002      	movs	r0, #2
    b900:	4b0e      	ldr	r3, [pc, #56]	; (b93c <mqtt_clear_conn+0x48>)
    b902:	5620      	ldrsb	r0, [r4, r0]
    b904:	4798      	blx	r3
    b906:	1c23      	adds	r3, r4, #0
    b908:	3343      	adds	r3, #67	; 0x43
    b90a:	781a      	ldrb	r2, [r3, #0]
    b90c:	21fc      	movs	r1, #252	; 0xfc
    b90e:	0795      	lsls	r5, r2, #30
    b910:	400a      	ands	r2, r1
    b912:	701a      	strb	r2, [r3, #0]
    b914:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    b916:	6de0      	ldr	r0, [r4, #92]	; 0x5c
    b918:	9301      	str	r3, [sp, #4]
    b91a:	2300      	movs	r3, #0
    b91c:	64e3      	str	r3, [r4, #76]	; 0x4c
    b91e:	6d21      	ldr	r1, [r4, #80]	; 0x50
    b920:	4b07      	ldr	r3, [pc, #28]	; (b940 <mqtt_clear_conn+0x4c>)
    b922:	4798      	blx	r3
    b924:	6d63      	ldr	r3, [r4, #84]	; 0x54
    b926:	0fed      	lsrs	r5, r5, #31
    b928:	2b00      	cmp	r3, #0
    b92a:	d005      	beq.n	b938 <mqtt_clear_conn+0x44>
    b92c:	2d00      	cmp	r5, #0
    b92e:	d003      	beq.n	b938 <mqtt_clear_conn+0x44>
    b930:	1c20      	adds	r0, r4, #0
    b932:	2105      	movs	r1, #5
    b934:	aa01      	add	r2, sp, #4
    b936:	4798      	blx	r3
    b938:	b007      	add	sp, #28
    b93a:	bd30      	pop	{r4, r5, pc}
    b93c:	00003f8d 	.word	0x00003f8d
    b940:	00006595 	.word	0x00006595

0000b944 <mqtt_disconnect>:
    b944:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b946:	23e0      	movs	r3, #224	; 0xe0
    b948:	ae01      	add	r6, sp, #4
    b94a:	2700      	movs	r7, #0
    b94c:	1c05      	adds	r5, r0, #0
    b94e:	7033      	strb	r3, [r6, #0]
    b950:	7077      	strb	r7, [r6, #1]
    b952:	42b8      	cmp	r0, r7
    b954:	d036      	beq.n	b9c4 <mqtt_disconnect+0x80>
    b956:	1c04      	adds	r4, r0, #0
    b958:	3443      	adds	r4, #67	; 0x43
    b95a:	7823      	ldrb	r3, [r4, #0]
    b95c:	079a      	lsls	r2, r3, #30
    b95e:	d533      	bpl.n	b9c8 <mqtt_disconnect+0x84>
    b960:	42b9      	cmp	r1, r7
    b962:	d12b      	bne.n	b9bc <mqtt_disconnect+0x78>
    b964:	071a      	lsls	r2, r3, #28
    b966:	d414      	bmi.n	b992 <mqtt_disconnect+0x4e>
    b968:	7823      	ldrb	r3, [r4, #0]
    b96a:	2210      	movs	r2, #16
    b96c:	4313      	orrs	r3, r2
    b96e:	2708      	movs	r7, #8
    b970:	433b      	orrs	r3, r7
    b972:	7023      	strb	r3, [r4, #0]
    b974:	2002      	movs	r0, #2
    b976:	5628      	ldrsb	r0, [r5, r0]
    b978:	1c31      	adds	r1, r6, #0
    b97a:	2202      	movs	r2, #2
    b97c:	2300      	movs	r3, #0
    b97e:	4d15      	ldr	r5, [pc, #84]	; (b9d4 <mqtt_disconnect+0x90>)
    b980:	47a8      	blx	r5
    b982:	2800      	cmp	r0, #0
    b984:	da14      	bge.n	b9b0 <mqtt_disconnect+0x6c>
    b986:	7823      	ldrb	r3, [r4, #0]
    b988:	43bb      	bics	r3, r7
    b98a:	7023      	strb	r3, [r4, #0]
    b98c:	4b12      	ldr	r3, [pc, #72]	; (b9d8 <mqtt_disconnect+0x94>)
    b98e:	4798      	blx	r3
    b990:	e01e      	b.n	b9d0 <mqtt_disconnect+0x8c>
    b992:	1c03      	adds	r3, r0, #0
    b994:	3370      	adds	r3, #112	; 0x70
    b996:	781b      	ldrb	r3, [r3, #0]
    b998:	2b00      	cmp	r3, #0
    b99a:	d117      	bne.n	b9cc <mqtt_disconnect+0x88>
    b99c:	7823      	ldrb	r3, [r4, #0]
    b99e:	071a      	lsls	r2, r3, #28
    b9a0:	d5e2      	bpl.n	b968 <mqtt_disconnect+0x24>
    b9a2:	4b0e      	ldr	r3, [pc, #56]	; (b9dc <mqtt_disconnect+0x98>)
    b9a4:	2000      	movs	r0, #0
    b9a6:	4798      	blx	r3
    b9a8:	6de8      	ldr	r0, [r5, #92]	; 0x5c
    b9aa:	4b0d      	ldr	r3, [pc, #52]	; (b9e0 <mqtt_disconnect+0x9c>)
    b9ac:	4798      	blx	r3
    b9ae:	e7f5      	b.n	b99c <mqtt_disconnect+0x58>
    b9b0:	7823      	ldrb	r3, [r4, #0]
    b9b2:	2202      	movs	r2, #2
    b9b4:	4393      	bics	r3, r2
    b9b6:	7023      	strb	r3, [r4, #0]
    b9b8:	2000      	movs	r0, #0
    b9ba:	e009      	b.n	b9d0 <mqtt_disconnect+0x8c>
    b9bc:	4b09      	ldr	r3, [pc, #36]	; (b9e4 <mqtt_disconnect+0xa0>)
    b9be:	4798      	blx	r3
    b9c0:	1c38      	adds	r0, r7, #0
    b9c2:	e005      	b.n	b9d0 <mqtt_disconnect+0x8c>
    b9c4:	2016      	movs	r0, #22
    b9c6:	e002      	b.n	b9ce <mqtt_disconnect+0x8a>
    b9c8:	2080      	movs	r0, #128	; 0x80
    b9ca:	e000      	b.n	b9ce <mqtt_disconnect+0x8a>
    b9cc:	200b      	movs	r0, #11
    b9ce:	4240      	negs	r0, r0
    b9d0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    b9d2:	46c0      	nop			; (mov r8, r8)
    b9d4:	00003e55 	.word	0x00003e55
    b9d8:	0000b0c5 	.word	0x0000b0c5
    b9dc:	00002ac9 	.word	0x00002ac9
    b9e0:	000065a5 	.word	0x000065a5
    b9e4:	0000b8f5 	.word	0x0000b8f5

0000b9e8 <_mqtt_recv_handler>:
    b9e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    b9ea:	1c04      	adds	r4, r0, #0
    b9ec:	6e40      	ldr	r0, [r0, #100]	; 0x64
    b9ee:	230f      	movs	r3, #15
    b9f0:	7802      	ldrb	r2, [r0, #0]
    b9f2:	b087      	sub	sp, #28
    b9f4:	1c15      	adds	r5, r2, #0
    b9f6:	439d      	bics	r5, r3
    b9f8:	2d50      	cmp	r5, #80	; 0x50
    b9fa:	d100      	bne.n	b9fe <_mqtt_recv_handler+0x16>
    b9fc:	e098      	b.n	bb30 <_mqtt_recv_handler+0x148>
    b9fe:	d808      	bhi.n	ba12 <_mqtt_recv_handler+0x2a>
    ba00:	2d30      	cmp	r5, #48	; 0x30
    ba02:	d03f      	beq.n	ba84 <_mqtt_recv_handler+0x9c>
    ba04:	2d40      	cmp	r5, #64	; 0x40
    ba06:	d100      	bne.n	ba0a <_mqtt_recv_handler+0x22>
    ba08:	e0b3      	b.n	bb72 <_mqtt_recv_handler+0x18a>
    ba0a:	2d20      	cmp	r5, #32
    ba0c:	d000      	beq.n	ba10 <_mqtt_recv_handler+0x28>
    ba0e:	e0c3      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    ba10:	e00e      	b.n	ba30 <_mqtt_recv_handler+0x48>
    ba12:	2d70      	cmp	r5, #112	; 0x70
    ba14:	d100      	bne.n	ba18 <_mqtt_recv_handler+0x30>
    ba16:	e0ac      	b.n	bb72 <_mqtt_recv_handler+0x18a>
    ba18:	d803      	bhi.n	ba22 <_mqtt_recv_handler+0x3a>
    ba1a:	2d60      	cmp	r5, #96	; 0x60
    ba1c:	d100      	bne.n	ba20 <_mqtt_recv_handler+0x38>
    ba1e:	e096      	b.n	bb4e <_mqtt_recv_handler+0x166>
    ba20:	e0ba      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    ba22:	2d90      	cmp	r5, #144	; 0x90
    ba24:	d100      	bne.n	ba28 <_mqtt_recv_handler+0x40>
    ba26:	e0aa      	b.n	bb7e <_mqtt_recv_handler+0x196>
    ba28:	2db0      	cmp	r5, #176	; 0xb0
    ba2a:	d100      	bne.n	ba2e <_mqtt_recv_handler+0x46>
    ba2c:	e0ad      	b.n	bb8a <_mqtt_recv_handler+0x1a2>
    ba2e:	e0b3      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    ba30:	aa01      	add	r2, sp, #4
    ba32:	2303      	movs	r3, #3
    ba34:	2901      	cmp	r1, #1
    ba36:	d900      	bls.n	ba3a <_mqtt_recv_handler+0x52>
    ba38:	78c3      	ldrb	r3, [r0, #3]
    ba3a:	7013      	strb	r3, [r2, #0]
    ba3c:	7813      	ldrb	r3, [r2, #0]
    ba3e:	2b00      	cmp	r3, #0
    ba40:	d00d      	beq.n	ba5e <_mqtt_recv_handler+0x76>
    ba42:	6d63      	ldr	r3, [r4, #84]	; 0x54
    ba44:	2b00      	cmp	r3, #0
    ba46:	d002      	beq.n	ba4e <_mqtt_recv_handler+0x66>
    ba48:	1c20      	adds	r0, r4, #0
    ba4a:	2101      	movs	r1, #1
    ba4c:	4798      	blx	r3
    ba4e:	236f      	movs	r3, #111	; 0x6f
    ba50:	425b      	negs	r3, r3
    ba52:	64e3      	str	r3, [r4, #76]	; 0x4c
    ba54:	1c20      	adds	r0, r4, #0
    ba56:	2100      	movs	r1, #0
    ba58:	4b50      	ldr	r3, [pc, #320]	; (bb9c <_mqtt_recv_handler+0x1b4>)
    ba5a:	4798      	blx	r3
    ba5c:	e09c      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    ba5e:	1c23      	adds	r3, r4, #0
    ba60:	3343      	adds	r3, #67	; 0x43
    ba62:	7819      	ldrb	r1, [r3, #0]
    ba64:	0789      	lsls	r1, r1, #30
    ba66:	0fc9      	lsrs	r1, r1, #31
    ba68:	d105      	bne.n	ba76 <_mqtt_recv_handler+0x8e>
    ba6a:	781a      	ldrb	r2, [r3, #0]
    ba6c:	64e1      	str	r1, [r4, #76]	; 0x4c
    ba6e:	2102      	movs	r1, #2
    ba70:	430a      	orrs	r2, r1
    ba72:	701a      	strb	r2, [r3, #0]
    ba74:	e090      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    ba76:	6d63      	ldr	r3, [r4, #84]	; 0x54
    ba78:	2b00      	cmp	r3, #0
    ba7a:	d100      	bne.n	ba7e <_mqtt_recv_handler+0x96>
    ba7c:	e08c      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    ba7e:	1c20      	adds	r0, r4, #0
    ba80:	2101      	movs	r1, #1
    ba82:	e088      	b.n	bb96 <_mqtt_recv_handler+0x1ae>
    ba84:	ad01      	add	r5, sp, #4
    ba86:	0713      	lsls	r3, r2, #28
    ba88:	7c2a      	ldrb	r2, [r5, #16]
    ba8a:	0fdb      	lsrs	r3, r3, #31
    ba8c:	2604      	movs	r6, #4
    ba8e:	009b      	lsls	r3, r3, #2
    ba90:	43b2      	bics	r2, r6
    ba92:	431a      	orrs	r2, r3
    ba94:	742a      	strb	r2, [r5, #16]
    ba96:	7807      	ldrb	r7, [r0, #0]
    ba98:	2303      	movs	r3, #3
    ba9a:	b2d2      	uxtb	r2, r2
    ba9c:	087f      	lsrs	r7, r7, #1
    ba9e:	439a      	bics	r2, r3
    baa0:	401f      	ands	r7, r3
    baa2:	1c13      	adds	r3, r2, #0
    baa4:	433b      	orrs	r3, r7
    baa6:	742b      	strb	r3, [r5, #16]
    baa8:	1c43      	adds	r3, r0, #1
    baaa:	7818      	ldrb	r0, [r3, #0]
    baac:	1c5a      	adds	r2, r3, #1
    baae:	287f      	cmp	r0, #127	; 0x7f
    bab0:	d901      	bls.n	bab6 <_mqtt_recv_handler+0xce>
    bab2:	1c13      	adds	r3, r2, #0
    bab4:	e7f9      	b.n	baaa <_mqtt_recv_handler+0xc2>
    bab6:	7858      	ldrb	r0, [r3, #1]
    bab8:	789e      	ldrb	r6, [r3, #2]
    baba:	0200      	lsls	r0, r0, #8
    babc:	4330      	orrs	r0, r6
    babe:	3303      	adds	r3, #3
    bac0:	2600      	movs	r6, #0
    bac2:	6068      	str	r0, [r5, #4]
    bac4:	9301      	str	r3, [sp, #4]
    bac6:	1818      	adds	r0, r3, r0
    bac8:	42b7      	cmp	r7, r6
    baca:	d004      	beq.n	bad6 <_mqtt_recv_handler+0xee>
    bacc:	7806      	ldrb	r6, [r0, #0]
    bace:	7843      	ldrb	r3, [r0, #1]
    bad0:	0236      	lsls	r6, r6, #8
    bad2:	431e      	orrs	r6, r3
    bad4:	3002      	adds	r0, #2
    bad6:	1851      	adds	r1, r2, r1
    bad8:	6d63      	ldr	r3, [r4, #84]	; 0x54
    bada:	60a8      	str	r0, [r5, #8]
    badc:	1a08      	subs	r0, r1, r0
    bade:	60e8      	str	r0, [r5, #12]
    bae0:	2b00      	cmp	r3, #0
    bae2:	d003      	beq.n	baec <_mqtt_recv_handler+0x104>
    bae4:	1c20      	adds	r0, r4, #0
    bae6:	2106      	movs	r1, #6
    bae8:	1c2a      	adds	r2, r5, #0
    baea:	4798      	blx	r3
    baec:	7c2b      	ldrb	r3, [r5, #16]
    baee:	079b      	lsls	r3, r3, #30
    baf0:	0f9b      	lsrs	r3, r3, #30
    baf2:	2b01      	cmp	r3, #1
    baf4:	d10b      	bne.n	bb0e <_mqtt_recv_handler+0x126>
    baf6:	b2b6      	uxth	r6, r6
    baf8:	1c20      	adds	r0, r4, #0
    bafa:	2140      	movs	r1, #64	; 0x40
    bafc:	1c32      	adds	r2, r6, #0
    bafe:	4b28      	ldr	r3, [pc, #160]	; (bba0 <_mqtt_recv_handler+0x1b8>)
    bb00:	4798      	blx	r3
    bb02:	2800      	cmp	r0, #0
    bb04:	d048      	beq.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb06:	1c23      	adds	r3, r4, #0
    bb08:	3348      	adds	r3, #72	; 0x48
    bb0a:	2240      	movs	r2, #64	; 0x40
    bb0c:	e00c      	b.n	bb28 <_mqtt_recv_handler+0x140>
    bb0e:	2b02      	cmp	r3, #2
    bb10:	d142      	bne.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb12:	b2b6      	uxth	r6, r6
    bb14:	1c20      	adds	r0, r4, #0
    bb16:	2150      	movs	r1, #80	; 0x50
    bb18:	1c32      	adds	r2, r6, #0
    bb1a:	4b21      	ldr	r3, [pc, #132]	; (bba0 <_mqtt_recv_handler+0x1b8>)
    bb1c:	4798      	blx	r3
    bb1e:	2800      	cmp	r0, #0
    bb20:	d03a      	beq.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb22:	1c23      	adds	r3, r4, #0
    bb24:	3348      	adds	r3, #72	; 0x48
    bb26:	2250      	movs	r2, #80	; 0x50
    bb28:	344a      	adds	r4, #74	; 0x4a
    bb2a:	701a      	strb	r2, [r3, #0]
    bb2c:	8026      	strh	r6, [r4, #0]
    bb2e:	e033      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb30:	7885      	ldrb	r5, [r0, #2]
    bb32:	78c3      	ldrb	r3, [r0, #3]
    bb34:	022d      	lsls	r5, r5, #8
    bb36:	431d      	orrs	r5, r3
    bb38:	1c20      	adds	r0, r4, #0
    bb3a:	2162      	movs	r1, #98	; 0x62
    bb3c:	1c2a      	adds	r2, r5, #0
    bb3e:	4b18      	ldr	r3, [pc, #96]	; (bba0 <_mqtt_recv_handler+0x1b8>)
    bb40:	4798      	blx	r3
    bb42:	2800      	cmp	r0, #0
    bb44:	d028      	beq.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb46:	1c23      	adds	r3, r4, #0
    bb48:	3348      	adds	r3, #72	; 0x48
    bb4a:	2260      	movs	r2, #96	; 0x60
    bb4c:	e00d      	b.n	bb6a <_mqtt_recv_handler+0x182>
    bb4e:	7885      	ldrb	r5, [r0, #2]
    bb50:	78c3      	ldrb	r3, [r0, #3]
    bb52:	022d      	lsls	r5, r5, #8
    bb54:	431d      	orrs	r5, r3
    bb56:	1c20      	adds	r0, r4, #0
    bb58:	2170      	movs	r1, #112	; 0x70
    bb5a:	1c2a      	adds	r2, r5, #0
    bb5c:	4b10      	ldr	r3, [pc, #64]	; (bba0 <_mqtt_recv_handler+0x1b8>)
    bb5e:	4798      	blx	r3
    bb60:	2800      	cmp	r0, #0
    bb62:	d019      	beq.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb64:	1c23      	adds	r3, r4, #0
    bb66:	3348      	adds	r3, #72	; 0x48
    bb68:	2270      	movs	r2, #112	; 0x70
    bb6a:	344a      	adds	r4, #74	; 0x4a
    bb6c:	701a      	strb	r2, [r3, #0]
    bb6e:	8025      	strh	r5, [r4, #0]
    bb70:	e012      	b.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb72:	6d63      	ldr	r3, [r4, #84]	; 0x54
    bb74:	2b00      	cmp	r3, #0
    bb76:	d00f      	beq.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb78:	1c20      	adds	r0, r4, #0
    bb7a:	2102      	movs	r1, #2
    bb7c:	e00a      	b.n	bb94 <_mqtt_recv_handler+0x1ac>
    bb7e:	6d63      	ldr	r3, [r4, #84]	; 0x54
    bb80:	2b00      	cmp	r3, #0
    bb82:	d009      	beq.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb84:	1c20      	adds	r0, r4, #0
    bb86:	2103      	movs	r1, #3
    bb88:	e004      	b.n	bb94 <_mqtt_recv_handler+0x1ac>
    bb8a:	6d63      	ldr	r3, [r4, #84]	; 0x54
    bb8c:	2b00      	cmp	r3, #0
    bb8e:	d003      	beq.n	bb98 <_mqtt_recv_handler+0x1b0>
    bb90:	1c20      	adds	r0, r4, #0
    bb92:	2104      	movs	r1, #4
    bb94:	aa01      	add	r2, sp, #4
    bb96:	4798      	blx	r3
    bb98:	b007      	add	sp, #28
    bb9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bb9c:	0000b945 	.word	0x0000b945
    bba0:	0000b891 	.word	0x0000b891

0000bba4 <mqtt_recv_packet>:
    bba4:	b538      	push	{r3, r4, r5, lr}
    bba6:	1e04      	subs	r4, r0, #0
    bba8:	d017      	beq.n	bbda <mqtt_recv_packet+0x36>
    bbaa:	6c42      	ldr	r2, [r0, #68]	; 0x44
    bbac:	6e83      	ldr	r3, [r0, #104]	; 0x68
    bbae:	429a      	cmp	r2, r3
    bbb0:	d906      	bls.n	bbc0 <mqtt_recv_packet+0x1c>
    bbb2:	238b      	movs	r3, #139	; 0x8b
    bbb4:	425b      	negs	r3, r3
    bbb6:	64c3      	str	r3, [r0, #76]	; 0x4c
    bbb8:	2100      	movs	r1, #0
    bbba:	4b08      	ldr	r3, [pc, #32]	; (bbdc <mqtt_recv_packet+0x38>)
    bbbc:	4798      	blx	r3
    bbbe:	e00c      	b.n	bbda <mqtt_recv_packet+0x36>
    bbc0:	6c62      	ldr	r2, [r4, #68]	; 0x44
    bbc2:	6e63      	ldr	r3, [r4, #100]	; 0x64
    bbc4:	2002      	movs	r0, #2
    bbc6:	1899      	adds	r1, r3, r2
    bbc8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    bbca:	5620      	ldrsb	r0, [r4, r0]
    bbcc:	1a9a      	subs	r2, r3, r2
    bbce:	b292      	uxth	r2, r2
    bbd0:	2300      	movs	r3, #0
    bbd2:	4d03      	ldr	r5, [pc, #12]	; (bbe0 <mqtt_recv_packet+0x3c>)
    bbd4:	47a8      	blx	r5
    bbd6:	2800      	cmp	r0, #0
    bbd8:	d1f2      	bne.n	bbc0 <mqtt_recv_packet+0x1c>
    bbda:	bd38      	pop	{r3, r4, r5, pc}
    bbdc:	0000b945 	.word	0x0000b945
    bbe0:	00003ef1 	.word	0x00003ef1

0000bbe4 <mqtt_recved_packet>:
    bbe4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    bbe6:	1e04      	subs	r4, r0, #0
    bbe8:	d042      	beq.n	bc70 <mqtt_recved_packet+0x8c>
    bbea:	6c63      	ldr	r3, [r4, #68]	; 0x44
    bbec:	6e67      	ldr	r7, [r4, #100]	; 0x64
    bbee:	18ca      	adds	r2, r1, r3
    bbf0:	2301      	movs	r3, #1
    bbf2:	9701      	str	r7, [sp, #4]
    bbf4:	6462      	str	r2, [r4, #68]	; 0x44
    bbf6:	2600      	movs	r6, #0
    bbf8:	1c1d      	adds	r5, r3, #0
    bbfa:	42a9      	cmp	r1, r5
    bbfc:	dc03      	bgt.n	bc06 <mqtt_recved_packet+0x22>
    bbfe:	1c20      	adds	r0, r4, #0
    bc00:	4b1c      	ldr	r3, [pc, #112]	; (bc74 <mqtt_recved_packet+0x90>)
    bc02:	4798      	blx	r3
    bc04:	e034      	b.n	bc70 <mqtt_recved_packet+0x8c>
    bc06:	9f01      	ldr	r7, [sp, #4]
    bc08:	5d78      	ldrb	r0, [r7, r5]
    bc0a:	01df      	lsls	r7, r3, #7
    bc0c:	46bc      	mov	ip, r7
    bc0e:	2d03      	cmp	r5, #3
    bc10:	d101      	bne.n	bc16 <mqtt_recved_packet+0x32>
    bc12:	234d      	movs	r3, #77	; 0x4d
    bc14:	e00e      	b.n	bc34 <mqtt_recved_packet+0x50>
    bc16:	277f      	movs	r7, #127	; 0x7f
    bc18:	4007      	ands	r7, r0
    bc1a:	437b      	muls	r3, r7
    bc1c:	b240      	sxtb	r0, r0
    bc1e:	3501      	adds	r5, #1
    bc20:	18f6      	adds	r6, r6, r3
    bc22:	2800      	cmp	r0, #0
    bc24:	da01      	bge.n	bc2a <mqtt_recved_packet+0x46>
    bc26:	4663      	mov	r3, ip
    bc28:	e7e7      	b.n	bbfa <mqtt_recved_packet+0x16>
    bc2a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    bc2c:	19af      	adds	r7, r5, r6
    bc2e:	429f      	cmp	r7, r3
    bc30:	d907      	bls.n	bc42 <mqtt_recved_packet+0x5e>
    bc32:	238b      	movs	r3, #139	; 0x8b
    bc34:	425b      	negs	r3, r3
    bc36:	64e3      	str	r3, [r4, #76]	; 0x4c
    bc38:	1c20      	adds	r0, r4, #0
    bc3a:	2100      	movs	r1, #0
    bc3c:	4b0e      	ldr	r3, [pc, #56]	; (bc78 <mqtt_recved_packet+0x94>)
    bc3e:	4798      	blx	r3
    bc40:	e016      	b.n	bc70 <mqtt_recved_packet+0x8c>
    bc42:	42ba      	cmp	r2, r7
    bc44:	d314      	bcc.n	bc70 <mqtt_recved_packet+0x8c>
    bc46:	4b0d      	ldr	r3, [pc, #52]	; (bc7c <mqtt_recved_packet+0x98>)
    bc48:	1c20      	adds	r0, r4, #0
    bc4a:	1c31      	adds	r1, r6, #0
    bc4c:	4798      	blx	r3
    bc4e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    bc50:	42bb      	cmp	r3, r7
    bc52:	d102      	bne.n	bc5a <mqtt_recved_packet+0x76>
    bc54:	2300      	movs	r3, #0
    bc56:	6463      	str	r3, [r4, #68]	; 0x44
    bc58:	e00a      	b.n	bc70 <mqtt_recved_packet+0x8c>
    bc5a:	1b9e      	subs	r6, r3, r6
    bc5c:	9b01      	ldr	r3, [sp, #4]
    bc5e:	1b75      	subs	r5, r6, r5
    bc60:	19d9      	adds	r1, r3, r7
    bc62:	1c18      	adds	r0, r3, #0
    bc64:	1c2a      	adds	r2, r5, #0
    bc66:	4b06      	ldr	r3, [pc, #24]	; (bc80 <mqtt_recved_packet+0x9c>)
    bc68:	4798      	blx	r3
    bc6a:	6465      	str	r5, [r4, #68]	; 0x44
    bc6c:	2100      	movs	r1, #0
    bc6e:	e7bc      	b.n	bbea <mqtt_recved_packet+0x6>
    bc70:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    bc72:	46c0      	nop			; (mov r8, r8)
    bc74:	0000bba5 	.word	0x0000bba5
    bc78:	0000b945 	.word	0x0000b945
    bc7c:	0000b9e9 	.word	0x0000b9e9
    bc80:	0000d7fd 	.word	0x0000d7fd

0000bc84 <mqtt_socket_event_handler>:
    bc84:	b570      	push	{r4, r5, r6, lr}
    bc86:	4d37      	ldr	r5, [pc, #220]	; (bd64 <mqtt_socket_event_handler+0xe0>)
    bc88:	0086      	lsls	r6, r0, #2
    bc8a:	5974      	ldr	r4, [r6, r5]
    bc8c:	b086      	sub	sp, #24
    bc8e:	2c00      	cmp	r4, #0
    bc90:	d066      	beq.n	bd60 <mqtt_socket_event_handler+0xdc>
    bc92:	2906      	cmp	r1, #6
    bc94:	d02b      	beq.n	bcee <mqtt_socket_event_handler+0x6a>
    bc96:	2907      	cmp	r1, #7
    bc98:	d039      	beq.n	bd0e <mqtt_socket_event_handler+0x8a>
    bc9a:	2905      	cmp	r1, #5
    bc9c:	d160      	bne.n	bd60 <mqtt_socket_event_handler+0xdc>
    bc9e:	2001      	movs	r0, #1
    bca0:	5610      	ldrsb	r0, [r2, r0]
    bca2:	4b31      	ldr	r3, [pc, #196]	; (bd68 <mqtt_socket_event_handler+0xe4>)
    bca4:	4798      	blx	r3
    bca6:	9001      	str	r0, [sp, #4]
    bca8:	2800      	cmp	r0, #0
    bcaa:	da06      	bge.n	bcba <mqtt_socket_event_handler+0x36>
    bcac:	2002      	movs	r0, #2
    bcae:	4b2f      	ldr	r3, [pc, #188]	; (bd6c <mqtt_socket_event_handler+0xe8>)
    bcb0:	5620      	ldrsb	r0, [r4, r0]
    bcb2:	4798      	blx	r3
    bcb4:	2300      	movs	r3, #0
    bcb6:	5173      	str	r3, [r6, r5]
    bcb8:	e011      	b.n	bcde <mqtt_socket_event_handler+0x5a>
    bcba:	1c23      	adds	r3, r4, #0
    bcbc:	3343      	adds	r3, #67	; 0x43
    bcbe:	781a      	ldrb	r2, [r3, #0]
    bcc0:	2101      	movs	r1, #1
    bcc2:	430a      	orrs	r2, r1
    bcc4:	701a      	strb	r2, [r3, #0]
    bcc6:	331d      	adds	r3, #29
    bcc8:	881b      	ldrh	r3, [r3, #0]
    bcca:	2b00      	cmp	r3, #0
    bccc:	d004      	beq.n	bcd8 <mqtt_socket_event_handler+0x54>
    bcce:	6de0      	ldr	r0, [r4, #92]	; 0x5c
    bcd0:	6d21      	ldr	r1, [r4, #80]	; 0x50
    bcd2:	2200      	movs	r2, #0
    bcd4:	4b26      	ldr	r3, [pc, #152]	; (bd70 <mqtt_socket_event_handler+0xec>)
    bcd6:	4798      	blx	r3
    bcd8:	1c20      	adds	r0, r4, #0
    bcda:	4b26      	ldr	r3, [pc, #152]	; (bd74 <mqtt_socket_event_handler+0xf0>)
    bcdc:	4798      	blx	r3
    bcde:	6d63      	ldr	r3, [r4, #84]	; 0x54
    bce0:	2b00      	cmp	r3, #0
    bce2:	d03d      	beq.n	bd60 <mqtt_socket_event_handler+0xdc>
    bce4:	1c20      	adds	r0, r4, #0
    bce6:	2100      	movs	r1, #0
    bce8:	aa01      	add	r2, sp, #4
    bcea:	4798      	blx	r3
    bcec:	e038      	b.n	bd60 <mqtt_socket_event_handler+0xdc>
    bcee:	2304      	movs	r3, #4
    bcf0:	5ed1      	ldrsh	r1, [r2, r3]
    bcf2:	2900      	cmp	r1, #0
    bcf4:	dd03      	ble.n	bcfe <mqtt_socket_event_handler+0x7a>
    bcf6:	1c20      	adds	r0, r4, #0
    bcf8:	4b1f      	ldr	r3, [pc, #124]	; (bd78 <mqtt_socket_event_handler+0xf4>)
    bcfa:	4798      	blx	r3
    bcfc:	e003      	b.n	bd06 <mqtt_socket_event_handler+0x82>
    bcfe:	1c0b      	adds	r3, r1, #0
    bd00:	1c08      	adds	r0, r1, #0
    bd02:	330d      	adds	r3, #13
    bd04:	d11a      	bne.n	bd3c <mqtt_socket_event_handler+0xb8>
    bd06:	4b1b      	ldr	r3, [pc, #108]	; (bd74 <mqtt_socket_event_handler+0xf0>)
    bd08:	1c20      	adds	r0, r4, #0
    bd0a:	4798      	blx	r3
    bd0c:	e028      	b.n	bd60 <mqtt_socket_event_handler+0xdc>
    bd0e:	1c23      	adds	r3, r4, #0
    bd10:	3343      	adds	r3, #67	; 0x43
    bd12:	8810      	ldrh	r0, [r2, #0]
    bd14:	781a      	ldrb	r2, [r3, #0]
    bd16:	0751      	lsls	r1, r2, #29
    bd18:	d402      	bmi.n	bd20 <mqtt_socket_event_handler+0x9c>
    bd1a:	2108      	movs	r1, #8
    bd1c:	438a      	bics	r2, r1
    bd1e:	701a      	strb	r2, [r3, #0]
    bd20:	781a      	ldrb	r2, [r3, #0]
    bd22:	2104      	movs	r1, #4
    bd24:	438a      	bics	r2, r1
    bd26:	701a      	strb	r2, [r3, #0]
    bd28:	06d3      	lsls	r3, r2, #27
    bd2a:	0fde      	lsrs	r6, r3, #31
    bd2c:	b200      	sxth	r0, r0
    bd2e:	2b00      	cmp	r3, #0
    bd30:	db02      	blt.n	bd38 <mqtt_socket_event_handler+0xb4>
    bd32:	2800      	cmp	r0, #0
    bd34:	da08      	bge.n	bd48 <mqtt_socket_event_handler+0xc4>
    bd36:	e001      	b.n	bd3c <mqtt_socket_event_handler+0xb8>
    bd38:	2800      	cmp	r0, #0
    bd3a:	da02      	bge.n	bd42 <mqtt_socket_event_handler+0xbe>
    bd3c:	4b0a      	ldr	r3, [pc, #40]	; (bd68 <mqtt_socket_event_handler+0xe4>)
    bd3e:	4798      	blx	r3
    bd40:	64e0      	str	r0, [r4, #76]	; 0x4c
    bd42:	1c20      	adds	r0, r4, #0
    bd44:	4b0d      	ldr	r3, [pc, #52]	; (bd7c <mqtt_socket_event_handler+0xf8>)
    bd46:	e7e0      	b.n	bd0a <mqtt_socket_event_handler+0x86>
    bd48:	1c25      	adds	r5, r4, #0
    bd4a:	3548      	adds	r5, #72	; 0x48
    bd4c:	7829      	ldrb	r1, [r5, #0]
    bd4e:	2900      	cmp	r1, #0
    bd50:	d006      	beq.n	bd60 <mqtt_socket_event_handler+0xdc>
    bd52:	1c23      	adds	r3, r4, #0
    bd54:	334a      	adds	r3, #74	; 0x4a
    bd56:	881a      	ldrh	r2, [r3, #0]
    bd58:	1c20      	adds	r0, r4, #0
    bd5a:	4b09      	ldr	r3, [pc, #36]	; (bd80 <mqtt_socket_event_handler+0xfc>)
    bd5c:	4798      	blx	r3
    bd5e:	702e      	strb	r6, [r5, #0]
    bd60:	b006      	add	sp, #24
    bd62:	bd70      	pop	{r4, r5, r6, pc}
    bd64:	200006a0 	.word	0x200006a0
    bd68:	0000b0c5 	.word	0x0000b0c5
    bd6c:	00003f8d 	.word	0x00003f8d
    bd70:	00006565 	.word	0x00006565
    bd74:	0000bba5 	.word	0x0000bba5
    bd78:	0000bbe5 	.word	0x0000bbe5
    bd7c:	0000b8f5 	.word	0x0000b8f5
    bd80:	0000b891 	.word	0x0000b891

0000bd84 <__gnu_thumb1_case_sqi>:
    bd84:	b402      	push	{r1}
    bd86:	4671      	mov	r1, lr
    bd88:	0849      	lsrs	r1, r1, #1
    bd8a:	0049      	lsls	r1, r1, #1
    bd8c:	5609      	ldrsb	r1, [r1, r0]
    bd8e:	0049      	lsls	r1, r1, #1
    bd90:	448e      	add	lr, r1
    bd92:	bc02      	pop	{r1}
    bd94:	4770      	bx	lr
    bd96:	46c0      	nop			; (mov r8, r8)

0000bd98 <__gnu_thumb1_case_uqi>:
    bd98:	b402      	push	{r1}
    bd9a:	4671      	mov	r1, lr
    bd9c:	0849      	lsrs	r1, r1, #1
    bd9e:	0049      	lsls	r1, r1, #1
    bda0:	5c09      	ldrb	r1, [r1, r0]
    bda2:	0049      	lsls	r1, r1, #1
    bda4:	448e      	add	lr, r1
    bda6:	bc02      	pop	{r1}
    bda8:	4770      	bx	lr
    bdaa:	46c0      	nop			; (mov r8, r8)

0000bdac <__aeabi_uidiv>:
    bdac:	2200      	movs	r2, #0
    bdae:	0843      	lsrs	r3, r0, #1
    bdb0:	428b      	cmp	r3, r1
    bdb2:	d374      	bcc.n	be9e <__aeabi_uidiv+0xf2>
    bdb4:	0903      	lsrs	r3, r0, #4
    bdb6:	428b      	cmp	r3, r1
    bdb8:	d35f      	bcc.n	be7a <__aeabi_uidiv+0xce>
    bdba:	0a03      	lsrs	r3, r0, #8
    bdbc:	428b      	cmp	r3, r1
    bdbe:	d344      	bcc.n	be4a <__aeabi_uidiv+0x9e>
    bdc0:	0b03      	lsrs	r3, r0, #12
    bdc2:	428b      	cmp	r3, r1
    bdc4:	d328      	bcc.n	be18 <__aeabi_uidiv+0x6c>
    bdc6:	0c03      	lsrs	r3, r0, #16
    bdc8:	428b      	cmp	r3, r1
    bdca:	d30d      	bcc.n	bde8 <__aeabi_uidiv+0x3c>
    bdcc:	22ff      	movs	r2, #255	; 0xff
    bdce:	0209      	lsls	r1, r1, #8
    bdd0:	ba12      	rev	r2, r2
    bdd2:	0c03      	lsrs	r3, r0, #16
    bdd4:	428b      	cmp	r3, r1
    bdd6:	d302      	bcc.n	bdde <__aeabi_uidiv+0x32>
    bdd8:	1212      	asrs	r2, r2, #8
    bdda:	0209      	lsls	r1, r1, #8
    bddc:	d065      	beq.n	beaa <__aeabi_uidiv+0xfe>
    bdde:	0b03      	lsrs	r3, r0, #12
    bde0:	428b      	cmp	r3, r1
    bde2:	d319      	bcc.n	be18 <__aeabi_uidiv+0x6c>
    bde4:	e000      	b.n	bde8 <__aeabi_uidiv+0x3c>
    bde6:	0a09      	lsrs	r1, r1, #8
    bde8:	0bc3      	lsrs	r3, r0, #15
    bdea:	428b      	cmp	r3, r1
    bdec:	d301      	bcc.n	bdf2 <__aeabi_uidiv+0x46>
    bdee:	03cb      	lsls	r3, r1, #15
    bdf0:	1ac0      	subs	r0, r0, r3
    bdf2:	4152      	adcs	r2, r2
    bdf4:	0b83      	lsrs	r3, r0, #14
    bdf6:	428b      	cmp	r3, r1
    bdf8:	d301      	bcc.n	bdfe <__aeabi_uidiv+0x52>
    bdfa:	038b      	lsls	r3, r1, #14
    bdfc:	1ac0      	subs	r0, r0, r3
    bdfe:	4152      	adcs	r2, r2
    be00:	0b43      	lsrs	r3, r0, #13
    be02:	428b      	cmp	r3, r1
    be04:	d301      	bcc.n	be0a <__aeabi_uidiv+0x5e>
    be06:	034b      	lsls	r3, r1, #13
    be08:	1ac0      	subs	r0, r0, r3
    be0a:	4152      	adcs	r2, r2
    be0c:	0b03      	lsrs	r3, r0, #12
    be0e:	428b      	cmp	r3, r1
    be10:	d301      	bcc.n	be16 <__aeabi_uidiv+0x6a>
    be12:	030b      	lsls	r3, r1, #12
    be14:	1ac0      	subs	r0, r0, r3
    be16:	4152      	adcs	r2, r2
    be18:	0ac3      	lsrs	r3, r0, #11
    be1a:	428b      	cmp	r3, r1
    be1c:	d301      	bcc.n	be22 <__aeabi_uidiv+0x76>
    be1e:	02cb      	lsls	r3, r1, #11
    be20:	1ac0      	subs	r0, r0, r3
    be22:	4152      	adcs	r2, r2
    be24:	0a83      	lsrs	r3, r0, #10
    be26:	428b      	cmp	r3, r1
    be28:	d301      	bcc.n	be2e <__aeabi_uidiv+0x82>
    be2a:	028b      	lsls	r3, r1, #10
    be2c:	1ac0      	subs	r0, r0, r3
    be2e:	4152      	adcs	r2, r2
    be30:	0a43      	lsrs	r3, r0, #9
    be32:	428b      	cmp	r3, r1
    be34:	d301      	bcc.n	be3a <__aeabi_uidiv+0x8e>
    be36:	024b      	lsls	r3, r1, #9
    be38:	1ac0      	subs	r0, r0, r3
    be3a:	4152      	adcs	r2, r2
    be3c:	0a03      	lsrs	r3, r0, #8
    be3e:	428b      	cmp	r3, r1
    be40:	d301      	bcc.n	be46 <__aeabi_uidiv+0x9a>
    be42:	020b      	lsls	r3, r1, #8
    be44:	1ac0      	subs	r0, r0, r3
    be46:	4152      	adcs	r2, r2
    be48:	d2cd      	bcs.n	bde6 <__aeabi_uidiv+0x3a>
    be4a:	09c3      	lsrs	r3, r0, #7
    be4c:	428b      	cmp	r3, r1
    be4e:	d301      	bcc.n	be54 <__aeabi_uidiv+0xa8>
    be50:	01cb      	lsls	r3, r1, #7
    be52:	1ac0      	subs	r0, r0, r3
    be54:	4152      	adcs	r2, r2
    be56:	0983      	lsrs	r3, r0, #6
    be58:	428b      	cmp	r3, r1
    be5a:	d301      	bcc.n	be60 <__aeabi_uidiv+0xb4>
    be5c:	018b      	lsls	r3, r1, #6
    be5e:	1ac0      	subs	r0, r0, r3
    be60:	4152      	adcs	r2, r2
    be62:	0943      	lsrs	r3, r0, #5
    be64:	428b      	cmp	r3, r1
    be66:	d301      	bcc.n	be6c <__aeabi_uidiv+0xc0>
    be68:	014b      	lsls	r3, r1, #5
    be6a:	1ac0      	subs	r0, r0, r3
    be6c:	4152      	adcs	r2, r2
    be6e:	0903      	lsrs	r3, r0, #4
    be70:	428b      	cmp	r3, r1
    be72:	d301      	bcc.n	be78 <__aeabi_uidiv+0xcc>
    be74:	010b      	lsls	r3, r1, #4
    be76:	1ac0      	subs	r0, r0, r3
    be78:	4152      	adcs	r2, r2
    be7a:	08c3      	lsrs	r3, r0, #3
    be7c:	428b      	cmp	r3, r1
    be7e:	d301      	bcc.n	be84 <__aeabi_uidiv+0xd8>
    be80:	00cb      	lsls	r3, r1, #3
    be82:	1ac0      	subs	r0, r0, r3
    be84:	4152      	adcs	r2, r2
    be86:	0883      	lsrs	r3, r0, #2
    be88:	428b      	cmp	r3, r1
    be8a:	d301      	bcc.n	be90 <__aeabi_uidiv+0xe4>
    be8c:	008b      	lsls	r3, r1, #2
    be8e:	1ac0      	subs	r0, r0, r3
    be90:	4152      	adcs	r2, r2
    be92:	0843      	lsrs	r3, r0, #1
    be94:	428b      	cmp	r3, r1
    be96:	d301      	bcc.n	be9c <__aeabi_uidiv+0xf0>
    be98:	004b      	lsls	r3, r1, #1
    be9a:	1ac0      	subs	r0, r0, r3
    be9c:	4152      	adcs	r2, r2
    be9e:	1a41      	subs	r1, r0, r1
    bea0:	d200      	bcs.n	bea4 <__aeabi_uidiv+0xf8>
    bea2:	4601      	mov	r1, r0
    bea4:	4152      	adcs	r2, r2
    bea6:	4610      	mov	r0, r2
    bea8:	4770      	bx	lr
    beaa:	e7ff      	b.n	beac <__aeabi_uidiv+0x100>
    beac:	b501      	push	{r0, lr}
    beae:	2000      	movs	r0, #0
    beb0:	f000 f8fc 	bl	c0ac <__aeabi_idiv0>
    beb4:	bd02      	pop	{r1, pc}
    beb6:	46c0      	nop			; (mov r8, r8)

0000beb8 <__aeabi_uidivmod>:
    beb8:	2900      	cmp	r1, #0
    beba:	d0f7      	beq.n	beac <__aeabi_uidiv+0x100>
    bebc:	b503      	push	{r0, r1, lr}
    bebe:	f7ff ff75 	bl	bdac <__aeabi_uidiv>
    bec2:	bc0e      	pop	{r1, r2, r3}
    bec4:	4342      	muls	r2, r0
    bec6:	1a89      	subs	r1, r1, r2
    bec8:	4718      	bx	r3
    beca:	46c0      	nop			; (mov r8, r8)

0000becc <__aeabi_idiv>:
    becc:	4603      	mov	r3, r0
    bece:	430b      	orrs	r3, r1
    bed0:	d47f      	bmi.n	bfd2 <__aeabi_idiv+0x106>
    bed2:	2200      	movs	r2, #0
    bed4:	0843      	lsrs	r3, r0, #1
    bed6:	428b      	cmp	r3, r1
    bed8:	d374      	bcc.n	bfc4 <__aeabi_idiv+0xf8>
    beda:	0903      	lsrs	r3, r0, #4
    bedc:	428b      	cmp	r3, r1
    bede:	d35f      	bcc.n	bfa0 <__aeabi_idiv+0xd4>
    bee0:	0a03      	lsrs	r3, r0, #8
    bee2:	428b      	cmp	r3, r1
    bee4:	d344      	bcc.n	bf70 <__aeabi_idiv+0xa4>
    bee6:	0b03      	lsrs	r3, r0, #12
    bee8:	428b      	cmp	r3, r1
    beea:	d328      	bcc.n	bf3e <__aeabi_idiv+0x72>
    beec:	0c03      	lsrs	r3, r0, #16
    beee:	428b      	cmp	r3, r1
    bef0:	d30d      	bcc.n	bf0e <__aeabi_idiv+0x42>
    bef2:	22ff      	movs	r2, #255	; 0xff
    bef4:	0209      	lsls	r1, r1, #8
    bef6:	ba12      	rev	r2, r2
    bef8:	0c03      	lsrs	r3, r0, #16
    befa:	428b      	cmp	r3, r1
    befc:	d302      	bcc.n	bf04 <__aeabi_idiv+0x38>
    befe:	1212      	asrs	r2, r2, #8
    bf00:	0209      	lsls	r1, r1, #8
    bf02:	d065      	beq.n	bfd0 <__aeabi_idiv+0x104>
    bf04:	0b03      	lsrs	r3, r0, #12
    bf06:	428b      	cmp	r3, r1
    bf08:	d319      	bcc.n	bf3e <__aeabi_idiv+0x72>
    bf0a:	e000      	b.n	bf0e <__aeabi_idiv+0x42>
    bf0c:	0a09      	lsrs	r1, r1, #8
    bf0e:	0bc3      	lsrs	r3, r0, #15
    bf10:	428b      	cmp	r3, r1
    bf12:	d301      	bcc.n	bf18 <__aeabi_idiv+0x4c>
    bf14:	03cb      	lsls	r3, r1, #15
    bf16:	1ac0      	subs	r0, r0, r3
    bf18:	4152      	adcs	r2, r2
    bf1a:	0b83      	lsrs	r3, r0, #14
    bf1c:	428b      	cmp	r3, r1
    bf1e:	d301      	bcc.n	bf24 <__aeabi_idiv+0x58>
    bf20:	038b      	lsls	r3, r1, #14
    bf22:	1ac0      	subs	r0, r0, r3
    bf24:	4152      	adcs	r2, r2
    bf26:	0b43      	lsrs	r3, r0, #13
    bf28:	428b      	cmp	r3, r1
    bf2a:	d301      	bcc.n	bf30 <__aeabi_idiv+0x64>
    bf2c:	034b      	lsls	r3, r1, #13
    bf2e:	1ac0      	subs	r0, r0, r3
    bf30:	4152      	adcs	r2, r2
    bf32:	0b03      	lsrs	r3, r0, #12
    bf34:	428b      	cmp	r3, r1
    bf36:	d301      	bcc.n	bf3c <__aeabi_idiv+0x70>
    bf38:	030b      	lsls	r3, r1, #12
    bf3a:	1ac0      	subs	r0, r0, r3
    bf3c:	4152      	adcs	r2, r2
    bf3e:	0ac3      	lsrs	r3, r0, #11
    bf40:	428b      	cmp	r3, r1
    bf42:	d301      	bcc.n	bf48 <__aeabi_idiv+0x7c>
    bf44:	02cb      	lsls	r3, r1, #11
    bf46:	1ac0      	subs	r0, r0, r3
    bf48:	4152      	adcs	r2, r2
    bf4a:	0a83      	lsrs	r3, r0, #10
    bf4c:	428b      	cmp	r3, r1
    bf4e:	d301      	bcc.n	bf54 <__aeabi_idiv+0x88>
    bf50:	028b      	lsls	r3, r1, #10
    bf52:	1ac0      	subs	r0, r0, r3
    bf54:	4152      	adcs	r2, r2
    bf56:	0a43      	lsrs	r3, r0, #9
    bf58:	428b      	cmp	r3, r1
    bf5a:	d301      	bcc.n	bf60 <__aeabi_idiv+0x94>
    bf5c:	024b      	lsls	r3, r1, #9
    bf5e:	1ac0      	subs	r0, r0, r3
    bf60:	4152      	adcs	r2, r2
    bf62:	0a03      	lsrs	r3, r0, #8
    bf64:	428b      	cmp	r3, r1
    bf66:	d301      	bcc.n	bf6c <__aeabi_idiv+0xa0>
    bf68:	020b      	lsls	r3, r1, #8
    bf6a:	1ac0      	subs	r0, r0, r3
    bf6c:	4152      	adcs	r2, r2
    bf6e:	d2cd      	bcs.n	bf0c <__aeabi_idiv+0x40>
    bf70:	09c3      	lsrs	r3, r0, #7
    bf72:	428b      	cmp	r3, r1
    bf74:	d301      	bcc.n	bf7a <__aeabi_idiv+0xae>
    bf76:	01cb      	lsls	r3, r1, #7
    bf78:	1ac0      	subs	r0, r0, r3
    bf7a:	4152      	adcs	r2, r2
    bf7c:	0983      	lsrs	r3, r0, #6
    bf7e:	428b      	cmp	r3, r1
    bf80:	d301      	bcc.n	bf86 <__aeabi_idiv+0xba>
    bf82:	018b      	lsls	r3, r1, #6
    bf84:	1ac0      	subs	r0, r0, r3
    bf86:	4152      	adcs	r2, r2
    bf88:	0943      	lsrs	r3, r0, #5
    bf8a:	428b      	cmp	r3, r1
    bf8c:	d301      	bcc.n	bf92 <__aeabi_idiv+0xc6>
    bf8e:	014b      	lsls	r3, r1, #5
    bf90:	1ac0      	subs	r0, r0, r3
    bf92:	4152      	adcs	r2, r2
    bf94:	0903      	lsrs	r3, r0, #4
    bf96:	428b      	cmp	r3, r1
    bf98:	d301      	bcc.n	bf9e <__aeabi_idiv+0xd2>
    bf9a:	010b      	lsls	r3, r1, #4
    bf9c:	1ac0      	subs	r0, r0, r3
    bf9e:	4152      	adcs	r2, r2
    bfa0:	08c3      	lsrs	r3, r0, #3
    bfa2:	428b      	cmp	r3, r1
    bfa4:	d301      	bcc.n	bfaa <__aeabi_idiv+0xde>
    bfa6:	00cb      	lsls	r3, r1, #3
    bfa8:	1ac0      	subs	r0, r0, r3
    bfaa:	4152      	adcs	r2, r2
    bfac:	0883      	lsrs	r3, r0, #2
    bfae:	428b      	cmp	r3, r1
    bfb0:	d301      	bcc.n	bfb6 <__aeabi_idiv+0xea>
    bfb2:	008b      	lsls	r3, r1, #2
    bfb4:	1ac0      	subs	r0, r0, r3
    bfb6:	4152      	adcs	r2, r2
    bfb8:	0843      	lsrs	r3, r0, #1
    bfba:	428b      	cmp	r3, r1
    bfbc:	d301      	bcc.n	bfc2 <__aeabi_idiv+0xf6>
    bfbe:	004b      	lsls	r3, r1, #1
    bfc0:	1ac0      	subs	r0, r0, r3
    bfc2:	4152      	adcs	r2, r2
    bfc4:	1a41      	subs	r1, r0, r1
    bfc6:	d200      	bcs.n	bfca <__aeabi_idiv+0xfe>
    bfc8:	4601      	mov	r1, r0
    bfca:	4152      	adcs	r2, r2
    bfcc:	4610      	mov	r0, r2
    bfce:	4770      	bx	lr
    bfd0:	e05d      	b.n	c08e <__aeabi_idiv+0x1c2>
    bfd2:	0fca      	lsrs	r2, r1, #31
    bfd4:	d000      	beq.n	bfd8 <__aeabi_idiv+0x10c>
    bfd6:	4249      	negs	r1, r1
    bfd8:	1003      	asrs	r3, r0, #32
    bfda:	d300      	bcc.n	bfde <__aeabi_idiv+0x112>
    bfdc:	4240      	negs	r0, r0
    bfde:	4053      	eors	r3, r2
    bfe0:	2200      	movs	r2, #0
    bfe2:	469c      	mov	ip, r3
    bfe4:	0903      	lsrs	r3, r0, #4
    bfe6:	428b      	cmp	r3, r1
    bfe8:	d32d      	bcc.n	c046 <__aeabi_idiv+0x17a>
    bfea:	0a03      	lsrs	r3, r0, #8
    bfec:	428b      	cmp	r3, r1
    bfee:	d312      	bcc.n	c016 <__aeabi_idiv+0x14a>
    bff0:	22fc      	movs	r2, #252	; 0xfc
    bff2:	0189      	lsls	r1, r1, #6
    bff4:	ba12      	rev	r2, r2
    bff6:	0a03      	lsrs	r3, r0, #8
    bff8:	428b      	cmp	r3, r1
    bffa:	d30c      	bcc.n	c016 <__aeabi_idiv+0x14a>
    bffc:	0189      	lsls	r1, r1, #6
    bffe:	1192      	asrs	r2, r2, #6
    c000:	428b      	cmp	r3, r1
    c002:	d308      	bcc.n	c016 <__aeabi_idiv+0x14a>
    c004:	0189      	lsls	r1, r1, #6
    c006:	1192      	asrs	r2, r2, #6
    c008:	428b      	cmp	r3, r1
    c00a:	d304      	bcc.n	c016 <__aeabi_idiv+0x14a>
    c00c:	0189      	lsls	r1, r1, #6
    c00e:	d03a      	beq.n	c086 <__aeabi_idiv+0x1ba>
    c010:	1192      	asrs	r2, r2, #6
    c012:	e000      	b.n	c016 <__aeabi_idiv+0x14a>
    c014:	0989      	lsrs	r1, r1, #6
    c016:	09c3      	lsrs	r3, r0, #7
    c018:	428b      	cmp	r3, r1
    c01a:	d301      	bcc.n	c020 <__aeabi_idiv+0x154>
    c01c:	01cb      	lsls	r3, r1, #7
    c01e:	1ac0      	subs	r0, r0, r3
    c020:	4152      	adcs	r2, r2
    c022:	0983      	lsrs	r3, r0, #6
    c024:	428b      	cmp	r3, r1
    c026:	d301      	bcc.n	c02c <__aeabi_idiv+0x160>
    c028:	018b      	lsls	r3, r1, #6
    c02a:	1ac0      	subs	r0, r0, r3
    c02c:	4152      	adcs	r2, r2
    c02e:	0943      	lsrs	r3, r0, #5
    c030:	428b      	cmp	r3, r1
    c032:	d301      	bcc.n	c038 <__aeabi_idiv+0x16c>
    c034:	014b      	lsls	r3, r1, #5
    c036:	1ac0      	subs	r0, r0, r3
    c038:	4152      	adcs	r2, r2
    c03a:	0903      	lsrs	r3, r0, #4
    c03c:	428b      	cmp	r3, r1
    c03e:	d301      	bcc.n	c044 <__aeabi_idiv+0x178>
    c040:	010b      	lsls	r3, r1, #4
    c042:	1ac0      	subs	r0, r0, r3
    c044:	4152      	adcs	r2, r2
    c046:	08c3      	lsrs	r3, r0, #3
    c048:	428b      	cmp	r3, r1
    c04a:	d301      	bcc.n	c050 <__aeabi_idiv+0x184>
    c04c:	00cb      	lsls	r3, r1, #3
    c04e:	1ac0      	subs	r0, r0, r3
    c050:	4152      	adcs	r2, r2
    c052:	0883      	lsrs	r3, r0, #2
    c054:	428b      	cmp	r3, r1
    c056:	d301      	bcc.n	c05c <__aeabi_idiv+0x190>
    c058:	008b      	lsls	r3, r1, #2
    c05a:	1ac0      	subs	r0, r0, r3
    c05c:	4152      	adcs	r2, r2
    c05e:	d2d9      	bcs.n	c014 <__aeabi_idiv+0x148>
    c060:	0843      	lsrs	r3, r0, #1
    c062:	428b      	cmp	r3, r1
    c064:	d301      	bcc.n	c06a <__aeabi_idiv+0x19e>
    c066:	004b      	lsls	r3, r1, #1
    c068:	1ac0      	subs	r0, r0, r3
    c06a:	4152      	adcs	r2, r2
    c06c:	1a41      	subs	r1, r0, r1
    c06e:	d200      	bcs.n	c072 <__aeabi_idiv+0x1a6>
    c070:	4601      	mov	r1, r0
    c072:	4663      	mov	r3, ip
    c074:	4152      	adcs	r2, r2
    c076:	105b      	asrs	r3, r3, #1
    c078:	4610      	mov	r0, r2
    c07a:	d301      	bcc.n	c080 <__aeabi_idiv+0x1b4>
    c07c:	4240      	negs	r0, r0
    c07e:	2b00      	cmp	r3, #0
    c080:	d500      	bpl.n	c084 <__aeabi_idiv+0x1b8>
    c082:	4249      	negs	r1, r1
    c084:	4770      	bx	lr
    c086:	4663      	mov	r3, ip
    c088:	105b      	asrs	r3, r3, #1
    c08a:	d300      	bcc.n	c08e <__aeabi_idiv+0x1c2>
    c08c:	4240      	negs	r0, r0
    c08e:	b501      	push	{r0, lr}
    c090:	2000      	movs	r0, #0
    c092:	f000 f80b 	bl	c0ac <__aeabi_idiv0>
    c096:	bd02      	pop	{r1, pc}

0000c098 <__aeabi_idivmod>:
    c098:	2900      	cmp	r1, #0
    c09a:	d0f8      	beq.n	c08e <__aeabi_idiv+0x1c2>
    c09c:	b503      	push	{r0, r1, lr}
    c09e:	f7ff ff15 	bl	becc <__aeabi_idiv>
    c0a2:	bc0e      	pop	{r1, r2, r3}
    c0a4:	4342      	muls	r2, r0
    c0a6:	1a89      	subs	r1, r1, r2
    c0a8:	4718      	bx	r3
    c0aa:	46c0      	nop			; (mov r8, r8)

0000c0ac <__aeabi_idiv0>:
    c0ac:	4770      	bx	lr
    c0ae:	46c0      	nop			; (mov r8, r8)

0000c0b0 <__aeabi_lmul>:
    c0b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    c0b2:	464f      	mov	r7, r9
    c0b4:	4646      	mov	r6, r8
    c0b6:	0405      	lsls	r5, r0, #16
    c0b8:	0c2d      	lsrs	r5, r5, #16
    c0ba:	1c2c      	adds	r4, r5, #0
    c0bc:	b4c0      	push	{r6, r7}
    c0be:	0417      	lsls	r7, r2, #16
    c0c0:	0c16      	lsrs	r6, r2, #16
    c0c2:	0c3f      	lsrs	r7, r7, #16
    c0c4:	4699      	mov	r9, r3
    c0c6:	0c03      	lsrs	r3, r0, #16
    c0c8:	437c      	muls	r4, r7
    c0ca:	4375      	muls	r5, r6
    c0cc:	435f      	muls	r7, r3
    c0ce:	4373      	muls	r3, r6
    c0d0:	197d      	adds	r5, r7, r5
    c0d2:	0c26      	lsrs	r6, r4, #16
    c0d4:	19ad      	adds	r5, r5, r6
    c0d6:	469c      	mov	ip, r3
    c0d8:	42af      	cmp	r7, r5
    c0da:	d903      	bls.n	c0e4 <__aeabi_lmul+0x34>
    c0dc:	2380      	movs	r3, #128	; 0x80
    c0de:	025b      	lsls	r3, r3, #9
    c0e0:	4698      	mov	r8, r3
    c0e2:	44c4      	add	ip, r8
    c0e4:	464b      	mov	r3, r9
    c0e6:	4351      	muls	r1, r2
    c0e8:	4343      	muls	r3, r0
    c0ea:	0424      	lsls	r4, r4, #16
    c0ec:	0c2e      	lsrs	r6, r5, #16
    c0ee:	0c24      	lsrs	r4, r4, #16
    c0f0:	042d      	lsls	r5, r5, #16
    c0f2:	4466      	add	r6, ip
    c0f4:	192c      	adds	r4, r5, r4
    c0f6:	1859      	adds	r1, r3, r1
    c0f8:	1989      	adds	r1, r1, r6
    c0fa:	1c20      	adds	r0, r4, #0
    c0fc:	bc0c      	pop	{r2, r3}
    c0fe:	4690      	mov	r8, r2
    c100:	4699      	mov	r9, r3
    c102:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000c104 <__aeabi_d2uiz>:
    c104:	b538      	push	{r3, r4, r5, lr}
    c106:	2200      	movs	r2, #0
    c108:	4b0c      	ldr	r3, [pc, #48]	; (c13c <__aeabi_d2uiz+0x38>)
    c10a:	1c04      	adds	r4, r0, #0
    c10c:	1c0d      	adds	r5, r1, #0
    c10e:	f001 f9eb 	bl	d4e8 <__aeabi_dcmpge>
    c112:	2800      	cmp	r0, #0
    c114:	d104      	bne.n	c120 <__aeabi_d2uiz+0x1c>
    c116:	1c20      	adds	r0, r4, #0
    c118:	1c29      	adds	r1, r5, #0
    c11a:	f001 f949 	bl	d3b0 <__aeabi_d2iz>
    c11e:	bd38      	pop	{r3, r4, r5, pc}
    c120:	4b06      	ldr	r3, [pc, #24]	; (c13c <__aeabi_d2uiz+0x38>)
    c122:	2200      	movs	r2, #0
    c124:	1c20      	adds	r0, r4, #0
    c126:	1c29      	adds	r1, r5, #0
    c128:	f000 fdc8 	bl	ccbc <__aeabi_dsub>
    c12c:	f001 f940 	bl	d3b0 <__aeabi_d2iz>
    c130:	2380      	movs	r3, #128	; 0x80
    c132:	061b      	lsls	r3, r3, #24
    c134:	469c      	mov	ip, r3
    c136:	4460      	add	r0, ip
    c138:	e7f1      	b.n	c11e <__aeabi_d2uiz+0x1a>
    c13a:	46c0      	nop			; (mov r8, r8)
    c13c:	41e00000 	.word	0x41e00000

0000c140 <__aeabi_ddiv>:
    c140:	b5f0      	push	{r4, r5, r6, r7, lr}
    c142:	465f      	mov	r7, fp
    c144:	4656      	mov	r6, sl
    c146:	464d      	mov	r5, r9
    c148:	4644      	mov	r4, r8
    c14a:	b4f0      	push	{r4, r5, r6, r7}
    c14c:	030f      	lsls	r7, r1, #12
    c14e:	b087      	sub	sp, #28
    c150:	4698      	mov	r8, r3
    c152:	004d      	lsls	r5, r1, #1
    c154:	0b3b      	lsrs	r3, r7, #12
    c156:	0fcc      	lsrs	r4, r1, #31
    c158:	1c06      	adds	r6, r0, #0
    c15a:	4692      	mov	sl, r2
    c15c:	4681      	mov	r9, r0
    c15e:	469b      	mov	fp, r3
    c160:	0d6d      	lsrs	r5, r5, #21
    c162:	9401      	str	r4, [sp, #4]
    c164:	d06b      	beq.n	c23e <__aeabi_ddiv+0xfe>
    c166:	4b66      	ldr	r3, [pc, #408]	; (c300 <__aeabi_ddiv+0x1c0>)
    c168:	429d      	cmp	r5, r3
    c16a:	d035      	beq.n	c1d8 <__aeabi_ddiv+0x98>
    c16c:	2780      	movs	r7, #128	; 0x80
    c16e:	465b      	mov	r3, fp
    c170:	037f      	lsls	r7, r7, #13
    c172:	431f      	orrs	r7, r3
    c174:	00f3      	lsls	r3, r6, #3
    c176:	4699      	mov	r9, r3
    c178:	4b62      	ldr	r3, [pc, #392]	; (c304 <__aeabi_ddiv+0x1c4>)
    c17a:	00ff      	lsls	r7, r7, #3
    c17c:	0f40      	lsrs	r0, r0, #29
    c17e:	469c      	mov	ip, r3
    c180:	4307      	orrs	r7, r0
    c182:	2300      	movs	r3, #0
    c184:	46bb      	mov	fp, r7
    c186:	2600      	movs	r6, #0
    c188:	4465      	add	r5, ip
    c18a:	9300      	str	r3, [sp, #0]
    c18c:	4642      	mov	r2, r8
    c18e:	0317      	lsls	r7, r2, #12
    c190:	0050      	lsls	r0, r2, #1
    c192:	0fd2      	lsrs	r2, r2, #31
    c194:	4653      	mov	r3, sl
    c196:	0b3f      	lsrs	r7, r7, #12
    c198:	0d40      	lsrs	r0, r0, #21
    c19a:	4690      	mov	r8, r2
    c19c:	d100      	bne.n	c1a0 <__aeabi_ddiv+0x60>
    c19e:	e072      	b.n	c286 <__aeabi_ddiv+0x146>
    c1a0:	4a57      	ldr	r2, [pc, #348]	; (c300 <__aeabi_ddiv+0x1c0>)
    c1a2:	4290      	cmp	r0, r2
    c1a4:	d067      	beq.n	c276 <__aeabi_ddiv+0x136>
    c1a6:	2380      	movs	r3, #128	; 0x80
    c1a8:	035b      	lsls	r3, r3, #13
    c1aa:	431f      	orrs	r7, r3
    c1ac:	4653      	mov	r3, sl
    c1ae:	4a55      	ldr	r2, [pc, #340]	; (c304 <__aeabi_ddiv+0x1c4>)
    c1b0:	0f5b      	lsrs	r3, r3, #29
    c1b2:	00ff      	lsls	r7, r7, #3
    c1b4:	431f      	orrs	r7, r3
    c1b6:	4694      	mov	ip, r2
    c1b8:	4653      	mov	r3, sl
    c1ba:	2100      	movs	r1, #0
    c1bc:	00db      	lsls	r3, r3, #3
    c1be:	4460      	add	r0, ip
    c1c0:	4642      	mov	r2, r8
    c1c2:	4062      	eors	r2, r4
    c1c4:	4692      	mov	sl, r2
    c1c6:	1a2d      	subs	r5, r5, r0
    c1c8:	430e      	orrs	r6, r1
    c1ca:	2e0f      	cmp	r6, #15
    c1cc:	d900      	bls.n	c1d0 <__aeabi_ddiv+0x90>
    c1ce:	e0a1      	b.n	c314 <__aeabi_ddiv+0x1d4>
    c1d0:	484d      	ldr	r0, [pc, #308]	; (c308 <__aeabi_ddiv+0x1c8>)
    c1d2:	00b6      	lsls	r6, r6, #2
    c1d4:	5980      	ldr	r0, [r0, r6]
    c1d6:	4687      	mov	pc, r0
    c1d8:	465b      	mov	r3, fp
    c1da:	431e      	orrs	r6, r3
    c1dc:	d000      	beq.n	c1e0 <__aeabi_ddiv+0xa0>
    c1de:	e076      	b.n	c2ce <__aeabi_ddiv+0x18e>
    c1e0:	2300      	movs	r3, #0
    c1e2:	469b      	mov	fp, r3
    c1e4:	4699      	mov	r9, r3
    c1e6:	3302      	adds	r3, #2
    c1e8:	2608      	movs	r6, #8
    c1ea:	9300      	str	r3, [sp, #0]
    c1ec:	e7ce      	b.n	c18c <__aeabi_ddiv+0x4c>
    c1ee:	4699      	mov	r9, r3
    c1f0:	4643      	mov	r3, r8
    c1f2:	46bb      	mov	fp, r7
    c1f4:	9301      	str	r3, [sp, #4]
    c1f6:	9100      	str	r1, [sp, #0]
    c1f8:	9b00      	ldr	r3, [sp, #0]
    c1fa:	2b02      	cmp	r3, #2
    c1fc:	d16b      	bne.n	c2d6 <__aeabi_ddiv+0x196>
    c1fe:	9b01      	ldr	r3, [sp, #4]
    c200:	469a      	mov	sl, r3
    c202:	2100      	movs	r1, #0
    c204:	4653      	mov	r3, sl
    c206:	2201      	movs	r2, #1
    c208:	2700      	movs	r7, #0
    c20a:	4689      	mov	r9, r1
    c20c:	401a      	ands	r2, r3
    c20e:	4b3c      	ldr	r3, [pc, #240]	; (c300 <__aeabi_ddiv+0x1c0>)
    c210:	2100      	movs	r1, #0
    c212:	033f      	lsls	r7, r7, #12
    c214:	0d0c      	lsrs	r4, r1, #20
    c216:	0524      	lsls	r4, r4, #20
    c218:	0b3f      	lsrs	r7, r7, #12
    c21a:	4327      	orrs	r7, r4
    c21c:	4c3b      	ldr	r4, [pc, #236]	; (c30c <__aeabi_ddiv+0x1cc>)
    c21e:	051b      	lsls	r3, r3, #20
    c220:	4027      	ands	r7, r4
    c222:	431f      	orrs	r7, r3
    c224:	007f      	lsls	r7, r7, #1
    c226:	07d2      	lsls	r2, r2, #31
    c228:	087f      	lsrs	r7, r7, #1
    c22a:	4317      	orrs	r7, r2
    c22c:	4648      	mov	r0, r9
    c22e:	1c39      	adds	r1, r7, #0
    c230:	b007      	add	sp, #28
    c232:	bc3c      	pop	{r2, r3, r4, r5}
    c234:	4690      	mov	r8, r2
    c236:	4699      	mov	r9, r3
    c238:	46a2      	mov	sl, r4
    c23a:	46ab      	mov	fp, r5
    c23c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c23e:	4303      	orrs	r3, r0
    c240:	d03e      	beq.n	c2c0 <__aeabi_ddiv+0x180>
    c242:	465b      	mov	r3, fp
    c244:	2b00      	cmp	r3, #0
    c246:	d100      	bne.n	c24a <__aeabi_ddiv+0x10a>
    c248:	e19c      	b.n	c584 <__aeabi_ddiv+0x444>
    c24a:	4658      	mov	r0, fp
    c24c:	f001 f956 	bl	d4fc <__clzsi2>
    c250:	2328      	movs	r3, #40	; 0x28
    c252:	1c31      	adds	r1, r6, #0
    c254:	1a1b      	subs	r3, r3, r0
    c256:	1c02      	adds	r2, r0, #0
    c258:	465f      	mov	r7, fp
    c25a:	40d9      	lsrs	r1, r3
    c25c:	3a08      	subs	r2, #8
    c25e:	4097      	lsls	r7, r2
    c260:	1c0b      	adds	r3, r1, #0
    c262:	4096      	lsls	r6, r2
    c264:	433b      	orrs	r3, r7
    c266:	469b      	mov	fp, r3
    c268:	46b1      	mov	r9, r6
    c26a:	2300      	movs	r3, #0
    c26c:	4d28      	ldr	r5, [pc, #160]	; (c310 <__aeabi_ddiv+0x1d0>)
    c26e:	2600      	movs	r6, #0
    c270:	1a2d      	subs	r5, r5, r0
    c272:	9300      	str	r3, [sp, #0]
    c274:	e78a      	b.n	c18c <__aeabi_ddiv+0x4c>
    c276:	4652      	mov	r2, sl
    c278:	2103      	movs	r1, #3
    c27a:	433a      	orrs	r2, r7
    c27c:	d1a0      	bne.n	c1c0 <__aeabi_ddiv+0x80>
    c27e:	2700      	movs	r7, #0
    c280:	2300      	movs	r3, #0
    c282:	2102      	movs	r1, #2
    c284:	e79c      	b.n	c1c0 <__aeabi_ddiv+0x80>
    c286:	4652      	mov	r2, sl
    c288:	433a      	orrs	r2, r7
    c28a:	d015      	beq.n	c2b8 <__aeabi_ddiv+0x178>
    c28c:	2f00      	cmp	r7, #0
    c28e:	d100      	bne.n	c292 <__aeabi_ddiv+0x152>
    c290:	e185      	b.n	c59e <__aeabi_ddiv+0x45e>
    c292:	1c38      	adds	r0, r7, #0
    c294:	f001 f932 	bl	d4fc <__clzsi2>
    c298:	1c02      	adds	r2, r0, #0
    c29a:	2128      	movs	r1, #40	; 0x28
    c29c:	4650      	mov	r0, sl
    c29e:	1a89      	subs	r1, r1, r2
    c2a0:	1c13      	adds	r3, r2, #0
    c2a2:	40c8      	lsrs	r0, r1
    c2a4:	4651      	mov	r1, sl
    c2a6:	3b08      	subs	r3, #8
    c2a8:	4099      	lsls	r1, r3
    c2aa:	409f      	lsls	r7, r3
    c2ac:	1c0b      	adds	r3, r1, #0
    c2ae:	4307      	orrs	r7, r0
    c2b0:	4817      	ldr	r0, [pc, #92]	; (c310 <__aeabi_ddiv+0x1d0>)
    c2b2:	2100      	movs	r1, #0
    c2b4:	1a80      	subs	r0, r0, r2
    c2b6:	e783      	b.n	c1c0 <__aeabi_ddiv+0x80>
    c2b8:	2700      	movs	r7, #0
    c2ba:	2300      	movs	r3, #0
    c2bc:	2101      	movs	r1, #1
    c2be:	e77f      	b.n	c1c0 <__aeabi_ddiv+0x80>
    c2c0:	2300      	movs	r3, #0
    c2c2:	469b      	mov	fp, r3
    c2c4:	4699      	mov	r9, r3
    c2c6:	3301      	adds	r3, #1
    c2c8:	2604      	movs	r6, #4
    c2ca:	9300      	str	r3, [sp, #0]
    c2cc:	e75e      	b.n	c18c <__aeabi_ddiv+0x4c>
    c2ce:	2303      	movs	r3, #3
    c2d0:	260c      	movs	r6, #12
    c2d2:	9300      	str	r3, [sp, #0]
    c2d4:	e75a      	b.n	c18c <__aeabi_ddiv+0x4c>
    c2d6:	2b03      	cmp	r3, #3
    c2d8:	d100      	bne.n	c2dc <__aeabi_ddiv+0x19c>
    c2da:	e23c      	b.n	c756 <__aeabi_ddiv+0x616>
    c2dc:	2b01      	cmp	r3, #1
    c2de:	d000      	beq.n	c2e2 <__aeabi_ddiv+0x1a2>
    c2e0:	e1bf      	b.n	c662 <__aeabi_ddiv+0x522>
    c2e2:	1c1a      	adds	r2, r3, #0
    c2e4:	9b01      	ldr	r3, [sp, #4]
    c2e6:	401a      	ands	r2, r3
    c2e8:	2100      	movs	r1, #0
    c2ea:	2300      	movs	r3, #0
    c2ec:	2700      	movs	r7, #0
    c2ee:	4689      	mov	r9, r1
    c2f0:	e78e      	b.n	c210 <__aeabi_ddiv+0xd0>
    c2f2:	2300      	movs	r3, #0
    c2f4:	2780      	movs	r7, #128	; 0x80
    c2f6:	4699      	mov	r9, r3
    c2f8:	2200      	movs	r2, #0
    c2fa:	033f      	lsls	r7, r7, #12
    c2fc:	4b00      	ldr	r3, [pc, #0]	; (c300 <__aeabi_ddiv+0x1c0>)
    c2fe:	e787      	b.n	c210 <__aeabi_ddiv+0xd0>
    c300:	000007ff 	.word	0x000007ff
    c304:	fffffc01 	.word	0xfffffc01
    c308:	00011498 	.word	0x00011498
    c30c:	800fffff 	.word	0x800fffff
    c310:	fffffc0d 	.word	0xfffffc0d
    c314:	45bb      	cmp	fp, r7
    c316:	d900      	bls.n	c31a <__aeabi_ddiv+0x1da>
    c318:	e151      	b.n	c5be <__aeabi_ddiv+0x47e>
    c31a:	d100      	bne.n	c31e <__aeabi_ddiv+0x1de>
    c31c:	e14c      	b.n	c5b8 <__aeabi_ddiv+0x478>
    c31e:	464a      	mov	r2, r9
    c320:	9203      	str	r2, [sp, #12]
    c322:	2200      	movs	r2, #0
    c324:	465c      	mov	r4, fp
    c326:	4690      	mov	r8, r2
    c328:	3d01      	subs	r5, #1
    c32a:	0e18      	lsrs	r0, r3, #24
    c32c:	023f      	lsls	r7, r7, #8
    c32e:	4338      	orrs	r0, r7
    c330:	021b      	lsls	r3, r3, #8
    c332:	9301      	str	r3, [sp, #4]
    c334:	0c03      	lsrs	r3, r0, #16
    c336:	4699      	mov	r9, r3
    c338:	0403      	lsls	r3, r0, #16
    c33a:	0c1b      	lsrs	r3, r3, #16
    c33c:	4649      	mov	r1, r9
    c33e:	1c06      	adds	r6, r0, #0
    c340:	1c20      	adds	r0, r4, #0
    c342:	1c1f      	adds	r7, r3, #0
    c344:	9300      	str	r3, [sp, #0]
    c346:	f7ff fd31 	bl	bdac <__aeabi_uidiv>
    c34a:	1c02      	adds	r2, r0, #0
    c34c:	437a      	muls	r2, r7
    c34e:	9002      	str	r0, [sp, #8]
    c350:	4649      	mov	r1, r9
    c352:	1c20      	adds	r0, r4, #0
    c354:	1c17      	adds	r7, r2, #0
    c356:	f7ff fdaf 	bl	beb8 <__aeabi_uidivmod>
    c35a:	9b03      	ldr	r3, [sp, #12]
    c35c:	0409      	lsls	r1, r1, #16
    c35e:	0c1b      	lsrs	r3, r3, #16
    c360:	4319      	orrs	r1, r3
    c362:	428f      	cmp	r7, r1
    c364:	d90c      	bls.n	c380 <__aeabi_ddiv+0x240>
    c366:	9b02      	ldr	r3, [sp, #8]
    c368:	1989      	adds	r1, r1, r6
    c36a:	3b01      	subs	r3, #1
    c36c:	428e      	cmp	r6, r1
    c36e:	d900      	bls.n	c372 <__aeabi_ddiv+0x232>
    c370:	e152      	b.n	c618 <__aeabi_ddiv+0x4d8>
    c372:	428f      	cmp	r7, r1
    c374:	d800      	bhi.n	c378 <__aeabi_ddiv+0x238>
    c376:	e14f      	b.n	c618 <__aeabi_ddiv+0x4d8>
    c378:	9b02      	ldr	r3, [sp, #8]
    c37a:	1989      	adds	r1, r1, r6
    c37c:	3b02      	subs	r3, #2
    c37e:	9302      	str	r3, [sp, #8]
    c380:	1bcc      	subs	r4, r1, r7
    c382:	1c20      	adds	r0, r4, #0
    c384:	4649      	mov	r1, r9
    c386:	f7ff fd11 	bl	bdac <__aeabi_uidiv>
    c38a:	9f00      	ldr	r7, [sp, #0]
    c38c:	4683      	mov	fp, r0
    c38e:	4347      	muls	r7, r0
    c390:	4649      	mov	r1, r9
    c392:	1c20      	adds	r0, r4, #0
    c394:	f7ff fd90 	bl	beb8 <__aeabi_uidivmod>
    c398:	9a03      	ldr	r2, [sp, #12]
    c39a:	040b      	lsls	r3, r1, #16
    c39c:	0414      	lsls	r4, r2, #16
    c39e:	0c24      	lsrs	r4, r4, #16
    c3a0:	4323      	orrs	r3, r4
    c3a2:	429f      	cmp	r7, r3
    c3a4:	d90d      	bls.n	c3c2 <__aeabi_ddiv+0x282>
    c3a6:	465a      	mov	r2, fp
    c3a8:	199b      	adds	r3, r3, r6
    c3aa:	3a01      	subs	r2, #1
    c3ac:	429e      	cmp	r6, r3
    c3ae:	d900      	bls.n	c3b2 <__aeabi_ddiv+0x272>
    c3b0:	e130      	b.n	c614 <__aeabi_ddiv+0x4d4>
    c3b2:	429f      	cmp	r7, r3
    c3b4:	d800      	bhi.n	c3b8 <__aeabi_ddiv+0x278>
    c3b6:	e12d      	b.n	c614 <__aeabi_ddiv+0x4d4>
    c3b8:	2202      	movs	r2, #2
    c3ba:	4252      	negs	r2, r2
    c3bc:	4694      	mov	ip, r2
    c3be:	199b      	adds	r3, r3, r6
    c3c0:	44e3      	add	fp, ip
    c3c2:	9a02      	ldr	r2, [sp, #8]
    c3c4:	1bdb      	subs	r3, r3, r7
    c3c6:	0417      	lsls	r7, r2, #16
    c3c8:	465a      	mov	r2, fp
    c3ca:	433a      	orrs	r2, r7
    c3cc:	4693      	mov	fp, r2
    c3ce:	9c01      	ldr	r4, [sp, #4]
    c3d0:	0c17      	lsrs	r7, r2, #16
    c3d2:	0c22      	lsrs	r2, r4, #16
    c3d4:	1c10      	adds	r0, r2, #0
    c3d6:	9204      	str	r2, [sp, #16]
    c3d8:	465a      	mov	r2, fp
    c3da:	0411      	lsls	r1, r2, #16
    c3dc:	0422      	lsls	r2, r4, #16
    c3de:	0c12      	lsrs	r2, r2, #16
    c3e0:	1c14      	adds	r4, r2, #0
    c3e2:	0c09      	lsrs	r1, r1, #16
    c3e4:	437c      	muls	r4, r7
    c3e6:	9205      	str	r2, [sp, #20]
    c3e8:	434a      	muls	r2, r1
    c3ea:	4341      	muls	r1, r0
    c3ec:	4347      	muls	r7, r0
    c3ee:	1861      	adds	r1, r4, r1
    c3f0:	0c10      	lsrs	r0, r2, #16
    c3f2:	1809      	adds	r1, r1, r0
    c3f4:	428c      	cmp	r4, r1
    c3f6:	d903      	bls.n	c400 <__aeabi_ddiv+0x2c0>
    c3f8:	2080      	movs	r0, #128	; 0x80
    c3fa:	0240      	lsls	r0, r0, #9
    c3fc:	4684      	mov	ip, r0
    c3fe:	4467      	add	r7, ip
    c400:	0c0c      	lsrs	r4, r1, #16
    c402:	0412      	lsls	r2, r2, #16
    c404:	0408      	lsls	r0, r1, #16
    c406:	0c12      	lsrs	r2, r2, #16
    c408:	193c      	adds	r4, r7, r4
    c40a:	1881      	adds	r1, r0, r2
    c40c:	42a3      	cmp	r3, r4
    c40e:	d200      	bcs.n	c412 <__aeabi_ddiv+0x2d2>
    c410:	e0e5      	b.n	c5de <__aeabi_ddiv+0x49e>
    c412:	d100      	bne.n	c416 <__aeabi_ddiv+0x2d6>
    c414:	e0df      	b.n	c5d6 <__aeabi_ddiv+0x496>
    c416:	1b1f      	subs	r7, r3, r4
    c418:	4643      	mov	r3, r8
    c41a:	1a5c      	subs	r4, r3, r1
    c41c:	45a0      	cmp	r8, r4
    c41e:	4192      	sbcs	r2, r2
    c420:	4252      	negs	r2, r2
    c422:	1abf      	subs	r7, r7, r2
    c424:	42b7      	cmp	r7, r6
    c426:	d100      	bne.n	c42a <__aeabi_ddiv+0x2ea>
    c428:	e10e      	b.n	c648 <__aeabi_ddiv+0x508>
    c42a:	1c38      	adds	r0, r7, #0
    c42c:	4649      	mov	r1, r9
    c42e:	f7ff fcbd 	bl	bdac <__aeabi_uidiv>
    c432:	9b00      	ldr	r3, [sp, #0]
    c434:	9002      	str	r0, [sp, #8]
    c436:	4343      	muls	r3, r0
    c438:	4649      	mov	r1, r9
    c43a:	1c38      	adds	r0, r7, #0
    c43c:	4698      	mov	r8, r3
    c43e:	f7ff fd3b 	bl	beb8 <__aeabi_uidivmod>
    c442:	0c23      	lsrs	r3, r4, #16
    c444:	040f      	lsls	r7, r1, #16
    c446:	431f      	orrs	r7, r3
    c448:	45b8      	cmp	r8, r7
    c44a:	d90c      	bls.n	c466 <__aeabi_ddiv+0x326>
    c44c:	9b02      	ldr	r3, [sp, #8]
    c44e:	19bf      	adds	r7, r7, r6
    c450:	3b01      	subs	r3, #1
    c452:	42be      	cmp	r6, r7
    c454:	d900      	bls.n	c458 <__aeabi_ddiv+0x318>
    c456:	e0fb      	b.n	c650 <__aeabi_ddiv+0x510>
    c458:	45b8      	cmp	r8, r7
    c45a:	d800      	bhi.n	c45e <__aeabi_ddiv+0x31e>
    c45c:	e0f8      	b.n	c650 <__aeabi_ddiv+0x510>
    c45e:	9b02      	ldr	r3, [sp, #8]
    c460:	19bf      	adds	r7, r7, r6
    c462:	3b02      	subs	r3, #2
    c464:	9302      	str	r3, [sp, #8]
    c466:	4643      	mov	r3, r8
    c468:	1aff      	subs	r7, r7, r3
    c46a:	4649      	mov	r1, r9
    c46c:	1c38      	adds	r0, r7, #0
    c46e:	f7ff fc9d 	bl	bdac <__aeabi_uidiv>
    c472:	9b00      	ldr	r3, [sp, #0]
    c474:	9003      	str	r0, [sp, #12]
    c476:	4343      	muls	r3, r0
    c478:	4649      	mov	r1, r9
    c47a:	1c38      	adds	r0, r7, #0
    c47c:	4698      	mov	r8, r3
    c47e:	f7ff fd1b 	bl	beb8 <__aeabi_uidivmod>
    c482:	0424      	lsls	r4, r4, #16
    c484:	0409      	lsls	r1, r1, #16
    c486:	0c24      	lsrs	r4, r4, #16
    c488:	4321      	orrs	r1, r4
    c48a:	4588      	cmp	r8, r1
    c48c:	d90c      	bls.n	c4a8 <__aeabi_ddiv+0x368>
    c48e:	9b03      	ldr	r3, [sp, #12]
    c490:	1989      	adds	r1, r1, r6
    c492:	3b01      	subs	r3, #1
    c494:	428e      	cmp	r6, r1
    c496:	d900      	bls.n	c49a <__aeabi_ddiv+0x35a>
    c498:	e0dc      	b.n	c654 <__aeabi_ddiv+0x514>
    c49a:	4588      	cmp	r8, r1
    c49c:	d800      	bhi.n	c4a0 <__aeabi_ddiv+0x360>
    c49e:	e0d9      	b.n	c654 <__aeabi_ddiv+0x514>
    c4a0:	9b03      	ldr	r3, [sp, #12]
    c4a2:	1989      	adds	r1, r1, r6
    c4a4:	3b02      	subs	r3, #2
    c4a6:	9303      	str	r3, [sp, #12]
    c4a8:	4643      	mov	r3, r8
    c4aa:	1ac9      	subs	r1, r1, r3
    c4ac:	9b02      	ldr	r3, [sp, #8]
    c4ae:	9a03      	ldr	r2, [sp, #12]
    c4b0:	041b      	lsls	r3, r3, #16
    c4b2:	9c05      	ldr	r4, [sp, #20]
    c4b4:	431a      	orrs	r2, r3
    c4b6:	0c10      	lsrs	r0, r2, #16
    c4b8:	0413      	lsls	r3, r2, #16
    c4ba:	4691      	mov	r9, r2
    c4bc:	1c22      	adds	r2, r4, #0
    c4be:	9f04      	ldr	r7, [sp, #16]
    c4c0:	0c1b      	lsrs	r3, r3, #16
    c4c2:	435a      	muls	r2, r3
    c4c4:	4344      	muls	r4, r0
    c4c6:	437b      	muls	r3, r7
    c4c8:	4378      	muls	r0, r7
    c4ca:	18e3      	adds	r3, r4, r3
    c4cc:	0c17      	lsrs	r7, r2, #16
    c4ce:	19db      	adds	r3, r3, r7
    c4d0:	429c      	cmp	r4, r3
    c4d2:	d903      	bls.n	c4dc <__aeabi_ddiv+0x39c>
    c4d4:	2480      	movs	r4, #128	; 0x80
    c4d6:	0264      	lsls	r4, r4, #9
    c4d8:	46a4      	mov	ip, r4
    c4da:	4460      	add	r0, ip
    c4dc:	0c1c      	lsrs	r4, r3, #16
    c4de:	0412      	lsls	r2, r2, #16
    c4e0:	041b      	lsls	r3, r3, #16
    c4e2:	0c12      	lsrs	r2, r2, #16
    c4e4:	1900      	adds	r0, r0, r4
    c4e6:	189b      	adds	r3, r3, r2
    c4e8:	4281      	cmp	r1, r0
    c4ea:	d200      	bcs.n	c4ee <__aeabi_ddiv+0x3ae>
    c4ec:	e096      	b.n	c61c <__aeabi_ddiv+0x4dc>
    c4ee:	d100      	bne.n	c4f2 <__aeabi_ddiv+0x3b2>
    c4f0:	e0fc      	b.n	c6ec <__aeabi_ddiv+0x5ac>
    c4f2:	464a      	mov	r2, r9
    c4f4:	2301      	movs	r3, #1
    c4f6:	431a      	orrs	r2, r3
    c4f8:	4691      	mov	r9, r2
    c4fa:	4b9b      	ldr	r3, [pc, #620]	; (c768 <__aeabi_ddiv+0x628>)
    c4fc:	18eb      	adds	r3, r5, r3
    c4fe:	2b00      	cmp	r3, #0
    c500:	dc00      	bgt.n	c504 <__aeabi_ddiv+0x3c4>
    c502:	e099      	b.n	c638 <__aeabi_ddiv+0x4f8>
    c504:	464a      	mov	r2, r9
    c506:	0752      	lsls	r2, r2, #29
    c508:	d00a      	beq.n	c520 <__aeabi_ddiv+0x3e0>
    c50a:	220f      	movs	r2, #15
    c50c:	4649      	mov	r1, r9
    c50e:	400a      	ands	r2, r1
    c510:	2a04      	cmp	r2, #4
    c512:	d005      	beq.n	c520 <__aeabi_ddiv+0x3e0>
    c514:	3104      	adds	r1, #4
    c516:	4549      	cmp	r1, r9
    c518:	4192      	sbcs	r2, r2
    c51a:	4689      	mov	r9, r1
    c51c:	4252      	negs	r2, r2
    c51e:	4493      	add	fp, r2
    c520:	465a      	mov	r2, fp
    c522:	01d2      	lsls	r2, r2, #7
    c524:	d506      	bpl.n	c534 <__aeabi_ddiv+0x3f4>
    c526:	465a      	mov	r2, fp
    c528:	4b90      	ldr	r3, [pc, #576]	; (c76c <__aeabi_ddiv+0x62c>)
    c52a:	401a      	ands	r2, r3
    c52c:	2380      	movs	r3, #128	; 0x80
    c52e:	4693      	mov	fp, r2
    c530:	00db      	lsls	r3, r3, #3
    c532:	18eb      	adds	r3, r5, r3
    c534:	4a8e      	ldr	r2, [pc, #568]	; (c770 <__aeabi_ddiv+0x630>)
    c536:	4293      	cmp	r3, r2
    c538:	dd00      	ble.n	c53c <__aeabi_ddiv+0x3fc>
    c53a:	e662      	b.n	c202 <__aeabi_ddiv+0xc2>
    c53c:	464a      	mov	r2, r9
    c53e:	4659      	mov	r1, fp
    c540:	08d2      	lsrs	r2, r2, #3
    c542:	0749      	lsls	r1, r1, #29
    c544:	4311      	orrs	r1, r2
    c546:	465a      	mov	r2, fp
    c548:	4689      	mov	r9, r1
    c54a:	0257      	lsls	r7, r2, #9
    c54c:	4651      	mov	r1, sl
    c54e:	2201      	movs	r2, #1
    c550:	055b      	lsls	r3, r3, #21
    c552:	0b3f      	lsrs	r7, r7, #12
    c554:	0d5b      	lsrs	r3, r3, #21
    c556:	400a      	ands	r2, r1
    c558:	e65a      	b.n	c210 <__aeabi_ddiv+0xd0>
    c55a:	2080      	movs	r0, #128	; 0x80
    c55c:	465a      	mov	r2, fp
    c55e:	0300      	lsls	r0, r0, #12
    c560:	4202      	tst	r2, r0
    c562:	d008      	beq.n	c576 <__aeabi_ddiv+0x436>
    c564:	4207      	tst	r7, r0
    c566:	d106      	bne.n	c576 <__aeabi_ddiv+0x436>
    c568:	4307      	orrs	r7, r0
    c56a:	033f      	lsls	r7, r7, #12
    c56c:	4699      	mov	r9, r3
    c56e:	0b3f      	lsrs	r7, r7, #12
    c570:	4642      	mov	r2, r8
    c572:	4b80      	ldr	r3, [pc, #512]	; (c774 <__aeabi_ddiv+0x634>)
    c574:	e64c      	b.n	c210 <__aeabi_ddiv+0xd0>
    c576:	465f      	mov	r7, fp
    c578:	4307      	orrs	r7, r0
    c57a:	033f      	lsls	r7, r7, #12
    c57c:	0b3f      	lsrs	r7, r7, #12
    c57e:	1c22      	adds	r2, r4, #0
    c580:	4b7c      	ldr	r3, [pc, #496]	; (c774 <__aeabi_ddiv+0x634>)
    c582:	e645      	b.n	c210 <__aeabi_ddiv+0xd0>
    c584:	f000 ffba 	bl	d4fc <__clzsi2>
    c588:	1c03      	adds	r3, r0, #0
    c58a:	3020      	adds	r0, #32
    c58c:	2827      	cmp	r0, #39	; 0x27
    c58e:	dc00      	bgt.n	c592 <__aeabi_ddiv+0x452>
    c590:	e65e      	b.n	c250 <__aeabi_ddiv+0x110>
    c592:	3b08      	subs	r3, #8
    c594:	409e      	lsls	r6, r3
    c596:	2300      	movs	r3, #0
    c598:	46b3      	mov	fp, r6
    c59a:	4699      	mov	r9, r3
    c59c:	e665      	b.n	c26a <__aeabi_ddiv+0x12a>
    c59e:	4650      	mov	r0, sl
    c5a0:	f000 ffac 	bl	d4fc <__clzsi2>
    c5a4:	1c02      	adds	r2, r0, #0
    c5a6:	3220      	adds	r2, #32
    c5a8:	2a27      	cmp	r2, #39	; 0x27
    c5aa:	dc00      	bgt.n	c5ae <__aeabi_ddiv+0x46e>
    c5ac:	e675      	b.n	c29a <__aeabi_ddiv+0x15a>
    c5ae:	4657      	mov	r7, sl
    c5b0:	3808      	subs	r0, #8
    c5b2:	4087      	lsls	r7, r0
    c5b4:	2300      	movs	r3, #0
    c5b6:	e67b      	b.n	c2b0 <__aeabi_ddiv+0x170>
    c5b8:	4599      	cmp	r9, r3
    c5ba:	d200      	bcs.n	c5be <__aeabi_ddiv+0x47e>
    c5bc:	e6af      	b.n	c31e <__aeabi_ddiv+0x1de>
    c5be:	465a      	mov	r2, fp
    c5c0:	4659      	mov	r1, fp
    c5c2:	0854      	lsrs	r4, r2, #1
    c5c4:	464a      	mov	r2, r9
    c5c6:	07c8      	lsls	r0, r1, #31
    c5c8:	0852      	lsrs	r2, r2, #1
    c5ca:	4302      	orrs	r2, r0
    c5cc:	9203      	str	r2, [sp, #12]
    c5ce:	464a      	mov	r2, r9
    c5d0:	07d2      	lsls	r2, r2, #31
    c5d2:	4690      	mov	r8, r2
    c5d4:	e6a9      	b.n	c32a <__aeabi_ddiv+0x1ea>
    c5d6:	2700      	movs	r7, #0
    c5d8:	4588      	cmp	r8, r1
    c5da:	d300      	bcc.n	c5de <__aeabi_ddiv+0x49e>
    c5dc:	e71c      	b.n	c418 <__aeabi_ddiv+0x2d8>
    c5de:	9f01      	ldr	r7, [sp, #4]
    c5e0:	465a      	mov	r2, fp
    c5e2:	46bc      	mov	ip, r7
    c5e4:	44e0      	add	r8, ip
    c5e6:	45b8      	cmp	r8, r7
    c5e8:	41bf      	sbcs	r7, r7
    c5ea:	427f      	negs	r7, r7
    c5ec:	19bf      	adds	r7, r7, r6
    c5ee:	18ff      	adds	r7, r7, r3
    c5f0:	3a01      	subs	r2, #1
    c5f2:	42be      	cmp	r6, r7
    c5f4:	d206      	bcs.n	c604 <__aeabi_ddiv+0x4c4>
    c5f6:	42bc      	cmp	r4, r7
    c5f8:	d85f      	bhi.n	c6ba <__aeabi_ddiv+0x57a>
    c5fa:	d100      	bne.n	c5fe <__aeabi_ddiv+0x4be>
    c5fc:	e09f      	b.n	c73e <__aeabi_ddiv+0x5fe>
    c5fe:	1b3f      	subs	r7, r7, r4
    c600:	4693      	mov	fp, r2
    c602:	e709      	b.n	c418 <__aeabi_ddiv+0x2d8>
    c604:	42b7      	cmp	r7, r6
    c606:	d1fa      	bne.n	c5fe <__aeabi_ddiv+0x4be>
    c608:	9b01      	ldr	r3, [sp, #4]
    c60a:	4543      	cmp	r3, r8
    c60c:	d9f3      	bls.n	c5f6 <__aeabi_ddiv+0x4b6>
    c60e:	1b37      	subs	r7, r6, r4
    c610:	4693      	mov	fp, r2
    c612:	e701      	b.n	c418 <__aeabi_ddiv+0x2d8>
    c614:	4693      	mov	fp, r2
    c616:	e6d4      	b.n	c3c2 <__aeabi_ddiv+0x282>
    c618:	9302      	str	r3, [sp, #8]
    c61a:	e6b1      	b.n	c380 <__aeabi_ddiv+0x240>
    c61c:	464a      	mov	r2, r9
    c61e:	1989      	adds	r1, r1, r6
    c620:	3a01      	subs	r2, #1
    c622:	428e      	cmp	r6, r1
    c624:	d918      	bls.n	c658 <__aeabi_ddiv+0x518>
    c626:	4691      	mov	r9, r2
    c628:	4281      	cmp	r1, r0
    c62a:	d000      	beq.n	c62e <__aeabi_ddiv+0x4ee>
    c62c:	e761      	b.n	c4f2 <__aeabi_ddiv+0x3b2>
    c62e:	9a01      	ldr	r2, [sp, #4]
    c630:	429a      	cmp	r2, r3
    c632:	d000      	beq.n	c636 <__aeabi_ddiv+0x4f6>
    c634:	e75d      	b.n	c4f2 <__aeabi_ddiv+0x3b2>
    c636:	e760      	b.n	c4fa <__aeabi_ddiv+0x3ba>
    c638:	4f4f      	ldr	r7, [pc, #316]	; (c778 <__aeabi_ddiv+0x638>)
    c63a:	1b7f      	subs	r7, r7, r5
    c63c:	2f38      	cmp	r7, #56	; 0x38
    c63e:	dd13      	ble.n	c668 <__aeabi_ddiv+0x528>
    c640:	2201      	movs	r2, #1
    c642:	4653      	mov	r3, sl
    c644:	401a      	ands	r2, r3
    c646:	e64f      	b.n	c2e8 <__aeabi_ddiv+0x1a8>
    c648:	2301      	movs	r3, #1
    c64a:	425b      	negs	r3, r3
    c64c:	4699      	mov	r9, r3
    c64e:	e754      	b.n	c4fa <__aeabi_ddiv+0x3ba>
    c650:	9302      	str	r3, [sp, #8]
    c652:	e708      	b.n	c466 <__aeabi_ddiv+0x326>
    c654:	9303      	str	r3, [sp, #12]
    c656:	e727      	b.n	c4a8 <__aeabi_ddiv+0x368>
    c658:	4288      	cmp	r0, r1
    c65a:	d83c      	bhi.n	c6d6 <__aeabi_ddiv+0x596>
    c65c:	d074      	beq.n	c748 <__aeabi_ddiv+0x608>
    c65e:	4691      	mov	r9, r2
    c660:	e747      	b.n	c4f2 <__aeabi_ddiv+0x3b2>
    c662:	9b01      	ldr	r3, [sp, #4]
    c664:	469a      	mov	sl, r3
    c666:	e748      	b.n	c4fa <__aeabi_ddiv+0x3ba>
    c668:	2f1f      	cmp	r7, #31
    c66a:	dc44      	bgt.n	c6f6 <__aeabi_ddiv+0x5b6>
    c66c:	4b43      	ldr	r3, [pc, #268]	; (c77c <__aeabi_ddiv+0x63c>)
    c66e:	464a      	mov	r2, r9
    c670:	469c      	mov	ip, r3
    c672:	465b      	mov	r3, fp
    c674:	4465      	add	r5, ip
    c676:	40fa      	lsrs	r2, r7
    c678:	40ab      	lsls	r3, r5
    c67a:	4313      	orrs	r3, r2
    c67c:	464a      	mov	r2, r9
    c67e:	40aa      	lsls	r2, r5
    c680:	1c15      	adds	r5, r2, #0
    c682:	1e6a      	subs	r2, r5, #1
    c684:	4195      	sbcs	r5, r2
    c686:	465a      	mov	r2, fp
    c688:	40fa      	lsrs	r2, r7
    c68a:	432b      	orrs	r3, r5
    c68c:	1c17      	adds	r7, r2, #0
    c68e:	075a      	lsls	r2, r3, #29
    c690:	d009      	beq.n	c6a6 <__aeabi_ddiv+0x566>
    c692:	220f      	movs	r2, #15
    c694:	401a      	ands	r2, r3
    c696:	2a04      	cmp	r2, #4
    c698:	d005      	beq.n	c6a6 <__aeabi_ddiv+0x566>
    c69a:	1d1a      	adds	r2, r3, #4
    c69c:	429a      	cmp	r2, r3
    c69e:	419b      	sbcs	r3, r3
    c6a0:	425b      	negs	r3, r3
    c6a2:	18ff      	adds	r7, r7, r3
    c6a4:	1c13      	adds	r3, r2, #0
    c6a6:	023a      	lsls	r2, r7, #8
    c6a8:	d53e      	bpl.n	c728 <__aeabi_ddiv+0x5e8>
    c6aa:	4653      	mov	r3, sl
    c6ac:	2201      	movs	r2, #1
    c6ae:	2100      	movs	r1, #0
    c6b0:	401a      	ands	r2, r3
    c6b2:	2700      	movs	r7, #0
    c6b4:	2301      	movs	r3, #1
    c6b6:	4689      	mov	r9, r1
    c6b8:	e5aa      	b.n	c210 <__aeabi_ddiv+0xd0>
    c6ba:	2302      	movs	r3, #2
    c6bc:	425b      	negs	r3, r3
    c6be:	469c      	mov	ip, r3
    c6c0:	9a01      	ldr	r2, [sp, #4]
    c6c2:	44e3      	add	fp, ip
    c6c4:	4694      	mov	ip, r2
    c6c6:	44e0      	add	r8, ip
    c6c8:	4590      	cmp	r8, r2
    c6ca:	419b      	sbcs	r3, r3
    c6cc:	425b      	negs	r3, r3
    c6ce:	199b      	adds	r3, r3, r6
    c6d0:	19df      	adds	r7, r3, r7
    c6d2:	1b3f      	subs	r7, r7, r4
    c6d4:	e6a0      	b.n	c418 <__aeabi_ddiv+0x2d8>
    c6d6:	9f01      	ldr	r7, [sp, #4]
    c6d8:	464a      	mov	r2, r9
    c6da:	007c      	lsls	r4, r7, #1
    c6dc:	42bc      	cmp	r4, r7
    c6de:	41bf      	sbcs	r7, r7
    c6e0:	427f      	negs	r7, r7
    c6e2:	19bf      	adds	r7, r7, r6
    c6e4:	3a02      	subs	r2, #2
    c6e6:	19c9      	adds	r1, r1, r7
    c6e8:	9401      	str	r4, [sp, #4]
    c6ea:	e79c      	b.n	c626 <__aeabi_ddiv+0x4e6>
    c6ec:	2b00      	cmp	r3, #0
    c6ee:	d195      	bne.n	c61c <__aeabi_ddiv+0x4dc>
    c6f0:	2200      	movs	r2, #0
    c6f2:	9201      	str	r2, [sp, #4]
    c6f4:	e79b      	b.n	c62e <__aeabi_ddiv+0x4ee>
    c6f6:	465a      	mov	r2, fp
    c6f8:	4b21      	ldr	r3, [pc, #132]	; (c780 <__aeabi_ddiv+0x640>)
    c6fa:	1b5b      	subs	r3, r3, r5
    c6fc:	40da      	lsrs	r2, r3
    c6fe:	2f20      	cmp	r7, #32
    c700:	d027      	beq.n	c752 <__aeabi_ddiv+0x612>
    c702:	4b20      	ldr	r3, [pc, #128]	; (c784 <__aeabi_ddiv+0x644>)
    c704:	469c      	mov	ip, r3
    c706:	465b      	mov	r3, fp
    c708:	4465      	add	r5, ip
    c70a:	40ab      	lsls	r3, r5
    c70c:	4649      	mov	r1, r9
    c70e:	430b      	orrs	r3, r1
    c710:	1e59      	subs	r1, r3, #1
    c712:	418b      	sbcs	r3, r1
    c714:	4313      	orrs	r3, r2
    c716:	2207      	movs	r2, #7
    c718:	2700      	movs	r7, #0
    c71a:	401a      	ands	r2, r3
    c71c:	d007      	beq.n	c72e <__aeabi_ddiv+0x5ee>
    c71e:	220f      	movs	r2, #15
    c720:	2700      	movs	r7, #0
    c722:	401a      	ands	r2, r3
    c724:	2a04      	cmp	r2, #4
    c726:	d1b8      	bne.n	c69a <__aeabi_ddiv+0x55a>
    c728:	077a      	lsls	r2, r7, #29
    c72a:	027f      	lsls	r7, r7, #9
    c72c:	0b3f      	lsrs	r7, r7, #12
    c72e:	08db      	lsrs	r3, r3, #3
    c730:	4313      	orrs	r3, r2
    c732:	4699      	mov	r9, r3
    c734:	2201      	movs	r2, #1
    c736:	4653      	mov	r3, sl
    c738:	401a      	ands	r2, r3
    c73a:	2300      	movs	r3, #0
    c73c:	e568      	b.n	c210 <__aeabi_ddiv+0xd0>
    c73e:	4541      	cmp	r1, r8
    c740:	d8bb      	bhi.n	c6ba <__aeabi_ddiv+0x57a>
    c742:	4693      	mov	fp, r2
    c744:	2700      	movs	r7, #0
    c746:	e667      	b.n	c418 <__aeabi_ddiv+0x2d8>
    c748:	9c01      	ldr	r4, [sp, #4]
    c74a:	429c      	cmp	r4, r3
    c74c:	d3c3      	bcc.n	c6d6 <__aeabi_ddiv+0x596>
    c74e:	4691      	mov	r9, r2
    c750:	e76d      	b.n	c62e <__aeabi_ddiv+0x4ee>
    c752:	2300      	movs	r3, #0
    c754:	e7da      	b.n	c70c <__aeabi_ddiv+0x5cc>
    c756:	2780      	movs	r7, #128	; 0x80
    c758:	465b      	mov	r3, fp
    c75a:	033f      	lsls	r7, r7, #12
    c75c:	431f      	orrs	r7, r3
    c75e:	033f      	lsls	r7, r7, #12
    c760:	0b3f      	lsrs	r7, r7, #12
    c762:	9a01      	ldr	r2, [sp, #4]
    c764:	4b03      	ldr	r3, [pc, #12]	; (c774 <__aeabi_ddiv+0x634>)
    c766:	e553      	b.n	c210 <__aeabi_ddiv+0xd0>
    c768:	000003ff 	.word	0x000003ff
    c76c:	feffffff 	.word	0xfeffffff
    c770:	000007fe 	.word	0x000007fe
    c774:	000007ff 	.word	0x000007ff
    c778:	fffffc02 	.word	0xfffffc02
    c77c:	0000041e 	.word	0x0000041e
    c780:	fffffbe2 	.word	0xfffffbe2
    c784:	0000043e 	.word	0x0000043e

0000c788 <__aeabi_dmul>:
    c788:	b5f0      	push	{r4, r5, r6, r7, lr}
    c78a:	465f      	mov	r7, fp
    c78c:	4656      	mov	r6, sl
    c78e:	464d      	mov	r5, r9
    c790:	4644      	mov	r4, r8
    c792:	b4f0      	push	{r4, r5, r6, r7}
    c794:	1c05      	adds	r5, r0, #0
    c796:	1c06      	adds	r6, r0, #0
    c798:	0308      	lsls	r0, r1, #12
    c79a:	b087      	sub	sp, #28
    c79c:	4699      	mov	r9, r3
    c79e:	004f      	lsls	r7, r1, #1
    c7a0:	0b03      	lsrs	r3, r0, #12
    c7a2:	0fcc      	lsrs	r4, r1, #31
    c7a4:	4692      	mov	sl, r2
    c7a6:	469b      	mov	fp, r3
    c7a8:	0d7f      	lsrs	r7, r7, #21
    c7aa:	9401      	str	r4, [sp, #4]
    c7ac:	d067      	beq.n	c87e <__aeabi_dmul+0xf6>
    c7ae:	4b6c      	ldr	r3, [pc, #432]	; (c960 <__aeabi_dmul+0x1d8>)
    c7b0:	429f      	cmp	r7, r3
    c7b2:	d036      	beq.n	c822 <__aeabi_dmul+0x9a>
    c7b4:	2080      	movs	r0, #128	; 0x80
    c7b6:	465b      	mov	r3, fp
    c7b8:	0340      	lsls	r0, r0, #13
    c7ba:	4318      	orrs	r0, r3
    c7bc:	00c0      	lsls	r0, r0, #3
    c7be:	0f6b      	lsrs	r3, r5, #29
    c7c0:	4318      	orrs	r0, r3
    c7c2:	4b68      	ldr	r3, [pc, #416]	; (c964 <__aeabi_dmul+0x1dc>)
    c7c4:	4683      	mov	fp, r0
    c7c6:	469c      	mov	ip, r3
    c7c8:	2300      	movs	r3, #0
    c7ca:	4698      	mov	r8, r3
    c7cc:	00ee      	lsls	r6, r5, #3
    c7ce:	4467      	add	r7, ip
    c7d0:	9300      	str	r3, [sp, #0]
    c7d2:	464b      	mov	r3, r9
    c7d4:	4649      	mov	r1, r9
    c7d6:	031d      	lsls	r5, r3, #12
    c7d8:	0fc9      	lsrs	r1, r1, #31
    c7da:	005b      	lsls	r3, r3, #1
    c7dc:	4652      	mov	r2, sl
    c7de:	0b2d      	lsrs	r5, r5, #12
    c7e0:	0d5b      	lsrs	r3, r3, #21
    c7e2:	4689      	mov	r9, r1
    c7e4:	d100      	bne.n	c7e8 <__aeabi_dmul+0x60>
    c7e6:	e06e      	b.n	c8c6 <__aeabi_dmul+0x13e>
    c7e8:	495d      	ldr	r1, [pc, #372]	; (c960 <__aeabi_dmul+0x1d8>)
    c7ea:	428b      	cmp	r3, r1
    c7ec:	d064      	beq.n	c8b8 <__aeabi_dmul+0x130>
    c7ee:	2080      	movs	r0, #128	; 0x80
    c7f0:	495c      	ldr	r1, [pc, #368]	; (c964 <__aeabi_dmul+0x1dc>)
    c7f2:	0340      	lsls	r0, r0, #13
    c7f4:	468c      	mov	ip, r1
    c7f6:	2100      	movs	r1, #0
    c7f8:	4305      	orrs	r5, r0
    c7fa:	00ed      	lsls	r5, r5, #3
    c7fc:	0f50      	lsrs	r0, r2, #29
    c7fe:	4305      	orrs	r5, r0
    c800:	00d2      	lsls	r2, r2, #3
    c802:	4463      	add	r3, ip
    c804:	4648      	mov	r0, r9
    c806:	18ff      	adds	r7, r7, r3
    c808:	1c7b      	adds	r3, r7, #1
    c80a:	469a      	mov	sl, r3
    c80c:	9b00      	ldr	r3, [sp, #0]
    c80e:	4060      	eors	r0, r4
    c810:	9002      	str	r0, [sp, #8]
    c812:	430b      	orrs	r3, r1
    c814:	2b0f      	cmp	r3, #15
    c816:	d900      	bls.n	c81a <__aeabi_dmul+0x92>
    c818:	e0ac      	b.n	c974 <__aeabi_dmul+0x1ec>
    c81a:	4853      	ldr	r0, [pc, #332]	; (c968 <__aeabi_dmul+0x1e0>)
    c81c:	009b      	lsls	r3, r3, #2
    c81e:	58c3      	ldr	r3, [r0, r3]
    c820:	469f      	mov	pc, r3
    c822:	465b      	mov	r3, fp
    c824:	431d      	orrs	r5, r3
    c826:	d000      	beq.n	c82a <__aeabi_dmul+0xa2>
    c828:	e082      	b.n	c930 <__aeabi_dmul+0x1a8>
    c82a:	2308      	movs	r3, #8
    c82c:	9300      	str	r3, [sp, #0]
    c82e:	2300      	movs	r3, #0
    c830:	469b      	mov	fp, r3
    c832:	3302      	adds	r3, #2
    c834:	2600      	movs	r6, #0
    c836:	4698      	mov	r8, r3
    c838:	e7cb      	b.n	c7d2 <__aeabi_dmul+0x4a>
    c83a:	9b02      	ldr	r3, [sp, #8]
    c83c:	9301      	str	r3, [sp, #4]
    c83e:	4643      	mov	r3, r8
    c840:	2b02      	cmp	r3, #2
    c842:	d159      	bne.n	c8f8 <__aeabi_dmul+0x170>
    c844:	2401      	movs	r4, #1
    c846:	2500      	movs	r5, #0
    c848:	2600      	movs	r6, #0
    c84a:	9b01      	ldr	r3, [sp, #4]
    c84c:	401c      	ands	r4, r3
    c84e:	4b44      	ldr	r3, [pc, #272]	; (c960 <__aeabi_dmul+0x1d8>)
    c850:	2100      	movs	r1, #0
    c852:	032d      	lsls	r5, r5, #12
    c854:	0d0a      	lsrs	r2, r1, #20
    c856:	0512      	lsls	r2, r2, #20
    c858:	0b2d      	lsrs	r5, r5, #12
    c85a:	4315      	orrs	r5, r2
    c85c:	4a43      	ldr	r2, [pc, #268]	; (c96c <__aeabi_dmul+0x1e4>)
    c85e:	051b      	lsls	r3, r3, #20
    c860:	4015      	ands	r5, r2
    c862:	431d      	orrs	r5, r3
    c864:	006d      	lsls	r5, r5, #1
    c866:	07e4      	lsls	r4, r4, #31
    c868:	086d      	lsrs	r5, r5, #1
    c86a:	4325      	orrs	r5, r4
    c86c:	1c30      	adds	r0, r6, #0
    c86e:	1c29      	adds	r1, r5, #0
    c870:	b007      	add	sp, #28
    c872:	bc3c      	pop	{r2, r3, r4, r5}
    c874:	4690      	mov	r8, r2
    c876:	4699      	mov	r9, r3
    c878:	46a2      	mov	sl, r4
    c87a:	46ab      	mov	fp, r5
    c87c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    c87e:	432b      	orrs	r3, r5
    c880:	d04e      	beq.n	c920 <__aeabi_dmul+0x198>
    c882:	465b      	mov	r3, fp
    c884:	2b00      	cmp	r3, #0
    c886:	d100      	bne.n	c88a <__aeabi_dmul+0x102>
    c888:	e185      	b.n	cb96 <__aeabi_dmul+0x40e>
    c88a:	4658      	mov	r0, fp
    c88c:	f000 fe36 	bl	d4fc <__clzsi2>
    c890:	1c02      	adds	r2, r0, #0
    c892:	2328      	movs	r3, #40	; 0x28
    c894:	1c29      	adds	r1, r5, #0
    c896:	1a9b      	subs	r3, r3, r2
    c898:	1c16      	adds	r6, r2, #0
    c89a:	4658      	mov	r0, fp
    c89c:	40d9      	lsrs	r1, r3
    c89e:	3e08      	subs	r6, #8
    c8a0:	40b0      	lsls	r0, r6
    c8a2:	1c0b      	adds	r3, r1, #0
    c8a4:	40b5      	lsls	r5, r6
    c8a6:	4303      	orrs	r3, r0
    c8a8:	469b      	mov	fp, r3
    c8aa:	1c2e      	adds	r6, r5, #0
    c8ac:	2300      	movs	r3, #0
    c8ae:	4f30      	ldr	r7, [pc, #192]	; (c970 <__aeabi_dmul+0x1e8>)
    c8b0:	9300      	str	r3, [sp, #0]
    c8b2:	1abf      	subs	r7, r7, r2
    c8b4:	4698      	mov	r8, r3
    c8b6:	e78c      	b.n	c7d2 <__aeabi_dmul+0x4a>
    c8b8:	4651      	mov	r1, sl
    c8ba:	4329      	orrs	r1, r5
    c8bc:	d12e      	bne.n	c91c <__aeabi_dmul+0x194>
    c8be:	2500      	movs	r5, #0
    c8c0:	2200      	movs	r2, #0
    c8c2:	2102      	movs	r1, #2
    c8c4:	e79e      	b.n	c804 <__aeabi_dmul+0x7c>
    c8c6:	4651      	mov	r1, sl
    c8c8:	4329      	orrs	r1, r5
    c8ca:	d023      	beq.n	c914 <__aeabi_dmul+0x18c>
    c8cc:	2d00      	cmp	r5, #0
    c8ce:	d100      	bne.n	c8d2 <__aeabi_dmul+0x14a>
    c8d0:	e154      	b.n	cb7c <__aeabi_dmul+0x3f4>
    c8d2:	1c28      	adds	r0, r5, #0
    c8d4:	f000 fe12 	bl	d4fc <__clzsi2>
    c8d8:	1c03      	adds	r3, r0, #0
    c8da:	2128      	movs	r1, #40	; 0x28
    c8dc:	4650      	mov	r0, sl
    c8de:	1ac9      	subs	r1, r1, r3
    c8e0:	1c1a      	adds	r2, r3, #0
    c8e2:	40c8      	lsrs	r0, r1
    c8e4:	4651      	mov	r1, sl
    c8e6:	3a08      	subs	r2, #8
    c8e8:	4091      	lsls	r1, r2
    c8ea:	4095      	lsls	r5, r2
    c8ec:	1c0a      	adds	r2, r1, #0
    c8ee:	4305      	orrs	r5, r0
    c8f0:	481f      	ldr	r0, [pc, #124]	; (c970 <__aeabi_dmul+0x1e8>)
    c8f2:	2100      	movs	r1, #0
    c8f4:	1ac3      	subs	r3, r0, r3
    c8f6:	e785      	b.n	c804 <__aeabi_dmul+0x7c>
    c8f8:	2b03      	cmp	r3, #3
    c8fa:	d100      	bne.n	c8fe <__aeabi_dmul+0x176>
    c8fc:	e1c2      	b.n	cc84 <__aeabi_dmul+0x4fc>
    c8fe:	2b01      	cmp	r3, #1
    c900:	d000      	beq.n	c904 <__aeabi_dmul+0x17c>
    c902:	e16d      	b.n	cbe0 <__aeabi_dmul+0x458>
    c904:	4644      	mov	r4, r8
    c906:	9b01      	ldr	r3, [sp, #4]
    c908:	2500      	movs	r5, #0
    c90a:	401c      	ands	r4, r3
    c90c:	b2e4      	uxtb	r4, r4
    c90e:	2300      	movs	r3, #0
    c910:	2600      	movs	r6, #0
    c912:	e79d      	b.n	c850 <__aeabi_dmul+0xc8>
    c914:	2500      	movs	r5, #0
    c916:	2200      	movs	r2, #0
    c918:	2101      	movs	r1, #1
    c91a:	e773      	b.n	c804 <__aeabi_dmul+0x7c>
    c91c:	2103      	movs	r1, #3
    c91e:	e771      	b.n	c804 <__aeabi_dmul+0x7c>
    c920:	2304      	movs	r3, #4
    c922:	9300      	str	r3, [sp, #0]
    c924:	2300      	movs	r3, #0
    c926:	469b      	mov	fp, r3
    c928:	3301      	adds	r3, #1
    c92a:	2600      	movs	r6, #0
    c92c:	4698      	mov	r8, r3
    c92e:	e750      	b.n	c7d2 <__aeabi_dmul+0x4a>
    c930:	230c      	movs	r3, #12
    c932:	9300      	str	r3, [sp, #0]
    c934:	3b09      	subs	r3, #9
    c936:	4698      	mov	r8, r3
    c938:	e74b      	b.n	c7d2 <__aeabi_dmul+0x4a>
    c93a:	2580      	movs	r5, #128	; 0x80
    c93c:	2400      	movs	r4, #0
    c93e:	032d      	lsls	r5, r5, #12
    c940:	2600      	movs	r6, #0
    c942:	4b07      	ldr	r3, [pc, #28]	; (c960 <__aeabi_dmul+0x1d8>)
    c944:	e784      	b.n	c850 <__aeabi_dmul+0xc8>
    c946:	464b      	mov	r3, r9
    c948:	46ab      	mov	fp, r5
    c94a:	1c16      	adds	r6, r2, #0
    c94c:	9301      	str	r3, [sp, #4]
    c94e:	4688      	mov	r8, r1
    c950:	e775      	b.n	c83e <__aeabi_dmul+0xb6>
    c952:	9b02      	ldr	r3, [sp, #8]
    c954:	46ab      	mov	fp, r5
    c956:	1c16      	adds	r6, r2, #0
    c958:	9301      	str	r3, [sp, #4]
    c95a:	4688      	mov	r8, r1
    c95c:	e76f      	b.n	c83e <__aeabi_dmul+0xb6>
    c95e:	46c0      	nop			; (mov r8, r8)
    c960:	000007ff 	.word	0x000007ff
    c964:	fffffc01 	.word	0xfffffc01
    c968:	000114d8 	.word	0x000114d8
    c96c:	800fffff 	.word	0x800fffff
    c970:	fffffc0d 	.word	0xfffffc0d
    c974:	0c33      	lsrs	r3, r6, #16
    c976:	0436      	lsls	r6, r6, #16
    c978:	0c36      	lsrs	r6, r6, #16
    c97a:	469c      	mov	ip, r3
    c97c:	1c33      	adds	r3, r6, #0
    c97e:	0c14      	lsrs	r4, r2, #16
    c980:	0412      	lsls	r2, r2, #16
    c982:	0c12      	lsrs	r2, r2, #16
    c984:	4353      	muls	r3, r2
    c986:	4698      	mov	r8, r3
    c988:	4663      	mov	r3, ip
    c98a:	4353      	muls	r3, r2
    c98c:	4699      	mov	r9, r3
    c98e:	4663      	mov	r3, ip
    c990:	4363      	muls	r3, r4
    c992:	9301      	str	r3, [sp, #4]
    c994:	1c33      	adds	r3, r6, #0
    c996:	4641      	mov	r1, r8
    c998:	4363      	muls	r3, r4
    c99a:	0c09      	lsrs	r1, r1, #16
    c99c:	444b      	add	r3, r9
    c99e:	185b      	adds	r3, r3, r1
    c9a0:	4599      	cmp	r9, r3
    c9a2:	d905      	bls.n	c9b0 <__aeabi_dmul+0x228>
    c9a4:	2080      	movs	r0, #128	; 0x80
    c9a6:	0240      	lsls	r0, r0, #9
    c9a8:	4681      	mov	r9, r0
    c9aa:	9901      	ldr	r1, [sp, #4]
    c9ac:	4449      	add	r1, r9
    c9ae:	9101      	str	r1, [sp, #4]
    c9b0:	0c19      	lsrs	r1, r3, #16
    c9b2:	9103      	str	r1, [sp, #12]
    c9b4:	4641      	mov	r1, r8
    c9b6:	0409      	lsls	r1, r1, #16
    c9b8:	0c09      	lsrs	r1, r1, #16
    c9ba:	041b      	lsls	r3, r3, #16
    c9bc:	185b      	adds	r3, r3, r1
    c9be:	9304      	str	r3, [sp, #16]
    c9c0:	0c2b      	lsrs	r3, r5, #16
    c9c2:	4698      	mov	r8, r3
    c9c4:	1c33      	adds	r3, r6, #0
    c9c6:	042d      	lsls	r5, r5, #16
    c9c8:	0c29      	lsrs	r1, r5, #16
    c9ca:	434b      	muls	r3, r1
    c9cc:	4660      	mov	r0, ip
    c9ce:	9300      	str	r3, [sp, #0]
    c9d0:	4643      	mov	r3, r8
    c9d2:	4665      	mov	r5, ip
    c9d4:	4358      	muls	r0, r3
    c9d6:	435e      	muls	r6, r3
    c9d8:	9b00      	ldr	r3, [sp, #0]
    c9da:	434d      	muls	r5, r1
    c9dc:	0c1b      	lsrs	r3, r3, #16
    c9de:	4699      	mov	r9, r3
    c9e0:	19ae      	adds	r6, r5, r6
    c9e2:	444e      	add	r6, r9
    c9e4:	4684      	mov	ip, r0
    c9e6:	42b5      	cmp	r5, r6
    c9e8:	d903      	bls.n	c9f2 <__aeabi_dmul+0x26a>
    c9ea:	2380      	movs	r3, #128	; 0x80
    c9ec:	025b      	lsls	r3, r3, #9
    c9ee:	4699      	mov	r9, r3
    c9f0:	44cc      	add	ip, r9
    c9f2:	0c35      	lsrs	r5, r6, #16
    c9f4:	1c2b      	adds	r3, r5, #0
    c9f6:	9803      	ldr	r0, [sp, #12]
    c9f8:	4463      	add	r3, ip
    c9fa:	4684      	mov	ip, r0
    c9fc:	9305      	str	r3, [sp, #20]
    c9fe:	9b00      	ldr	r3, [sp, #0]
    ca00:	0436      	lsls	r6, r6, #16
    ca02:	041b      	lsls	r3, r3, #16
    ca04:	0c1b      	lsrs	r3, r3, #16
    ca06:	18f3      	adds	r3, r6, r3
    ca08:	449c      	add	ip, r3
    ca0a:	4660      	mov	r0, ip
    ca0c:	9003      	str	r0, [sp, #12]
    ca0e:	4658      	mov	r0, fp
    ca10:	0405      	lsls	r5, r0, #16
    ca12:	0c06      	lsrs	r6, r0, #16
    ca14:	0c28      	lsrs	r0, r5, #16
    ca16:	4684      	mov	ip, r0
    ca18:	4350      	muls	r0, r2
    ca1a:	1c35      	adds	r5, r6, #0
    ca1c:	4681      	mov	r9, r0
    ca1e:	4660      	mov	r0, ip
    ca20:	4365      	muls	r5, r4
    ca22:	4344      	muls	r4, r0
    ca24:	4648      	mov	r0, r9
    ca26:	0c00      	lsrs	r0, r0, #16
    ca28:	4683      	mov	fp, r0
    ca2a:	4372      	muls	r2, r6
    ca2c:	1914      	adds	r4, r2, r4
    ca2e:	445c      	add	r4, fp
    ca30:	42a2      	cmp	r2, r4
    ca32:	d903      	bls.n	ca3c <__aeabi_dmul+0x2b4>
    ca34:	2280      	movs	r2, #128	; 0x80
    ca36:	0252      	lsls	r2, r2, #9
    ca38:	4693      	mov	fp, r2
    ca3a:	445d      	add	r5, fp
    ca3c:	0c22      	lsrs	r2, r4, #16
    ca3e:	18ad      	adds	r5, r5, r2
    ca40:	464a      	mov	r2, r9
    ca42:	0412      	lsls	r2, r2, #16
    ca44:	0c12      	lsrs	r2, r2, #16
    ca46:	0424      	lsls	r4, r4, #16
    ca48:	4640      	mov	r0, r8
    ca4a:	18a4      	adds	r4, r4, r2
    ca4c:	4662      	mov	r2, ip
    ca4e:	434a      	muls	r2, r1
    ca50:	4371      	muls	r1, r6
    ca52:	4346      	muls	r6, r0
    ca54:	4660      	mov	r0, ip
    ca56:	9600      	str	r6, [sp, #0]
    ca58:	4646      	mov	r6, r8
    ca5a:	4370      	muls	r0, r6
    ca5c:	4680      	mov	r8, r0
    ca5e:	0c10      	lsrs	r0, r2, #16
    ca60:	4684      	mov	ip, r0
    ca62:	4488      	add	r8, r1
    ca64:	44e0      	add	r8, ip
    ca66:	4541      	cmp	r1, r8
    ca68:	d905      	bls.n	ca76 <__aeabi_dmul+0x2ee>
    ca6a:	2180      	movs	r1, #128	; 0x80
    ca6c:	0249      	lsls	r1, r1, #9
    ca6e:	468c      	mov	ip, r1
    ca70:	9900      	ldr	r1, [sp, #0]
    ca72:	4461      	add	r1, ip
    ca74:	9100      	str	r1, [sp, #0]
    ca76:	9801      	ldr	r0, [sp, #4]
    ca78:	9903      	ldr	r1, [sp, #12]
    ca7a:	4684      	mov	ip, r0
    ca7c:	4461      	add	r1, ip
    ca7e:	4299      	cmp	r1, r3
    ca80:	419b      	sbcs	r3, r3
    ca82:	425b      	negs	r3, r3
    ca84:	4699      	mov	r9, r3
    ca86:	9805      	ldr	r0, [sp, #20]
    ca88:	4643      	mov	r3, r8
    ca8a:	4684      	mov	ip, r0
    ca8c:	0412      	lsls	r2, r2, #16
    ca8e:	0c12      	lsrs	r2, r2, #16
    ca90:	041b      	lsls	r3, r3, #16
    ca92:	189b      	adds	r3, r3, r2
    ca94:	4463      	add	r3, ip
    ca96:	469c      	mov	ip, r3
    ca98:	46ab      	mov	fp, r5
    ca9a:	4283      	cmp	r3, r0
    ca9c:	419b      	sbcs	r3, r3
    ca9e:	4640      	mov	r0, r8
    caa0:	190a      	adds	r2, r1, r4
    caa2:	44cc      	add	ip, r9
    caa4:	42a2      	cmp	r2, r4
    caa6:	4189      	sbcs	r1, r1
    caa8:	44e3      	add	fp, ip
    caaa:	45cc      	cmp	ip, r9
    caac:	41b6      	sbcs	r6, r6
    caae:	465c      	mov	r4, fp
    cab0:	0c00      	lsrs	r0, r0, #16
    cab2:	4680      	mov	r8, r0
    cab4:	4249      	negs	r1, r1
    cab6:	4276      	negs	r6, r6
    cab8:	425b      	negs	r3, r3
    caba:	1864      	adds	r4, r4, r1
    cabc:	4333      	orrs	r3, r6
    cabe:	4498      	add	r8, r3
    cac0:	428c      	cmp	r4, r1
    cac2:	4189      	sbcs	r1, r1
    cac4:	45ab      	cmp	fp, r5
    cac6:	419b      	sbcs	r3, r3
    cac8:	4249      	negs	r1, r1
    caca:	425b      	negs	r3, r3
    cacc:	4319      	orrs	r1, r3
    cace:	1c0d      	adds	r5, r1, #0
    cad0:	9b00      	ldr	r3, [sp, #0]
    cad2:	4445      	add	r5, r8
    cad4:	18ee      	adds	r6, r5, r3
    cad6:	0276      	lsls	r6, r6, #9
    cad8:	0de5      	lsrs	r5, r4, #23
    cada:	432e      	orrs	r6, r5
    cadc:	46b3      	mov	fp, r6
    cade:	9b04      	ldr	r3, [sp, #16]
    cae0:	0256      	lsls	r6, r2, #9
    cae2:	431e      	orrs	r6, r3
    cae4:	1e73      	subs	r3, r6, #1
    cae6:	419e      	sbcs	r6, r3
    cae8:	465b      	mov	r3, fp
    caea:	0dd2      	lsrs	r2, r2, #23
    caec:	4332      	orrs	r2, r6
    caee:	0266      	lsls	r6, r4, #9
    caf0:	4316      	orrs	r6, r2
    caf2:	01db      	lsls	r3, r3, #7
    caf4:	d50a      	bpl.n	cb0c <__aeabi_dmul+0x384>
    caf6:	2301      	movs	r3, #1
    caf8:	4033      	ands	r3, r6
    cafa:	0876      	lsrs	r6, r6, #1
    cafc:	431e      	orrs	r6, r3
    cafe:	465b      	mov	r3, fp
    cb00:	07db      	lsls	r3, r3, #31
    cb02:	431e      	orrs	r6, r3
    cb04:	465b      	mov	r3, fp
    cb06:	085b      	lsrs	r3, r3, #1
    cb08:	469b      	mov	fp, r3
    cb0a:	4657      	mov	r7, sl
    cb0c:	4b63      	ldr	r3, [pc, #396]	; (cc9c <__aeabi_dmul+0x514>)
    cb0e:	18fb      	adds	r3, r7, r3
    cb10:	2b00      	cmp	r3, #0
    cb12:	dd5a      	ble.n	cbca <__aeabi_dmul+0x442>
    cb14:	0772      	lsls	r2, r6, #29
    cb16:	d009      	beq.n	cb2c <__aeabi_dmul+0x3a4>
    cb18:	220f      	movs	r2, #15
    cb1a:	4032      	ands	r2, r6
    cb1c:	2a04      	cmp	r2, #4
    cb1e:	d005      	beq.n	cb2c <__aeabi_dmul+0x3a4>
    cb20:	1d32      	adds	r2, r6, #4
    cb22:	42b2      	cmp	r2, r6
    cb24:	41b6      	sbcs	r6, r6
    cb26:	4276      	negs	r6, r6
    cb28:	44b3      	add	fp, r6
    cb2a:	1c16      	adds	r6, r2, #0
    cb2c:	465a      	mov	r2, fp
    cb2e:	01d2      	lsls	r2, r2, #7
    cb30:	d506      	bpl.n	cb40 <__aeabi_dmul+0x3b8>
    cb32:	465a      	mov	r2, fp
    cb34:	4b5a      	ldr	r3, [pc, #360]	; (cca0 <__aeabi_dmul+0x518>)
    cb36:	401a      	ands	r2, r3
    cb38:	2380      	movs	r3, #128	; 0x80
    cb3a:	4693      	mov	fp, r2
    cb3c:	00db      	lsls	r3, r3, #3
    cb3e:	18fb      	adds	r3, r7, r3
    cb40:	4a58      	ldr	r2, [pc, #352]	; (cca4 <__aeabi_dmul+0x51c>)
    cb42:	4293      	cmp	r3, r2
    cb44:	dd34      	ble.n	cbb0 <__aeabi_dmul+0x428>
    cb46:	2401      	movs	r4, #1
    cb48:	9b02      	ldr	r3, [sp, #8]
    cb4a:	2500      	movs	r5, #0
    cb4c:	401c      	ands	r4, r3
    cb4e:	2600      	movs	r6, #0
    cb50:	4b55      	ldr	r3, [pc, #340]	; (cca8 <__aeabi_dmul+0x520>)
    cb52:	e67d      	b.n	c850 <__aeabi_dmul+0xc8>
    cb54:	2080      	movs	r0, #128	; 0x80
    cb56:	465b      	mov	r3, fp
    cb58:	0300      	lsls	r0, r0, #12
    cb5a:	4203      	tst	r3, r0
    cb5c:	d008      	beq.n	cb70 <__aeabi_dmul+0x3e8>
    cb5e:	4205      	tst	r5, r0
    cb60:	d106      	bne.n	cb70 <__aeabi_dmul+0x3e8>
    cb62:	4305      	orrs	r5, r0
    cb64:	032d      	lsls	r5, r5, #12
    cb66:	0b2d      	lsrs	r5, r5, #12
    cb68:	464c      	mov	r4, r9
    cb6a:	1c16      	adds	r6, r2, #0
    cb6c:	4b4e      	ldr	r3, [pc, #312]	; (cca8 <__aeabi_dmul+0x520>)
    cb6e:	e66f      	b.n	c850 <__aeabi_dmul+0xc8>
    cb70:	465d      	mov	r5, fp
    cb72:	4305      	orrs	r5, r0
    cb74:	032d      	lsls	r5, r5, #12
    cb76:	0b2d      	lsrs	r5, r5, #12
    cb78:	4b4b      	ldr	r3, [pc, #300]	; (cca8 <__aeabi_dmul+0x520>)
    cb7a:	e669      	b.n	c850 <__aeabi_dmul+0xc8>
    cb7c:	4650      	mov	r0, sl
    cb7e:	f000 fcbd 	bl	d4fc <__clzsi2>
    cb82:	1c03      	adds	r3, r0, #0
    cb84:	3320      	adds	r3, #32
    cb86:	2b27      	cmp	r3, #39	; 0x27
    cb88:	dc00      	bgt.n	cb8c <__aeabi_dmul+0x404>
    cb8a:	e6a6      	b.n	c8da <__aeabi_dmul+0x152>
    cb8c:	4655      	mov	r5, sl
    cb8e:	3808      	subs	r0, #8
    cb90:	4085      	lsls	r5, r0
    cb92:	2200      	movs	r2, #0
    cb94:	e6ac      	b.n	c8f0 <__aeabi_dmul+0x168>
    cb96:	1c28      	adds	r0, r5, #0
    cb98:	f000 fcb0 	bl	d4fc <__clzsi2>
    cb9c:	1c02      	adds	r2, r0, #0
    cb9e:	3220      	adds	r2, #32
    cba0:	2a27      	cmp	r2, #39	; 0x27
    cba2:	dc00      	bgt.n	cba6 <__aeabi_dmul+0x41e>
    cba4:	e675      	b.n	c892 <__aeabi_dmul+0x10a>
    cba6:	3808      	subs	r0, #8
    cba8:	4085      	lsls	r5, r0
    cbaa:	2600      	movs	r6, #0
    cbac:	46ab      	mov	fp, r5
    cbae:	e67d      	b.n	c8ac <__aeabi_dmul+0x124>
    cbb0:	465a      	mov	r2, fp
    cbb2:	08f6      	lsrs	r6, r6, #3
    cbb4:	0752      	lsls	r2, r2, #29
    cbb6:	4316      	orrs	r6, r2
    cbb8:	465a      	mov	r2, fp
    cbba:	2401      	movs	r4, #1
    cbbc:	0255      	lsls	r5, r2, #9
    cbbe:	9a02      	ldr	r2, [sp, #8]
    cbc0:	055b      	lsls	r3, r3, #21
    cbc2:	0b2d      	lsrs	r5, r5, #12
    cbc4:	0d5b      	lsrs	r3, r3, #21
    cbc6:	4014      	ands	r4, r2
    cbc8:	e642      	b.n	c850 <__aeabi_dmul+0xc8>
    cbca:	4d38      	ldr	r5, [pc, #224]	; (ccac <__aeabi_dmul+0x524>)
    cbcc:	1bed      	subs	r5, r5, r7
    cbce:	2d38      	cmp	r5, #56	; 0x38
    cbd0:	dd0a      	ble.n	cbe8 <__aeabi_dmul+0x460>
    cbd2:	2401      	movs	r4, #1
    cbd4:	9b02      	ldr	r3, [sp, #8]
    cbd6:	2500      	movs	r5, #0
    cbd8:	401c      	ands	r4, r3
    cbda:	2600      	movs	r6, #0
    cbdc:	2300      	movs	r3, #0
    cbde:	e637      	b.n	c850 <__aeabi_dmul+0xc8>
    cbe0:	9b01      	ldr	r3, [sp, #4]
    cbe2:	4657      	mov	r7, sl
    cbe4:	9302      	str	r3, [sp, #8]
    cbe6:	e791      	b.n	cb0c <__aeabi_dmul+0x384>
    cbe8:	2d1f      	cmp	r5, #31
    cbea:	dc25      	bgt.n	cc38 <__aeabi_dmul+0x4b0>
    cbec:	4b30      	ldr	r3, [pc, #192]	; (ccb0 <__aeabi_dmul+0x528>)
    cbee:	1c32      	adds	r2, r6, #0
    cbf0:	469c      	mov	ip, r3
    cbf2:	4467      	add	r7, ip
    cbf4:	40be      	lsls	r6, r7
    cbf6:	465b      	mov	r3, fp
    cbf8:	40bb      	lsls	r3, r7
    cbfa:	1c37      	adds	r7, r6, #0
    cbfc:	40ea      	lsrs	r2, r5
    cbfe:	1e7e      	subs	r6, r7, #1
    cc00:	41b7      	sbcs	r7, r6
    cc02:	4313      	orrs	r3, r2
    cc04:	433b      	orrs	r3, r7
    cc06:	1c1e      	adds	r6, r3, #0
    cc08:	465b      	mov	r3, fp
    cc0a:	40eb      	lsrs	r3, r5
    cc0c:	1c1d      	adds	r5, r3, #0
    cc0e:	0773      	lsls	r3, r6, #29
    cc10:	d009      	beq.n	cc26 <__aeabi_dmul+0x49e>
    cc12:	230f      	movs	r3, #15
    cc14:	4033      	ands	r3, r6
    cc16:	2b04      	cmp	r3, #4
    cc18:	d005      	beq.n	cc26 <__aeabi_dmul+0x49e>
    cc1a:	1d33      	adds	r3, r6, #4
    cc1c:	42b3      	cmp	r3, r6
    cc1e:	41b6      	sbcs	r6, r6
    cc20:	4276      	negs	r6, r6
    cc22:	19ad      	adds	r5, r5, r6
    cc24:	1c1e      	adds	r6, r3, #0
    cc26:	022b      	lsls	r3, r5, #8
    cc28:	d520      	bpl.n	cc6c <__aeabi_dmul+0x4e4>
    cc2a:	2401      	movs	r4, #1
    cc2c:	9b02      	ldr	r3, [sp, #8]
    cc2e:	2500      	movs	r5, #0
    cc30:	401c      	ands	r4, r3
    cc32:	2600      	movs	r6, #0
    cc34:	2301      	movs	r3, #1
    cc36:	e60b      	b.n	c850 <__aeabi_dmul+0xc8>
    cc38:	465a      	mov	r2, fp
    cc3a:	4b1e      	ldr	r3, [pc, #120]	; (ccb4 <__aeabi_dmul+0x52c>)
    cc3c:	1bdb      	subs	r3, r3, r7
    cc3e:	40da      	lsrs	r2, r3
    cc40:	1c13      	adds	r3, r2, #0
    cc42:	2d20      	cmp	r5, #32
    cc44:	d01c      	beq.n	cc80 <__aeabi_dmul+0x4f8>
    cc46:	4a1c      	ldr	r2, [pc, #112]	; (ccb8 <__aeabi_dmul+0x530>)
    cc48:	4694      	mov	ip, r2
    cc4a:	465a      	mov	r2, fp
    cc4c:	4467      	add	r7, ip
    cc4e:	40ba      	lsls	r2, r7
    cc50:	1c17      	adds	r7, r2, #0
    cc52:	433e      	orrs	r6, r7
    cc54:	1e72      	subs	r2, r6, #1
    cc56:	4196      	sbcs	r6, r2
    cc58:	431e      	orrs	r6, r3
    cc5a:	2307      	movs	r3, #7
    cc5c:	2500      	movs	r5, #0
    cc5e:	4033      	ands	r3, r6
    cc60:	d007      	beq.n	cc72 <__aeabi_dmul+0x4ea>
    cc62:	230f      	movs	r3, #15
    cc64:	2500      	movs	r5, #0
    cc66:	4033      	ands	r3, r6
    cc68:	2b04      	cmp	r3, #4
    cc6a:	d1d6      	bne.n	cc1a <__aeabi_dmul+0x492>
    cc6c:	076b      	lsls	r3, r5, #29
    cc6e:	026d      	lsls	r5, r5, #9
    cc70:	0b2d      	lsrs	r5, r5, #12
    cc72:	2401      	movs	r4, #1
    cc74:	08f6      	lsrs	r6, r6, #3
    cc76:	431e      	orrs	r6, r3
    cc78:	9b02      	ldr	r3, [sp, #8]
    cc7a:	401c      	ands	r4, r3
    cc7c:	2300      	movs	r3, #0
    cc7e:	e5e7      	b.n	c850 <__aeabi_dmul+0xc8>
    cc80:	2700      	movs	r7, #0
    cc82:	e7e6      	b.n	cc52 <__aeabi_dmul+0x4ca>
    cc84:	2580      	movs	r5, #128	; 0x80
    cc86:	465b      	mov	r3, fp
    cc88:	2401      	movs	r4, #1
    cc8a:	032d      	lsls	r5, r5, #12
    cc8c:	431d      	orrs	r5, r3
    cc8e:	9b01      	ldr	r3, [sp, #4]
    cc90:	032d      	lsls	r5, r5, #12
    cc92:	4023      	ands	r3, r4
    cc94:	1c1c      	adds	r4, r3, #0
    cc96:	0b2d      	lsrs	r5, r5, #12
    cc98:	4b03      	ldr	r3, [pc, #12]	; (cca8 <__aeabi_dmul+0x520>)
    cc9a:	e5d9      	b.n	c850 <__aeabi_dmul+0xc8>
    cc9c:	000003ff 	.word	0x000003ff
    cca0:	feffffff 	.word	0xfeffffff
    cca4:	000007fe 	.word	0x000007fe
    cca8:	000007ff 	.word	0x000007ff
    ccac:	fffffc02 	.word	0xfffffc02
    ccb0:	0000041e 	.word	0x0000041e
    ccb4:	fffffbe2 	.word	0xfffffbe2
    ccb8:	0000043e 	.word	0x0000043e

0000ccbc <__aeabi_dsub>:
    ccbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    ccbe:	464d      	mov	r5, r9
    ccc0:	4644      	mov	r4, r8
    ccc2:	465f      	mov	r7, fp
    ccc4:	4656      	mov	r6, sl
    ccc6:	b4f0      	push	{r4, r5, r6, r7}
    ccc8:	1c0e      	adds	r6, r1, #0
    ccca:	1c11      	adds	r1, r2, #0
    cccc:	0332      	lsls	r2, r6, #12
    ccce:	0a52      	lsrs	r2, r2, #9
    ccd0:	0f47      	lsrs	r7, r0, #29
    ccd2:	4317      	orrs	r7, r2
    ccd4:	00c5      	lsls	r5, r0, #3
    ccd6:	031a      	lsls	r2, r3, #12
    ccd8:	0058      	lsls	r0, r3, #1
    ccda:	0fdb      	lsrs	r3, r3, #31
    ccdc:	4699      	mov	r9, r3
    ccde:	0a52      	lsrs	r2, r2, #9
    cce0:	0f4b      	lsrs	r3, r1, #29
    cce2:	b083      	sub	sp, #12
    cce4:	431a      	orrs	r2, r3
    cce6:	00cb      	lsls	r3, r1, #3
    cce8:	9301      	str	r3, [sp, #4]
    ccea:	4bcf      	ldr	r3, [pc, #828]	; (d028 <__aeabi_dsub+0x36c>)
    ccec:	0074      	lsls	r4, r6, #1
    ccee:	0ff6      	lsrs	r6, r6, #31
    ccf0:	0d64      	lsrs	r4, r4, #21
    ccf2:	46b0      	mov	r8, r6
    ccf4:	0d40      	lsrs	r0, r0, #21
    ccf6:	4298      	cmp	r0, r3
    ccf8:	d100      	bne.n	ccfc <__aeabi_dsub+0x40>
    ccfa:	e0e8      	b.n	cece <__aeabi_dsub+0x212>
    ccfc:	2301      	movs	r3, #1
    ccfe:	4649      	mov	r1, r9
    cd00:	4059      	eors	r1, r3
    cd02:	1c0b      	adds	r3, r1, #0
    cd04:	429e      	cmp	r6, r3
    cd06:	d100      	bne.n	cd0a <__aeabi_dsub+0x4e>
    cd08:	e0b1      	b.n	ce6e <__aeabi_dsub+0x1b2>
    cd0a:	1a26      	subs	r6, r4, r0
    cd0c:	2e00      	cmp	r6, #0
    cd0e:	dc00      	bgt.n	cd12 <__aeabi_dsub+0x56>
    cd10:	e11c      	b.n	cf4c <__aeabi_dsub+0x290>
    cd12:	2800      	cmp	r0, #0
    cd14:	d142      	bne.n	cd9c <__aeabi_dsub+0xe0>
    cd16:	1c13      	adds	r3, r2, #0
    cd18:	9901      	ldr	r1, [sp, #4]
    cd1a:	430b      	orrs	r3, r1
    cd1c:	d000      	beq.n	cd20 <__aeabi_dsub+0x64>
    cd1e:	e0e6      	b.n	ceee <__aeabi_dsub+0x232>
    cd20:	076b      	lsls	r3, r5, #29
    cd22:	d100      	bne.n	cd26 <__aeabi_dsub+0x6a>
    cd24:	e08e      	b.n	ce44 <__aeabi_dsub+0x188>
    cd26:	230f      	movs	r3, #15
    cd28:	402b      	ands	r3, r5
    cd2a:	2b04      	cmp	r3, #4
    cd2c:	d100      	bne.n	cd30 <__aeabi_dsub+0x74>
    cd2e:	e089      	b.n	ce44 <__aeabi_dsub+0x188>
    cd30:	1d2a      	adds	r2, r5, #4
    cd32:	42aa      	cmp	r2, r5
    cd34:	41ad      	sbcs	r5, r5
    cd36:	2380      	movs	r3, #128	; 0x80
    cd38:	2601      	movs	r6, #1
    cd3a:	4641      	mov	r1, r8
    cd3c:	426d      	negs	r5, r5
    cd3e:	197f      	adds	r7, r7, r5
    cd40:	041b      	lsls	r3, r3, #16
    cd42:	403b      	ands	r3, r7
    cd44:	400e      	ands	r6, r1
    cd46:	1c15      	adds	r5, r2, #0
    cd48:	2b00      	cmp	r3, #0
    cd4a:	d100      	bne.n	cd4e <__aeabi_dsub+0x92>
    cd4c:	e083      	b.n	ce56 <__aeabi_dsub+0x19a>
    cd4e:	4bb6      	ldr	r3, [pc, #728]	; (d028 <__aeabi_dsub+0x36c>)
    cd50:	3401      	adds	r4, #1
    cd52:	429c      	cmp	r4, r3
    cd54:	d100      	bne.n	cd58 <__aeabi_dsub+0x9c>
    cd56:	e116      	b.n	cf86 <__aeabi_dsub+0x2ca>
    cd58:	1c3a      	adds	r2, r7, #0
    cd5a:	4bb4      	ldr	r3, [pc, #720]	; (d02c <__aeabi_dsub+0x370>)
    cd5c:	08ed      	lsrs	r5, r5, #3
    cd5e:	401a      	ands	r2, r3
    cd60:	0750      	lsls	r0, r2, #29
    cd62:	0564      	lsls	r4, r4, #21
    cd64:	0252      	lsls	r2, r2, #9
    cd66:	4305      	orrs	r5, r0
    cd68:	0b12      	lsrs	r2, r2, #12
    cd6a:	0d64      	lsrs	r4, r4, #21
    cd6c:	2100      	movs	r1, #0
    cd6e:	0312      	lsls	r2, r2, #12
    cd70:	0d0b      	lsrs	r3, r1, #20
    cd72:	051b      	lsls	r3, r3, #20
    cd74:	0564      	lsls	r4, r4, #21
    cd76:	0b12      	lsrs	r2, r2, #12
    cd78:	431a      	orrs	r2, r3
    cd7a:	0863      	lsrs	r3, r4, #1
    cd7c:	4cac      	ldr	r4, [pc, #688]	; (d030 <__aeabi_dsub+0x374>)
    cd7e:	07f6      	lsls	r6, r6, #31
    cd80:	4014      	ands	r4, r2
    cd82:	431c      	orrs	r4, r3
    cd84:	0064      	lsls	r4, r4, #1
    cd86:	0864      	lsrs	r4, r4, #1
    cd88:	4334      	orrs	r4, r6
    cd8a:	1c28      	adds	r0, r5, #0
    cd8c:	1c21      	adds	r1, r4, #0
    cd8e:	b003      	add	sp, #12
    cd90:	bc3c      	pop	{r2, r3, r4, r5}
    cd92:	4690      	mov	r8, r2
    cd94:	4699      	mov	r9, r3
    cd96:	46a2      	mov	sl, r4
    cd98:	46ab      	mov	fp, r5
    cd9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cd9c:	4ba2      	ldr	r3, [pc, #648]	; (d028 <__aeabi_dsub+0x36c>)
    cd9e:	429c      	cmp	r4, r3
    cda0:	d0be      	beq.n	cd20 <__aeabi_dsub+0x64>
    cda2:	2380      	movs	r3, #128	; 0x80
    cda4:	041b      	lsls	r3, r3, #16
    cda6:	431a      	orrs	r2, r3
    cda8:	2e38      	cmp	r6, #56	; 0x38
    cdaa:	dd00      	ble.n	cdae <__aeabi_dsub+0xf2>
    cdac:	e103      	b.n	cfb6 <__aeabi_dsub+0x2fa>
    cdae:	2e1f      	cmp	r6, #31
    cdb0:	dd00      	ble.n	cdb4 <__aeabi_dsub+0xf8>
    cdb2:	e13f      	b.n	d034 <__aeabi_dsub+0x378>
    cdb4:	2020      	movs	r0, #32
    cdb6:	1b83      	subs	r3, r0, r6
    cdb8:	4699      	mov	r9, r3
    cdba:	1c13      	adds	r3, r2, #0
    cdbc:	4649      	mov	r1, r9
    cdbe:	408b      	lsls	r3, r1
    cdc0:	469c      	mov	ip, r3
    cdc2:	9b01      	ldr	r3, [sp, #4]
    cdc4:	4660      	mov	r0, ip
    cdc6:	40f3      	lsrs	r3, r6
    cdc8:	4303      	orrs	r3, r0
    cdca:	9801      	ldr	r0, [sp, #4]
    cdcc:	40f2      	lsrs	r2, r6
    cdce:	4088      	lsls	r0, r1
    cdd0:	1c01      	adds	r1, r0, #0
    cdd2:	1e48      	subs	r0, r1, #1
    cdd4:	4181      	sbcs	r1, r0
    cdd6:	430b      	orrs	r3, r1
    cdd8:	1aeb      	subs	r3, r5, r3
    cdda:	429d      	cmp	r5, r3
    cddc:	4180      	sbcs	r0, r0
    cdde:	1c1d      	adds	r5, r3, #0
    cde0:	1aba      	subs	r2, r7, r2
    cde2:	4240      	negs	r0, r0
    cde4:	1a17      	subs	r7, r2, r0
    cde6:	023b      	lsls	r3, r7, #8
    cde8:	d400      	bmi.n	cdec <__aeabi_dsub+0x130>
    cdea:	e0a8      	b.n	cf3e <__aeabi_dsub+0x282>
    cdec:	027a      	lsls	r2, r7, #9
    cdee:	0a56      	lsrs	r6, r2, #9
    cdf0:	2e00      	cmp	r6, #0
    cdf2:	d100      	bne.n	cdf6 <__aeabi_dsub+0x13a>
    cdf4:	e0ca      	b.n	cf8c <__aeabi_dsub+0x2d0>
    cdf6:	1c30      	adds	r0, r6, #0
    cdf8:	f000 fb80 	bl	d4fc <__clzsi2>
    cdfc:	1c03      	adds	r3, r0, #0
    cdfe:	3b08      	subs	r3, #8
    ce00:	2b1f      	cmp	r3, #31
    ce02:	dd00      	ble.n	ce06 <__aeabi_dsub+0x14a>
    ce04:	e0cb      	b.n	cf9e <__aeabi_dsub+0x2e2>
    ce06:	2228      	movs	r2, #40	; 0x28
    ce08:	1c29      	adds	r1, r5, #0
    ce0a:	1a12      	subs	r2, r2, r0
    ce0c:	40d1      	lsrs	r1, r2
    ce0e:	409e      	lsls	r6, r3
    ce10:	1c0a      	adds	r2, r1, #0
    ce12:	409d      	lsls	r5, r3
    ce14:	4332      	orrs	r2, r6
    ce16:	429c      	cmp	r4, r3
    ce18:	dd00      	ble.n	ce1c <__aeabi_dsub+0x160>
    ce1a:	e0c8      	b.n	cfae <__aeabi_dsub+0x2f2>
    ce1c:	1b1c      	subs	r4, r3, r4
    ce1e:	1c67      	adds	r7, r4, #1
    ce20:	2f1f      	cmp	r7, #31
    ce22:	dd00      	ble.n	ce26 <__aeabi_dsub+0x16a>
    ce24:	e0ed      	b.n	d002 <__aeabi_dsub+0x346>
    ce26:	231f      	movs	r3, #31
    ce28:	1c29      	adds	r1, r5, #0
    ce2a:	1b1c      	subs	r4, r3, r4
    ce2c:	1c13      	adds	r3, r2, #0
    ce2e:	40a5      	lsls	r5, r4
    ce30:	40a3      	lsls	r3, r4
    ce32:	40f9      	lsrs	r1, r7
    ce34:	1e6c      	subs	r4, r5, #1
    ce36:	41a5      	sbcs	r5, r4
    ce38:	40fa      	lsrs	r2, r7
    ce3a:	4319      	orrs	r1, r3
    ce3c:	430d      	orrs	r5, r1
    ce3e:	1c17      	adds	r7, r2, #0
    ce40:	2400      	movs	r4, #0
    ce42:	e76d      	b.n	cd20 <__aeabi_dsub+0x64>
    ce44:	2380      	movs	r3, #128	; 0x80
    ce46:	2601      	movs	r6, #1
    ce48:	4642      	mov	r2, r8
    ce4a:	041b      	lsls	r3, r3, #16
    ce4c:	403b      	ands	r3, r7
    ce4e:	4016      	ands	r6, r2
    ce50:	2b00      	cmp	r3, #0
    ce52:	d000      	beq.n	ce56 <__aeabi_dsub+0x19a>
    ce54:	e77b      	b.n	cd4e <__aeabi_dsub+0x92>
    ce56:	4b74      	ldr	r3, [pc, #464]	; (d028 <__aeabi_dsub+0x36c>)
    ce58:	08ed      	lsrs	r5, r5, #3
    ce5a:	0778      	lsls	r0, r7, #29
    ce5c:	4305      	orrs	r5, r0
    ce5e:	08fa      	lsrs	r2, r7, #3
    ce60:	429c      	cmp	r4, r3
    ce62:	d03b      	beq.n	cedc <__aeabi_dsub+0x220>
    ce64:	0312      	lsls	r2, r2, #12
    ce66:	0564      	lsls	r4, r4, #21
    ce68:	0b12      	lsrs	r2, r2, #12
    ce6a:	0d64      	lsrs	r4, r4, #21
    ce6c:	e77e      	b.n	cd6c <__aeabi_dsub+0xb0>
    ce6e:	1a23      	subs	r3, r4, r0
    ce70:	469a      	mov	sl, r3
    ce72:	2b00      	cmp	r3, #0
    ce74:	dc00      	bgt.n	ce78 <__aeabi_dsub+0x1bc>
    ce76:	e0a5      	b.n	cfc4 <__aeabi_dsub+0x308>
    ce78:	2800      	cmp	r0, #0
    ce7a:	d044      	beq.n	cf06 <__aeabi_dsub+0x24a>
    ce7c:	486a      	ldr	r0, [pc, #424]	; (d028 <__aeabi_dsub+0x36c>)
    ce7e:	4284      	cmp	r4, r0
    ce80:	d100      	bne.n	ce84 <__aeabi_dsub+0x1c8>
    ce82:	e74d      	b.n	cd20 <__aeabi_dsub+0x64>
    ce84:	2080      	movs	r0, #128	; 0x80
    ce86:	0400      	lsls	r0, r0, #16
    ce88:	4302      	orrs	r2, r0
    ce8a:	4653      	mov	r3, sl
    ce8c:	2b38      	cmp	r3, #56	; 0x38
    ce8e:	dc00      	bgt.n	ce92 <__aeabi_dsub+0x1d6>
    ce90:	e11c      	b.n	d0cc <__aeabi_dsub+0x410>
    ce92:	9b01      	ldr	r3, [sp, #4]
    ce94:	431a      	orrs	r2, r3
    ce96:	1e51      	subs	r1, r2, #1
    ce98:	418a      	sbcs	r2, r1
    ce9a:	b2d1      	uxtb	r1, r2
    ce9c:	2200      	movs	r2, #0
    ce9e:	1949      	adds	r1, r1, r5
    cea0:	42a9      	cmp	r1, r5
    cea2:	4180      	sbcs	r0, r0
    cea4:	1c0d      	adds	r5, r1, #0
    cea6:	19d2      	adds	r2, r2, r7
    cea8:	4240      	negs	r0, r0
    ceaa:	1817      	adds	r7, r2, r0
    ceac:	023b      	lsls	r3, r7, #8
    ceae:	d546      	bpl.n	cf3e <__aeabi_dsub+0x282>
    ceb0:	4b5d      	ldr	r3, [pc, #372]	; (d028 <__aeabi_dsub+0x36c>)
    ceb2:	3401      	adds	r4, #1
    ceb4:	429c      	cmp	r4, r3
    ceb6:	d100      	bne.n	ceba <__aeabi_dsub+0x1fe>
    ceb8:	e169      	b.n	d18e <__aeabi_dsub+0x4d2>
    ceba:	2001      	movs	r0, #1
    cebc:	4a5b      	ldr	r2, [pc, #364]	; (d02c <__aeabi_dsub+0x370>)
    cebe:	086b      	lsrs	r3, r5, #1
    cec0:	403a      	ands	r2, r7
    cec2:	4028      	ands	r0, r5
    cec4:	4318      	orrs	r0, r3
    cec6:	07d5      	lsls	r5, r2, #31
    cec8:	4305      	orrs	r5, r0
    ceca:	0857      	lsrs	r7, r2, #1
    cecc:	e728      	b.n	cd20 <__aeabi_dsub+0x64>
    cece:	1c13      	adds	r3, r2, #0
    ced0:	9901      	ldr	r1, [sp, #4]
    ced2:	430b      	orrs	r3, r1
    ced4:	d100      	bne.n	ced8 <__aeabi_dsub+0x21c>
    ced6:	e711      	b.n	ccfc <__aeabi_dsub+0x40>
    ced8:	464b      	mov	r3, r9
    ceda:	e713      	b.n	cd04 <__aeabi_dsub+0x48>
    cedc:	1c2b      	adds	r3, r5, #0
    cede:	4313      	orrs	r3, r2
    cee0:	d051      	beq.n	cf86 <__aeabi_dsub+0x2ca>
    cee2:	2380      	movs	r3, #128	; 0x80
    cee4:	031b      	lsls	r3, r3, #12
    cee6:	431a      	orrs	r2, r3
    cee8:	0312      	lsls	r2, r2, #12
    ceea:	0b12      	lsrs	r2, r2, #12
    ceec:	e73e      	b.n	cd6c <__aeabi_dsub+0xb0>
    ceee:	3e01      	subs	r6, #1
    cef0:	2e00      	cmp	r6, #0
    cef2:	d000      	beq.n	cef6 <__aeabi_dsub+0x23a>
    cef4:	e080      	b.n	cff8 <__aeabi_dsub+0x33c>
    cef6:	1a69      	subs	r1, r5, r1
    cef8:	428d      	cmp	r5, r1
    cefa:	419b      	sbcs	r3, r3
    cefc:	1aba      	subs	r2, r7, r2
    cefe:	425b      	negs	r3, r3
    cf00:	1ad7      	subs	r7, r2, r3
    cf02:	1c0d      	adds	r5, r1, #0
    cf04:	e76f      	b.n	cde6 <__aeabi_dsub+0x12a>
    cf06:	1c10      	adds	r0, r2, #0
    cf08:	9b01      	ldr	r3, [sp, #4]
    cf0a:	4318      	orrs	r0, r3
    cf0c:	d100      	bne.n	cf10 <__aeabi_dsub+0x254>
    cf0e:	e707      	b.n	cd20 <__aeabi_dsub+0x64>
    cf10:	2301      	movs	r3, #1
    cf12:	425b      	negs	r3, r3
    cf14:	469c      	mov	ip, r3
    cf16:	44e2      	add	sl, ip
    cf18:	4653      	mov	r3, sl
    cf1a:	2b00      	cmp	r3, #0
    cf1c:	d000      	beq.n	cf20 <__aeabi_dsub+0x264>
    cf1e:	e102      	b.n	d126 <__aeabi_dsub+0x46a>
    cf20:	9b01      	ldr	r3, [sp, #4]
    cf22:	19d2      	adds	r2, r2, r7
    cf24:	1959      	adds	r1, r3, r5
    cf26:	42a9      	cmp	r1, r5
    cf28:	419b      	sbcs	r3, r3
    cf2a:	425b      	negs	r3, r3
    cf2c:	18d7      	adds	r7, r2, r3
    cf2e:	1c0d      	adds	r5, r1, #0
    cf30:	e7bc      	b.n	ceac <__aeabi_dsub+0x1f0>
    cf32:	4663      	mov	r3, ip
    cf34:	4303      	orrs	r3, r0
    cf36:	d100      	bne.n	cf3a <__aeabi_dsub+0x27e>
    cf38:	e128      	b.n	d18c <__aeabi_dsub+0x4d0>
    cf3a:	1c07      	adds	r7, r0, #0
    cf3c:	4665      	mov	r5, ip
    cf3e:	076b      	lsls	r3, r5, #29
    cf40:	d000      	beq.n	cf44 <__aeabi_dsub+0x288>
    cf42:	e6f0      	b.n	cd26 <__aeabi_dsub+0x6a>
    cf44:	2601      	movs	r6, #1
    cf46:	4643      	mov	r3, r8
    cf48:	401e      	ands	r6, r3
    cf4a:	e784      	b.n	ce56 <__aeabi_dsub+0x19a>
    cf4c:	2e00      	cmp	r6, #0
    cf4e:	d000      	beq.n	cf52 <__aeabi_dsub+0x296>
    cf50:	e081      	b.n	d056 <__aeabi_dsub+0x39a>
    cf52:	1c60      	adds	r0, r4, #1
    cf54:	0540      	lsls	r0, r0, #21
    cf56:	0d40      	lsrs	r0, r0, #21
    cf58:	2801      	cmp	r0, #1
    cf5a:	dc00      	bgt.n	cf5e <__aeabi_dsub+0x2a2>
    cf5c:	e107      	b.n	d16e <__aeabi_dsub+0x4b2>
    cf5e:	9901      	ldr	r1, [sp, #4]
    cf60:	1a68      	subs	r0, r5, r1
    cf62:	4684      	mov	ip, r0
    cf64:	4565      	cmp	r5, ip
    cf66:	41b6      	sbcs	r6, r6
    cf68:	1ab8      	subs	r0, r7, r2
    cf6a:	4276      	negs	r6, r6
    cf6c:	1b86      	subs	r6, r0, r6
    cf6e:	0230      	lsls	r0, r6, #8
    cf70:	d400      	bmi.n	cf74 <__aeabi_dsub+0x2b8>
    cf72:	e0a1      	b.n	d0b8 <__aeabi_dsub+0x3fc>
    cf74:	468c      	mov	ip, r1
    cf76:	1b4d      	subs	r5, r1, r5
    cf78:	45ac      	cmp	ip, r5
    cf7a:	4189      	sbcs	r1, r1
    cf7c:	1bd2      	subs	r2, r2, r7
    cf7e:	4249      	negs	r1, r1
    cf80:	1a56      	subs	r6, r2, r1
    cf82:	4698      	mov	r8, r3
    cf84:	e734      	b.n	cdf0 <__aeabi_dsub+0x134>
    cf86:	2200      	movs	r2, #0
    cf88:	2500      	movs	r5, #0
    cf8a:	e6ef      	b.n	cd6c <__aeabi_dsub+0xb0>
    cf8c:	1c28      	adds	r0, r5, #0
    cf8e:	f000 fab5 	bl	d4fc <__clzsi2>
    cf92:	3020      	adds	r0, #32
    cf94:	1c03      	adds	r3, r0, #0
    cf96:	3b08      	subs	r3, #8
    cf98:	2b1f      	cmp	r3, #31
    cf9a:	dc00      	bgt.n	cf9e <__aeabi_dsub+0x2e2>
    cf9c:	e733      	b.n	ce06 <__aeabi_dsub+0x14a>
    cf9e:	1c02      	adds	r2, r0, #0
    cfa0:	3a28      	subs	r2, #40	; 0x28
    cfa2:	4095      	lsls	r5, r2
    cfa4:	1c2a      	adds	r2, r5, #0
    cfa6:	2500      	movs	r5, #0
    cfa8:	429c      	cmp	r4, r3
    cfaa:	dc00      	bgt.n	cfae <__aeabi_dsub+0x2f2>
    cfac:	e736      	b.n	ce1c <__aeabi_dsub+0x160>
    cfae:	4f1f      	ldr	r7, [pc, #124]	; (d02c <__aeabi_dsub+0x370>)
    cfb0:	1ae4      	subs	r4, r4, r3
    cfb2:	4017      	ands	r7, r2
    cfb4:	e6b4      	b.n	cd20 <__aeabi_dsub+0x64>
    cfb6:	9b01      	ldr	r3, [sp, #4]
    cfb8:	431a      	orrs	r2, r3
    cfba:	1e51      	subs	r1, r2, #1
    cfbc:	418a      	sbcs	r2, r1
    cfbe:	b2d3      	uxtb	r3, r2
    cfc0:	2200      	movs	r2, #0
    cfc2:	e709      	b.n	cdd8 <__aeabi_dsub+0x11c>
    cfc4:	2b00      	cmp	r3, #0
    cfc6:	d000      	beq.n	cfca <__aeabi_dsub+0x30e>
    cfc8:	e101      	b.n	d1ce <__aeabi_dsub+0x512>
    cfca:	1c60      	adds	r0, r4, #1
    cfcc:	0543      	lsls	r3, r0, #21
    cfce:	0d5b      	lsrs	r3, r3, #21
    cfd0:	2b01      	cmp	r3, #1
    cfd2:	dc00      	bgt.n	cfd6 <__aeabi_dsub+0x31a>
    cfd4:	e0b0      	b.n	d138 <__aeabi_dsub+0x47c>
    cfd6:	4b14      	ldr	r3, [pc, #80]	; (d028 <__aeabi_dsub+0x36c>)
    cfd8:	4298      	cmp	r0, r3
    cfda:	d100      	bne.n	cfde <__aeabi_dsub+0x322>
    cfdc:	e11e      	b.n	d21c <__aeabi_dsub+0x560>
    cfde:	9b01      	ldr	r3, [sp, #4]
    cfe0:	19d2      	adds	r2, r2, r7
    cfe2:	1959      	adds	r1, r3, r5
    cfe4:	42a9      	cmp	r1, r5
    cfe6:	419b      	sbcs	r3, r3
    cfe8:	425b      	negs	r3, r3
    cfea:	18d2      	adds	r2, r2, r3
    cfec:	0849      	lsrs	r1, r1, #1
    cfee:	07d5      	lsls	r5, r2, #31
    cff0:	430d      	orrs	r5, r1
    cff2:	0857      	lsrs	r7, r2, #1
    cff4:	1c04      	adds	r4, r0, #0
    cff6:	e693      	b.n	cd20 <__aeabi_dsub+0x64>
    cff8:	4b0b      	ldr	r3, [pc, #44]	; (d028 <__aeabi_dsub+0x36c>)
    cffa:	429c      	cmp	r4, r3
    cffc:	d000      	beq.n	d000 <__aeabi_dsub+0x344>
    cffe:	e6d3      	b.n	cda8 <__aeabi_dsub+0xec>
    d000:	e68e      	b.n	cd20 <__aeabi_dsub+0x64>
    d002:	1c21      	adds	r1, r4, #0
    d004:	1c13      	adds	r3, r2, #0
    d006:	391f      	subs	r1, #31
    d008:	40cb      	lsrs	r3, r1
    d00a:	1c19      	adds	r1, r3, #0
    d00c:	2f20      	cmp	r7, #32
    d00e:	d100      	bne.n	d012 <__aeabi_dsub+0x356>
    d010:	e08e      	b.n	d130 <__aeabi_dsub+0x474>
    d012:	233f      	movs	r3, #63	; 0x3f
    d014:	1b1c      	subs	r4, r3, r4
    d016:	40a2      	lsls	r2, r4
    d018:	4315      	orrs	r5, r2
    d01a:	1e6a      	subs	r2, r5, #1
    d01c:	4195      	sbcs	r5, r2
    d01e:	2700      	movs	r7, #0
    d020:	430d      	orrs	r5, r1
    d022:	2400      	movs	r4, #0
    d024:	e78b      	b.n	cf3e <__aeabi_dsub+0x282>
    d026:	46c0      	nop			; (mov r8, r8)
    d028:	000007ff 	.word	0x000007ff
    d02c:	ff7fffff 	.word	0xff7fffff
    d030:	800fffff 	.word	0x800fffff
    d034:	1c33      	adds	r3, r6, #0
    d036:	1c10      	adds	r0, r2, #0
    d038:	3b20      	subs	r3, #32
    d03a:	40d8      	lsrs	r0, r3
    d03c:	2e20      	cmp	r6, #32
    d03e:	d079      	beq.n	d134 <__aeabi_dsub+0x478>
    d040:	2340      	movs	r3, #64	; 0x40
    d042:	1b9b      	subs	r3, r3, r6
    d044:	409a      	lsls	r2, r3
    d046:	1c13      	adds	r3, r2, #0
    d048:	9a01      	ldr	r2, [sp, #4]
    d04a:	4313      	orrs	r3, r2
    d04c:	1e59      	subs	r1, r3, #1
    d04e:	418b      	sbcs	r3, r1
    d050:	2200      	movs	r2, #0
    d052:	4303      	orrs	r3, r0
    d054:	e6c0      	b.n	cdd8 <__aeabi_dsub+0x11c>
    d056:	2c00      	cmp	r4, #0
    d058:	d053      	beq.n	d102 <__aeabi_dsub+0x446>
    d05a:	4cc7      	ldr	r4, [pc, #796]	; (d378 <__aeabi_dsub+0x6bc>)
    d05c:	42a0      	cmp	r0, r4
    d05e:	d100      	bne.n	d062 <__aeabi_dsub+0x3a6>
    d060:	e0b0      	b.n	d1c4 <__aeabi_dsub+0x508>
    d062:	2480      	movs	r4, #128	; 0x80
    d064:	4271      	negs	r1, r6
    d066:	4689      	mov	r9, r1
    d068:	0424      	lsls	r4, r4, #16
    d06a:	4327      	orrs	r7, r4
    d06c:	4649      	mov	r1, r9
    d06e:	2938      	cmp	r1, #56	; 0x38
    d070:	dd00      	ble.n	d074 <__aeabi_dsub+0x3b8>
    d072:	e0cd      	b.n	d210 <__aeabi_dsub+0x554>
    d074:	291f      	cmp	r1, #31
    d076:	dd00      	ble.n	d07a <__aeabi_dsub+0x3be>
    d078:	e159      	b.n	d32e <__aeabi_dsub+0x672>
    d07a:	2420      	movs	r4, #32
    d07c:	1c3e      	adds	r6, r7, #0
    d07e:	1a61      	subs	r1, r4, r1
    d080:	408e      	lsls	r6, r1
    d082:	468a      	mov	sl, r1
    d084:	46b0      	mov	r8, r6
    d086:	4649      	mov	r1, r9
    d088:	1c2e      	adds	r6, r5, #0
    d08a:	40ce      	lsrs	r6, r1
    d08c:	4651      	mov	r1, sl
    d08e:	46b4      	mov	ip, r6
    d090:	408d      	lsls	r5, r1
    d092:	4664      	mov	r4, ip
    d094:	4646      	mov	r6, r8
    d096:	4649      	mov	r1, r9
    d098:	4326      	orrs	r6, r4
    d09a:	1e6c      	subs	r4, r5, #1
    d09c:	41a5      	sbcs	r5, r4
    d09e:	40cf      	lsrs	r7, r1
    d0a0:	4335      	orrs	r5, r6
    d0a2:	9901      	ldr	r1, [sp, #4]
    d0a4:	1bd7      	subs	r7, r2, r7
    d0a6:	468c      	mov	ip, r1
    d0a8:	1b4d      	subs	r5, r1, r5
    d0aa:	45ac      	cmp	ip, r5
    d0ac:	4192      	sbcs	r2, r2
    d0ae:	4252      	negs	r2, r2
    d0b0:	1abf      	subs	r7, r7, r2
    d0b2:	1c04      	adds	r4, r0, #0
    d0b4:	4698      	mov	r8, r3
    d0b6:	e696      	b.n	cde6 <__aeabi_dsub+0x12a>
    d0b8:	4663      	mov	r3, ip
    d0ba:	4665      	mov	r5, ip
    d0bc:	4333      	orrs	r3, r6
    d0be:	d000      	beq.n	d0c2 <__aeabi_dsub+0x406>
    d0c0:	e696      	b.n	cdf0 <__aeabi_dsub+0x134>
    d0c2:	2600      	movs	r6, #0
    d0c4:	2700      	movs	r7, #0
    d0c6:	2400      	movs	r4, #0
    d0c8:	2500      	movs	r5, #0
    d0ca:	e6c4      	b.n	ce56 <__aeabi_dsub+0x19a>
    d0cc:	2b1f      	cmp	r3, #31
    d0ce:	dc61      	bgt.n	d194 <__aeabi_dsub+0x4d8>
    d0d0:	2020      	movs	r0, #32
    d0d2:	1ac3      	subs	r3, r0, r3
    d0d4:	469b      	mov	fp, r3
    d0d6:	1c13      	adds	r3, r2, #0
    d0d8:	4659      	mov	r1, fp
    d0da:	408b      	lsls	r3, r1
    d0dc:	4651      	mov	r1, sl
    d0de:	4699      	mov	r9, r3
    d0e0:	9b01      	ldr	r3, [sp, #4]
    d0e2:	40cb      	lsrs	r3, r1
    d0e4:	469c      	mov	ip, r3
    d0e6:	464b      	mov	r3, r9
    d0e8:	4660      	mov	r0, ip
    d0ea:	4303      	orrs	r3, r0
    d0ec:	469c      	mov	ip, r3
    d0ee:	465b      	mov	r3, fp
    d0f0:	9901      	ldr	r1, [sp, #4]
    d0f2:	4099      	lsls	r1, r3
    d0f4:	4663      	mov	r3, ip
    d0f6:	1e48      	subs	r0, r1, #1
    d0f8:	4181      	sbcs	r1, r0
    d0fa:	4319      	orrs	r1, r3
    d0fc:	4653      	mov	r3, sl
    d0fe:	40da      	lsrs	r2, r3
    d100:	e6cd      	b.n	ce9e <__aeabi_dsub+0x1e2>
    d102:	1c3c      	adds	r4, r7, #0
    d104:	432c      	orrs	r4, r5
    d106:	d05d      	beq.n	d1c4 <__aeabi_dsub+0x508>
    d108:	43f1      	mvns	r1, r6
    d10a:	4689      	mov	r9, r1
    d10c:	2900      	cmp	r1, #0
    d10e:	d155      	bne.n	d1bc <__aeabi_dsub+0x500>
    d110:	9901      	ldr	r1, [sp, #4]
    d112:	1bd2      	subs	r2, r2, r7
    d114:	468c      	mov	ip, r1
    d116:	1b4d      	subs	r5, r1, r5
    d118:	45ac      	cmp	ip, r5
    d11a:	4189      	sbcs	r1, r1
    d11c:	4249      	negs	r1, r1
    d11e:	1a57      	subs	r7, r2, r1
    d120:	1c04      	adds	r4, r0, #0
    d122:	4698      	mov	r8, r3
    d124:	e65f      	b.n	cde6 <__aeabi_dsub+0x12a>
    d126:	4894      	ldr	r0, [pc, #592]	; (d378 <__aeabi_dsub+0x6bc>)
    d128:	4284      	cmp	r4, r0
    d12a:	d000      	beq.n	d12e <__aeabi_dsub+0x472>
    d12c:	e6ad      	b.n	ce8a <__aeabi_dsub+0x1ce>
    d12e:	e5f7      	b.n	cd20 <__aeabi_dsub+0x64>
    d130:	2200      	movs	r2, #0
    d132:	e771      	b.n	d018 <__aeabi_dsub+0x35c>
    d134:	2300      	movs	r3, #0
    d136:	e787      	b.n	d048 <__aeabi_dsub+0x38c>
    d138:	1c3b      	adds	r3, r7, #0
    d13a:	432b      	orrs	r3, r5
    d13c:	2c00      	cmp	r4, #0
    d13e:	d000      	beq.n	d142 <__aeabi_dsub+0x486>
    d140:	e0da      	b.n	d2f8 <__aeabi_dsub+0x63c>
    d142:	2b00      	cmp	r3, #0
    d144:	d100      	bne.n	d148 <__aeabi_dsub+0x48c>
    d146:	e113      	b.n	d370 <__aeabi_dsub+0x6b4>
    d148:	1c13      	adds	r3, r2, #0
    d14a:	9901      	ldr	r1, [sp, #4]
    d14c:	430b      	orrs	r3, r1
    d14e:	d100      	bne.n	d152 <__aeabi_dsub+0x496>
    d150:	e5e6      	b.n	cd20 <__aeabi_dsub+0x64>
    d152:	1949      	adds	r1, r1, r5
    d154:	42a9      	cmp	r1, r5
    d156:	419b      	sbcs	r3, r3
    d158:	19d2      	adds	r2, r2, r7
    d15a:	425b      	negs	r3, r3
    d15c:	18d7      	adds	r7, r2, r3
    d15e:	023b      	lsls	r3, r7, #8
    d160:	d400      	bmi.n	d164 <__aeabi_dsub+0x4a8>
    d162:	e121      	b.n	d3a8 <__aeabi_dsub+0x6ec>
    d164:	4b85      	ldr	r3, [pc, #532]	; (d37c <__aeabi_dsub+0x6c0>)
    d166:	1c0d      	adds	r5, r1, #0
    d168:	401f      	ands	r7, r3
    d16a:	1c04      	adds	r4, r0, #0
    d16c:	e5d8      	b.n	cd20 <__aeabi_dsub+0x64>
    d16e:	1c38      	adds	r0, r7, #0
    d170:	4328      	orrs	r0, r5
    d172:	2c00      	cmp	r4, #0
    d174:	d140      	bne.n	d1f8 <__aeabi_dsub+0x53c>
    d176:	2800      	cmp	r0, #0
    d178:	d000      	beq.n	d17c <__aeabi_dsub+0x4c0>
    d17a:	e083      	b.n	d284 <__aeabi_dsub+0x5c8>
    d17c:	1c10      	adds	r0, r2, #0
    d17e:	9901      	ldr	r1, [sp, #4]
    d180:	4308      	orrs	r0, r1
    d182:	d003      	beq.n	d18c <__aeabi_dsub+0x4d0>
    d184:	1c17      	adds	r7, r2, #0
    d186:	1c0d      	adds	r5, r1, #0
    d188:	4698      	mov	r8, r3
    d18a:	e5c9      	b.n	cd20 <__aeabi_dsub+0x64>
    d18c:	2600      	movs	r6, #0
    d18e:	2700      	movs	r7, #0
    d190:	2500      	movs	r5, #0
    d192:	e660      	b.n	ce56 <__aeabi_dsub+0x19a>
    d194:	4650      	mov	r0, sl
    d196:	1c13      	adds	r3, r2, #0
    d198:	3820      	subs	r0, #32
    d19a:	40c3      	lsrs	r3, r0
    d19c:	1c18      	adds	r0, r3, #0
    d19e:	4653      	mov	r3, sl
    d1a0:	2b20      	cmp	r3, #32
    d1a2:	d100      	bne.n	d1a6 <__aeabi_dsub+0x4ea>
    d1a4:	e0c1      	b.n	d32a <__aeabi_dsub+0x66e>
    d1a6:	2340      	movs	r3, #64	; 0x40
    d1a8:	4651      	mov	r1, sl
    d1aa:	1a5b      	subs	r3, r3, r1
    d1ac:	409a      	lsls	r2, r3
    d1ae:	9901      	ldr	r1, [sp, #4]
    d1b0:	4311      	orrs	r1, r2
    d1b2:	1e4a      	subs	r2, r1, #1
    d1b4:	4191      	sbcs	r1, r2
    d1b6:	2200      	movs	r2, #0
    d1b8:	4301      	orrs	r1, r0
    d1ba:	e670      	b.n	ce9e <__aeabi_dsub+0x1e2>
    d1bc:	4c6e      	ldr	r4, [pc, #440]	; (d378 <__aeabi_dsub+0x6bc>)
    d1be:	42a0      	cmp	r0, r4
    d1c0:	d000      	beq.n	d1c4 <__aeabi_dsub+0x508>
    d1c2:	e753      	b.n	d06c <__aeabi_dsub+0x3b0>
    d1c4:	1c17      	adds	r7, r2, #0
    d1c6:	9d01      	ldr	r5, [sp, #4]
    d1c8:	1c04      	adds	r4, r0, #0
    d1ca:	4698      	mov	r8, r3
    d1cc:	e5a8      	b.n	cd20 <__aeabi_dsub+0x64>
    d1ce:	2c00      	cmp	r4, #0
    d1d0:	d128      	bne.n	d224 <__aeabi_dsub+0x568>
    d1d2:	1c3c      	adds	r4, r7, #0
    d1d4:	432c      	orrs	r4, r5
    d1d6:	d100      	bne.n	d1da <__aeabi_dsub+0x51e>
    d1d8:	e08a      	b.n	d2f0 <__aeabi_dsub+0x634>
    d1da:	43db      	mvns	r3, r3
    d1dc:	469a      	mov	sl, r3
    d1de:	2b00      	cmp	r3, #0
    d1e0:	d000      	beq.n	d1e4 <__aeabi_dsub+0x528>
    d1e2:	e082      	b.n	d2ea <__aeabi_dsub+0x62e>
    d1e4:	9b01      	ldr	r3, [sp, #4]
    d1e6:	19d2      	adds	r2, r2, r7
    d1e8:	469c      	mov	ip, r3
    d1ea:	4465      	add	r5, ip
    d1ec:	429d      	cmp	r5, r3
    d1ee:	4189      	sbcs	r1, r1
    d1f0:	4249      	negs	r1, r1
    d1f2:	1857      	adds	r7, r2, r1
    d1f4:	1c04      	adds	r4, r0, #0
    d1f6:	e659      	b.n	ceac <__aeabi_dsub+0x1f0>
    d1f8:	2800      	cmp	r0, #0
    d1fa:	d15b      	bne.n	d2b4 <__aeabi_dsub+0x5f8>
    d1fc:	1c10      	adds	r0, r2, #0
    d1fe:	9901      	ldr	r1, [sp, #4]
    d200:	4308      	orrs	r0, r1
    d202:	d100      	bne.n	d206 <__aeabi_dsub+0x54a>
    d204:	e0a4      	b.n	d350 <__aeabi_dsub+0x694>
    d206:	1c17      	adds	r7, r2, #0
    d208:	1c0d      	adds	r5, r1, #0
    d20a:	4698      	mov	r8, r3
    d20c:	4c5a      	ldr	r4, [pc, #360]	; (d378 <__aeabi_dsub+0x6bc>)
    d20e:	e587      	b.n	cd20 <__aeabi_dsub+0x64>
    d210:	433d      	orrs	r5, r7
    d212:	1e6f      	subs	r7, r5, #1
    d214:	41bd      	sbcs	r5, r7
    d216:	2700      	movs	r7, #0
    d218:	b2ed      	uxtb	r5, r5
    d21a:	e742      	b.n	d0a2 <__aeabi_dsub+0x3e6>
    d21c:	1c04      	adds	r4, r0, #0
    d21e:	2700      	movs	r7, #0
    d220:	2500      	movs	r5, #0
    d222:	e618      	b.n	ce56 <__aeabi_dsub+0x19a>
    d224:	4c54      	ldr	r4, [pc, #336]	; (d378 <__aeabi_dsub+0x6bc>)
    d226:	42a0      	cmp	r0, r4
    d228:	d062      	beq.n	d2f0 <__aeabi_dsub+0x634>
    d22a:	4653      	mov	r3, sl
    d22c:	2480      	movs	r4, #128	; 0x80
    d22e:	425b      	negs	r3, r3
    d230:	469a      	mov	sl, r3
    d232:	0424      	lsls	r4, r4, #16
    d234:	4327      	orrs	r7, r4
    d236:	4653      	mov	r3, sl
    d238:	2b38      	cmp	r3, #56	; 0x38
    d23a:	dd00      	ble.n	d23e <__aeabi_dsub+0x582>
    d23c:	e08e      	b.n	d35c <__aeabi_dsub+0x6a0>
    d23e:	2b1f      	cmp	r3, #31
    d240:	dd00      	ble.n	d244 <__aeabi_dsub+0x588>
    d242:	e09d      	b.n	d380 <__aeabi_dsub+0x6c4>
    d244:	2420      	movs	r4, #32
    d246:	1ae3      	subs	r3, r4, r3
    d248:	469b      	mov	fp, r3
    d24a:	1c3b      	adds	r3, r7, #0
    d24c:	4659      	mov	r1, fp
    d24e:	408b      	lsls	r3, r1
    d250:	4651      	mov	r1, sl
    d252:	4699      	mov	r9, r3
    d254:	1c2b      	adds	r3, r5, #0
    d256:	40cb      	lsrs	r3, r1
    d258:	469c      	mov	ip, r3
    d25a:	464b      	mov	r3, r9
    d25c:	4664      	mov	r4, ip
    d25e:	4323      	orrs	r3, r4
    d260:	469c      	mov	ip, r3
    d262:	465b      	mov	r3, fp
    d264:	409d      	lsls	r5, r3
    d266:	4663      	mov	r3, ip
    d268:	1e6c      	subs	r4, r5, #1
    d26a:	41a5      	sbcs	r5, r4
    d26c:	40cf      	lsrs	r7, r1
    d26e:	431d      	orrs	r5, r3
    d270:	9b01      	ldr	r3, [sp, #4]
    d272:	18bf      	adds	r7, r7, r2
    d274:	469c      	mov	ip, r3
    d276:	4465      	add	r5, ip
    d278:	429d      	cmp	r5, r3
    d27a:	4192      	sbcs	r2, r2
    d27c:	4252      	negs	r2, r2
    d27e:	18bf      	adds	r7, r7, r2
    d280:	1c04      	adds	r4, r0, #0
    d282:	e613      	b.n	ceac <__aeabi_dsub+0x1f0>
    d284:	1c10      	adds	r0, r2, #0
    d286:	9901      	ldr	r1, [sp, #4]
    d288:	4308      	orrs	r0, r1
    d28a:	d100      	bne.n	d28e <__aeabi_dsub+0x5d2>
    d28c:	e548      	b.n	cd20 <__aeabi_dsub+0x64>
    d28e:	1a68      	subs	r0, r5, r1
    d290:	4684      	mov	ip, r0
    d292:	4285      	cmp	r5, r0
    d294:	4180      	sbcs	r0, r0
    d296:	1abe      	subs	r6, r7, r2
    d298:	4240      	negs	r0, r0
    d29a:	1a30      	subs	r0, r6, r0
    d29c:	0206      	lsls	r6, r0, #8
    d29e:	d400      	bmi.n	d2a2 <__aeabi_dsub+0x5e6>
    d2a0:	e647      	b.n	cf32 <__aeabi_dsub+0x276>
    d2a2:	468c      	mov	ip, r1
    d2a4:	1b4d      	subs	r5, r1, r5
    d2a6:	45ac      	cmp	ip, r5
    d2a8:	4189      	sbcs	r1, r1
    d2aa:	1bd2      	subs	r2, r2, r7
    d2ac:	4249      	negs	r1, r1
    d2ae:	1a57      	subs	r7, r2, r1
    d2b0:	4698      	mov	r8, r3
    d2b2:	e535      	b.n	cd20 <__aeabi_dsub+0x64>
    d2b4:	1c10      	adds	r0, r2, #0
    d2b6:	9901      	ldr	r1, [sp, #4]
    d2b8:	4308      	orrs	r0, r1
    d2ba:	d034      	beq.n	d326 <__aeabi_dsub+0x66a>
    d2bc:	2480      	movs	r4, #128	; 0x80
    d2be:	0778      	lsls	r0, r7, #29
    d2c0:	08ed      	lsrs	r5, r5, #3
    d2c2:	08ff      	lsrs	r7, r7, #3
    d2c4:	0324      	lsls	r4, r4, #12
    d2c6:	4328      	orrs	r0, r5
    d2c8:	4227      	tst	r7, r4
    d2ca:	d008      	beq.n	d2de <__aeabi_dsub+0x622>
    d2cc:	08d6      	lsrs	r6, r2, #3
    d2ce:	4226      	tst	r6, r4
    d2d0:	d105      	bne.n	d2de <__aeabi_dsub+0x622>
    d2d2:	08c9      	lsrs	r1, r1, #3
    d2d4:	0752      	lsls	r2, r2, #29
    d2d6:	430a      	orrs	r2, r1
    d2d8:	1c10      	adds	r0, r2, #0
    d2da:	1c37      	adds	r7, r6, #0
    d2dc:	4698      	mov	r8, r3
    d2de:	00ff      	lsls	r7, r7, #3
    d2e0:	0f42      	lsrs	r2, r0, #29
    d2e2:	4317      	orrs	r7, r2
    d2e4:	00c5      	lsls	r5, r0, #3
    d2e6:	4c24      	ldr	r4, [pc, #144]	; (d378 <__aeabi_dsub+0x6bc>)
    d2e8:	e51a      	b.n	cd20 <__aeabi_dsub+0x64>
    d2ea:	4c23      	ldr	r4, [pc, #140]	; (d378 <__aeabi_dsub+0x6bc>)
    d2ec:	42a0      	cmp	r0, r4
    d2ee:	d1a2      	bne.n	d236 <__aeabi_dsub+0x57a>
    d2f0:	1c17      	adds	r7, r2, #0
    d2f2:	9d01      	ldr	r5, [sp, #4]
    d2f4:	1c04      	adds	r4, r0, #0
    d2f6:	e513      	b.n	cd20 <__aeabi_dsub+0x64>
    d2f8:	2b00      	cmp	r3, #0
    d2fa:	d035      	beq.n	d368 <__aeabi_dsub+0x6ac>
    d2fc:	1c13      	adds	r3, r2, #0
    d2fe:	9901      	ldr	r1, [sp, #4]
    d300:	430b      	orrs	r3, r1
    d302:	d010      	beq.n	d326 <__aeabi_dsub+0x66a>
    d304:	2480      	movs	r4, #128	; 0x80
    d306:	0778      	lsls	r0, r7, #29
    d308:	08ed      	lsrs	r5, r5, #3
    d30a:	08ff      	lsrs	r7, r7, #3
    d30c:	0324      	lsls	r4, r4, #12
    d30e:	4328      	orrs	r0, r5
    d310:	4227      	tst	r7, r4
    d312:	d0e4      	beq.n	d2de <__aeabi_dsub+0x622>
    d314:	08d3      	lsrs	r3, r2, #3
    d316:	4223      	tst	r3, r4
    d318:	d1e1      	bne.n	d2de <__aeabi_dsub+0x622>
    d31a:	08c9      	lsrs	r1, r1, #3
    d31c:	0752      	lsls	r2, r2, #29
    d31e:	430a      	orrs	r2, r1
    d320:	1c10      	adds	r0, r2, #0
    d322:	1c1f      	adds	r7, r3, #0
    d324:	e7db      	b.n	d2de <__aeabi_dsub+0x622>
    d326:	4c14      	ldr	r4, [pc, #80]	; (d378 <__aeabi_dsub+0x6bc>)
    d328:	e4fa      	b.n	cd20 <__aeabi_dsub+0x64>
    d32a:	2200      	movs	r2, #0
    d32c:	e73f      	b.n	d1ae <__aeabi_dsub+0x4f2>
    d32e:	464c      	mov	r4, r9
    d330:	1c3e      	adds	r6, r7, #0
    d332:	3c20      	subs	r4, #32
    d334:	40e6      	lsrs	r6, r4
    d336:	4649      	mov	r1, r9
    d338:	1c34      	adds	r4, r6, #0
    d33a:	2920      	cmp	r1, #32
    d33c:	d032      	beq.n	d3a4 <__aeabi_dsub+0x6e8>
    d33e:	2640      	movs	r6, #64	; 0x40
    d340:	1a76      	subs	r6, r6, r1
    d342:	40b7      	lsls	r7, r6
    d344:	433d      	orrs	r5, r7
    d346:	1e6f      	subs	r7, r5, #1
    d348:	41bd      	sbcs	r5, r7
    d34a:	2700      	movs	r7, #0
    d34c:	4325      	orrs	r5, r4
    d34e:	e6a8      	b.n	d0a2 <__aeabi_dsub+0x3e6>
    d350:	2780      	movs	r7, #128	; 0x80
    d352:	2600      	movs	r6, #0
    d354:	03ff      	lsls	r7, r7, #15
    d356:	4c08      	ldr	r4, [pc, #32]	; (d378 <__aeabi_dsub+0x6bc>)
    d358:	2500      	movs	r5, #0
    d35a:	e57c      	b.n	ce56 <__aeabi_dsub+0x19a>
    d35c:	433d      	orrs	r5, r7
    d35e:	1e6f      	subs	r7, r5, #1
    d360:	41bd      	sbcs	r5, r7
    d362:	2700      	movs	r7, #0
    d364:	b2ed      	uxtb	r5, r5
    d366:	e783      	b.n	d270 <__aeabi_dsub+0x5b4>
    d368:	1c17      	adds	r7, r2, #0
    d36a:	9d01      	ldr	r5, [sp, #4]
    d36c:	4c02      	ldr	r4, [pc, #8]	; (d378 <__aeabi_dsub+0x6bc>)
    d36e:	e4d7      	b.n	cd20 <__aeabi_dsub+0x64>
    d370:	1c17      	adds	r7, r2, #0
    d372:	9d01      	ldr	r5, [sp, #4]
    d374:	e4d4      	b.n	cd20 <__aeabi_dsub+0x64>
    d376:	46c0      	nop			; (mov r8, r8)
    d378:	000007ff 	.word	0x000007ff
    d37c:	ff7fffff 	.word	0xff7fffff
    d380:	4654      	mov	r4, sl
    d382:	1c3b      	adds	r3, r7, #0
    d384:	3c20      	subs	r4, #32
    d386:	40e3      	lsrs	r3, r4
    d388:	1c1c      	adds	r4, r3, #0
    d38a:	4653      	mov	r3, sl
    d38c:	2b20      	cmp	r3, #32
    d38e:	d00d      	beq.n	d3ac <__aeabi_dsub+0x6f0>
    d390:	2340      	movs	r3, #64	; 0x40
    d392:	4651      	mov	r1, sl
    d394:	1a5b      	subs	r3, r3, r1
    d396:	409f      	lsls	r7, r3
    d398:	433d      	orrs	r5, r7
    d39a:	1e6f      	subs	r7, r5, #1
    d39c:	41bd      	sbcs	r5, r7
    d39e:	2700      	movs	r7, #0
    d3a0:	4325      	orrs	r5, r4
    d3a2:	e765      	b.n	d270 <__aeabi_dsub+0x5b4>
    d3a4:	2700      	movs	r7, #0
    d3a6:	e7cd      	b.n	d344 <__aeabi_dsub+0x688>
    d3a8:	1c0d      	adds	r5, r1, #0
    d3aa:	e5c8      	b.n	cf3e <__aeabi_dsub+0x282>
    d3ac:	2700      	movs	r7, #0
    d3ae:	e7f3      	b.n	d398 <__aeabi_dsub+0x6dc>

0000d3b0 <__aeabi_d2iz>:
    d3b0:	030b      	lsls	r3, r1, #12
    d3b2:	b530      	push	{r4, r5, lr}
    d3b4:	4c13      	ldr	r4, [pc, #76]	; (d404 <__aeabi_d2iz+0x54>)
    d3b6:	0b1a      	lsrs	r2, r3, #12
    d3b8:	004b      	lsls	r3, r1, #1
    d3ba:	1c05      	adds	r5, r0, #0
    d3bc:	0d5b      	lsrs	r3, r3, #21
    d3be:	0fc9      	lsrs	r1, r1, #31
    d3c0:	2000      	movs	r0, #0
    d3c2:	42a3      	cmp	r3, r4
    d3c4:	dd10      	ble.n	d3e8 <__aeabi_d2iz+0x38>
    d3c6:	4810      	ldr	r0, [pc, #64]	; (d408 <__aeabi_d2iz+0x58>)
    d3c8:	4283      	cmp	r3, r0
    d3ca:	dc0e      	bgt.n	d3ea <__aeabi_d2iz+0x3a>
    d3cc:	2080      	movs	r0, #128	; 0x80
    d3ce:	4c0f      	ldr	r4, [pc, #60]	; (d40c <__aeabi_d2iz+0x5c>)
    d3d0:	0340      	lsls	r0, r0, #13
    d3d2:	4302      	orrs	r2, r0
    d3d4:	1ae4      	subs	r4, r4, r3
    d3d6:	2c1f      	cmp	r4, #31
    d3d8:	dd0a      	ble.n	d3f0 <__aeabi_d2iz+0x40>
    d3da:	480d      	ldr	r0, [pc, #52]	; (d410 <__aeabi_d2iz+0x60>)
    d3dc:	1ac3      	subs	r3, r0, r3
    d3de:	40da      	lsrs	r2, r3
    d3e0:	1c13      	adds	r3, r2, #0
    d3e2:	4248      	negs	r0, r1
    d3e4:	4043      	eors	r3, r0
    d3e6:	1858      	adds	r0, r3, r1
    d3e8:	bd30      	pop	{r4, r5, pc}
    d3ea:	4b0a      	ldr	r3, [pc, #40]	; (d414 <__aeabi_d2iz+0x64>)
    d3ec:	18c8      	adds	r0, r1, r3
    d3ee:	e7fb      	b.n	d3e8 <__aeabi_d2iz+0x38>
    d3f0:	1c28      	adds	r0, r5, #0
    d3f2:	40e0      	lsrs	r0, r4
    d3f4:	4c08      	ldr	r4, [pc, #32]	; (d418 <__aeabi_d2iz+0x68>)
    d3f6:	46a4      	mov	ip, r4
    d3f8:	4463      	add	r3, ip
    d3fa:	409a      	lsls	r2, r3
    d3fc:	1c13      	adds	r3, r2, #0
    d3fe:	4303      	orrs	r3, r0
    d400:	e7ef      	b.n	d3e2 <__aeabi_d2iz+0x32>
    d402:	46c0      	nop			; (mov r8, r8)
    d404:	000003fe 	.word	0x000003fe
    d408:	0000041d 	.word	0x0000041d
    d40c:	00000433 	.word	0x00000433
    d410:	00000413 	.word	0x00000413
    d414:	7fffffff 	.word	0x7fffffff
    d418:	fffffbed 	.word	0xfffffbed

0000d41c <__aeabi_ui2d>:
    d41c:	b510      	push	{r4, lr}
    d41e:	1e04      	subs	r4, r0, #0
    d420:	d010      	beq.n	d444 <__aeabi_ui2d+0x28>
    d422:	f000 f86b 	bl	d4fc <__clzsi2>
    d426:	4a14      	ldr	r2, [pc, #80]	; (d478 <__aeabi_ui2d+0x5c>)
    d428:	1a12      	subs	r2, r2, r0
    d42a:	280a      	cmp	r0, #10
    d42c:	dc1a      	bgt.n	d464 <__aeabi_ui2d+0x48>
    d42e:	230b      	movs	r3, #11
    d430:	1c21      	adds	r1, r4, #0
    d432:	1a1b      	subs	r3, r3, r0
    d434:	40d9      	lsrs	r1, r3
    d436:	3015      	adds	r0, #21
    d438:	030b      	lsls	r3, r1, #12
    d43a:	0552      	lsls	r2, r2, #21
    d43c:	4084      	lsls	r4, r0
    d43e:	0b1b      	lsrs	r3, r3, #12
    d440:	0d52      	lsrs	r2, r2, #21
    d442:	e001      	b.n	d448 <__aeabi_ui2d+0x2c>
    d444:	2200      	movs	r2, #0
    d446:	2300      	movs	r3, #0
    d448:	2100      	movs	r1, #0
    d44a:	031b      	lsls	r3, r3, #12
    d44c:	1c20      	adds	r0, r4, #0
    d44e:	0b1c      	lsrs	r4, r3, #12
    d450:	0d0b      	lsrs	r3, r1, #20
    d452:	051b      	lsls	r3, r3, #20
    d454:	4323      	orrs	r3, r4
    d456:	4c09      	ldr	r4, [pc, #36]	; (d47c <__aeabi_ui2d+0x60>)
    d458:	0512      	lsls	r2, r2, #20
    d45a:	4023      	ands	r3, r4
    d45c:	4313      	orrs	r3, r2
    d45e:	005b      	lsls	r3, r3, #1
    d460:	0859      	lsrs	r1, r3, #1
    d462:	bd10      	pop	{r4, pc}
    d464:	1c03      	adds	r3, r0, #0
    d466:	3b0b      	subs	r3, #11
    d468:	409c      	lsls	r4, r3
    d46a:	0552      	lsls	r2, r2, #21
    d46c:	0323      	lsls	r3, r4, #12
    d46e:	0b1b      	lsrs	r3, r3, #12
    d470:	0d52      	lsrs	r2, r2, #21
    d472:	2400      	movs	r4, #0
    d474:	e7e8      	b.n	d448 <__aeabi_ui2d+0x2c>
    d476:	46c0      	nop			; (mov r8, r8)
    d478:	0000041e 	.word	0x0000041e
    d47c:	800fffff 	.word	0x800fffff

0000d480 <__aeabi_cdrcmple>:
    d480:	4684      	mov	ip, r0
    d482:	1c10      	adds	r0, r2, #0
    d484:	4662      	mov	r2, ip
    d486:	468c      	mov	ip, r1
    d488:	1c19      	adds	r1, r3, #0
    d48a:	4663      	mov	r3, ip
    d48c:	e000      	b.n	d490 <__aeabi_cdcmpeq>
    d48e:	46c0      	nop			; (mov r8, r8)

0000d490 <__aeabi_cdcmpeq>:
    d490:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    d492:	f000 f905 	bl	d6a0 <__ledf2>
    d496:	2800      	cmp	r0, #0
    d498:	d401      	bmi.n	d49e <__aeabi_cdcmpeq+0xe>
    d49a:	2100      	movs	r1, #0
    d49c:	42c8      	cmn	r0, r1
    d49e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0000d4a0 <__aeabi_dcmpeq>:
    d4a0:	b510      	push	{r4, lr}
    d4a2:	f000 f849 	bl	d538 <__eqdf2>
    d4a6:	4240      	negs	r0, r0
    d4a8:	3001      	adds	r0, #1
    d4aa:	bd10      	pop	{r4, pc}

0000d4ac <__aeabi_dcmplt>:
    d4ac:	b510      	push	{r4, lr}
    d4ae:	f000 f8f7 	bl	d6a0 <__ledf2>
    d4b2:	2800      	cmp	r0, #0
    d4b4:	db01      	blt.n	d4ba <__aeabi_dcmplt+0xe>
    d4b6:	2000      	movs	r0, #0
    d4b8:	bd10      	pop	{r4, pc}
    d4ba:	2001      	movs	r0, #1
    d4bc:	bd10      	pop	{r4, pc}
    d4be:	46c0      	nop			; (mov r8, r8)

0000d4c0 <__aeabi_dcmple>:
    d4c0:	b510      	push	{r4, lr}
    d4c2:	f000 f8ed 	bl	d6a0 <__ledf2>
    d4c6:	2800      	cmp	r0, #0
    d4c8:	dd01      	ble.n	d4ce <__aeabi_dcmple+0xe>
    d4ca:	2000      	movs	r0, #0
    d4cc:	bd10      	pop	{r4, pc}
    d4ce:	2001      	movs	r0, #1
    d4d0:	bd10      	pop	{r4, pc}
    d4d2:	46c0      	nop			; (mov r8, r8)

0000d4d4 <__aeabi_dcmpgt>:
    d4d4:	b510      	push	{r4, lr}
    d4d6:	f000 f873 	bl	d5c0 <__gedf2>
    d4da:	2800      	cmp	r0, #0
    d4dc:	dc01      	bgt.n	d4e2 <__aeabi_dcmpgt+0xe>
    d4de:	2000      	movs	r0, #0
    d4e0:	bd10      	pop	{r4, pc}
    d4e2:	2001      	movs	r0, #1
    d4e4:	bd10      	pop	{r4, pc}
    d4e6:	46c0      	nop			; (mov r8, r8)

0000d4e8 <__aeabi_dcmpge>:
    d4e8:	b510      	push	{r4, lr}
    d4ea:	f000 f869 	bl	d5c0 <__gedf2>
    d4ee:	2800      	cmp	r0, #0
    d4f0:	da01      	bge.n	d4f6 <__aeabi_dcmpge+0xe>
    d4f2:	2000      	movs	r0, #0
    d4f4:	bd10      	pop	{r4, pc}
    d4f6:	2001      	movs	r0, #1
    d4f8:	bd10      	pop	{r4, pc}
    d4fa:	46c0      	nop			; (mov r8, r8)

0000d4fc <__clzsi2>:
    d4fc:	211c      	movs	r1, #28
    d4fe:	2301      	movs	r3, #1
    d500:	041b      	lsls	r3, r3, #16
    d502:	4298      	cmp	r0, r3
    d504:	d301      	bcc.n	d50a <__clzsi2+0xe>
    d506:	0c00      	lsrs	r0, r0, #16
    d508:	3910      	subs	r1, #16
    d50a:	0a1b      	lsrs	r3, r3, #8
    d50c:	4298      	cmp	r0, r3
    d50e:	d301      	bcc.n	d514 <__clzsi2+0x18>
    d510:	0a00      	lsrs	r0, r0, #8
    d512:	3908      	subs	r1, #8
    d514:	091b      	lsrs	r3, r3, #4
    d516:	4298      	cmp	r0, r3
    d518:	d301      	bcc.n	d51e <__clzsi2+0x22>
    d51a:	0900      	lsrs	r0, r0, #4
    d51c:	3904      	subs	r1, #4
    d51e:	a202      	add	r2, pc, #8	; (adr r2, d528 <__clzsi2+0x2c>)
    d520:	5c10      	ldrb	r0, [r2, r0]
    d522:	1840      	adds	r0, r0, r1
    d524:	4770      	bx	lr
    d526:	46c0      	nop			; (mov r8, r8)
    d528:	02020304 	.word	0x02020304
    d52c:	01010101 	.word	0x01010101
	...

0000d538 <__eqdf2>:
    d538:	b5f0      	push	{r4, r5, r6, r7, lr}
    d53a:	465f      	mov	r7, fp
    d53c:	464d      	mov	r5, r9
    d53e:	4644      	mov	r4, r8
    d540:	4656      	mov	r6, sl
    d542:	b4f0      	push	{r4, r5, r6, r7}
    d544:	031f      	lsls	r7, r3, #12
    d546:	005c      	lsls	r4, r3, #1
    d548:	0fdb      	lsrs	r3, r3, #31
    d54a:	4699      	mov	r9, r3
    d54c:	4b1b      	ldr	r3, [pc, #108]	; (d5bc <__eqdf2+0x84>)
    d54e:	030e      	lsls	r6, r1, #12
    d550:	004d      	lsls	r5, r1, #1
    d552:	0fc9      	lsrs	r1, r1, #31
    d554:	4684      	mov	ip, r0
    d556:	0b36      	lsrs	r6, r6, #12
    d558:	0d6d      	lsrs	r5, r5, #21
    d55a:	468b      	mov	fp, r1
    d55c:	4690      	mov	r8, r2
    d55e:	0b3f      	lsrs	r7, r7, #12
    d560:	0d64      	lsrs	r4, r4, #21
    d562:	429d      	cmp	r5, r3
    d564:	d00c      	beq.n	d580 <__eqdf2+0x48>
    d566:	4b15      	ldr	r3, [pc, #84]	; (d5bc <__eqdf2+0x84>)
    d568:	429c      	cmp	r4, r3
    d56a:	d010      	beq.n	d58e <__eqdf2+0x56>
    d56c:	2301      	movs	r3, #1
    d56e:	42a5      	cmp	r5, r4
    d570:	d014      	beq.n	d59c <__eqdf2+0x64>
    d572:	1c18      	adds	r0, r3, #0
    d574:	bc3c      	pop	{r2, r3, r4, r5}
    d576:	4690      	mov	r8, r2
    d578:	4699      	mov	r9, r3
    d57a:	46a2      	mov	sl, r4
    d57c:	46ab      	mov	fp, r5
    d57e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d580:	1c31      	adds	r1, r6, #0
    d582:	2301      	movs	r3, #1
    d584:	4301      	orrs	r1, r0
    d586:	d1f4      	bne.n	d572 <__eqdf2+0x3a>
    d588:	4b0c      	ldr	r3, [pc, #48]	; (d5bc <__eqdf2+0x84>)
    d58a:	429c      	cmp	r4, r3
    d58c:	d1ee      	bne.n	d56c <__eqdf2+0x34>
    d58e:	433a      	orrs	r2, r7
    d590:	2301      	movs	r3, #1
    d592:	2a00      	cmp	r2, #0
    d594:	d1ed      	bne.n	d572 <__eqdf2+0x3a>
    d596:	2301      	movs	r3, #1
    d598:	42a5      	cmp	r5, r4
    d59a:	d1ea      	bne.n	d572 <__eqdf2+0x3a>
    d59c:	42be      	cmp	r6, r7
    d59e:	d1e8      	bne.n	d572 <__eqdf2+0x3a>
    d5a0:	45c4      	cmp	ip, r8
    d5a2:	d1e6      	bne.n	d572 <__eqdf2+0x3a>
    d5a4:	45cb      	cmp	fp, r9
    d5a6:	d006      	beq.n	d5b6 <__eqdf2+0x7e>
    d5a8:	2d00      	cmp	r5, #0
    d5aa:	d1e2      	bne.n	d572 <__eqdf2+0x3a>
    d5ac:	4330      	orrs	r0, r6
    d5ae:	1c03      	adds	r3, r0, #0
    d5b0:	1e58      	subs	r0, r3, #1
    d5b2:	4183      	sbcs	r3, r0
    d5b4:	e7dd      	b.n	d572 <__eqdf2+0x3a>
    d5b6:	2300      	movs	r3, #0
    d5b8:	e7db      	b.n	d572 <__eqdf2+0x3a>
    d5ba:	46c0      	nop			; (mov r8, r8)
    d5bc:	000007ff 	.word	0x000007ff

0000d5c0 <__gedf2>:
    d5c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    d5c2:	4657      	mov	r7, sl
    d5c4:	4645      	mov	r5, r8
    d5c6:	464e      	mov	r6, r9
    d5c8:	b4e0      	push	{r5, r6, r7}
    d5ca:	030f      	lsls	r7, r1, #12
    d5cc:	004e      	lsls	r6, r1, #1
    d5ce:	0fc9      	lsrs	r1, r1, #31
    d5d0:	468a      	mov	sl, r1
    d5d2:	4932      	ldr	r1, [pc, #200]	; (d69c <__gedf2+0xdc>)
    d5d4:	031d      	lsls	r5, r3, #12
    d5d6:	005c      	lsls	r4, r3, #1
    d5d8:	4684      	mov	ip, r0
    d5da:	0b3f      	lsrs	r7, r7, #12
    d5dc:	0d76      	lsrs	r6, r6, #21
    d5de:	4690      	mov	r8, r2
    d5e0:	0b2d      	lsrs	r5, r5, #12
    d5e2:	0d64      	lsrs	r4, r4, #21
    d5e4:	0fdb      	lsrs	r3, r3, #31
    d5e6:	428e      	cmp	r6, r1
    d5e8:	d00f      	beq.n	d60a <__gedf2+0x4a>
    d5ea:	428c      	cmp	r4, r1
    d5ec:	d039      	beq.n	d662 <__gedf2+0xa2>
    d5ee:	2e00      	cmp	r6, #0
    d5f0:	d110      	bne.n	d614 <__gedf2+0x54>
    d5f2:	4338      	orrs	r0, r7
    d5f4:	4241      	negs	r1, r0
    d5f6:	4141      	adcs	r1, r0
    d5f8:	4689      	mov	r9, r1
    d5fa:	2c00      	cmp	r4, #0
    d5fc:	d127      	bne.n	d64e <__gedf2+0x8e>
    d5fe:	432a      	orrs	r2, r5
    d600:	d125      	bne.n	d64e <__gedf2+0x8e>
    d602:	2000      	movs	r0, #0
    d604:	2900      	cmp	r1, #0
    d606:	d10e      	bne.n	d626 <__gedf2+0x66>
    d608:	e008      	b.n	d61c <__gedf2+0x5c>
    d60a:	1c39      	adds	r1, r7, #0
    d60c:	4301      	orrs	r1, r0
    d60e:	d12e      	bne.n	d66e <__gedf2+0xae>
    d610:	42b4      	cmp	r4, r6
    d612:	d026      	beq.n	d662 <__gedf2+0xa2>
    d614:	2c00      	cmp	r4, #0
    d616:	d00b      	beq.n	d630 <__gedf2+0x70>
    d618:	459a      	cmp	sl, r3
    d61a:	d00d      	beq.n	d638 <__gedf2+0x78>
    d61c:	4653      	mov	r3, sl
    d61e:	4259      	negs	r1, r3
    d620:	2301      	movs	r3, #1
    d622:	4319      	orrs	r1, r3
    d624:	1c08      	adds	r0, r1, #0
    d626:	bc1c      	pop	{r2, r3, r4}
    d628:	4690      	mov	r8, r2
    d62a:	4699      	mov	r9, r3
    d62c:	46a2      	mov	sl, r4
    d62e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d630:	432a      	orrs	r2, r5
    d632:	d0f3      	beq.n	d61c <__gedf2+0x5c>
    d634:	459a      	cmp	sl, r3
    d636:	d1f1      	bne.n	d61c <__gedf2+0x5c>
    d638:	42a6      	cmp	r6, r4
    d63a:	dcef      	bgt.n	d61c <__gedf2+0x5c>
    d63c:	da1a      	bge.n	d674 <__gedf2+0xb4>
    d63e:	4650      	mov	r0, sl
    d640:	4241      	negs	r1, r0
    d642:	4148      	adcs	r0, r1
    d644:	2301      	movs	r3, #1
    d646:	4241      	negs	r1, r0
    d648:	4319      	orrs	r1, r3
    d64a:	1c08      	adds	r0, r1, #0
    d64c:	e7eb      	b.n	d626 <__gedf2+0x66>
    d64e:	464a      	mov	r2, r9
    d650:	2a00      	cmp	r2, #0
    d652:	d0e1      	beq.n	d618 <__gedf2+0x58>
    d654:	4258      	negs	r0, r3
    d656:	4158      	adcs	r0, r3
    d658:	2201      	movs	r2, #1
    d65a:	4241      	negs	r1, r0
    d65c:	4311      	orrs	r1, r2
    d65e:	1c08      	adds	r0, r1, #0
    d660:	e7e1      	b.n	d626 <__gedf2+0x66>
    d662:	1c29      	adds	r1, r5, #0
    d664:	4311      	orrs	r1, r2
    d666:	d102      	bne.n	d66e <__gedf2+0xae>
    d668:	2e00      	cmp	r6, #0
    d66a:	d0c2      	beq.n	d5f2 <__gedf2+0x32>
    d66c:	e7d4      	b.n	d618 <__gedf2+0x58>
    d66e:	2002      	movs	r0, #2
    d670:	4240      	negs	r0, r0
    d672:	e7d8      	b.n	d626 <__gedf2+0x66>
    d674:	42af      	cmp	r7, r5
    d676:	d8d1      	bhi.n	d61c <__gedf2+0x5c>
    d678:	d009      	beq.n	d68e <__gedf2+0xce>
    d67a:	2000      	movs	r0, #0
    d67c:	42af      	cmp	r7, r5
    d67e:	d2d2      	bcs.n	d626 <__gedf2+0x66>
    d680:	4650      	mov	r0, sl
    d682:	4241      	negs	r1, r0
    d684:	4148      	adcs	r0, r1
    d686:	2301      	movs	r3, #1
    d688:	4240      	negs	r0, r0
    d68a:	4318      	orrs	r0, r3
    d68c:	e7cb      	b.n	d626 <__gedf2+0x66>
    d68e:	45c4      	cmp	ip, r8
    d690:	d8c4      	bhi.n	d61c <__gedf2+0x5c>
    d692:	2000      	movs	r0, #0
    d694:	45c4      	cmp	ip, r8
    d696:	d3f3      	bcc.n	d680 <__gedf2+0xc0>
    d698:	e7c5      	b.n	d626 <__gedf2+0x66>
    d69a:	46c0      	nop			; (mov r8, r8)
    d69c:	000007ff 	.word	0x000007ff

0000d6a0 <__ledf2>:
    d6a0:	b5f0      	push	{r4, r5, r6, r7, lr}
    d6a2:	465f      	mov	r7, fp
    d6a4:	464d      	mov	r5, r9
    d6a6:	4644      	mov	r4, r8
    d6a8:	4656      	mov	r6, sl
    d6aa:	4680      	mov	r8, r0
    d6ac:	b4f0      	push	{r4, r5, r6, r7}
    d6ae:	1c06      	adds	r6, r0, #0
    d6b0:	0308      	lsls	r0, r1, #12
    d6b2:	0b00      	lsrs	r0, r0, #12
    d6b4:	4684      	mov	ip, r0
    d6b6:	482c      	ldr	r0, [pc, #176]	; (d768 <__ledf2+0xc8>)
    d6b8:	004c      	lsls	r4, r1, #1
    d6ba:	031f      	lsls	r7, r3, #12
    d6bc:	005d      	lsls	r5, r3, #1
    d6be:	0fc9      	lsrs	r1, r1, #31
    d6c0:	0d64      	lsrs	r4, r4, #21
    d6c2:	468b      	mov	fp, r1
    d6c4:	4691      	mov	r9, r2
    d6c6:	0b3f      	lsrs	r7, r7, #12
    d6c8:	0d6d      	lsrs	r5, r5, #21
    d6ca:	0fdb      	lsrs	r3, r3, #31
    d6cc:	4284      	cmp	r4, r0
    d6ce:	d012      	beq.n	d6f6 <__ledf2+0x56>
    d6d0:	4285      	cmp	r5, r0
    d6d2:	d025      	beq.n	d720 <__ledf2+0x80>
    d6d4:	2c00      	cmp	r4, #0
    d6d6:	d114      	bne.n	d702 <__ledf2+0x62>
    d6d8:	4661      	mov	r1, ip
    d6da:	430e      	orrs	r6, r1
    d6dc:	4270      	negs	r0, r6
    d6de:	4146      	adcs	r6, r0
    d6e0:	2d00      	cmp	r5, #0
    d6e2:	d035      	beq.n	d750 <__ledf2+0xb0>
    d6e4:	2e00      	cmp	r6, #0
    d6e6:	d021      	beq.n	d72c <__ledf2+0x8c>
    d6e8:	4258      	negs	r0, r3
    d6ea:	4158      	adcs	r0, r3
    d6ec:	2101      	movs	r1, #1
    d6ee:	4243      	negs	r3, r0
    d6f0:	430b      	orrs	r3, r1
    d6f2:	1c18      	adds	r0, r3, #0
    d6f4:	e00e      	b.n	d714 <__ledf2+0x74>
    d6f6:	4661      	mov	r1, ip
    d6f8:	2002      	movs	r0, #2
    d6fa:	4331      	orrs	r1, r6
    d6fc:	d10a      	bne.n	d714 <__ledf2+0x74>
    d6fe:	42a5      	cmp	r5, r4
    d700:	d00e      	beq.n	d720 <__ledf2+0x80>
    d702:	2d00      	cmp	r5, #0
    d704:	d112      	bne.n	d72c <__ledf2+0x8c>
    d706:	433a      	orrs	r2, r7
    d708:	d110      	bne.n	d72c <__ledf2+0x8c>
    d70a:	465b      	mov	r3, fp
    d70c:	4259      	negs	r1, r3
    d70e:	2301      	movs	r3, #1
    d710:	4319      	orrs	r1, r3
    d712:	1c08      	adds	r0, r1, #0
    d714:	bc3c      	pop	{r2, r3, r4, r5}
    d716:	4690      	mov	r8, r2
    d718:	4699      	mov	r9, r3
    d71a:	46a2      	mov	sl, r4
    d71c:	46ab      	mov	fp, r5
    d71e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d720:	1c39      	adds	r1, r7, #0
    d722:	2002      	movs	r0, #2
    d724:	4311      	orrs	r1, r2
    d726:	d1f5      	bne.n	d714 <__ledf2+0x74>
    d728:	2c00      	cmp	r4, #0
    d72a:	d0d5      	beq.n	d6d8 <__ledf2+0x38>
    d72c:	459b      	cmp	fp, r3
    d72e:	d1ec      	bne.n	d70a <__ledf2+0x6a>
    d730:	42ac      	cmp	r4, r5
    d732:	dcea      	bgt.n	d70a <__ledf2+0x6a>
    d734:	db05      	blt.n	d742 <__ledf2+0xa2>
    d736:	45bc      	cmp	ip, r7
    d738:	d8e7      	bhi.n	d70a <__ledf2+0x6a>
    d73a:	d00f      	beq.n	d75c <__ledf2+0xbc>
    d73c:	2000      	movs	r0, #0
    d73e:	45bc      	cmp	ip, r7
    d740:	d2e8      	bcs.n	d714 <__ledf2+0x74>
    d742:	4658      	mov	r0, fp
    d744:	4241      	negs	r1, r0
    d746:	4148      	adcs	r0, r1
    d748:	4241      	negs	r1, r0
    d74a:	2001      	movs	r0, #1
    d74c:	4308      	orrs	r0, r1
    d74e:	e7e1      	b.n	d714 <__ledf2+0x74>
    d750:	433a      	orrs	r2, r7
    d752:	d1c7      	bne.n	d6e4 <__ledf2+0x44>
    d754:	2000      	movs	r0, #0
    d756:	2e00      	cmp	r6, #0
    d758:	d1dc      	bne.n	d714 <__ledf2+0x74>
    d75a:	e7d6      	b.n	d70a <__ledf2+0x6a>
    d75c:	45c8      	cmp	r8, r9
    d75e:	d8d4      	bhi.n	d70a <__ledf2+0x6a>
    d760:	2000      	movs	r0, #0
    d762:	45c8      	cmp	r8, r9
    d764:	d3ed      	bcc.n	d742 <__ledf2+0xa2>
    d766:	e7d5      	b.n	d714 <__ledf2+0x74>
    d768:	000007ff 	.word	0x000007ff

0000d76c <__libc_init_array>:
    d76c:	4b0e      	ldr	r3, [pc, #56]	; (d7a8 <__libc_init_array+0x3c>)
    d76e:	b570      	push	{r4, r5, r6, lr}
    d770:	2500      	movs	r5, #0
    d772:	1c1e      	adds	r6, r3, #0
    d774:	4c0d      	ldr	r4, [pc, #52]	; (d7ac <__libc_init_array+0x40>)
    d776:	1ae4      	subs	r4, r4, r3
    d778:	10a4      	asrs	r4, r4, #2
    d77a:	42a5      	cmp	r5, r4
    d77c:	d004      	beq.n	d788 <__libc_init_array+0x1c>
    d77e:	00ab      	lsls	r3, r5, #2
    d780:	58f3      	ldr	r3, [r6, r3]
    d782:	4798      	blx	r3
    d784:	3501      	adds	r5, #1
    d786:	e7f8      	b.n	d77a <__libc_init_array+0xe>
    d788:	f003 ff14 	bl	115b4 <_init>
    d78c:	4b08      	ldr	r3, [pc, #32]	; (d7b0 <__libc_init_array+0x44>)
    d78e:	2500      	movs	r5, #0
    d790:	1c1e      	adds	r6, r3, #0
    d792:	4c08      	ldr	r4, [pc, #32]	; (d7b4 <__libc_init_array+0x48>)
    d794:	1ae4      	subs	r4, r4, r3
    d796:	10a4      	asrs	r4, r4, #2
    d798:	42a5      	cmp	r5, r4
    d79a:	d004      	beq.n	d7a6 <__libc_init_array+0x3a>
    d79c:	00ab      	lsls	r3, r5, #2
    d79e:	58f3      	ldr	r3, [r6, r3]
    d7a0:	4798      	blx	r3
    d7a2:	3501      	adds	r5, #1
    d7a4:	e7f8      	b.n	d798 <__libc_init_array+0x2c>
    d7a6:	bd70      	pop	{r4, r5, r6, pc}
    d7a8:	000115c0 	.word	0x000115c0
    d7ac:	000115c0 	.word	0x000115c0
    d7b0:	000115c0 	.word	0x000115c0
    d7b4:	000115c4 	.word	0x000115c4

0000d7b8 <malloc>:
    d7b8:	b508      	push	{r3, lr}
    d7ba:	4b03      	ldr	r3, [pc, #12]	; (d7c8 <malloc+0x10>)
    d7bc:	1c01      	adds	r1, r0, #0
    d7be:	6818      	ldr	r0, [r3, #0]
    d7c0:	f000 f87e 	bl	d8c0 <_malloc_r>
    d7c4:	bd08      	pop	{r3, pc}
    d7c6:	46c0      	nop			; (mov r8, r8)
    d7c8:	2000009c 	.word	0x2000009c

0000d7cc <memcmp>:
    d7cc:	b530      	push	{r4, r5, lr}
    d7ce:	2400      	movs	r4, #0
    d7d0:	4294      	cmp	r4, r2
    d7d2:	d008      	beq.n	d7e6 <memcmp+0x1a>
    d7d4:	5d03      	ldrb	r3, [r0, r4]
    d7d6:	1c65      	adds	r5, r4, #1
    d7d8:	5d0c      	ldrb	r4, [r1, r4]
    d7da:	42a3      	cmp	r3, r4
    d7dc:	d001      	beq.n	d7e2 <memcmp+0x16>
    d7de:	1b18      	subs	r0, r3, r4
    d7e0:	e002      	b.n	d7e8 <memcmp+0x1c>
    d7e2:	1c2c      	adds	r4, r5, #0
    d7e4:	e7f4      	b.n	d7d0 <memcmp+0x4>
    d7e6:	2000      	movs	r0, #0
    d7e8:	bd30      	pop	{r4, r5, pc}

0000d7ea <memcpy>:
    d7ea:	2300      	movs	r3, #0
    d7ec:	b510      	push	{r4, lr}
    d7ee:	4293      	cmp	r3, r2
    d7f0:	d003      	beq.n	d7fa <memcpy+0x10>
    d7f2:	5ccc      	ldrb	r4, [r1, r3]
    d7f4:	54c4      	strb	r4, [r0, r3]
    d7f6:	3301      	adds	r3, #1
    d7f8:	e7f9      	b.n	d7ee <memcpy+0x4>
    d7fa:	bd10      	pop	{r4, pc}

0000d7fc <memmove>:
    d7fc:	b510      	push	{r4, lr}
    d7fe:	4281      	cmp	r1, r0
    d800:	d208      	bcs.n	d814 <memmove+0x18>
    d802:	188b      	adds	r3, r1, r2
    d804:	4298      	cmp	r0, r3
    d806:	d205      	bcs.n	d814 <memmove+0x18>
    d808:	1a9b      	subs	r3, r3, r2
    d80a:	3a01      	subs	r2, #1
    d80c:	d309      	bcc.n	d822 <memmove+0x26>
    d80e:	5c99      	ldrb	r1, [r3, r2]
    d810:	5481      	strb	r1, [r0, r2]
    d812:	e7fa      	b.n	d80a <memmove+0xe>
    d814:	2300      	movs	r3, #0
    d816:	4293      	cmp	r3, r2
    d818:	d003      	beq.n	d822 <memmove+0x26>
    d81a:	5ccc      	ldrb	r4, [r1, r3]
    d81c:	54c4      	strb	r4, [r0, r3]
    d81e:	3301      	adds	r3, #1
    d820:	e7f9      	b.n	d816 <memmove+0x1a>
    d822:	bd10      	pop	{r4, pc}

0000d824 <memset>:
    d824:	1c03      	adds	r3, r0, #0
    d826:	1882      	adds	r2, r0, r2
    d828:	4293      	cmp	r3, r2
    d82a:	d002      	beq.n	d832 <memset+0xe>
    d82c:	7019      	strb	r1, [r3, #0]
    d82e:	3301      	adds	r3, #1
    d830:	e7fa      	b.n	d828 <memset+0x4>
    d832:	4770      	bx	lr

0000d834 <_free_r>:
    d834:	b530      	push	{r4, r5, lr}
    d836:	2900      	cmp	r1, #0
    d838:	d03e      	beq.n	d8b8 <_free_r+0x84>
    d83a:	3904      	subs	r1, #4
    d83c:	680b      	ldr	r3, [r1, #0]
    d83e:	2b00      	cmp	r3, #0
    d840:	da00      	bge.n	d844 <_free_r+0x10>
    d842:	18c9      	adds	r1, r1, r3
    d844:	4a1d      	ldr	r2, [pc, #116]	; (d8bc <_free_r+0x88>)
    d846:	6813      	ldr	r3, [r2, #0]
    d848:	1c14      	adds	r4, r2, #0
    d84a:	2b00      	cmp	r3, #0
    d84c:	d102      	bne.n	d854 <_free_r+0x20>
    d84e:	604b      	str	r3, [r1, #4]
    d850:	6011      	str	r1, [r2, #0]
    d852:	e031      	b.n	d8b8 <_free_r+0x84>
    d854:	4299      	cmp	r1, r3
    d856:	d20d      	bcs.n	d874 <_free_r+0x40>
    d858:	6808      	ldr	r0, [r1, #0]
    d85a:	180a      	adds	r2, r1, r0
    d85c:	429a      	cmp	r2, r3
    d85e:	d103      	bne.n	d868 <_free_r+0x34>
    d860:	6813      	ldr	r3, [r2, #0]
    d862:	18c3      	adds	r3, r0, r3
    d864:	600b      	str	r3, [r1, #0]
    d866:	6853      	ldr	r3, [r2, #4]
    d868:	604b      	str	r3, [r1, #4]
    d86a:	6021      	str	r1, [r4, #0]
    d86c:	e024      	b.n	d8b8 <_free_r+0x84>
    d86e:	428a      	cmp	r2, r1
    d870:	d803      	bhi.n	d87a <_free_r+0x46>
    d872:	1c13      	adds	r3, r2, #0
    d874:	685a      	ldr	r2, [r3, #4]
    d876:	2a00      	cmp	r2, #0
    d878:	d1f9      	bne.n	d86e <_free_r+0x3a>
    d87a:	681d      	ldr	r5, [r3, #0]
    d87c:	195c      	adds	r4, r3, r5
    d87e:	428c      	cmp	r4, r1
    d880:	d10b      	bne.n	d89a <_free_r+0x66>
    d882:	6809      	ldr	r1, [r1, #0]
    d884:	1869      	adds	r1, r5, r1
    d886:	1858      	adds	r0, r3, r1
    d888:	6019      	str	r1, [r3, #0]
    d88a:	4290      	cmp	r0, r2
    d88c:	d114      	bne.n	d8b8 <_free_r+0x84>
    d88e:	6810      	ldr	r0, [r2, #0]
    d890:	6852      	ldr	r2, [r2, #4]
    d892:	1809      	adds	r1, r1, r0
    d894:	6019      	str	r1, [r3, #0]
    d896:	605a      	str	r2, [r3, #4]
    d898:	e00e      	b.n	d8b8 <_free_r+0x84>
    d89a:	428c      	cmp	r4, r1
    d89c:	d902      	bls.n	d8a4 <_free_r+0x70>
    d89e:	230c      	movs	r3, #12
    d8a0:	6003      	str	r3, [r0, #0]
    d8a2:	e009      	b.n	d8b8 <_free_r+0x84>
    d8a4:	6808      	ldr	r0, [r1, #0]
    d8a6:	180c      	adds	r4, r1, r0
    d8a8:	4294      	cmp	r4, r2
    d8aa:	d103      	bne.n	d8b4 <_free_r+0x80>
    d8ac:	6814      	ldr	r4, [r2, #0]
    d8ae:	6852      	ldr	r2, [r2, #4]
    d8b0:	1900      	adds	r0, r0, r4
    d8b2:	6008      	str	r0, [r1, #0]
    d8b4:	604a      	str	r2, [r1, #4]
    d8b6:	6059      	str	r1, [r3, #4]
    d8b8:	bd30      	pop	{r4, r5, pc}
    d8ba:	46c0      	nop			; (mov r8, r8)
    d8bc:	200006c0 	.word	0x200006c0

0000d8c0 <_malloc_r>:
    d8c0:	2303      	movs	r3, #3
    d8c2:	b570      	push	{r4, r5, r6, lr}
    d8c4:	1ccc      	adds	r4, r1, #3
    d8c6:	439c      	bics	r4, r3
    d8c8:	3408      	adds	r4, #8
    d8ca:	1c05      	adds	r5, r0, #0
    d8cc:	2c0c      	cmp	r4, #12
    d8ce:	d201      	bcs.n	d8d4 <_malloc_r+0x14>
    d8d0:	240c      	movs	r4, #12
    d8d2:	e005      	b.n	d8e0 <_malloc_r+0x20>
    d8d4:	2c00      	cmp	r4, #0
    d8d6:	da03      	bge.n	d8e0 <_malloc_r+0x20>
    d8d8:	230c      	movs	r3, #12
    d8da:	2000      	movs	r0, #0
    d8dc:	602b      	str	r3, [r5, #0]
    d8de:	e042      	b.n	d966 <_malloc_r+0xa6>
    d8e0:	428c      	cmp	r4, r1
    d8e2:	d3f9      	bcc.n	d8d8 <_malloc_r+0x18>
    d8e4:	4a20      	ldr	r2, [pc, #128]	; (d968 <_malloc_r+0xa8>)
    d8e6:	6813      	ldr	r3, [r2, #0]
    d8e8:	1c10      	adds	r0, r2, #0
    d8ea:	1c19      	adds	r1, r3, #0
    d8ec:	2900      	cmp	r1, #0
    d8ee:	d013      	beq.n	d918 <_malloc_r+0x58>
    d8f0:	680a      	ldr	r2, [r1, #0]
    d8f2:	1b12      	subs	r2, r2, r4
    d8f4:	d40d      	bmi.n	d912 <_malloc_r+0x52>
    d8f6:	2a0b      	cmp	r2, #11
    d8f8:	d902      	bls.n	d900 <_malloc_r+0x40>
    d8fa:	600a      	str	r2, [r1, #0]
    d8fc:	188b      	adds	r3, r1, r2
    d8fe:	e01f      	b.n	d940 <_malloc_r+0x80>
    d900:	428b      	cmp	r3, r1
    d902:	d102      	bne.n	d90a <_malloc_r+0x4a>
    d904:	685a      	ldr	r2, [r3, #4]
    d906:	6002      	str	r2, [r0, #0]
    d908:	e01b      	b.n	d942 <_malloc_r+0x82>
    d90a:	684a      	ldr	r2, [r1, #4]
    d90c:	605a      	str	r2, [r3, #4]
    d90e:	1c0b      	adds	r3, r1, #0
    d910:	e017      	b.n	d942 <_malloc_r+0x82>
    d912:	1c0b      	adds	r3, r1, #0
    d914:	6849      	ldr	r1, [r1, #4]
    d916:	e7e9      	b.n	d8ec <_malloc_r+0x2c>
    d918:	4e14      	ldr	r6, [pc, #80]	; (d96c <_malloc_r+0xac>)
    d91a:	6833      	ldr	r3, [r6, #0]
    d91c:	2b00      	cmp	r3, #0
    d91e:	d103      	bne.n	d928 <_malloc_r+0x68>
    d920:	1c28      	adds	r0, r5, #0
    d922:	f000 f875 	bl	da10 <_sbrk_r>
    d926:	6030      	str	r0, [r6, #0]
    d928:	1c28      	adds	r0, r5, #0
    d92a:	1c21      	adds	r1, r4, #0
    d92c:	f000 f870 	bl	da10 <_sbrk_r>
    d930:	1c03      	adds	r3, r0, #0
    d932:	1c42      	adds	r2, r0, #1
    d934:	d0d0      	beq.n	d8d8 <_malloc_r+0x18>
    d936:	2203      	movs	r2, #3
    d938:	1cc6      	adds	r6, r0, #3
    d93a:	4396      	bics	r6, r2
    d93c:	4286      	cmp	r6, r0
    d93e:	d10a      	bne.n	d956 <_malloc_r+0x96>
    d940:	601c      	str	r4, [r3, #0]
    d942:	1c18      	adds	r0, r3, #0
    d944:	2107      	movs	r1, #7
    d946:	300b      	adds	r0, #11
    d948:	1d1a      	adds	r2, r3, #4
    d94a:	4388      	bics	r0, r1
    d94c:	1a82      	subs	r2, r0, r2
    d94e:	d00a      	beq.n	d966 <_malloc_r+0xa6>
    d950:	4251      	negs	r1, r2
    d952:	5099      	str	r1, [r3, r2]
    d954:	e007      	b.n	d966 <_malloc_r+0xa6>
    d956:	1a31      	subs	r1, r6, r0
    d958:	1c28      	adds	r0, r5, #0
    d95a:	f000 f859 	bl	da10 <_sbrk_r>
    d95e:	1c43      	adds	r3, r0, #1
    d960:	d0ba      	beq.n	d8d8 <_malloc_r+0x18>
    d962:	1c33      	adds	r3, r6, #0
    d964:	e7ec      	b.n	d940 <_malloc_r+0x80>
    d966:	bd70      	pop	{r4, r5, r6, pc}
    d968:	200006c0 	.word	0x200006c0
    d96c:	200006bc 	.word	0x200006bc

0000d970 <putchar>:
    d970:	b538      	push	{r3, r4, r5, lr}
    d972:	4b08      	ldr	r3, [pc, #32]	; (d994 <putchar+0x24>)
    d974:	1c05      	adds	r5, r0, #0
    d976:	681c      	ldr	r4, [r3, #0]
    d978:	2c00      	cmp	r4, #0
    d97a:	d005      	beq.n	d988 <putchar+0x18>
    d97c:	69a3      	ldr	r3, [r4, #24]
    d97e:	2b00      	cmp	r3, #0
    d980:	d102      	bne.n	d988 <putchar+0x18>
    d982:	1c20      	adds	r0, r4, #0
    d984:	f000 fa6a 	bl	de5c <__sinit>
    d988:	1c29      	adds	r1, r5, #0
    d98a:	1c20      	adds	r0, r4, #0
    d98c:	68a2      	ldr	r2, [r4, #8]
    d98e:	f000 fe2b 	bl	e5e8 <_putc_r>
    d992:	bd38      	pop	{r3, r4, r5, pc}
    d994:	2000009c 	.word	0x2000009c

0000d998 <rand>:
    d998:	4b15      	ldr	r3, [pc, #84]	; (d9f0 <rand+0x58>)
    d99a:	b510      	push	{r4, lr}
    d99c:	681c      	ldr	r4, [r3, #0]
    d99e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d9a0:	2b00      	cmp	r3, #0
    d9a2:	d115      	bne.n	d9d0 <rand+0x38>
    d9a4:	2018      	movs	r0, #24
    d9a6:	f7ff ff07 	bl	d7b8 <malloc>
    d9aa:	4b12      	ldr	r3, [pc, #72]	; (d9f4 <rand+0x5c>)
    d9ac:	63a0      	str	r0, [r4, #56]	; 0x38
    d9ae:	8003      	strh	r3, [r0, #0]
    d9b0:	4b11      	ldr	r3, [pc, #68]	; (d9f8 <rand+0x60>)
    d9b2:	2201      	movs	r2, #1
    d9b4:	8043      	strh	r3, [r0, #2]
    d9b6:	4b11      	ldr	r3, [pc, #68]	; (d9fc <rand+0x64>)
    d9b8:	8083      	strh	r3, [r0, #4]
    d9ba:	4b11      	ldr	r3, [pc, #68]	; (da00 <rand+0x68>)
    d9bc:	80c3      	strh	r3, [r0, #6]
    d9be:	4b11      	ldr	r3, [pc, #68]	; (da04 <rand+0x6c>)
    d9c0:	8103      	strh	r3, [r0, #8]
    d9c2:	2305      	movs	r3, #5
    d9c4:	8143      	strh	r3, [r0, #10]
    d9c6:	3306      	adds	r3, #6
    d9c8:	8183      	strh	r3, [r0, #12]
    d9ca:	2300      	movs	r3, #0
    d9cc:	6102      	str	r2, [r0, #16]
    d9ce:	6143      	str	r3, [r0, #20]
    d9d0:	6ba4      	ldr	r4, [r4, #56]	; 0x38
    d9d2:	4a0d      	ldr	r2, [pc, #52]	; (da08 <rand+0x70>)
    d9d4:	6920      	ldr	r0, [r4, #16]
    d9d6:	6961      	ldr	r1, [r4, #20]
    d9d8:	4b0c      	ldr	r3, [pc, #48]	; (da0c <rand+0x74>)
    d9da:	f7fe fb69 	bl	c0b0 <__aeabi_lmul>
    d9de:	2201      	movs	r2, #1
    d9e0:	2300      	movs	r3, #0
    d9e2:	1880      	adds	r0, r0, r2
    d9e4:	4159      	adcs	r1, r3
    d9e6:	6120      	str	r0, [r4, #16]
    d9e8:	6161      	str	r1, [r4, #20]
    d9ea:	0048      	lsls	r0, r1, #1
    d9ec:	0840      	lsrs	r0, r0, #1
    d9ee:	bd10      	pop	{r4, pc}
    d9f0:	2000009c 	.word	0x2000009c
    d9f4:	0000330e 	.word	0x0000330e
    d9f8:	ffffabcd 	.word	0xffffabcd
    d9fc:	00001234 	.word	0x00001234
    da00:	ffffe66d 	.word	0xffffe66d
    da04:	ffffdeec 	.word	0xffffdeec
    da08:	4c957f2d 	.word	0x4c957f2d
    da0c:	5851f42d 	.word	0x5851f42d

0000da10 <_sbrk_r>:
    da10:	b538      	push	{r3, r4, r5, lr}
    da12:	2300      	movs	r3, #0
    da14:	4c06      	ldr	r4, [pc, #24]	; (da30 <_sbrk_r+0x20>)
    da16:	1c05      	adds	r5, r0, #0
    da18:	1c08      	adds	r0, r1, #0
    da1a:	6023      	str	r3, [r4, #0]
    da1c:	f7f8 fcb4 	bl	6388 <_sbrk>
    da20:	1c43      	adds	r3, r0, #1
    da22:	d103      	bne.n	da2c <_sbrk_r+0x1c>
    da24:	6823      	ldr	r3, [r4, #0]
    da26:	2b00      	cmp	r3, #0
    da28:	d000      	beq.n	da2c <_sbrk_r+0x1c>
    da2a:	602b      	str	r3, [r5, #0]
    da2c:	bd38      	pop	{r3, r4, r5, pc}
    da2e:	46c0      	nop			; (mov r8, r8)
    da30:	20002214 	.word	0x20002214

0000da34 <siprintf>:
    da34:	b40e      	push	{r1, r2, r3}
    da36:	b510      	push	{r4, lr}
    da38:	b09d      	sub	sp, #116	; 0x74
    da3a:	a902      	add	r1, sp, #8
    da3c:	9002      	str	r0, [sp, #8]
    da3e:	6108      	str	r0, [r1, #16]
    da40:	480b      	ldr	r0, [pc, #44]	; (da70 <siprintf+0x3c>)
    da42:	2482      	movs	r4, #130	; 0x82
    da44:	6088      	str	r0, [r1, #8]
    da46:	6148      	str	r0, [r1, #20]
    da48:	2001      	movs	r0, #1
    da4a:	4240      	negs	r0, r0
    da4c:	ab1f      	add	r3, sp, #124	; 0x7c
    da4e:	81c8      	strh	r0, [r1, #14]
    da50:	4808      	ldr	r0, [pc, #32]	; (da74 <siprintf+0x40>)
    da52:	cb04      	ldmia	r3!, {r2}
    da54:	00a4      	lsls	r4, r4, #2
    da56:	6800      	ldr	r0, [r0, #0]
    da58:	9301      	str	r3, [sp, #4]
    da5a:	818c      	strh	r4, [r1, #12]
    da5c:	f000 fb48 	bl	e0f0 <_svfiprintf_r>
    da60:	2300      	movs	r3, #0
    da62:	9a02      	ldr	r2, [sp, #8]
    da64:	7013      	strb	r3, [r2, #0]
    da66:	b01d      	add	sp, #116	; 0x74
    da68:	bc10      	pop	{r4}
    da6a:	bc08      	pop	{r3}
    da6c:	b003      	add	sp, #12
    da6e:	4718      	bx	r3
    da70:	7fffffff 	.word	0x7fffffff
    da74:	2000009c 	.word	0x2000009c

0000da78 <strcmp>:
    da78:	7802      	ldrb	r2, [r0, #0]
    da7a:	780b      	ldrb	r3, [r1, #0]
    da7c:	2a00      	cmp	r2, #0
    da7e:	d003      	beq.n	da88 <strcmp+0x10>
    da80:	3001      	adds	r0, #1
    da82:	3101      	adds	r1, #1
    da84:	429a      	cmp	r2, r3
    da86:	d0f7      	beq.n	da78 <strcmp>
    da88:	1ad0      	subs	r0, r2, r3
    da8a:	4770      	bx	lr

0000da8c <strcpy>:
    da8c:	1c03      	adds	r3, r0, #0
    da8e:	780a      	ldrb	r2, [r1, #0]
    da90:	3101      	adds	r1, #1
    da92:	701a      	strb	r2, [r3, #0]
    da94:	3301      	adds	r3, #1
    da96:	2a00      	cmp	r2, #0
    da98:	d1f9      	bne.n	da8e <strcpy+0x2>
    da9a:	4770      	bx	lr

0000da9c <strlen>:
    da9c:	2300      	movs	r3, #0
    da9e:	5cc2      	ldrb	r2, [r0, r3]
    daa0:	3301      	adds	r3, #1
    daa2:	2a00      	cmp	r2, #0
    daa4:	d1fb      	bne.n	da9e <strlen+0x2>
    daa6:	1e58      	subs	r0, r3, #1
    daa8:	4770      	bx	lr

0000daaa <strncmp>:
    daaa:	2300      	movs	r3, #0
    daac:	b530      	push	{r4, r5, lr}
    daae:	429a      	cmp	r2, r3
    dab0:	d00d      	beq.n	dace <strncmp+0x24>
    dab2:	3a01      	subs	r2, #1
    dab4:	5cc4      	ldrb	r4, [r0, r3]
    dab6:	5ccd      	ldrb	r5, [r1, r3]
    dab8:	42ac      	cmp	r4, r5
    daba:	d102      	bne.n	dac2 <strncmp+0x18>
    dabc:	4293      	cmp	r3, r2
    dabe:	d102      	bne.n	dac6 <strncmp+0x1c>
    dac0:	1c25      	adds	r5, r4, #0
    dac2:	1b63      	subs	r3, r4, r5
    dac4:	e003      	b.n	dace <strncmp+0x24>
    dac6:	3301      	adds	r3, #1
    dac8:	2c00      	cmp	r4, #0
    daca:	d1f3      	bne.n	dab4 <strncmp+0xa>
    dacc:	e7f8      	b.n	dac0 <strncmp+0x16>
    dace:	1c18      	adds	r0, r3, #0
    dad0:	bd30      	pop	{r4, r5, pc}
	...

0000dad4 <__swbuf_r>:
    dad4:	b570      	push	{r4, r5, r6, lr}
    dad6:	1c05      	adds	r5, r0, #0
    dad8:	1c0e      	adds	r6, r1, #0
    dada:	1c14      	adds	r4, r2, #0
    dadc:	2800      	cmp	r0, #0
    dade:	d004      	beq.n	daea <__swbuf_r+0x16>
    dae0:	6983      	ldr	r3, [r0, #24]
    dae2:	2b00      	cmp	r3, #0
    dae4:	d101      	bne.n	daea <__swbuf_r+0x16>
    dae6:	f000 f9b9 	bl	de5c <__sinit>
    daea:	4b23      	ldr	r3, [pc, #140]	; (db78 <__swbuf_r+0xa4>)
    daec:	429c      	cmp	r4, r3
    daee:	d101      	bne.n	daf4 <__swbuf_r+0x20>
    daf0:	686c      	ldr	r4, [r5, #4]
    daf2:	e008      	b.n	db06 <__swbuf_r+0x32>
    daf4:	4b21      	ldr	r3, [pc, #132]	; (db7c <__swbuf_r+0xa8>)
    daf6:	429c      	cmp	r4, r3
    daf8:	d101      	bne.n	dafe <__swbuf_r+0x2a>
    dafa:	68ac      	ldr	r4, [r5, #8]
    dafc:	e003      	b.n	db06 <__swbuf_r+0x32>
    dafe:	4b20      	ldr	r3, [pc, #128]	; (db80 <__swbuf_r+0xac>)
    db00:	429c      	cmp	r4, r3
    db02:	d100      	bne.n	db06 <__swbuf_r+0x32>
    db04:	68ec      	ldr	r4, [r5, #12]
    db06:	69a3      	ldr	r3, [r4, #24]
    db08:	60a3      	str	r3, [r4, #8]
    db0a:	89a3      	ldrh	r3, [r4, #12]
    db0c:	071b      	lsls	r3, r3, #28
    db0e:	d50a      	bpl.n	db26 <__swbuf_r+0x52>
    db10:	6923      	ldr	r3, [r4, #16]
    db12:	2b00      	cmp	r3, #0
    db14:	d007      	beq.n	db26 <__swbuf_r+0x52>
    db16:	6823      	ldr	r3, [r4, #0]
    db18:	6922      	ldr	r2, [r4, #16]
    db1a:	b2f6      	uxtb	r6, r6
    db1c:	1a98      	subs	r0, r3, r2
    db1e:	6963      	ldr	r3, [r4, #20]
    db20:	4298      	cmp	r0, r3
    db22:	db0f      	blt.n	db44 <__swbuf_r+0x70>
    db24:	e008      	b.n	db38 <__swbuf_r+0x64>
    db26:	1c28      	adds	r0, r5, #0
    db28:	1c21      	adds	r1, r4, #0
    db2a:	f000 f82b 	bl	db84 <__swsetup_r>
    db2e:	2800      	cmp	r0, #0
    db30:	d0f1      	beq.n	db16 <__swbuf_r+0x42>
    db32:	2001      	movs	r0, #1
    db34:	4240      	negs	r0, r0
    db36:	e01d      	b.n	db74 <__swbuf_r+0xa0>
    db38:	1c28      	adds	r0, r5, #0
    db3a:	1c21      	adds	r1, r4, #0
    db3c:	f000 f920 	bl	dd80 <_fflush_r>
    db40:	2800      	cmp	r0, #0
    db42:	d1f6      	bne.n	db32 <__swbuf_r+0x5e>
    db44:	68a3      	ldr	r3, [r4, #8]
    db46:	3001      	adds	r0, #1
    db48:	3b01      	subs	r3, #1
    db4a:	60a3      	str	r3, [r4, #8]
    db4c:	6823      	ldr	r3, [r4, #0]
    db4e:	1c5a      	adds	r2, r3, #1
    db50:	6022      	str	r2, [r4, #0]
    db52:	701e      	strb	r6, [r3, #0]
    db54:	6963      	ldr	r3, [r4, #20]
    db56:	4298      	cmp	r0, r3
    db58:	d005      	beq.n	db66 <__swbuf_r+0x92>
    db5a:	89a3      	ldrh	r3, [r4, #12]
    db5c:	1c30      	adds	r0, r6, #0
    db5e:	07db      	lsls	r3, r3, #31
    db60:	d508      	bpl.n	db74 <__swbuf_r+0xa0>
    db62:	2e0a      	cmp	r6, #10
    db64:	d106      	bne.n	db74 <__swbuf_r+0xa0>
    db66:	1c28      	adds	r0, r5, #0
    db68:	1c21      	adds	r1, r4, #0
    db6a:	f000 f909 	bl	dd80 <_fflush_r>
    db6e:	2800      	cmp	r0, #0
    db70:	d1df      	bne.n	db32 <__swbuf_r+0x5e>
    db72:	1c30      	adds	r0, r6, #0
    db74:	bd70      	pop	{r4, r5, r6, pc}
    db76:	46c0      	nop			; (mov r8, r8)
    db78:	00011520 	.word	0x00011520
    db7c:	00011540 	.word	0x00011540
    db80:	00011560 	.word	0x00011560

0000db84 <__swsetup_r>:
    db84:	4b35      	ldr	r3, [pc, #212]	; (dc5c <__swsetup_r+0xd8>)
    db86:	b570      	push	{r4, r5, r6, lr}
    db88:	681d      	ldr	r5, [r3, #0]
    db8a:	1c06      	adds	r6, r0, #0
    db8c:	1c0c      	adds	r4, r1, #0
    db8e:	2d00      	cmp	r5, #0
    db90:	d005      	beq.n	db9e <__swsetup_r+0x1a>
    db92:	69ab      	ldr	r3, [r5, #24]
    db94:	2b00      	cmp	r3, #0
    db96:	d102      	bne.n	db9e <__swsetup_r+0x1a>
    db98:	1c28      	adds	r0, r5, #0
    db9a:	f000 f95f 	bl	de5c <__sinit>
    db9e:	4b30      	ldr	r3, [pc, #192]	; (dc60 <__swsetup_r+0xdc>)
    dba0:	429c      	cmp	r4, r3
    dba2:	d101      	bne.n	dba8 <__swsetup_r+0x24>
    dba4:	686c      	ldr	r4, [r5, #4]
    dba6:	e008      	b.n	dbba <__swsetup_r+0x36>
    dba8:	4b2e      	ldr	r3, [pc, #184]	; (dc64 <__swsetup_r+0xe0>)
    dbaa:	429c      	cmp	r4, r3
    dbac:	d101      	bne.n	dbb2 <__swsetup_r+0x2e>
    dbae:	68ac      	ldr	r4, [r5, #8]
    dbb0:	e003      	b.n	dbba <__swsetup_r+0x36>
    dbb2:	4b2d      	ldr	r3, [pc, #180]	; (dc68 <__swsetup_r+0xe4>)
    dbb4:	429c      	cmp	r4, r3
    dbb6:	d100      	bne.n	dbba <__swsetup_r+0x36>
    dbb8:	68ec      	ldr	r4, [r5, #12]
    dbba:	89a3      	ldrh	r3, [r4, #12]
    dbbc:	b29a      	uxth	r2, r3
    dbbe:	0711      	lsls	r1, r2, #28
    dbc0:	d423      	bmi.n	dc0a <__swsetup_r+0x86>
    dbc2:	06d1      	lsls	r1, r2, #27
    dbc4:	d407      	bmi.n	dbd6 <__swsetup_r+0x52>
    dbc6:	2209      	movs	r2, #9
    dbc8:	2001      	movs	r0, #1
    dbca:	6032      	str	r2, [r6, #0]
    dbcc:	3237      	adds	r2, #55	; 0x37
    dbce:	4313      	orrs	r3, r2
    dbd0:	81a3      	strh	r3, [r4, #12]
    dbd2:	4240      	negs	r0, r0
    dbd4:	e040      	b.n	dc58 <__swsetup_r+0xd4>
    dbd6:	0753      	lsls	r3, r2, #29
    dbd8:	d513      	bpl.n	dc02 <__swsetup_r+0x7e>
    dbda:	6b61      	ldr	r1, [r4, #52]	; 0x34
    dbdc:	2900      	cmp	r1, #0
    dbde:	d008      	beq.n	dbf2 <__swsetup_r+0x6e>
    dbe0:	1c23      	adds	r3, r4, #0
    dbe2:	3344      	adds	r3, #68	; 0x44
    dbe4:	4299      	cmp	r1, r3
    dbe6:	d002      	beq.n	dbee <__swsetup_r+0x6a>
    dbe8:	1c30      	adds	r0, r6, #0
    dbea:	f7ff fe23 	bl	d834 <_free_r>
    dbee:	2300      	movs	r3, #0
    dbf0:	6363      	str	r3, [r4, #52]	; 0x34
    dbf2:	2224      	movs	r2, #36	; 0x24
    dbf4:	89a3      	ldrh	r3, [r4, #12]
    dbf6:	4393      	bics	r3, r2
    dbf8:	81a3      	strh	r3, [r4, #12]
    dbfa:	2300      	movs	r3, #0
    dbfc:	6063      	str	r3, [r4, #4]
    dbfe:	6923      	ldr	r3, [r4, #16]
    dc00:	6023      	str	r3, [r4, #0]
    dc02:	2208      	movs	r2, #8
    dc04:	89a3      	ldrh	r3, [r4, #12]
    dc06:	4313      	orrs	r3, r2
    dc08:	81a3      	strh	r3, [r4, #12]
    dc0a:	6923      	ldr	r3, [r4, #16]
    dc0c:	2b00      	cmp	r3, #0
    dc0e:	d10b      	bne.n	dc28 <__swsetup_r+0xa4>
    dc10:	23a0      	movs	r3, #160	; 0xa0
    dc12:	89a2      	ldrh	r2, [r4, #12]
    dc14:	009b      	lsls	r3, r3, #2
    dc16:	4013      	ands	r3, r2
    dc18:	2280      	movs	r2, #128	; 0x80
    dc1a:	0092      	lsls	r2, r2, #2
    dc1c:	4293      	cmp	r3, r2
    dc1e:	d003      	beq.n	dc28 <__swsetup_r+0xa4>
    dc20:	1c30      	adds	r0, r6, #0
    dc22:	1c21      	adds	r1, r4, #0
    dc24:	f000 f9ac 	bl	df80 <__smakebuf_r>
    dc28:	2301      	movs	r3, #1
    dc2a:	89a2      	ldrh	r2, [r4, #12]
    dc2c:	4013      	ands	r3, r2
    dc2e:	d005      	beq.n	dc3c <__swsetup_r+0xb8>
    dc30:	2300      	movs	r3, #0
    dc32:	60a3      	str	r3, [r4, #8]
    dc34:	6963      	ldr	r3, [r4, #20]
    dc36:	425b      	negs	r3, r3
    dc38:	61a3      	str	r3, [r4, #24]
    dc3a:	e003      	b.n	dc44 <__swsetup_r+0xc0>
    dc3c:	0791      	lsls	r1, r2, #30
    dc3e:	d400      	bmi.n	dc42 <__swsetup_r+0xbe>
    dc40:	6963      	ldr	r3, [r4, #20]
    dc42:	60a3      	str	r3, [r4, #8]
    dc44:	2000      	movs	r0, #0
    dc46:	6923      	ldr	r3, [r4, #16]
    dc48:	4283      	cmp	r3, r0
    dc4a:	d105      	bne.n	dc58 <__swsetup_r+0xd4>
    dc4c:	0613      	lsls	r3, r2, #24
    dc4e:	d503      	bpl.n	dc58 <__swsetup_r+0xd4>
    dc50:	2340      	movs	r3, #64	; 0x40
    dc52:	431a      	orrs	r2, r3
    dc54:	81a2      	strh	r2, [r4, #12]
    dc56:	3801      	subs	r0, #1
    dc58:	bd70      	pop	{r4, r5, r6, pc}
    dc5a:	46c0      	nop			; (mov r8, r8)
    dc5c:	2000009c 	.word	0x2000009c
    dc60:	00011520 	.word	0x00011520
    dc64:	00011540 	.word	0x00011540
    dc68:	00011560 	.word	0x00011560

0000dc6c <__sflush_r>:
    dc6c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    dc6e:	898a      	ldrh	r2, [r1, #12]
    dc70:	1c05      	adds	r5, r0, #0
    dc72:	1c0c      	adds	r4, r1, #0
    dc74:	0713      	lsls	r3, r2, #28
    dc76:	d45e      	bmi.n	dd36 <__sflush_r+0xca>
    dc78:	684b      	ldr	r3, [r1, #4]
    dc7a:	2b00      	cmp	r3, #0
    dc7c:	dc02      	bgt.n	dc84 <__sflush_r+0x18>
    dc7e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    dc80:	2b00      	cmp	r3, #0
    dc82:	dd1a      	ble.n	dcba <__sflush_r+0x4e>
    dc84:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    dc86:	2f00      	cmp	r7, #0
    dc88:	d017      	beq.n	dcba <__sflush_r+0x4e>
    dc8a:	2300      	movs	r3, #0
    dc8c:	682e      	ldr	r6, [r5, #0]
    dc8e:	602b      	str	r3, [r5, #0]
    dc90:	2380      	movs	r3, #128	; 0x80
    dc92:	015b      	lsls	r3, r3, #5
    dc94:	401a      	ands	r2, r3
    dc96:	d001      	beq.n	dc9c <__sflush_r+0x30>
    dc98:	6d62      	ldr	r2, [r4, #84]	; 0x54
    dc9a:	e015      	b.n	dcc8 <__sflush_r+0x5c>
    dc9c:	1c28      	adds	r0, r5, #0
    dc9e:	6a21      	ldr	r1, [r4, #32]
    dca0:	2301      	movs	r3, #1
    dca2:	47b8      	blx	r7
    dca4:	1c02      	adds	r2, r0, #0
    dca6:	1c43      	adds	r3, r0, #1
    dca8:	d10e      	bne.n	dcc8 <__sflush_r+0x5c>
    dcaa:	682b      	ldr	r3, [r5, #0]
    dcac:	2b00      	cmp	r3, #0
    dcae:	d00b      	beq.n	dcc8 <__sflush_r+0x5c>
    dcb0:	2b1d      	cmp	r3, #29
    dcb2:	d001      	beq.n	dcb8 <__sflush_r+0x4c>
    dcb4:	2b16      	cmp	r3, #22
    dcb6:	d102      	bne.n	dcbe <__sflush_r+0x52>
    dcb8:	602e      	str	r6, [r5, #0]
    dcba:	2000      	movs	r0, #0
    dcbc:	e05e      	b.n	dd7c <__sflush_r+0x110>
    dcbe:	2140      	movs	r1, #64	; 0x40
    dcc0:	89a3      	ldrh	r3, [r4, #12]
    dcc2:	430b      	orrs	r3, r1
    dcc4:	81a3      	strh	r3, [r4, #12]
    dcc6:	e059      	b.n	dd7c <__sflush_r+0x110>
    dcc8:	89a3      	ldrh	r3, [r4, #12]
    dcca:	075b      	lsls	r3, r3, #29
    dccc:	d506      	bpl.n	dcdc <__sflush_r+0x70>
    dcce:	6863      	ldr	r3, [r4, #4]
    dcd0:	1ad2      	subs	r2, r2, r3
    dcd2:	6b63      	ldr	r3, [r4, #52]	; 0x34
    dcd4:	2b00      	cmp	r3, #0
    dcd6:	d001      	beq.n	dcdc <__sflush_r+0x70>
    dcd8:	6c23      	ldr	r3, [r4, #64]	; 0x40
    dcda:	1ad2      	subs	r2, r2, r3
    dcdc:	2300      	movs	r3, #0
    dcde:	1c28      	adds	r0, r5, #0
    dce0:	6a21      	ldr	r1, [r4, #32]
    dce2:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    dce4:	47b8      	blx	r7
    dce6:	89a3      	ldrh	r3, [r4, #12]
    dce8:	1c42      	adds	r2, r0, #1
    dcea:	d106      	bne.n	dcfa <__sflush_r+0x8e>
    dcec:	682a      	ldr	r2, [r5, #0]
    dcee:	2a00      	cmp	r2, #0
    dcf0:	d003      	beq.n	dcfa <__sflush_r+0x8e>
    dcf2:	2a1d      	cmp	r2, #29
    dcf4:	d001      	beq.n	dcfa <__sflush_r+0x8e>
    dcf6:	2a16      	cmp	r2, #22
    dcf8:	d119      	bne.n	dd2e <__sflush_r+0xc2>
    dcfa:	2200      	movs	r2, #0
    dcfc:	6062      	str	r2, [r4, #4]
    dcfe:	6922      	ldr	r2, [r4, #16]
    dd00:	6022      	str	r2, [r4, #0]
    dd02:	04db      	lsls	r3, r3, #19
    dd04:	d505      	bpl.n	dd12 <__sflush_r+0xa6>
    dd06:	1c43      	adds	r3, r0, #1
    dd08:	d102      	bne.n	dd10 <__sflush_r+0xa4>
    dd0a:	682b      	ldr	r3, [r5, #0]
    dd0c:	2b00      	cmp	r3, #0
    dd0e:	d100      	bne.n	dd12 <__sflush_r+0xa6>
    dd10:	6560      	str	r0, [r4, #84]	; 0x54
    dd12:	6b61      	ldr	r1, [r4, #52]	; 0x34
    dd14:	602e      	str	r6, [r5, #0]
    dd16:	2900      	cmp	r1, #0
    dd18:	d0cf      	beq.n	dcba <__sflush_r+0x4e>
    dd1a:	1c23      	adds	r3, r4, #0
    dd1c:	3344      	adds	r3, #68	; 0x44
    dd1e:	4299      	cmp	r1, r3
    dd20:	d002      	beq.n	dd28 <__sflush_r+0xbc>
    dd22:	1c28      	adds	r0, r5, #0
    dd24:	f7ff fd86 	bl	d834 <_free_r>
    dd28:	2000      	movs	r0, #0
    dd2a:	6360      	str	r0, [r4, #52]	; 0x34
    dd2c:	e026      	b.n	dd7c <__sflush_r+0x110>
    dd2e:	2240      	movs	r2, #64	; 0x40
    dd30:	4313      	orrs	r3, r2
    dd32:	81a3      	strh	r3, [r4, #12]
    dd34:	e022      	b.n	dd7c <__sflush_r+0x110>
    dd36:	690f      	ldr	r7, [r1, #16]
    dd38:	2f00      	cmp	r7, #0
    dd3a:	d0be      	beq.n	dcba <__sflush_r+0x4e>
    dd3c:	680b      	ldr	r3, [r1, #0]
    dd3e:	600f      	str	r7, [r1, #0]
    dd40:	1bdb      	subs	r3, r3, r7
    dd42:	9301      	str	r3, [sp, #4]
    dd44:	2300      	movs	r3, #0
    dd46:	0792      	lsls	r2, r2, #30
    dd48:	d100      	bne.n	dd4c <__sflush_r+0xe0>
    dd4a:	694b      	ldr	r3, [r1, #20]
    dd4c:	60a3      	str	r3, [r4, #8]
    dd4e:	9b01      	ldr	r3, [sp, #4]
    dd50:	2b00      	cmp	r3, #0
    dd52:	ddb2      	ble.n	dcba <__sflush_r+0x4e>
    dd54:	1c28      	adds	r0, r5, #0
    dd56:	6a21      	ldr	r1, [r4, #32]
    dd58:	1c3a      	adds	r2, r7, #0
    dd5a:	9b01      	ldr	r3, [sp, #4]
    dd5c:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    dd5e:	47b0      	blx	r6
    dd60:	2800      	cmp	r0, #0
    dd62:	dc06      	bgt.n	dd72 <__sflush_r+0x106>
    dd64:	2240      	movs	r2, #64	; 0x40
    dd66:	2001      	movs	r0, #1
    dd68:	89a3      	ldrh	r3, [r4, #12]
    dd6a:	4240      	negs	r0, r0
    dd6c:	4313      	orrs	r3, r2
    dd6e:	81a3      	strh	r3, [r4, #12]
    dd70:	e004      	b.n	dd7c <__sflush_r+0x110>
    dd72:	9b01      	ldr	r3, [sp, #4]
    dd74:	183f      	adds	r7, r7, r0
    dd76:	1a1b      	subs	r3, r3, r0
    dd78:	9301      	str	r3, [sp, #4]
    dd7a:	e7e8      	b.n	dd4e <__sflush_r+0xe2>
    dd7c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0000dd80 <_fflush_r>:
    dd80:	b538      	push	{r3, r4, r5, lr}
    dd82:	690b      	ldr	r3, [r1, #16]
    dd84:	1c05      	adds	r5, r0, #0
    dd86:	1c0c      	adds	r4, r1, #0
    dd88:	2b00      	cmp	r3, #0
    dd8a:	d101      	bne.n	dd90 <_fflush_r+0x10>
    dd8c:	2000      	movs	r0, #0
    dd8e:	e01c      	b.n	ddca <_fflush_r+0x4a>
    dd90:	2800      	cmp	r0, #0
    dd92:	d004      	beq.n	dd9e <_fflush_r+0x1e>
    dd94:	6983      	ldr	r3, [r0, #24]
    dd96:	2b00      	cmp	r3, #0
    dd98:	d101      	bne.n	dd9e <_fflush_r+0x1e>
    dd9a:	f000 f85f 	bl	de5c <__sinit>
    dd9e:	4b0b      	ldr	r3, [pc, #44]	; (ddcc <_fflush_r+0x4c>)
    dda0:	429c      	cmp	r4, r3
    dda2:	d101      	bne.n	dda8 <_fflush_r+0x28>
    dda4:	686c      	ldr	r4, [r5, #4]
    dda6:	e008      	b.n	ddba <_fflush_r+0x3a>
    dda8:	4b09      	ldr	r3, [pc, #36]	; (ddd0 <_fflush_r+0x50>)
    ddaa:	429c      	cmp	r4, r3
    ddac:	d101      	bne.n	ddb2 <_fflush_r+0x32>
    ddae:	68ac      	ldr	r4, [r5, #8]
    ddb0:	e003      	b.n	ddba <_fflush_r+0x3a>
    ddb2:	4b08      	ldr	r3, [pc, #32]	; (ddd4 <_fflush_r+0x54>)
    ddb4:	429c      	cmp	r4, r3
    ddb6:	d100      	bne.n	ddba <_fflush_r+0x3a>
    ddb8:	68ec      	ldr	r4, [r5, #12]
    ddba:	220c      	movs	r2, #12
    ddbc:	5ea3      	ldrsh	r3, [r4, r2]
    ddbe:	2b00      	cmp	r3, #0
    ddc0:	d0e4      	beq.n	dd8c <_fflush_r+0xc>
    ddc2:	1c28      	adds	r0, r5, #0
    ddc4:	1c21      	adds	r1, r4, #0
    ddc6:	f7ff ff51 	bl	dc6c <__sflush_r>
    ddca:	bd38      	pop	{r3, r4, r5, pc}
    ddcc:	00011520 	.word	0x00011520
    ddd0:	00011540 	.word	0x00011540
    ddd4:	00011560 	.word	0x00011560

0000ddd8 <_cleanup_r>:
    ddd8:	b508      	push	{r3, lr}
    ddda:	4902      	ldr	r1, [pc, #8]	; (dde4 <_cleanup_r+0xc>)
    dddc:	f000 f8ae 	bl	df3c <_fwalk_reent>
    dde0:	bd08      	pop	{r3, pc}
    dde2:	46c0      	nop			; (mov r8, r8)
    dde4:	0000dd81 	.word	0x0000dd81

0000dde8 <std.isra.0>:
    dde8:	2300      	movs	r3, #0
    ddea:	b510      	push	{r4, lr}
    ddec:	1c04      	adds	r4, r0, #0
    ddee:	6003      	str	r3, [r0, #0]
    ddf0:	6043      	str	r3, [r0, #4]
    ddf2:	6083      	str	r3, [r0, #8]
    ddf4:	8181      	strh	r1, [r0, #12]
    ddf6:	6643      	str	r3, [r0, #100]	; 0x64
    ddf8:	81c2      	strh	r2, [r0, #14]
    ddfa:	6103      	str	r3, [r0, #16]
    ddfc:	6143      	str	r3, [r0, #20]
    ddfe:	6183      	str	r3, [r0, #24]
    de00:	1c19      	adds	r1, r3, #0
    de02:	2208      	movs	r2, #8
    de04:	305c      	adds	r0, #92	; 0x5c
    de06:	f7ff fd0d 	bl	d824 <memset>
    de0a:	4b05      	ldr	r3, [pc, #20]	; (de20 <std.isra.0+0x38>)
    de0c:	6224      	str	r4, [r4, #32]
    de0e:	6263      	str	r3, [r4, #36]	; 0x24
    de10:	4b04      	ldr	r3, [pc, #16]	; (de24 <std.isra.0+0x3c>)
    de12:	62a3      	str	r3, [r4, #40]	; 0x28
    de14:	4b04      	ldr	r3, [pc, #16]	; (de28 <std.isra.0+0x40>)
    de16:	62e3      	str	r3, [r4, #44]	; 0x2c
    de18:	4b04      	ldr	r3, [pc, #16]	; (de2c <std.isra.0+0x44>)
    de1a:	6323      	str	r3, [r4, #48]	; 0x30
    de1c:	bd10      	pop	{r4, pc}
    de1e:	46c0      	nop			; (mov r8, r8)
    de20:	0000e661 	.word	0x0000e661
    de24:	0000e689 	.word	0x0000e689
    de28:	0000e6c1 	.word	0x0000e6c1
    de2c:	0000e6ed 	.word	0x0000e6ed

0000de30 <__sfmoreglue>:
    de30:	b570      	push	{r4, r5, r6, lr}
    de32:	2568      	movs	r5, #104	; 0x68
    de34:	1e4b      	subs	r3, r1, #1
    de36:	435d      	muls	r5, r3
    de38:	1c0e      	adds	r6, r1, #0
    de3a:	1c29      	adds	r1, r5, #0
    de3c:	3174      	adds	r1, #116	; 0x74
    de3e:	f7ff fd3f 	bl	d8c0 <_malloc_r>
    de42:	1e04      	subs	r4, r0, #0
    de44:	d008      	beq.n	de58 <__sfmoreglue+0x28>
    de46:	2100      	movs	r1, #0
    de48:	1c2a      	adds	r2, r5, #0
    de4a:	6001      	str	r1, [r0, #0]
    de4c:	6046      	str	r6, [r0, #4]
    de4e:	300c      	adds	r0, #12
    de50:	60a0      	str	r0, [r4, #8]
    de52:	3268      	adds	r2, #104	; 0x68
    de54:	f7ff fce6 	bl	d824 <memset>
    de58:	1c20      	adds	r0, r4, #0
    de5a:	bd70      	pop	{r4, r5, r6, pc}

0000de5c <__sinit>:
    de5c:	6983      	ldr	r3, [r0, #24]
    de5e:	b513      	push	{r0, r1, r4, lr}
    de60:	2b00      	cmp	r3, #0
    de62:	d128      	bne.n	deb6 <__sinit+0x5a>
    de64:	6483      	str	r3, [r0, #72]	; 0x48
    de66:	64c3      	str	r3, [r0, #76]	; 0x4c
    de68:	6503      	str	r3, [r0, #80]	; 0x50
    de6a:	4b13      	ldr	r3, [pc, #76]	; (deb8 <__sinit+0x5c>)
    de6c:	4a13      	ldr	r2, [pc, #76]	; (debc <__sinit+0x60>)
    de6e:	681b      	ldr	r3, [r3, #0]
    de70:	6282      	str	r2, [r0, #40]	; 0x28
    de72:	9301      	str	r3, [sp, #4]
    de74:	4298      	cmp	r0, r3
    de76:	d101      	bne.n	de7c <__sinit+0x20>
    de78:	2301      	movs	r3, #1
    de7a:	6183      	str	r3, [r0, #24]
    de7c:	1c04      	adds	r4, r0, #0
    de7e:	f000 f81f 	bl	dec0 <__sfp>
    de82:	6060      	str	r0, [r4, #4]
    de84:	1c20      	adds	r0, r4, #0
    de86:	f000 f81b 	bl	dec0 <__sfp>
    de8a:	60a0      	str	r0, [r4, #8]
    de8c:	1c20      	adds	r0, r4, #0
    de8e:	f000 f817 	bl	dec0 <__sfp>
    de92:	2104      	movs	r1, #4
    de94:	60e0      	str	r0, [r4, #12]
    de96:	2200      	movs	r2, #0
    de98:	6860      	ldr	r0, [r4, #4]
    de9a:	f7ff ffa5 	bl	dde8 <std.isra.0>
    de9e:	68a0      	ldr	r0, [r4, #8]
    dea0:	2109      	movs	r1, #9
    dea2:	2201      	movs	r2, #1
    dea4:	f7ff ffa0 	bl	dde8 <std.isra.0>
    dea8:	68e0      	ldr	r0, [r4, #12]
    deaa:	2112      	movs	r1, #18
    deac:	2202      	movs	r2, #2
    deae:	f7ff ff9b 	bl	dde8 <std.isra.0>
    deb2:	2301      	movs	r3, #1
    deb4:	61a3      	str	r3, [r4, #24]
    deb6:	bd13      	pop	{r0, r1, r4, pc}
    deb8:	0001151c 	.word	0x0001151c
    debc:	0000ddd9 	.word	0x0000ddd9

0000dec0 <__sfp>:
    dec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dec2:	4b1d      	ldr	r3, [pc, #116]	; (df38 <__sfp+0x78>)
    dec4:	1c06      	adds	r6, r0, #0
    dec6:	681d      	ldr	r5, [r3, #0]
    dec8:	69ab      	ldr	r3, [r5, #24]
    deca:	2b00      	cmp	r3, #0
    decc:	d102      	bne.n	ded4 <__sfp+0x14>
    dece:	1c28      	adds	r0, r5, #0
    ded0:	f7ff ffc4 	bl	de5c <__sinit>
    ded4:	3548      	adds	r5, #72	; 0x48
    ded6:	68ac      	ldr	r4, [r5, #8]
    ded8:	686b      	ldr	r3, [r5, #4]
    deda:	3b01      	subs	r3, #1
    dedc:	d405      	bmi.n	deea <__sfp+0x2a>
    dede:	220c      	movs	r2, #12
    dee0:	5ea7      	ldrsh	r7, [r4, r2]
    dee2:	2f00      	cmp	r7, #0
    dee4:	d010      	beq.n	df08 <__sfp+0x48>
    dee6:	3468      	adds	r4, #104	; 0x68
    dee8:	e7f7      	b.n	deda <__sfp+0x1a>
    deea:	682b      	ldr	r3, [r5, #0]
    deec:	2b00      	cmp	r3, #0
    deee:	d106      	bne.n	defe <__sfp+0x3e>
    def0:	1c30      	adds	r0, r6, #0
    def2:	2104      	movs	r1, #4
    def4:	f7ff ff9c 	bl	de30 <__sfmoreglue>
    def8:	6028      	str	r0, [r5, #0]
    defa:	2800      	cmp	r0, #0
    defc:	d001      	beq.n	df02 <__sfp+0x42>
    defe:	682d      	ldr	r5, [r5, #0]
    df00:	e7e9      	b.n	ded6 <__sfp+0x16>
    df02:	230c      	movs	r3, #12
    df04:	6033      	str	r3, [r6, #0]
    df06:	e016      	b.n	df36 <__sfp+0x76>
    df08:	2301      	movs	r3, #1
    df0a:	1c20      	adds	r0, r4, #0
    df0c:	425b      	negs	r3, r3
    df0e:	81e3      	strh	r3, [r4, #14]
    df10:	3302      	adds	r3, #2
    df12:	81a3      	strh	r3, [r4, #12]
    df14:	6667      	str	r7, [r4, #100]	; 0x64
    df16:	6027      	str	r7, [r4, #0]
    df18:	60a7      	str	r7, [r4, #8]
    df1a:	6067      	str	r7, [r4, #4]
    df1c:	6127      	str	r7, [r4, #16]
    df1e:	6167      	str	r7, [r4, #20]
    df20:	61a7      	str	r7, [r4, #24]
    df22:	305c      	adds	r0, #92	; 0x5c
    df24:	1c39      	adds	r1, r7, #0
    df26:	2208      	movs	r2, #8
    df28:	f7ff fc7c 	bl	d824 <memset>
    df2c:	1c20      	adds	r0, r4, #0
    df2e:	6367      	str	r7, [r4, #52]	; 0x34
    df30:	63a7      	str	r7, [r4, #56]	; 0x38
    df32:	64a7      	str	r7, [r4, #72]	; 0x48
    df34:	64e7      	str	r7, [r4, #76]	; 0x4c
    df36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    df38:	0001151c 	.word	0x0001151c

0000df3c <_fwalk_reent>:
    df3c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    df3e:	1c04      	adds	r4, r0, #0
    df40:	1c07      	adds	r7, r0, #0
    df42:	2600      	movs	r6, #0
    df44:	9101      	str	r1, [sp, #4]
    df46:	3448      	adds	r4, #72	; 0x48
    df48:	2c00      	cmp	r4, #0
    df4a:	d016      	beq.n	df7a <_fwalk_reent+0x3e>
    df4c:	6863      	ldr	r3, [r4, #4]
    df4e:	68a5      	ldr	r5, [r4, #8]
    df50:	9300      	str	r3, [sp, #0]
    df52:	9b00      	ldr	r3, [sp, #0]
    df54:	3b01      	subs	r3, #1
    df56:	9300      	str	r3, [sp, #0]
    df58:	d40d      	bmi.n	df76 <_fwalk_reent+0x3a>
    df5a:	89ab      	ldrh	r3, [r5, #12]
    df5c:	2b01      	cmp	r3, #1
    df5e:	d908      	bls.n	df72 <_fwalk_reent+0x36>
    df60:	220e      	movs	r2, #14
    df62:	5eab      	ldrsh	r3, [r5, r2]
    df64:	3301      	adds	r3, #1
    df66:	d004      	beq.n	df72 <_fwalk_reent+0x36>
    df68:	1c38      	adds	r0, r7, #0
    df6a:	1c29      	adds	r1, r5, #0
    df6c:	9b01      	ldr	r3, [sp, #4]
    df6e:	4798      	blx	r3
    df70:	4306      	orrs	r6, r0
    df72:	3568      	adds	r5, #104	; 0x68
    df74:	e7ed      	b.n	df52 <_fwalk_reent+0x16>
    df76:	6824      	ldr	r4, [r4, #0]
    df78:	e7e6      	b.n	df48 <_fwalk_reent+0xc>
    df7a:	1c30      	adds	r0, r6, #0
    df7c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0000df80 <__smakebuf_r>:
    df80:	b5f0      	push	{r4, r5, r6, r7, lr}
    df82:	898b      	ldrh	r3, [r1, #12]
    df84:	b091      	sub	sp, #68	; 0x44
    df86:	079b      	lsls	r3, r3, #30
    df88:	d506      	bpl.n	df98 <__smakebuf_r+0x18>
    df8a:	1c0b      	adds	r3, r1, #0
    df8c:	3347      	adds	r3, #71	; 0x47
    df8e:	600b      	str	r3, [r1, #0]
    df90:	610b      	str	r3, [r1, #16]
    df92:	2301      	movs	r3, #1
    df94:	614b      	str	r3, [r1, #20]
    df96:	e045      	b.n	e024 <__smakebuf_r+0xa4>
    df98:	1c0c      	adds	r4, r1, #0
    df9a:	230e      	movs	r3, #14
    df9c:	5ec9      	ldrsh	r1, [r1, r3]
    df9e:	1c06      	adds	r6, r0, #0
    dfa0:	2900      	cmp	r1, #0
    dfa2:	da04      	bge.n	dfae <__smakebuf_r+0x2e>
    dfa4:	2380      	movs	r3, #128	; 0x80
    dfa6:	89a5      	ldrh	r5, [r4, #12]
    dfa8:	401d      	ands	r5, r3
    dfaa:	d110      	bne.n	dfce <__smakebuf_r+0x4e>
    dfac:	e00c      	b.n	dfc8 <__smakebuf_r+0x48>
    dfae:	aa01      	add	r2, sp, #4
    dfb0:	f000 fbc8 	bl	e744 <_fstat_r>
    dfb4:	2800      	cmp	r0, #0
    dfb6:	dbf5      	blt.n	dfa4 <__smakebuf_r+0x24>
    dfb8:	23f0      	movs	r3, #240	; 0xf0
    dfba:	9d02      	ldr	r5, [sp, #8]
    dfbc:	021b      	lsls	r3, r3, #8
    dfbe:	401d      	ands	r5, r3
    dfc0:	4b19      	ldr	r3, [pc, #100]	; (e028 <__smakebuf_r+0xa8>)
    dfc2:	18ed      	adds	r5, r5, r3
    dfc4:	426b      	negs	r3, r5
    dfc6:	415d      	adcs	r5, r3
    dfc8:	2780      	movs	r7, #128	; 0x80
    dfca:	00ff      	lsls	r7, r7, #3
    dfcc:	e001      	b.n	dfd2 <__smakebuf_r+0x52>
    dfce:	2500      	movs	r5, #0
    dfd0:	2740      	movs	r7, #64	; 0x40
    dfd2:	1c30      	adds	r0, r6, #0
    dfd4:	1c39      	adds	r1, r7, #0
    dfd6:	f7ff fc73 	bl	d8c0 <_malloc_r>
    dfda:	2800      	cmp	r0, #0
    dfdc:	d10c      	bne.n	dff8 <__smakebuf_r+0x78>
    dfde:	89a3      	ldrh	r3, [r4, #12]
    dfe0:	059a      	lsls	r2, r3, #22
    dfe2:	d41f      	bmi.n	e024 <__smakebuf_r+0xa4>
    dfe4:	2202      	movs	r2, #2
    dfe6:	4313      	orrs	r3, r2
    dfe8:	81a3      	strh	r3, [r4, #12]
    dfea:	1c23      	adds	r3, r4, #0
    dfec:	3347      	adds	r3, #71	; 0x47
    dfee:	6023      	str	r3, [r4, #0]
    dff0:	6123      	str	r3, [r4, #16]
    dff2:	2301      	movs	r3, #1
    dff4:	6163      	str	r3, [r4, #20]
    dff6:	e015      	b.n	e024 <__smakebuf_r+0xa4>
    dff8:	2280      	movs	r2, #128	; 0x80
    dffa:	4b0c      	ldr	r3, [pc, #48]	; (e02c <__smakebuf_r+0xac>)
    dffc:	62b3      	str	r3, [r6, #40]	; 0x28
    dffe:	89a3      	ldrh	r3, [r4, #12]
    e000:	6020      	str	r0, [r4, #0]
    e002:	4313      	orrs	r3, r2
    e004:	81a3      	strh	r3, [r4, #12]
    e006:	6120      	str	r0, [r4, #16]
    e008:	6167      	str	r7, [r4, #20]
    e00a:	2d00      	cmp	r5, #0
    e00c:	d00a      	beq.n	e024 <__smakebuf_r+0xa4>
    e00e:	230e      	movs	r3, #14
    e010:	5ee1      	ldrsh	r1, [r4, r3]
    e012:	1c30      	adds	r0, r6, #0
    e014:	f000 fba8 	bl	e768 <_isatty_r>
    e018:	2800      	cmp	r0, #0
    e01a:	d003      	beq.n	e024 <__smakebuf_r+0xa4>
    e01c:	2201      	movs	r2, #1
    e01e:	89a3      	ldrh	r3, [r4, #12]
    e020:	4313      	orrs	r3, r2
    e022:	81a3      	strh	r3, [r4, #12]
    e024:	b011      	add	sp, #68	; 0x44
    e026:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e028:	ffffe000 	.word	0xffffe000
    e02c:	0000ddd9 	.word	0x0000ddd9

0000e030 <__ssputs_r>:
    e030:	b5f0      	push	{r4, r5, r6, r7, lr}
    e032:	688e      	ldr	r6, [r1, #8]
    e034:	b085      	sub	sp, #20
    e036:	1c07      	adds	r7, r0, #0
    e038:	1c0c      	adds	r4, r1, #0
    e03a:	9203      	str	r2, [sp, #12]
    e03c:	9301      	str	r3, [sp, #4]
    e03e:	42b3      	cmp	r3, r6
    e040:	d345      	bcc.n	e0ce <__ssputs_r+0x9e>
    e042:	2390      	movs	r3, #144	; 0x90
    e044:	898a      	ldrh	r2, [r1, #12]
    e046:	00db      	lsls	r3, r3, #3
    e048:	421a      	tst	r2, r3
    e04a:	d03d      	beq.n	e0c8 <__ssputs_r+0x98>
    e04c:	2503      	movs	r5, #3
    e04e:	6909      	ldr	r1, [r1, #16]
    e050:	6823      	ldr	r3, [r4, #0]
    e052:	9801      	ldr	r0, [sp, #4]
    e054:	1a5b      	subs	r3, r3, r1
    e056:	9302      	str	r3, [sp, #8]
    e058:	6963      	ldr	r3, [r4, #20]
    e05a:	435d      	muls	r5, r3
    e05c:	0feb      	lsrs	r3, r5, #31
    e05e:	195d      	adds	r5, r3, r5
    e060:	9b02      	ldr	r3, [sp, #8]
    e062:	106d      	asrs	r5, r5, #1
    e064:	3301      	adds	r3, #1
    e066:	181b      	adds	r3, r3, r0
    e068:	429d      	cmp	r5, r3
    e06a:	d200      	bcs.n	e06e <__ssputs_r+0x3e>
    e06c:	1c1d      	adds	r5, r3, #0
    e06e:	1c38      	adds	r0, r7, #0
    e070:	0553      	lsls	r3, r2, #21
    e072:	d50f      	bpl.n	e094 <__ssputs_r+0x64>
    e074:	1c29      	adds	r1, r5, #0
    e076:	f7ff fc23 	bl	d8c0 <_malloc_r>
    e07a:	1e06      	subs	r6, r0, #0
    e07c:	d013      	beq.n	e0a6 <__ssputs_r+0x76>
    e07e:	9a02      	ldr	r2, [sp, #8]
    e080:	6921      	ldr	r1, [r4, #16]
    e082:	f7ff fbb2 	bl	d7ea <memcpy>
    e086:	89a2      	ldrh	r2, [r4, #12]
    e088:	4b18      	ldr	r3, [pc, #96]	; (e0ec <__ssputs_r+0xbc>)
    e08a:	4013      	ands	r3, r2
    e08c:	2280      	movs	r2, #128	; 0x80
    e08e:	4313      	orrs	r3, r2
    e090:	81a3      	strh	r3, [r4, #12]
    e092:	e011      	b.n	e0b8 <__ssputs_r+0x88>
    e094:	1c2a      	adds	r2, r5, #0
    e096:	f000 fb98 	bl	e7ca <_realloc_r>
    e09a:	1e06      	subs	r6, r0, #0
    e09c:	d10c      	bne.n	e0b8 <__ssputs_r+0x88>
    e09e:	1c38      	adds	r0, r7, #0
    e0a0:	6921      	ldr	r1, [r4, #16]
    e0a2:	f7ff fbc7 	bl	d834 <_free_r>
    e0a6:	230c      	movs	r3, #12
    e0a8:	2240      	movs	r2, #64	; 0x40
    e0aa:	2001      	movs	r0, #1
    e0ac:	603b      	str	r3, [r7, #0]
    e0ae:	89a3      	ldrh	r3, [r4, #12]
    e0b0:	4240      	negs	r0, r0
    e0b2:	4313      	orrs	r3, r2
    e0b4:	81a3      	strh	r3, [r4, #12]
    e0b6:	e017      	b.n	e0e8 <__ssputs_r+0xb8>
    e0b8:	9b02      	ldr	r3, [sp, #8]
    e0ba:	6126      	str	r6, [r4, #16]
    e0bc:	18f6      	adds	r6, r6, r3
    e0be:	6026      	str	r6, [r4, #0]
    e0c0:	6165      	str	r5, [r4, #20]
    e0c2:	9e01      	ldr	r6, [sp, #4]
    e0c4:	1aed      	subs	r5, r5, r3
    e0c6:	60a5      	str	r5, [r4, #8]
    e0c8:	9b01      	ldr	r3, [sp, #4]
    e0ca:	42b3      	cmp	r3, r6
    e0cc:	d200      	bcs.n	e0d0 <__ssputs_r+0xa0>
    e0ce:	9e01      	ldr	r6, [sp, #4]
    e0d0:	1c32      	adds	r2, r6, #0
    e0d2:	6820      	ldr	r0, [r4, #0]
    e0d4:	9903      	ldr	r1, [sp, #12]
    e0d6:	f7ff fb91 	bl	d7fc <memmove>
    e0da:	2000      	movs	r0, #0
    e0dc:	68a3      	ldr	r3, [r4, #8]
    e0de:	1b9b      	subs	r3, r3, r6
    e0e0:	60a3      	str	r3, [r4, #8]
    e0e2:	6823      	ldr	r3, [r4, #0]
    e0e4:	199e      	adds	r6, r3, r6
    e0e6:	6026      	str	r6, [r4, #0]
    e0e8:	b005      	add	sp, #20
    e0ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e0ec:	fffffb7f 	.word	0xfffffb7f

0000e0f0 <_svfiprintf_r>:
    e0f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    e0f2:	b09f      	sub	sp, #124	; 0x7c
    e0f4:	9002      	str	r0, [sp, #8]
    e0f6:	9305      	str	r3, [sp, #20]
    e0f8:	898b      	ldrh	r3, [r1, #12]
    e0fa:	1c0e      	adds	r6, r1, #0
    e0fc:	1c17      	adds	r7, r2, #0
    e0fe:	061b      	lsls	r3, r3, #24
    e100:	d510      	bpl.n	e124 <_svfiprintf_r+0x34>
    e102:	690b      	ldr	r3, [r1, #16]
    e104:	2b00      	cmp	r3, #0
    e106:	d10d      	bne.n	e124 <_svfiprintf_r+0x34>
    e108:	2140      	movs	r1, #64	; 0x40
    e10a:	f7ff fbd9 	bl	d8c0 <_malloc_r>
    e10e:	6030      	str	r0, [r6, #0]
    e110:	6130      	str	r0, [r6, #16]
    e112:	2800      	cmp	r0, #0
    e114:	d104      	bne.n	e120 <_svfiprintf_r+0x30>
    e116:	230c      	movs	r3, #12
    e118:	9a02      	ldr	r2, [sp, #8]
    e11a:	3801      	subs	r0, #1
    e11c:	6013      	str	r3, [r2, #0]
    e11e:	e0d0      	b.n	e2c2 <_svfiprintf_r+0x1d2>
    e120:	2340      	movs	r3, #64	; 0x40
    e122:	6173      	str	r3, [r6, #20]
    e124:	2300      	movs	r3, #0
    e126:	ad06      	add	r5, sp, #24
    e128:	616b      	str	r3, [r5, #20]
    e12a:	3320      	adds	r3, #32
    e12c:	766b      	strb	r3, [r5, #25]
    e12e:	3310      	adds	r3, #16
    e130:	76ab      	strb	r3, [r5, #26]
    e132:	1c3c      	adds	r4, r7, #0
    e134:	7823      	ldrb	r3, [r4, #0]
    e136:	2b00      	cmp	r3, #0
    e138:	d103      	bne.n	e142 <_svfiprintf_r+0x52>
    e13a:	1be3      	subs	r3, r4, r7
    e13c:	9304      	str	r3, [sp, #16]
    e13e:	d012      	beq.n	e166 <_svfiprintf_r+0x76>
    e140:	e003      	b.n	e14a <_svfiprintf_r+0x5a>
    e142:	2b25      	cmp	r3, #37	; 0x25
    e144:	d0f9      	beq.n	e13a <_svfiprintf_r+0x4a>
    e146:	3401      	adds	r4, #1
    e148:	e7f4      	b.n	e134 <_svfiprintf_r+0x44>
    e14a:	9b04      	ldr	r3, [sp, #16]
    e14c:	9802      	ldr	r0, [sp, #8]
    e14e:	1c31      	adds	r1, r6, #0
    e150:	1c3a      	adds	r2, r7, #0
    e152:	f7ff ff6d 	bl	e030 <__ssputs_r>
    e156:	1c43      	adds	r3, r0, #1
    e158:	d100      	bne.n	e15c <_svfiprintf_r+0x6c>
    e15a:	e0ac      	b.n	e2b6 <_svfiprintf_r+0x1c6>
    e15c:	696a      	ldr	r2, [r5, #20]
    e15e:	9b04      	ldr	r3, [sp, #16]
    e160:	4694      	mov	ip, r2
    e162:	4463      	add	r3, ip
    e164:	616b      	str	r3, [r5, #20]
    e166:	7823      	ldrb	r3, [r4, #0]
    e168:	2b00      	cmp	r3, #0
    e16a:	d100      	bne.n	e16e <_svfiprintf_r+0x7e>
    e16c:	e0a3      	b.n	e2b6 <_svfiprintf_r+0x1c6>
    e16e:	2201      	movs	r2, #1
    e170:	2300      	movs	r3, #0
    e172:	4252      	negs	r2, r2
    e174:	606a      	str	r2, [r5, #4]
    e176:	a902      	add	r1, sp, #8
    e178:	3254      	adds	r2, #84	; 0x54
    e17a:	1852      	adds	r2, r2, r1
    e17c:	3401      	adds	r4, #1
    e17e:	602b      	str	r3, [r5, #0]
    e180:	60eb      	str	r3, [r5, #12]
    e182:	60ab      	str	r3, [r5, #8]
    e184:	7013      	strb	r3, [r2, #0]
    e186:	65ab      	str	r3, [r5, #88]	; 0x58
    e188:	4f4f      	ldr	r7, [pc, #316]	; (e2c8 <_svfiprintf_r+0x1d8>)
    e18a:	7821      	ldrb	r1, [r4, #0]
    e18c:	1c38      	adds	r0, r7, #0
    e18e:	2205      	movs	r2, #5
    e190:	f000 fb10 	bl	e7b4 <memchr>
    e194:	2800      	cmp	r0, #0
    e196:	d008      	beq.n	e1aa <_svfiprintf_r+0xba>
    e198:	1bc0      	subs	r0, r0, r7
    e19a:	2701      	movs	r7, #1
    e19c:	4087      	lsls	r7, r0
    e19e:	1c38      	adds	r0, r7, #0
    e1a0:	682b      	ldr	r3, [r5, #0]
    e1a2:	3401      	adds	r4, #1
    e1a4:	4318      	orrs	r0, r3
    e1a6:	6028      	str	r0, [r5, #0]
    e1a8:	e7ee      	b.n	e188 <_svfiprintf_r+0x98>
    e1aa:	682b      	ldr	r3, [r5, #0]
    e1ac:	06da      	lsls	r2, r3, #27
    e1ae:	d504      	bpl.n	e1ba <_svfiprintf_r+0xca>
    e1b0:	2253      	movs	r2, #83	; 0x53
    e1b2:	2120      	movs	r1, #32
    e1b4:	a802      	add	r0, sp, #8
    e1b6:	1812      	adds	r2, r2, r0
    e1b8:	7011      	strb	r1, [r2, #0]
    e1ba:	071a      	lsls	r2, r3, #28
    e1bc:	d504      	bpl.n	e1c8 <_svfiprintf_r+0xd8>
    e1be:	2253      	movs	r2, #83	; 0x53
    e1c0:	212b      	movs	r1, #43	; 0x2b
    e1c2:	a802      	add	r0, sp, #8
    e1c4:	1812      	adds	r2, r2, r0
    e1c6:	7011      	strb	r1, [r2, #0]
    e1c8:	7822      	ldrb	r2, [r4, #0]
    e1ca:	2a2a      	cmp	r2, #42	; 0x2a
    e1cc:	d001      	beq.n	e1d2 <_svfiprintf_r+0xe2>
    e1ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e1d0:	e00e      	b.n	e1f0 <_svfiprintf_r+0x100>
    e1d2:	9a05      	ldr	r2, [sp, #20]
    e1d4:	1d11      	adds	r1, r2, #4
    e1d6:	6812      	ldr	r2, [r2, #0]
    e1d8:	9105      	str	r1, [sp, #20]
    e1da:	2a00      	cmp	r2, #0
    e1dc:	db01      	blt.n	e1e2 <_svfiprintf_r+0xf2>
    e1de:	9209      	str	r2, [sp, #36]	; 0x24
    e1e0:	e004      	b.n	e1ec <_svfiprintf_r+0xfc>
    e1e2:	4252      	negs	r2, r2
    e1e4:	60ea      	str	r2, [r5, #12]
    e1e6:	2202      	movs	r2, #2
    e1e8:	4313      	orrs	r3, r2
    e1ea:	602b      	str	r3, [r5, #0]
    e1ec:	3401      	adds	r4, #1
    e1ee:	e009      	b.n	e204 <_svfiprintf_r+0x114>
    e1f0:	7822      	ldrb	r2, [r4, #0]
    e1f2:	3a30      	subs	r2, #48	; 0x30
    e1f4:	2a09      	cmp	r2, #9
    e1f6:	d804      	bhi.n	e202 <_svfiprintf_r+0x112>
    e1f8:	210a      	movs	r1, #10
    e1fa:	434b      	muls	r3, r1
    e1fc:	3401      	adds	r4, #1
    e1fe:	189b      	adds	r3, r3, r2
    e200:	e7f6      	b.n	e1f0 <_svfiprintf_r+0x100>
    e202:	9309      	str	r3, [sp, #36]	; 0x24
    e204:	7823      	ldrb	r3, [r4, #0]
    e206:	2b2e      	cmp	r3, #46	; 0x2e
    e208:	d118      	bne.n	e23c <_svfiprintf_r+0x14c>
    e20a:	7863      	ldrb	r3, [r4, #1]
    e20c:	2b2a      	cmp	r3, #42	; 0x2a
    e20e:	d109      	bne.n	e224 <_svfiprintf_r+0x134>
    e210:	9b05      	ldr	r3, [sp, #20]
    e212:	3402      	adds	r4, #2
    e214:	1d1a      	adds	r2, r3, #4
    e216:	681b      	ldr	r3, [r3, #0]
    e218:	9205      	str	r2, [sp, #20]
    e21a:	2b00      	cmp	r3, #0
    e21c:	da0d      	bge.n	e23a <_svfiprintf_r+0x14a>
    e21e:	2301      	movs	r3, #1
    e220:	425b      	negs	r3, r3
    e222:	e00a      	b.n	e23a <_svfiprintf_r+0x14a>
    e224:	2300      	movs	r3, #0
    e226:	3401      	adds	r4, #1
    e228:	7822      	ldrb	r2, [r4, #0]
    e22a:	3a30      	subs	r2, #48	; 0x30
    e22c:	2a09      	cmp	r2, #9
    e22e:	d804      	bhi.n	e23a <_svfiprintf_r+0x14a>
    e230:	210a      	movs	r1, #10
    e232:	434b      	muls	r3, r1
    e234:	3401      	adds	r4, #1
    e236:	189b      	adds	r3, r3, r2
    e238:	e7f6      	b.n	e228 <_svfiprintf_r+0x138>
    e23a:	9307      	str	r3, [sp, #28]
    e23c:	4f23      	ldr	r7, [pc, #140]	; (e2cc <_svfiprintf_r+0x1dc>)
    e23e:	7821      	ldrb	r1, [r4, #0]
    e240:	1c38      	adds	r0, r7, #0
    e242:	2203      	movs	r2, #3
    e244:	f000 fab6 	bl	e7b4 <memchr>
    e248:	2800      	cmp	r0, #0
    e24a:	d007      	beq.n	e25c <_svfiprintf_r+0x16c>
    e24c:	1bc0      	subs	r0, r0, r7
    e24e:	2740      	movs	r7, #64	; 0x40
    e250:	4087      	lsls	r7, r0
    e252:	1c38      	adds	r0, r7, #0
    e254:	682b      	ldr	r3, [r5, #0]
    e256:	3401      	adds	r4, #1
    e258:	4318      	orrs	r0, r3
    e25a:	6028      	str	r0, [r5, #0]
    e25c:	7821      	ldrb	r1, [r4, #0]
    e25e:	481c      	ldr	r0, [pc, #112]	; (e2d0 <_svfiprintf_r+0x1e0>)
    e260:	2206      	movs	r2, #6
    e262:	1c67      	adds	r7, r4, #1
    e264:	7629      	strb	r1, [r5, #24]
    e266:	f000 faa5 	bl	e7b4 <memchr>
    e26a:	2800      	cmp	r0, #0
    e26c:	d012      	beq.n	e294 <_svfiprintf_r+0x1a4>
    e26e:	4b19      	ldr	r3, [pc, #100]	; (e2d4 <_svfiprintf_r+0x1e4>)
    e270:	2b00      	cmp	r3, #0
    e272:	d106      	bne.n	e282 <_svfiprintf_r+0x192>
    e274:	2207      	movs	r2, #7
    e276:	9b05      	ldr	r3, [sp, #20]
    e278:	3307      	adds	r3, #7
    e27a:	4393      	bics	r3, r2
    e27c:	3308      	adds	r3, #8
    e27e:	9305      	str	r3, [sp, #20]
    e280:	e014      	b.n	e2ac <_svfiprintf_r+0x1bc>
    e282:	ab05      	add	r3, sp, #20
    e284:	9300      	str	r3, [sp, #0]
    e286:	9802      	ldr	r0, [sp, #8]
    e288:	1c29      	adds	r1, r5, #0
    e28a:	1c32      	adds	r2, r6, #0
    e28c:	4b12      	ldr	r3, [pc, #72]	; (e2d8 <_svfiprintf_r+0x1e8>)
    e28e:	e000      	b.n	e292 <_svfiprintf_r+0x1a2>
    e290:	bf00      	nop
    e292:	e007      	b.n	e2a4 <_svfiprintf_r+0x1b4>
    e294:	ab05      	add	r3, sp, #20
    e296:	9300      	str	r3, [sp, #0]
    e298:	9802      	ldr	r0, [sp, #8]
    e29a:	1c29      	adds	r1, r5, #0
    e29c:	1c32      	adds	r2, r6, #0
    e29e:	4b0e      	ldr	r3, [pc, #56]	; (e2d8 <_svfiprintf_r+0x1e8>)
    e2a0:	f000 f88a 	bl	e3b8 <_printf_i>
    e2a4:	9003      	str	r0, [sp, #12]
    e2a6:	9b03      	ldr	r3, [sp, #12]
    e2a8:	3301      	adds	r3, #1
    e2aa:	d004      	beq.n	e2b6 <_svfiprintf_r+0x1c6>
    e2ac:	696b      	ldr	r3, [r5, #20]
    e2ae:	9a03      	ldr	r2, [sp, #12]
    e2b0:	189b      	adds	r3, r3, r2
    e2b2:	616b      	str	r3, [r5, #20]
    e2b4:	e73d      	b.n	e132 <_svfiprintf_r+0x42>
    e2b6:	89b3      	ldrh	r3, [r6, #12]
    e2b8:	980b      	ldr	r0, [sp, #44]	; 0x2c
    e2ba:	065b      	lsls	r3, r3, #25
    e2bc:	d501      	bpl.n	e2c2 <_svfiprintf_r+0x1d2>
    e2be:	2001      	movs	r0, #1
    e2c0:	4240      	negs	r0, r0
    e2c2:	b01f      	add	sp, #124	; 0x7c
    e2c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e2c6:	46c0      	nop			; (mov r8, r8)
    e2c8:	00011580 	.word	0x00011580
    e2cc:	00011586 	.word	0x00011586
    e2d0:	0001158a 	.word	0x0001158a
    e2d4:	00000000 	.word	0x00000000
    e2d8:	0000e031 	.word	0x0000e031

0000e2dc <_printf_common>:
    e2dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    e2de:	1c17      	adds	r7, r2, #0
    e2e0:	9301      	str	r3, [sp, #4]
    e2e2:	690a      	ldr	r2, [r1, #16]
    e2e4:	688b      	ldr	r3, [r1, #8]
    e2e6:	9000      	str	r0, [sp, #0]
    e2e8:	1c0c      	adds	r4, r1, #0
    e2ea:	4293      	cmp	r3, r2
    e2ec:	da00      	bge.n	e2f0 <_printf_common+0x14>
    e2ee:	1c13      	adds	r3, r2, #0
    e2f0:	1c22      	adds	r2, r4, #0
    e2f2:	603b      	str	r3, [r7, #0]
    e2f4:	3243      	adds	r2, #67	; 0x43
    e2f6:	7812      	ldrb	r2, [r2, #0]
    e2f8:	2a00      	cmp	r2, #0
    e2fa:	d001      	beq.n	e300 <_printf_common+0x24>
    e2fc:	3301      	adds	r3, #1
    e2fe:	603b      	str	r3, [r7, #0]
    e300:	6823      	ldr	r3, [r4, #0]
    e302:	069b      	lsls	r3, r3, #26
    e304:	d502      	bpl.n	e30c <_printf_common+0x30>
    e306:	683b      	ldr	r3, [r7, #0]
    e308:	3302      	adds	r3, #2
    e30a:	603b      	str	r3, [r7, #0]
    e30c:	2506      	movs	r5, #6
    e30e:	6823      	ldr	r3, [r4, #0]
    e310:	401d      	ands	r5, r3
    e312:	d01e      	beq.n	e352 <_printf_common+0x76>
    e314:	1c23      	adds	r3, r4, #0
    e316:	3343      	adds	r3, #67	; 0x43
    e318:	781b      	ldrb	r3, [r3, #0]
    e31a:	1e5a      	subs	r2, r3, #1
    e31c:	4193      	sbcs	r3, r2
    e31e:	6822      	ldr	r2, [r4, #0]
    e320:	0692      	lsls	r2, r2, #26
    e322:	d51c      	bpl.n	e35e <_printf_common+0x82>
    e324:	2030      	movs	r0, #48	; 0x30
    e326:	18e1      	adds	r1, r4, r3
    e328:	3140      	adds	r1, #64	; 0x40
    e32a:	70c8      	strb	r0, [r1, #3]
    e32c:	1c21      	adds	r1, r4, #0
    e32e:	1c5a      	adds	r2, r3, #1
    e330:	3145      	adds	r1, #69	; 0x45
    e332:	7809      	ldrb	r1, [r1, #0]
    e334:	18a2      	adds	r2, r4, r2
    e336:	3240      	adds	r2, #64	; 0x40
    e338:	3302      	adds	r3, #2
    e33a:	70d1      	strb	r1, [r2, #3]
    e33c:	e00f      	b.n	e35e <_printf_common+0x82>
    e33e:	1c22      	adds	r2, r4, #0
    e340:	2301      	movs	r3, #1
    e342:	9800      	ldr	r0, [sp, #0]
    e344:	9901      	ldr	r1, [sp, #4]
    e346:	3219      	adds	r2, #25
    e348:	9e08      	ldr	r6, [sp, #32]
    e34a:	47b0      	blx	r6
    e34c:	1c43      	adds	r3, r0, #1
    e34e:	d00e      	beq.n	e36e <_printf_common+0x92>
    e350:	3501      	adds	r5, #1
    e352:	68e3      	ldr	r3, [r4, #12]
    e354:	683a      	ldr	r2, [r7, #0]
    e356:	1a9b      	subs	r3, r3, r2
    e358:	429d      	cmp	r5, r3
    e35a:	dbf0      	blt.n	e33e <_printf_common+0x62>
    e35c:	e7da      	b.n	e314 <_printf_common+0x38>
    e35e:	1c22      	adds	r2, r4, #0
    e360:	9800      	ldr	r0, [sp, #0]
    e362:	9901      	ldr	r1, [sp, #4]
    e364:	3243      	adds	r2, #67	; 0x43
    e366:	9d08      	ldr	r5, [sp, #32]
    e368:	47a8      	blx	r5
    e36a:	1c43      	adds	r3, r0, #1
    e36c:	d102      	bne.n	e374 <_printf_common+0x98>
    e36e:	2001      	movs	r0, #1
    e370:	4240      	negs	r0, r0
    e372:	e020      	b.n	e3b6 <_printf_common+0xda>
    e374:	2306      	movs	r3, #6
    e376:	6820      	ldr	r0, [r4, #0]
    e378:	68e1      	ldr	r1, [r4, #12]
    e37a:	683a      	ldr	r2, [r7, #0]
    e37c:	4003      	ands	r3, r0
    e37e:	2500      	movs	r5, #0
    e380:	2b04      	cmp	r3, #4
    e382:	d103      	bne.n	e38c <_printf_common+0xb0>
    e384:	1a8d      	subs	r5, r1, r2
    e386:	43eb      	mvns	r3, r5
    e388:	17db      	asrs	r3, r3, #31
    e38a:	401d      	ands	r5, r3
    e38c:	68a3      	ldr	r3, [r4, #8]
    e38e:	6922      	ldr	r2, [r4, #16]
    e390:	4293      	cmp	r3, r2
    e392:	dd01      	ble.n	e398 <_printf_common+0xbc>
    e394:	1a9b      	subs	r3, r3, r2
    e396:	18ed      	adds	r5, r5, r3
    e398:	2700      	movs	r7, #0
    e39a:	42af      	cmp	r7, r5
    e39c:	da0a      	bge.n	e3b4 <_printf_common+0xd8>
    e39e:	1c22      	adds	r2, r4, #0
    e3a0:	2301      	movs	r3, #1
    e3a2:	9800      	ldr	r0, [sp, #0]
    e3a4:	9901      	ldr	r1, [sp, #4]
    e3a6:	321a      	adds	r2, #26
    e3a8:	9e08      	ldr	r6, [sp, #32]
    e3aa:	47b0      	blx	r6
    e3ac:	1c43      	adds	r3, r0, #1
    e3ae:	d0de      	beq.n	e36e <_printf_common+0x92>
    e3b0:	3701      	adds	r7, #1
    e3b2:	e7f2      	b.n	e39a <_printf_common+0xbe>
    e3b4:	2000      	movs	r0, #0
    e3b6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0000e3b8 <_printf_i>:
    e3b8:	b5f0      	push	{r4, r5, r6, r7, lr}
    e3ba:	b08b      	sub	sp, #44	; 0x2c
    e3bc:	9206      	str	r2, [sp, #24]
    e3be:	1c0a      	adds	r2, r1, #0
    e3c0:	3243      	adds	r2, #67	; 0x43
    e3c2:	9307      	str	r3, [sp, #28]
    e3c4:	9005      	str	r0, [sp, #20]
    e3c6:	9204      	str	r2, [sp, #16]
    e3c8:	7e0a      	ldrb	r2, [r1, #24]
    e3ca:	1c0c      	adds	r4, r1, #0
    e3cc:	9b10      	ldr	r3, [sp, #64]	; 0x40
    e3ce:	2a6e      	cmp	r2, #110	; 0x6e
    e3d0:	d100      	bne.n	e3d4 <_printf_i+0x1c>
    e3d2:	e0a8      	b.n	e526 <_printf_i+0x16e>
    e3d4:	d811      	bhi.n	e3fa <_printf_i+0x42>
    e3d6:	2a63      	cmp	r2, #99	; 0x63
    e3d8:	d022      	beq.n	e420 <_printf_i+0x68>
    e3da:	d809      	bhi.n	e3f0 <_printf_i+0x38>
    e3dc:	2a00      	cmp	r2, #0
    e3de:	d100      	bne.n	e3e2 <_printf_i+0x2a>
    e3e0:	e0b2      	b.n	e548 <_printf_i+0x190>
    e3e2:	2a58      	cmp	r2, #88	; 0x58
    e3e4:	d000      	beq.n	e3e8 <_printf_i+0x30>
    e3e6:	e0c2      	b.n	e56e <_printf_i+0x1b6>
    e3e8:	3145      	adds	r1, #69	; 0x45
    e3ea:	700a      	strb	r2, [r1, #0]
    e3ec:	4a7c      	ldr	r2, [pc, #496]	; (e5e0 <_printf_i+0x228>)
    e3ee:	e04f      	b.n	e490 <_printf_i+0xd8>
    e3f0:	2a64      	cmp	r2, #100	; 0x64
    e3f2:	d01d      	beq.n	e430 <_printf_i+0x78>
    e3f4:	2a69      	cmp	r2, #105	; 0x69
    e3f6:	d01b      	beq.n	e430 <_printf_i+0x78>
    e3f8:	e0b9      	b.n	e56e <_printf_i+0x1b6>
    e3fa:	2a73      	cmp	r2, #115	; 0x73
    e3fc:	d100      	bne.n	e400 <_printf_i+0x48>
    e3fe:	e0a7      	b.n	e550 <_printf_i+0x198>
    e400:	d809      	bhi.n	e416 <_printf_i+0x5e>
    e402:	2a6f      	cmp	r2, #111	; 0x6f
    e404:	d029      	beq.n	e45a <_printf_i+0xa2>
    e406:	2a70      	cmp	r2, #112	; 0x70
    e408:	d000      	beq.n	e40c <_printf_i+0x54>
    e40a:	e0b0      	b.n	e56e <_printf_i+0x1b6>
    e40c:	2220      	movs	r2, #32
    e40e:	6809      	ldr	r1, [r1, #0]
    e410:	430a      	orrs	r2, r1
    e412:	6022      	str	r2, [r4, #0]
    e414:	e037      	b.n	e486 <_printf_i+0xce>
    e416:	2a75      	cmp	r2, #117	; 0x75
    e418:	d01f      	beq.n	e45a <_printf_i+0xa2>
    e41a:	2a78      	cmp	r2, #120	; 0x78
    e41c:	d033      	beq.n	e486 <_printf_i+0xce>
    e41e:	e0a6      	b.n	e56e <_printf_i+0x1b6>
    e420:	1c0e      	adds	r6, r1, #0
    e422:	681a      	ldr	r2, [r3, #0]
    e424:	3642      	adds	r6, #66	; 0x42
    e426:	1d11      	adds	r1, r2, #4
    e428:	6019      	str	r1, [r3, #0]
    e42a:	6813      	ldr	r3, [r2, #0]
    e42c:	7033      	strb	r3, [r6, #0]
    e42e:	e0a1      	b.n	e574 <_printf_i+0x1bc>
    e430:	6821      	ldr	r1, [r4, #0]
    e432:	681a      	ldr	r2, [r3, #0]
    e434:	0608      	lsls	r0, r1, #24
    e436:	d406      	bmi.n	e446 <_printf_i+0x8e>
    e438:	0649      	lsls	r1, r1, #25
    e43a:	d504      	bpl.n	e446 <_printf_i+0x8e>
    e43c:	1d11      	adds	r1, r2, #4
    e43e:	6019      	str	r1, [r3, #0]
    e440:	2300      	movs	r3, #0
    e442:	5ed5      	ldrsh	r5, [r2, r3]
    e444:	e002      	b.n	e44c <_printf_i+0x94>
    e446:	1d11      	adds	r1, r2, #4
    e448:	6019      	str	r1, [r3, #0]
    e44a:	6815      	ldr	r5, [r2, #0]
    e44c:	2d00      	cmp	r5, #0
    e44e:	da3b      	bge.n	e4c8 <_printf_i+0x110>
    e450:	232d      	movs	r3, #45	; 0x2d
    e452:	9a04      	ldr	r2, [sp, #16]
    e454:	426d      	negs	r5, r5
    e456:	7013      	strb	r3, [r2, #0]
    e458:	e036      	b.n	e4c8 <_printf_i+0x110>
    e45a:	6821      	ldr	r1, [r4, #0]
    e45c:	681a      	ldr	r2, [r3, #0]
    e45e:	0608      	lsls	r0, r1, #24
    e460:	d406      	bmi.n	e470 <_printf_i+0xb8>
    e462:	0649      	lsls	r1, r1, #25
    e464:	d504      	bpl.n	e470 <_printf_i+0xb8>
    e466:	6815      	ldr	r5, [r2, #0]
    e468:	1d11      	adds	r1, r2, #4
    e46a:	6019      	str	r1, [r3, #0]
    e46c:	b2ad      	uxth	r5, r5
    e46e:	e002      	b.n	e476 <_printf_i+0xbe>
    e470:	1d11      	adds	r1, r2, #4
    e472:	6019      	str	r1, [r3, #0]
    e474:	6815      	ldr	r5, [r2, #0]
    e476:	4b5a      	ldr	r3, [pc, #360]	; (e5e0 <_printf_i+0x228>)
    e478:	7e22      	ldrb	r2, [r4, #24]
    e47a:	9303      	str	r3, [sp, #12]
    e47c:	270a      	movs	r7, #10
    e47e:	2a6f      	cmp	r2, #111	; 0x6f
    e480:	d11d      	bne.n	e4be <_printf_i+0x106>
    e482:	2708      	movs	r7, #8
    e484:	e01b      	b.n	e4be <_printf_i+0x106>
    e486:	1c22      	adds	r2, r4, #0
    e488:	2178      	movs	r1, #120	; 0x78
    e48a:	3245      	adds	r2, #69	; 0x45
    e48c:	7011      	strb	r1, [r2, #0]
    e48e:	4a55      	ldr	r2, [pc, #340]	; (e5e4 <_printf_i+0x22c>)
    e490:	6819      	ldr	r1, [r3, #0]
    e492:	9203      	str	r2, [sp, #12]
    e494:	1d08      	adds	r0, r1, #4
    e496:	6822      	ldr	r2, [r4, #0]
    e498:	6018      	str	r0, [r3, #0]
    e49a:	680d      	ldr	r5, [r1, #0]
    e49c:	0610      	lsls	r0, r2, #24
    e49e:	d402      	bmi.n	e4a6 <_printf_i+0xee>
    e4a0:	0650      	lsls	r0, r2, #25
    e4a2:	d500      	bpl.n	e4a6 <_printf_i+0xee>
    e4a4:	b2ad      	uxth	r5, r5
    e4a6:	07d3      	lsls	r3, r2, #31
    e4a8:	d502      	bpl.n	e4b0 <_printf_i+0xf8>
    e4aa:	2320      	movs	r3, #32
    e4ac:	431a      	orrs	r2, r3
    e4ae:	6022      	str	r2, [r4, #0]
    e4b0:	2710      	movs	r7, #16
    e4b2:	2d00      	cmp	r5, #0
    e4b4:	d103      	bne.n	e4be <_printf_i+0x106>
    e4b6:	2320      	movs	r3, #32
    e4b8:	6822      	ldr	r2, [r4, #0]
    e4ba:	439a      	bics	r2, r3
    e4bc:	6022      	str	r2, [r4, #0]
    e4be:	1c23      	adds	r3, r4, #0
    e4c0:	2200      	movs	r2, #0
    e4c2:	3343      	adds	r3, #67	; 0x43
    e4c4:	701a      	strb	r2, [r3, #0]
    e4c6:	e002      	b.n	e4ce <_printf_i+0x116>
    e4c8:	270a      	movs	r7, #10
    e4ca:	4b45      	ldr	r3, [pc, #276]	; (e5e0 <_printf_i+0x228>)
    e4cc:	9303      	str	r3, [sp, #12]
    e4ce:	6863      	ldr	r3, [r4, #4]
    e4d0:	60a3      	str	r3, [r4, #8]
    e4d2:	2b00      	cmp	r3, #0
    e4d4:	db03      	blt.n	e4de <_printf_i+0x126>
    e4d6:	2204      	movs	r2, #4
    e4d8:	6821      	ldr	r1, [r4, #0]
    e4da:	4391      	bics	r1, r2
    e4dc:	6021      	str	r1, [r4, #0]
    e4de:	2d00      	cmp	r5, #0
    e4e0:	d102      	bne.n	e4e8 <_printf_i+0x130>
    e4e2:	9e04      	ldr	r6, [sp, #16]
    e4e4:	2b00      	cmp	r3, #0
    e4e6:	d00e      	beq.n	e506 <_printf_i+0x14e>
    e4e8:	9e04      	ldr	r6, [sp, #16]
    e4ea:	1c28      	adds	r0, r5, #0
    e4ec:	1c39      	adds	r1, r7, #0
    e4ee:	f7fd fce3 	bl	beb8 <__aeabi_uidivmod>
    e4f2:	9b03      	ldr	r3, [sp, #12]
    e4f4:	3e01      	subs	r6, #1
    e4f6:	5c5b      	ldrb	r3, [r3, r1]
    e4f8:	1c28      	adds	r0, r5, #0
    e4fa:	7033      	strb	r3, [r6, #0]
    e4fc:	1c39      	adds	r1, r7, #0
    e4fe:	f7fd fc55 	bl	bdac <__aeabi_uidiv>
    e502:	1e05      	subs	r5, r0, #0
    e504:	d1f1      	bne.n	e4ea <_printf_i+0x132>
    e506:	2f08      	cmp	r7, #8
    e508:	d109      	bne.n	e51e <_printf_i+0x166>
    e50a:	6823      	ldr	r3, [r4, #0]
    e50c:	07db      	lsls	r3, r3, #31
    e50e:	d506      	bpl.n	e51e <_printf_i+0x166>
    e510:	6863      	ldr	r3, [r4, #4]
    e512:	6922      	ldr	r2, [r4, #16]
    e514:	4293      	cmp	r3, r2
    e516:	dc02      	bgt.n	e51e <_printf_i+0x166>
    e518:	2330      	movs	r3, #48	; 0x30
    e51a:	3e01      	subs	r6, #1
    e51c:	7033      	strb	r3, [r6, #0]
    e51e:	9b04      	ldr	r3, [sp, #16]
    e520:	1b9b      	subs	r3, r3, r6
    e522:	6123      	str	r3, [r4, #16]
    e524:	e02b      	b.n	e57e <_printf_i+0x1c6>
    e526:	6809      	ldr	r1, [r1, #0]
    e528:	681a      	ldr	r2, [r3, #0]
    e52a:	0608      	lsls	r0, r1, #24
    e52c:	d407      	bmi.n	e53e <_printf_i+0x186>
    e52e:	0649      	lsls	r1, r1, #25
    e530:	d505      	bpl.n	e53e <_printf_i+0x186>
    e532:	1d11      	adds	r1, r2, #4
    e534:	6019      	str	r1, [r3, #0]
    e536:	6813      	ldr	r3, [r2, #0]
    e538:	8aa2      	ldrh	r2, [r4, #20]
    e53a:	801a      	strh	r2, [r3, #0]
    e53c:	e004      	b.n	e548 <_printf_i+0x190>
    e53e:	1d11      	adds	r1, r2, #4
    e540:	6019      	str	r1, [r3, #0]
    e542:	6813      	ldr	r3, [r2, #0]
    e544:	6962      	ldr	r2, [r4, #20]
    e546:	601a      	str	r2, [r3, #0]
    e548:	2300      	movs	r3, #0
    e54a:	9e04      	ldr	r6, [sp, #16]
    e54c:	6123      	str	r3, [r4, #16]
    e54e:	e016      	b.n	e57e <_printf_i+0x1c6>
    e550:	681a      	ldr	r2, [r3, #0]
    e552:	1d11      	adds	r1, r2, #4
    e554:	6019      	str	r1, [r3, #0]
    e556:	6816      	ldr	r6, [r2, #0]
    e558:	2100      	movs	r1, #0
    e55a:	1c30      	adds	r0, r6, #0
    e55c:	6862      	ldr	r2, [r4, #4]
    e55e:	f000 f929 	bl	e7b4 <memchr>
    e562:	2800      	cmp	r0, #0
    e564:	d001      	beq.n	e56a <_printf_i+0x1b2>
    e566:	1b80      	subs	r0, r0, r6
    e568:	6060      	str	r0, [r4, #4]
    e56a:	6863      	ldr	r3, [r4, #4]
    e56c:	e003      	b.n	e576 <_printf_i+0x1be>
    e56e:	1c26      	adds	r6, r4, #0
    e570:	3642      	adds	r6, #66	; 0x42
    e572:	7032      	strb	r2, [r6, #0]
    e574:	2301      	movs	r3, #1
    e576:	6123      	str	r3, [r4, #16]
    e578:	2300      	movs	r3, #0
    e57a:	9a04      	ldr	r2, [sp, #16]
    e57c:	7013      	strb	r3, [r2, #0]
    e57e:	9b07      	ldr	r3, [sp, #28]
    e580:	9805      	ldr	r0, [sp, #20]
    e582:	9300      	str	r3, [sp, #0]
    e584:	1c21      	adds	r1, r4, #0
    e586:	9b06      	ldr	r3, [sp, #24]
    e588:	aa09      	add	r2, sp, #36	; 0x24
    e58a:	f7ff fea7 	bl	e2dc <_printf_common>
    e58e:	1c43      	adds	r3, r0, #1
    e590:	d102      	bne.n	e598 <_printf_i+0x1e0>
    e592:	2001      	movs	r0, #1
    e594:	4240      	negs	r0, r0
    e596:	e021      	b.n	e5dc <_printf_i+0x224>
    e598:	6923      	ldr	r3, [r4, #16]
    e59a:	9805      	ldr	r0, [sp, #20]
    e59c:	9906      	ldr	r1, [sp, #24]
    e59e:	1c32      	adds	r2, r6, #0
    e5a0:	9d07      	ldr	r5, [sp, #28]
    e5a2:	47a8      	blx	r5
    e5a4:	1c43      	adds	r3, r0, #1
    e5a6:	d0f4      	beq.n	e592 <_printf_i+0x1da>
    e5a8:	6823      	ldr	r3, [r4, #0]
    e5aa:	079b      	lsls	r3, r3, #30
    e5ac:	d405      	bmi.n	e5ba <_printf_i+0x202>
    e5ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e5b0:	68e0      	ldr	r0, [r4, #12]
    e5b2:	4298      	cmp	r0, r3
    e5b4:	da12      	bge.n	e5dc <_printf_i+0x224>
    e5b6:	1c18      	adds	r0, r3, #0
    e5b8:	e010      	b.n	e5dc <_printf_i+0x224>
    e5ba:	2500      	movs	r5, #0
    e5bc:	68e3      	ldr	r3, [r4, #12]
    e5be:	9a09      	ldr	r2, [sp, #36]	; 0x24
    e5c0:	1a9b      	subs	r3, r3, r2
    e5c2:	429d      	cmp	r5, r3
    e5c4:	daf3      	bge.n	e5ae <_printf_i+0x1f6>
    e5c6:	1c22      	adds	r2, r4, #0
    e5c8:	2301      	movs	r3, #1
    e5ca:	9805      	ldr	r0, [sp, #20]
    e5cc:	9906      	ldr	r1, [sp, #24]
    e5ce:	3219      	adds	r2, #25
    e5d0:	9e07      	ldr	r6, [sp, #28]
    e5d2:	47b0      	blx	r6
    e5d4:	1c43      	adds	r3, r0, #1
    e5d6:	d0dc      	beq.n	e592 <_printf_i+0x1da>
    e5d8:	3501      	adds	r5, #1
    e5da:	e7ef      	b.n	e5bc <_printf_i+0x204>
    e5dc:	b00b      	add	sp, #44	; 0x2c
    e5de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e5e0:	00011591 	.word	0x00011591
    e5e4:	000115a2 	.word	0x000115a2

0000e5e8 <_putc_r>:
    e5e8:	b570      	push	{r4, r5, r6, lr}
    e5ea:	1c05      	adds	r5, r0, #0
    e5ec:	1c0e      	adds	r6, r1, #0
    e5ee:	1c14      	adds	r4, r2, #0
    e5f0:	2800      	cmp	r0, #0
    e5f2:	d004      	beq.n	e5fe <_putc_r+0x16>
    e5f4:	6983      	ldr	r3, [r0, #24]
    e5f6:	2b00      	cmp	r3, #0
    e5f8:	d101      	bne.n	e5fe <_putc_r+0x16>
    e5fa:	f7ff fc2f 	bl	de5c <__sinit>
    e5fe:	4b15      	ldr	r3, [pc, #84]	; (e654 <_putc_r+0x6c>)
    e600:	429c      	cmp	r4, r3
    e602:	d101      	bne.n	e608 <_putc_r+0x20>
    e604:	686c      	ldr	r4, [r5, #4]
    e606:	e008      	b.n	e61a <_putc_r+0x32>
    e608:	4b13      	ldr	r3, [pc, #76]	; (e658 <_putc_r+0x70>)
    e60a:	429c      	cmp	r4, r3
    e60c:	d101      	bne.n	e612 <_putc_r+0x2a>
    e60e:	68ac      	ldr	r4, [r5, #8]
    e610:	e003      	b.n	e61a <_putc_r+0x32>
    e612:	4b12      	ldr	r3, [pc, #72]	; (e65c <_putc_r+0x74>)
    e614:	429c      	cmp	r4, r3
    e616:	d100      	bne.n	e61a <_putc_r+0x32>
    e618:	68ec      	ldr	r4, [r5, #12]
    e61a:	68a3      	ldr	r3, [r4, #8]
    e61c:	3b01      	subs	r3, #1
    e61e:	60a3      	str	r3, [r4, #8]
    e620:	2b00      	cmp	r3, #0
    e622:	da10      	bge.n	e646 <_putc_r+0x5e>
    e624:	69a2      	ldr	r2, [r4, #24]
    e626:	4293      	cmp	r3, r2
    e628:	db07      	blt.n	e63a <_putc_r+0x52>
    e62a:	6823      	ldr	r3, [r4, #0]
    e62c:	701e      	strb	r6, [r3, #0]
    e62e:	6823      	ldr	r3, [r4, #0]
    e630:	7819      	ldrb	r1, [r3, #0]
    e632:	290a      	cmp	r1, #10
    e634:	d10a      	bne.n	e64c <_putc_r+0x64>
    e636:	1c28      	adds	r0, r5, #0
    e638:	e001      	b.n	e63e <_putc_r+0x56>
    e63a:	1c28      	adds	r0, r5, #0
    e63c:	1c31      	adds	r1, r6, #0
    e63e:	1c22      	adds	r2, r4, #0
    e640:	f7ff fa48 	bl	dad4 <__swbuf_r>
    e644:	e005      	b.n	e652 <_putc_r+0x6a>
    e646:	6823      	ldr	r3, [r4, #0]
    e648:	701e      	strb	r6, [r3, #0]
    e64a:	6823      	ldr	r3, [r4, #0]
    e64c:	1c5a      	adds	r2, r3, #1
    e64e:	6022      	str	r2, [r4, #0]
    e650:	7818      	ldrb	r0, [r3, #0]
    e652:	bd70      	pop	{r4, r5, r6, pc}
    e654:	00011520 	.word	0x00011520
    e658:	00011540 	.word	0x00011540
    e65c:	00011560 	.word	0x00011560

0000e660 <__sread>:
    e660:	b538      	push	{r3, r4, r5, lr}
    e662:	1c0c      	adds	r4, r1, #0
    e664:	250e      	movs	r5, #14
    e666:	5f49      	ldrsh	r1, [r1, r5]
    e668:	f000 f8d6 	bl	e818 <_read_r>
    e66c:	2800      	cmp	r0, #0
    e66e:	db03      	blt.n	e678 <__sread+0x18>
    e670:	6d63      	ldr	r3, [r4, #84]	; 0x54
    e672:	181b      	adds	r3, r3, r0
    e674:	6563      	str	r3, [r4, #84]	; 0x54
    e676:	e003      	b.n	e680 <__sread+0x20>
    e678:	89a2      	ldrh	r2, [r4, #12]
    e67a:	4b02      	ldr	r3, [pc, #8]	; (e684 <__sread+0x24>)
    e67c:	4013      	ands	r3, r2
    e67e:	81a3      	strh	r3, [r4, #12]
    e680:	bd38      	pop	{r3, r4, r5, pc}
    e682:	46c0      	nop			; (mov r8, r8)
    e684:	ffffefff 	.word	0xffffefff

0000e688 <__swrite>:
    e688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e68a:	1c1e      	adds	r6, r3, #0
    e68c:	898b      	ldrh	r3, [r1, #12]
    e68e:	1c05      	adds	r5, r0, #0
    e690:	1c0c      	adds	r4, r1, #0
    e692:	1c17      	adds	r7, r2, #0
    e694:	05db      	lsls	r3, r3, #23
    e696:	d505      	bpl.n	e6a4 <__swrite+0x1c>
    e698:	230e      	movs	r3, #14
    e69a:	5ec9      	ldrsh	r1, [r1, r3]
    e69c:	2200      	movs	r2, #0
    e69e:	2302      	movs	r3, #2
    e6a0:	f000 f874 	bl	e78c <_lseek_r>
    e6a4:	89a2      	ldrh	r2, [r4, #12]
    e6a6:	4b05      	ldr	r3, [pc, #20]	; (e6bc <__swrite+0x34>)
    e6a8:	1c28      	adds	r0, r5, #0
    e6aa:	4013      	ands	r3, r2
    e6ac:	81a3      	strh	r3, [r4, #12]
    e6ae:	1c3a      	adds	r2, r7, #0
    e6b0:	230e      	movs	r3, #14
    e6b2:	5ee1      	ldrsh	r1, [r4, r3]
    e6b4:	1c33      	adds	r3, r6, #0
    e6b6:	f000 f81f 	bl	e6f8 <_write_r>
    e6ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e6bc:	ffffefff 	.word	0xffffefff

0000e6c0 <__sseek>:
    e6c0:	b538      	push	{r3, r4, r5, lr}
    e6c2:	1c0c      	adds	r4, r1, #0
    e6c4:	250e      	movs	r5, #14
    e6c6:	5f49      	ldrsh	r1, [r1, r5]
    e6c8:	f000 f860 	bl	e78c <_lseek_r>
    e6cc:	89a3      	ldrh	r3, [r4, #12]
    e6ce:	1c42      	adds	r2, r0, #1
    e6d0:	d103      	bne.n	e6da <__sseek+0x1a>
    e6d2:	4a05      	ldr	r2, [pc, #20]	; (e6e8 <__sseek+0x28>)
    e6d4:	4013      	ands	r3, r2
    e6d6:	81a3      	strh	r3, [r4, #12]
    e6d8:	e004      	b.n	e6e4 <__sseek+0x24>
    e6da:	2280      	movs	r2, #128	; 0x80
    e6dc:	0152      	lsls	r2, r2, #5
    e6de:	4313      	orrs	r3, r2
    e6e0:	81a3      	strh	r3, [r4, #12]
    e6e2:	6560      	str	r0, [r4, #84]	; 0x54
    e6e4:	bd38      	pop	{r3, r4, r5, pc}
    e6e6:	46c0      	nop			; (mov r8, r8)
    e6e8:	ffffefff 	.word	0xffffefff

0000e6ec <__sclose>:
    e6ec:	b508      	push	{r3, lr}
    e6ee:	230e      	movs	r3, #14
    e6f0:	5ec9      	ldrsh	r1, [r1, r3]
    e6f2:	f000 f815 	bl	e720 <_close_r>
    e6f6:	bd08      	pop	{r3, pc}

0000e6f8 <_write_r>:
    e6f8:	b538      	push	{r3, r4, r5, lr}
    e6fa:	1c05      	adds	r5, r0, #0
    e6fc:	2000      	movs	r0, #0
    e6fe:	4c07      	ldr	r4, [pc, #28]	; (e71c <_write_r+0x24>)
    e700:	6020      	str	r0, [r4, #0]
    e702:	1c08      	adds	r0, r1, #0
    e704:	1c11      	adds	r1, r2, #0
    e706:	1c1a      	adds	r2, r3, #0
    e708:	f7f7 fe16 	bl	6338 <_write>
    e70c:	1c43      	adds	r3, r0, #1
    e70e:	d103      	bne.n	e718 <_write_r+0x20>
    e710:	6823      	ldr	r3, [r4, #0]
    e712:	2b00      	cmp	r3, #0
    e714:	d000      	beq.n	e718 <_write_r+0x20>
    e716:	602b      	str	r3, [r5, #0]
    e718:	bd38      	pop	{r3, r4, r5, pc}
    e71a:	46c0      	nop			; (mov r8, r8)
    e71c:	20002214 	.word	0x20002214

0000e720 <_close_r>:
    e720:	b538      	push	{r3, r4, r5, lr}
    e722:	2300      	movs	r3, #0
    e724:	4c06      	ldr	r4, [pc, #24]	; (e740 <_close_r+0x20>)
    e726:	1c05      	adds	r5, r0, #0
    e728:	1c08      	adds	r0, r1, #0
    e72a:	6023      	str	r3, [r4, #0]
    e72c:	f7f7 fe3e 	bl	63ac <_close>
    e730:	1c43      	adds	r3, r0, #1
    e732:	d103      	bne.n	e73c <_close_r+0x1c>
    e734:	6823      	ldr	r3, [r4, #0]
    e736:	2b00      	cmp	r3, #0
    e738:	d000      	beq.n	e73c <_close_r+0x1c>
    e73a:	602b      	str	r3, [r5, #0]
    e73c:	bd38      	pop	{r3, r4, r5, pc}
    e73e:	46c0      	nop			; (mov r8, r8)
    e740:	20002214 	.word	0x20002214

0000e744 <_fstat_r>:
    e744:	b538      	push	{r3, r4, r5, lr}
    e746:	2300      	movs	r3, #0
    e748:	4c06      	ldr	r4, [pc, #24]	; (e764 <_fstat_r+0x20>)
    e74a:	1c05      	adds	r5, r0, #0
    e74c:	1c08      	adds	r0, r1, #0
    e74e:	1c11      	adds	r1, r2, #0
    e750:	6023      	str	r3, [r4, #0]
    e752:	f7f7 fe2f 	bl	63b4 <_fstat>
    e756:	1c43      	adds	r3, r0, #1
    e758:	d103      	bne.n	e762 <_fstat_r+0x1e>
    e75a:	6823      	ldr	r3, [r4, #0]
    e75c:	2b00      	cmp	r3, #0
    e75e:	d000      	beq.n	e762 <_fstat_r+0x1e>
    e760:	602b      	str	r3, [r5, #0]
    e762:	bd38      	pop	{r3, r4, r5, pc}
    e764:	20002214 	.word	0x20002214

0000e768 <_isatty_r>:
    e768:	b538      	push	{r3, r4, r5, lr}
    e76a:	2300      	movs	r3, #0
    e76c:	4c06      	ldr	r4, [pc, #24]	; (e788 <_isatty_r+0x20>)
    e76e:	1c05      	adds	r5, r0, #0
    e770:	1c08      	adds	r0, r1, #0
    e772:	6023      	str	r3, [r4, #0]
    e774:	f7f7 fe24 	bl	63c0 <_isatty>
    e778:	1c43      	adds	r3, r0, #1
    e77a:	d103      	bne.n	e784 <_isatty_r+0x1c>
    e77c:	6823      	ldr	r3, [r4, #0]
    e77e:	2b00      	cmp	r3, #0
    e780:	d000      	beq.n	e784 <_isatty_r+0x1c>
    e782:	602b      	str	r3, [r5, #0]
    e784:	bd38      	pop	{r3, r4, r5, pc}
    e786:	46c0      	nop			; (mov r8, r8)
    e788:	20002214 	.word	0x20002214

0000e78c <_lseek_r>:
    e78c:	b538      	push	{r3, r4, r5, lr}
    e78e:	1c05      	adds	r5, r0, #0
    e790:	2000      	movs	r0, #0
    e792:	4c07      	ldr	r4, [pc, #28]	; (e7b0 <_lseek_r+0x24>)
    e794:	6020      	str	r0, [r4, #0]
    e796:	1c08      	adds	r0, r1, #0
    e798:	1c11      	adds	r1, r2, #0
    e79a:	1c1a      	adds	r2, r3, #0
    e79c:	f7f7 fe12 	bl	63c4 <_lseek>
    e7a0:	1c43      	adds	r3, r0, #1
    e7a2:	d103      	bne.n	e7ac <_lseek_r+0x20>
    e7a4:	6823      	ldr	r3, [r4, #0]
    e7a6:	2b00      	cmp	r3, #0
    e7a8:	d000      	beq.n	e7ac <_lseek_r+0x20>
    e7aa:	602b      	str	r3, [r5, #0]
    e7ac:	bd38      	pop	{r3, r4, r5, pc}
    e7ae:	46c0      	nop			; (mov r8, r8)
    e7b0:	20002214 	.word	0x20002214

0000e7b4 <memchr>:
    e7b4:	b2c9      	uxtb	r1, r1
    e7b6:	1882      	adds	r2, r0, r2
    e7b8:	4290      	cmp	r0, r2
    e7ba:	d004      	beq.n	e7c6 <memchr+0x12>
    e7bc:	7803      	ldrb	r3, [r0, #0]
    e7be:	428b      	cmp	r3, r1
    e7c0:	d002      	beq.n	e7c8 <memchr+0x14>
    e7c2:	3001      	adds	r0, #1
    e7c4:	e7f8      	b.n	e7b8 <memchr+0x4>
    e7c6:	2000      	movs	r0, #0
    e7c8:	4770      	bx	lr

0000e7ca <_realloc_r>:
    e7ca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e7cc:	1c06      	adds	r6, r0, #0
    e7ce:	1c0c      	adds	r4, r1, #0
    e7d0:	1c15      	adds	r5, r2, #0
    e7d2:	2900      	cmp	r1, #0
    e7d4:	d104      	bne.n	e7e0 <_realloc_r+0x16>
    e7d6:	1c11      	adds	r1, r2, #0
    e7d8:	f7ff f872 	bl	d8c0 <_malloc_r>
    e7dc:	1c04      	adds	r4, r0, #0
    e7de:	e018      	b.n	e812 <_realloc_r+0x48>
    e7e0:	2a00      	cmp	r2, #0
    e7e2:	d103      	bne.n	e7ec <_realloc_r+0x22>
    e7e4:	f7ff f826 	bl	d834 <_free_r>
    e7e8:	1c2c      	adds	r4, r5, #0
    e7ea:	e012      	b.n	e812 <_realloc_r+0x48>
    e7ec:	f000 f828 	bl	e840 <_malloc_usable_size_r>
    e7f0:	42a8      	cmp	r0, r5
    e7f2:	d20e      	bcs.n	e812 <_realloc_r+0x48>
    e7f4:	1c30      	adds	r0, r6, #0
    e7f6:	1c29      	adds	r1, r5, #0
    e7f8:	f7ff f862 	bl	d8c0 <_malloc_r>
    e7fc:	1e07      	subs	r7, r0, #0
    e7fe:	d007      	beq.n	e810 <_realloc_r+0x46>
    e800:	1c21      	adds	r1, r4, #0
    e802:	1c2a      	adds	r2, r5, #0
    e804:	f7fe fff1 	bl	d7ea <memcpy>
    e808:	1c30      	adds	r0, r6, #0
    e80a:	1c21      	adds	r1, r4, #0
    e80c:	f7ff f812 	bl	d834 <_free_r>
    e810:	1c3c      	adds	r4, r7, #0
    e812:	1c20      	adds	r0, r4, #0
    e814:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0000e818 <_read_r>:
    e818:	b538      	push	{r3, r4, r5, lr}
    e81a:	1c05      	adds	r5, r0, #0
    e81c:	2000      	movs	r0, #0
    e81e:	4c07      	ldr	r4, [pc, #28]	; (e83c <_read_r+0x24>)
    e820:	6020      	str	r0, [r4, #0]
    e822:	1c08      	adds	r0, r1, #0
    e824:	1c11      	adds	r1, r2, #0
    e826:	1c1a      	adds	r2, r3, #0
    e828:	f7f7 fd64 	bl	62f4 <_read>
    e82c:	1c43      	adds	r3, r0, #1
    e82e:	d103      	bne.n	e838 <_read_r+0x20>
    e830:	6823      	ldr	r3, [r4, #0]
    e832:	2b00      	cmp	r3, #0
    e834:	d000      	beq.n	e838 <_read_r+0x20>
    e836:	602b      	str	r3, [r5, #0]
    e838:	bd38      	pop	{r3, r4, r5, pc}
    e83a:	46c0      	nop			; (mov r8, r8)
    e83c:	20002214 	.word	0x20002214

0000e840 <_malloc_usable_size_r>:
    e840:	1f0b      	subs	r3, r1, #4
    e842:	681a      	ldr	r2, [r3, #0]
    e844:	1f10      	subs	r0, r2, #4
    e846:	2a00      	cmp	r2, #0
    e848:	da04      	bge.n	e854 <_malloc_usable_size_r+0x14>
    e84a:	1889      	adds	r1, r1, r2
    e84c:	3904      	subs	r1, #4
    e84e:	680b      	ldr	r3, [r1, #0]
    e850:	18d0      	adds	r0, r2, r3
    e852:	3804      	subs	r0, #4
    e854:	4770      	bx	lr
    e856:	0000      	movs	r0, r0
    e858:	42002c00 	.word	0x42002c00
    e85c:	42003000 	.word	0x42003000
    e860:	42003400 	.word	0x42003400
    e864:	001c1c1b 	.word	0x001c1c1b
    e868:	10000800 	.word	0x10000800
    e86c:	00002000 	.word	0x00002000
    e870:	00000476 	.word	0x00000476
    e874:	00000478 	.word	0x00000478
    e878:	0000045e 	.word	0x0000045e
    e87c:	0000045e 	.word	0x0000045e
    e880:	0000045e 	.word	0x0000045e
    e884:	00000476 	.word	0x00000476
    e888:	0000045e 	.word	0x0000045e
    e88c:	0000045e 	.word	0x0000045e
    e890:	00000a96 	.word	0x00000a96
    e894:	00000b0a 	.word	0x00000b0a
    e898:	00000a7e 	.word	0x00000a7e
    e89c:	00000b10 	.word	0x00000b10
    e8a0:	00000a84 	.word	0x00000a84
    e8a4:	00000a8a 	.word	0x00000a8a
    e8a8:	00000a90 	.word	0x00000a90
    e8ac:	00000f74 	.word	0x00000f74
    e8b0:	00000f74 	.word	0x00000f74
    e8b4:	00000f74 	.word	0x00000f74
    e8b8:	00000f74 	.word	0x00000f74
    e8bc:	00000f74 	.word	0x00000f74
    e8c0:	00000f74 	.word	0x00000f74
    e8c4:	00000f74 	.word	0x00000f74
    e8c8:	00000f74 	.word	0x00000f74
    e8cc:	00000f74 	.word	0x00000f74
    e8d0:	00000f74 	.word	0x00000f74
    e8d4:	00000f74 	.word	0x00000f74
    e8d8:	00000f74 	.word	0x00000f74
    e8dc:	00000f74 	.word	0x00000f74
    e8e0:	00000f74 	.word	0x00000f74
    e8e4:	00000f74 	.word	0x00000f74
    e8e8:	00000f74 	.word	0x00000f74
    e8ec:	00000f74 	.word	0x00000f74
    e8f0:	00000f74 	.word	0x00000f74
    e8f4:	00000f74 	.word	0x00000f74
    e8f8:	00000f92 	.word	0x00000f92
    e8fc:	00000f92 	.word	0x00000f92
    e900:	00000f92 	.word	0x00000f92
    e904:	00000f92 	.word	0x00000f92
    e908:	00000f92 	.word	0x00000f92
    e90c:	00000f92 	.word	0x00000f92
    e910:	00000f92 	.word	0x00000f92
    e914:	00000f92 	.word	0x00000f92
    e918:	00000f92 	.word	0x00000f92
    e91c:	00000f92 	.word	0x00000f92
    e920:	00000fb4 	.word	0x00000fb4
    e924:	00000fb4 	.word	0x00000fb4
    e928:	00000fb4 	.word	0x00000fb4
    e92c:	00000fb4 	.word	0x00000fb4
    e930:	00000fb4 	.word	0x00000fb4
    e934:	00000fb4 	.word	0x00000fb4
    e938:	00000fb4 	.word	0x00000fb4
    e93c:	00000fb4 	.word	0x00000fb4
    e940:	00000fb4 	.word	0x00000fb4
    e944:	00000fb4 	.word	0x00000fb4
    e948:	00000fd6 	.word	0x00000fd6
    e94c:	00000fd6 	.word	0x00000fd6
    e950:	00000fd6 	.word	0x00000fd6
    e954:	00000fd6 	.word	0x00000fd6
    e958:	00000fd6 	.word	0x00000fd6
    e95c:	00000fd6 	.word	0x00000fd6
    e960:	00000ff0 	.word	0x00000ff0
    e964:	00000ff0 	.word	0x00000ff0
    e968:	00000ff0 	.word	0x00000ff0
    e96c:	00000ff0 	.word	0x00000ff0
    e970:	00000ff0 	.word	0x00000ff0
    e974:	00000ff0 	.word	0x00000ff0
    e978:	00000ff0 	.word	0x00000ff0
    e97c:	00000ff0 	.word	0x00000ff0
    e980:	00000ff0 	.word	0x00000ff0
    e984:	0000100a 	.word	0x0000100a
    e988:	0000100a 	.word	0x0000100a
    e98c:	0000102c 	.word	0x0000102c
    e990:	0000102c 	.word	0x0000102c
    e994:	0000102c 	.word	0x0000102c
    e998:	34333231 	.word	0x34333231
    e99c:	00003635 	.word	0x00003635
    e9a0:	efcdab00 	.word	0xefcdab00
    e9a4:	00efcdab 	.word	0x00efcdab
    e9a8:	b2d60600 	.word	0xb2d60600
    e9ac:	f8f005f0 	.word	0xf8f005f0
    e9b0:	00000000 	.word	0x00000000

0000e9b4 <ble_mgr_gatt_server_handle>:
	...
    e9cc:	0000040d 00000411 0000041d 00000000     ................

0000e9dc <ble_mgr_gap_handle>:
    e9dc:	000003fd 00000509 00000401 00000000     ................
    e9ec:	00000000 00000cb5 00000429 00000491     ........).......
    e9fc:	00000605 00000555 000007c9 0000061d     ....U...........
    ea0c:	000008f5 0000099d 00000495 00000e79     ............y...
	...
    ea28:	454d5441 41422d4c 00000053              ATMEL-BAS...

0000ea34 <tc_interrupt_vectors.13082>:
    ea34:	00141312 000027f4 000027cc 000027c4     .....'...'...'..
    ea44:	000027dc 000027d4 000027f4 000027e4     .'...'...'...'..
    ea54:	000027ec 000034f0 000034f0 00003520     .'...4...4.. 5..
    ea64:	000034a2 000034c6 000034d4 00003506     .4...4...4...5..
    ea74:	00003506 0000354e 00003492 00003596     .5..N5...4...5..
    ea84:	00003596 00003596 00003596 000034e2     .5...5...5...4..

0000ea94 <crc7_syndrome_table>:
    ea94:	1b120900 3f362d24 535a4148 777e656c     ....$-6?HAZSle~w
    eaa4:	020b1019 262f343d 4a435851 6e677c75     ....=4/&QXCJu|gn
    eab4:	29203b32 0d041f16 6168737a 454c575e     2; )....zsha^WLE
    eac4:	3039222b 141d060f 78716a63 5c554e47     +"90....cjqxGNU\
    ead4:	7f766d64 5b524940 373e252c 131a0108     dmv.@IR[,%>7....
    eae4:	666f747d 424b5059 2e273c35 0a031811     }tofYPKB5<'.....
    eaf4:	4d445f56 69607b72 050c171e 2128333a     V_DMr{`i....:3(!
    eb04:	545d464f 7079626b 1c150e07 38312a23     OF]Tkbyp....#*18
    eb14:	5a534841 7e776c65 121b0009 363f242d     AHSZelw~....-$?6
    eb24:	434a5158 676e757c 0b021910 2f263d34     XQJC|ung....4=&/
    eb34:	68617a73 4c455e57 2029323b 040d161f     szahW^EL;2) ....
    eb44:	7178636a 555c474e 39302b22 1d140f06     jcxqNG\U"+09....
    eb54:	3e372c25 1a130801 767f646d 525b4049     %,7>....md.vI@[R
    eb64:	272e353c 030a1118 6f667d74 4b425950     <5.'....t}foPYBK
    eb74:	0c051e17 28213a33 444d565f 6069727b     ....3:!(_VMD{ri`
    eb84:	151c070e 3138232a 5d544f46 79706b62     ....*#81FOT]bkpy
    eb94:	42000800 42000c00 42001000 42001400     ...B...B...B...B
    eba4:	42001800 42001c00 0c0b0a09 00000e0d     ...B...B........
    ebb4:	000053d6 000053d2 000053d2 00005432     .S...S...S..2T..
    ebc4:	00005432 000053ec 000053dc 000053f2     2T...S...S...S..
    ebd4:	00005420 00005618 000055f8 000055f8      T...V...U...U..
    ebe4:	00005684 0000560a 00005626 000055fc     .V...V..&V...U..
    ebf4:	00005634 00005674                       4V..tV..

0000ebfc <_tcc_gclk_ids>:
    ebfc:	001b1a1a                                ....

0000ec00 <_tcc_apbcmasks>:
    ec00:	00000100 00000200 00000400              ............

0000ec0c <_tcc_maxs>:
    ec0c:	00ffffff 00ffffff 0000ffff              ............

0000ec18 <_tcc_cc_nums>:
    ec18:	00020204                                ....

0000ec1c <_tcc_ow_nums>:
    ec1c:	00020408                                ....

0000ec20 <tcc_interrupt_vectors.12383>:
    ec20:	0011100f                                ....

0000ec24 <_tcc_intflag>:
    ec24:	00000001 00000002 00000004 00000008     ................
    ec34:	00001000 00002000 00004000 00008000     ..... ...@......
    ec44:	00010000 00020000 00040000 00080000     ................
    ec54:	42002000 42002400 42002800              . .B.$.B.(.B

0000ec60 <battery_app_gap_cb>:
	...
    ec74:	00006609 000067e5 00000000 00000000     .f...g..........
    ec84:	000066c5 00000000 00000000 00000000     .f..............
    ec94:	00000000 000066c5 00000000 00000000     .....f..........
	...

0000ecac <main_mqtt_broker>:
    ecac:	74736574 736f6d2e 74697571 6f2e6f74     test.mosquitto.o
    ecbc:	00006772                                rg..

0000ecc0 <battery_app_gatt_server_cb>:
    ecc0:	00006619 00000000 000066a9 00000000     .f.......f......
	...
    ece8:	61766953 00000000 61766973 35343031     Siva....siva1045
    ecf8:	00003631 656d7461 61732f6c 656c706d     16..atmel/sample
    ed08:	656c622f 6669775f 65645f69 002f6f6d     /ble_wifi_demo/.
    ed18:	74746162 5f797265 6f666e69 0000002f     battery_info/...
    ed28:	73257325 00000000 00006425 2842494c     %s%s....%d..LIB(
    ed38:	25202945 7336312d 33302528 25202964     E) %-16s(%03d) %
    ed48:	28733233 203a2029 2f2e2e00 2f637273     32s() : .../src/
    ed58:	2f465341 72696874 72617064 772f7974     ASF/thirdparty/w
    ed68:	6c657269 2f737365 5f656c62 5f6b6473     ireless/ble_sdk_
    ed78:	2f62696c 5f656c62 63617473 70612f6b     lib/ble_stack/ap
    ed88:	6f635f69 652f6572 746e6576 5500632e     i_core/event.c.U
    ed98:	6e61686e 64656c64 73090a3a 695f6372     nhandled:..src_i
    eda8:	78303a64 78343025 736d090a 64695f67     d:0x%04x..msg_id
    edb8:	2578303a 0a783430 6e616800                       :0x%04x..

0000edc1 <__FUNCTION__.7990>:
    edc1:	646e6168 625f656c 655f656c 746e6576     handle_ble_event
    edd1:	6d744100 43206c65 2e70726f              .Atmel Corp.

0000eddd <__FUNCTION__.7956>:
    eddd:	625f7461 735f656c 645f7465 635f7665     at_ble_set_dev_c
    eded:	69666e6f 74610067                                onfig.

0000edf3 <__FUNCTION__.8097>:
    edf3:	625f7461 635f656c 5f6e6e6f 61647075     at_ble_conn_upda
    ee03:	725f6574 796c7065 2f2e2e00 2f637273     te_reply.../src/
    ee13:	2f465341 72696874 72617064 772f7974     ASF/thirdparty/w
    ee23:	6c657269 2f737365 5f656c62 5f6b6473     ireless/ble_sdk_
    ee33:	2f62696c 5f656c62 63617473 70612f6b     lib/ble_stack/ap
    ee43:	6f635f69 672f6572 632e7061 766e4900     i_core/gap.c.Inv
    ee53:	64696c61 72615020 74656d61 20737265     alid Parameters 
    ee63:	6f727265 74530072 73757461 30203a20     error.Status : 0
    ee73:	32302578 49000a58 6c61766e 50206469     x%02X..Invalid P
    ee83:	6d617261 72657465 6e550073 776f6e6b     arameters.Unknow
    ee93:	6461206e 73657264 79742073 30206570     n address type 0
    eea3:	32253c78 000a0d3e 6e6b6e55 206e776f     x<%2>...Unknown 
    eeb3:	69766564 72206563 20656c6f 253c7830     device role 0x<%
    eec3:	0a0d3e32 55544d00 6c615620 65206575     2>...MTU Value e
    eed3:	65656378 616d2064 756d6978 6c61206d     xceed maximum al
    eee3:	65776f6c 61762064 2065756c 55000a0d     lowed value ...U
    eef3:	6c62616e 6f742065 696e6920 6c702074     nable to init pl
    ef03:	6f667461 3c206d72 58323025 000a0d3e     atform <%02X>...
    ef13:	62616e55 7420656c 6e69206f 70207469     Unable to init p
    ef23:	68637461 30253c20 0d3e5832 6e55000a     atch <%02X>...Un
    ef33:	656c6261 206f7420 65736572 253c2074     able to reset <%
    ef43:	3e583230 616e5500 20656c62 73206f74     02X>.Unable to s
    ef53:	64207465 75616665 6420746c 63697665     et default devic
    ef63:	616e2065 3c20656d 58323025 000a0d3e     e name <%02X>...
    ef73:	65746e49 6c617672 6e616320 62207427     Interval can't b
    ef83:	20302065 6c20726f 0d737365 554e000a     e 0 or less...NU
    ef93:	70204c4c 746e696f 0a0d7265 4c554e00     LL pointer...NUL
    efa3:	6f70204c 65746e69 72652072 00726f72     L pointer error.
    efb3:	61766e49 2064696c 69766564 6e206563     Invalid device n
    efc3:	20656d61 74697277 65702065 73696d72     ame write permis
    efd3:	6e6f6973 74657300 76656420 20656369     sion.set device 
    efe3:	666e6f63 66206769 656c6961 73202c64     config failed, s
    eff3:	75746174 3c203a73 003e6425 61766e49     tatus: <%d>.Inva
    f003:	2064696c 2e6e6f43 646f4d20 253c2065     lid Con. Mode <%
    f013:	0a0d3e64 206f4e00 74706d45 6e452079     d>...No Empty En
    f023:	20797274 20726f66 6e6e6f63 69746365     try for connecti
    f033:	0a0d6e6f 766e4900 64696c61 746e6920     on...Invalid int
    f043:	61767265 000a0d6c 62616e55 7420656c     erval...Unable t
    f053:	6567206f 64612074 73657264 000a0d73     o get address...
    f063:	61766e49 2064696c 68747541 70795420     Invalid Auth Typ
    f073:	64252065 61000a0d                                e %d...

0000f07a <__FUNCTION__.7885>:
    f07a:	625f7461 695f656c 0074696e              at_ble_init.

0000f086 <CSWTCH.63>:
    f086:	00100402                                         ...

0000f089 <CSWTCH.65>:
    f089:	03010300 03030303 03030303 61020303              ...............

0000f098 <__FUNCTION__.7935>:
    f098:	625f7461 645f656c 63697665 616e5f65     at_ble_device_na
    f0a8:	735f656d 2e007465 72732f2e 53412f63     me_set.../src/AS
    f0b8:	68742f46 70647269 79747261 7269772f     F/thirdparty/wir
    f0c8:	73656c65 6c622f73 64735f65 696c5f6b     eless/ble_sdk_li
    f0d8:	6c622f62 74735f65 2f6b6361 5f697061     b/ble_stack/api_
    f0e8:	65726f63 7461672f 65735f74 72657672     core/gatt_server
    f0f8:	7500632e                                         .c.

0000f0fb <__FUNCTION__.7267>:
    f0fb:	72657375 7365645f 70697263 6e6f6974     user_description
    f10b:	6665645f 00656e69                       _define.

0000f113 <__FUNCTION__.7909>:
    f113:	63656863 6e655f6b 72705f63 7365636f     check_enc_proces
    f123:	74610073                                         s.

0000f125 <__FUNCTION__.7865>:
    f125:	625f7461 615f656c 65687475 6369746e     at_ble_authentic
    f135:	00657461 732f2e2e 412f6372 742f4653     ate.../src/ASF/t
    f145:	64726968 74726170 69772f79 656c6572     hirdparty/wirele
    f155:	622f7373 735f656c 6c5f6b64 622f6269     ss/ble_sdk_lib/b
    f165:	735f656c 6b636174 6970612f 726f635f     le_stack/api_cor
    f175:	65732f65 69727563 632e7974 766e4900     e/security.c.Inv
    f185:	64696c61 79654b20 7a697320 64252065     alid Key size %d
    f195:	55000a0d 6f6e6b6e 61682077 656c646e     ...Unknow handle
    f1a5:	00782520 41564e49 2044494c 4e4e4f43      %x.INVALID CONN
    f1b5:	4148202e 454c444e 4e49000a 494c4156     . HANDLE..INVALI
    f1c5:	45462044 52555441 000a5345 41564e49     D FEATURES..INVA
    f1d5:	2044494c 2059454b 455a4953 55000a0d     LID KEY SIZE...U
    f1e5:	4f4e4b4e 41204e57 45485455 54202e4e     NKNOWN AUTHEN. T
    f1f5:	0d455059 4e55000a 574f4e4b 454b204e     YPE...UNKNOWN KE
    f205:	49442059 0d2e5453 544c000a 7369204b     Y DIST....LTK is
    f215:	746f6e20 6f727020 65646976 000a0d64      not provided...
    f225:	41564e49 2044494c 2059454b 52544e45     INVALID KEY ENTR
    f235:	000a0d59 41564e49 2044494c 20564544     Y...INVALID DEV 
    f245:	45444f4d 49000a0d 4c41564e 54204449     MODE...INVALID T
    f255:	0d455059 6e55000a 776f6e6b 6e614820     YPE...Unknow Han
    f265:	0d656c64 6e49000a 696c6176 6f522064     dle...Invalid Ro
    f275:	0a0d656c 766e4900 64696c61 6c6f5220     le...Invalid Rol
    f285:	78252065 5f746100                                e %x.

0000f28a <__FUNCTION__.7919>:
    f28a:	625f7461 655f656c 7972636e 6f697470     at_ble_encryptio
    f29a:	74735f6e 00747261                       n_start.

0000f2a2 <__FUNCTION__.7928>:
    f2a2:	625f7461 655f656c 7972636e 6f697470     at_ble_encryptio
    f2b2:	65725f6e 73657571 65725f74 00796c70     n_request_reply.

0000f2c2 <__FUNCTION__.7884>:
    f2c2:	625f7461 705f656c 5f726961 5f79656b     at_ble_pair_key_
    f2d2:	6c706572 74610079                                reply.

0000f2d8 <__FUNCTION__.7894>:
    f2d8:	625f7461 735f656c 5f646e65 76616c73     at_ble_send_slav
    f2e8:	65735f65 65725f63 73657571 fea50074     e_sec_request...
    f2f8:	00215752                                RW!.

0000f2fc <patch_data>:
    f2fc:	461eb5f8 460c4617 f0014610 283ffcc5     ...F.F.F.F....?(
    f30c:	484cd031 89808821 d0052800 4d4a1d82     1.LH!....(....JM
    f31c:	d1034291 e0102402 e7f82200 d0042800     .B...$..."...(..
    f32c:	42911c82 2400d103 2200e007 2800e7f9     ...B...$..."...(
    f33c:	1d00d000 d10a4281 48402401 23016800     .....B...$@H.h.#
    f34c:	463ab281 f001483e 7004fca5 2306e009     ..:F>H.....p...#
    f35c:	4631463a f001483b 8821fc9d 21808001     :F1F;H....!....!
    f36c:	68297101 20004788 b5ffbdf8 460cb081     .q)h.G. .......F
    f37c:	f0019803 283ffc89 9803d036 0a007822     ......?(6..."x..
    f38c:	26000201 4d2b482f 2a003109 2702d005     ...&/H+M.1.*...'
    f39c:	d0172a01 d1272a02 8862e029 b2931d92     .*...*'.).b.....
    f3ac:	f0019a03 4607fc77 280089a8 1c80d000     ....w..F...(....
    f3bc:	713e8038 807a8862 1d781d21 fc70f001     8.>qb.z.!.x...p.
    f3cc:	e00e4638 9a032308 fc64f001 290089a9     8F...#....d....)
    f3dc:	1d09d000 71068001 88628047 0a127142     .......qG.b.Bq..
    f3ec:	49157182 47886809 b0052000 230ebdf0     .q.I.h.G. .....#
    f3fc:	f0019a03 89a9fc4f d0002900 80011d89     ....O....)......
    f40c:	21087106 88628041 0a127142 88a27182     .q.!A.b.Bq...q..
    f41c:	0a1271c2 88e27202 0a127242 89227282     .q...r..Br...r".
    f42c:	0a1272c2 e7dc7302 4907b510 f0012014     .r...s.....I. ..
    f43c:	bd10fc3d 100408e4 100400e4 10040018     =...............
    f44c:	00000e0a 00000c14 10006f54 2001b51c     ........To..... 
    f45c:	fc32f001 fc36f001 68004839 4c394780     ..2...6.9H.h.G9L
    f46c:	07407b20 28030f40 4937d803 68092000      {@.@..(..7I. .h
    f47c:	48364788 26007801 d00e2900 ca06a234     .G6H.x.&.)..4...
    f48c:	91009201 22007006 46682105 fc20f001     .....p.".!hF.. .
    f49c:	21052200 f0014668 68a0fc21 d4030040     .".!hF..!..h@...
    f4ac:	7801482d d0fc2900 fc1ef001 fc22f001     -H.x.)........".
    f4bc:	fc26f001 4d29492a 68686809 f0004788     ..&.*I)M.hhh.G..
    f4cc:	68a8fbad 68a04780 d40a0040 28017828     ...h.G.h@...(x.(
    f4dc:	7868d1fc d0042800 4923706e 60c84821     ..hx.(..np#I!H.`
    f4ec:	f001e7fe f7fffc13 4820ff9f 47806800     .......... H.h.G
    f4fc:	481fb662 fc10f001 07007b20 f001d501     b..H.... {......
    f50c:	4c1cfc11 fc14f001 47806820 d0f92800     ...L.... h.G.(..
    f51c:	f0014819 e7f5fc13 20004601 d00d2900     .H.......F. .)..
    f52c:	d1072902 780a490c d0042a02 29017809     .)...I.x.*...x.)
    f53c:	4812d100 48114770 47703010 47704810     ...HpG.H.0pG.HpG
    f54c:	10040160 10040828 100401c0 10040025     `...(.......%...
    f55c:	54554f42 00000021 100400d9 10040000     BOUT!...........
    f56c:	10040104 05fa0004 e000ed00 10040154     ............T...
    f57c:	100403bc 1004010c 100405ec 10006ef4     .............n..
    f58c:	0001e2bc 4ad6b5f0 49d66816 48d64bd6     .......J.h.I.K.H
    f59c:	128c3340 2e0012cd 6886d026 400e6857     @3......&..hWh.@
    f5ac:	0fff073f 4337047f 689e6087 6851400e     ?.....7C.`.h.@Qh
    f5bc:	0fc90709 43310449 69416099 40216853     ....I.1C.`AiSh!@
    f5cc:	0fdb075b 430b01db 69416143 40296853     [......CCaAiSh)@
    f5dc:	0fdb079b 430b019b 49c46143 400b6943     .......CCa.ICi.@
    f5ec:	07c96851 e02e0fc9 68d64ac1 07f60d76     Qh.......J.hv...
    f5fc:	68d6d12c 07f60d36 6886d028 400e68d7     ,..h6...(..h.h.@
    f60c:	0fff033f 4337047f 689e6087 68d1400e     ?.....7C.`.h.@.h
    f61c:	0fc90309 43310449 69416099 402168d3     ....I.1C.`Ai.h!@
    f62c:	0fdb04db 430b01db 69416143 402968d3     .......CCaAi.h)@
    f63c:	0fdb051b 430b019b 49ac6143 400b6943     .......CCa.ICi.@
    f64c:	054968d1 03c90fc9 61414319 4770bdf0     .hI......CAa..pG
    f65c:	49a8b530 61082000 684849a7 43102201     0..I. .a.IHh.".C
    f66c:	49a66048 158a6988 61884390 69184ba4     H`.I.i...C.a.K.i
    f67c:	43202404 69086118 78254ca2 02db2303     .$ C.a.i.L%x.#..
    f68c:	d1002d01 25e14398 43a803ad 68c86108     .-...C.%...C.a.h
    f69c:	78242502 2c0143a8 241cd101 242043a0     .%$x.C.,...$.C $
    f6ac:	439043a0 43984a98 60c84390 4f97bd30     .C.C.J.C.C.`0..O
    f6bc:	26004c97 47806838 d10d2800 28027a20     .L.&8h.G.(.. z.(
    f6cc:	f001d00a 2802fb41 f001d0fb 2800fb3d     ....A..(....=..(
    f6dc:	bf00d102 72202001 25007a20 d03b2800     .....  r z.%.(;.
    f6ec:	d04e2801 d1e52802 8800488a d0022800     .(N..(...H...(..
    f6fc:	68004889 f0014780 7860fb2d d0012800     .H.h.G..-.`x.(..
    f70c:	fb2ef001 fb32f001 20016aa1 f0014788     ......2..j. .G..
    f71c:	4882fb33 47806800 68004881 48744780     3..H.h.G.H.h.GtH
    f72c:	074068c0 28030f40 497ed803 68092001     .h@.@..(..~I. .h
    f73c:	78a04788 70a01c40 6800487b 6a204780     .G.x@..p{H.h.G j
    f74c:	d0012800 47806a20 ff82f7ff 20014977     .(.. j.G....wI. 
    f75c:	61886809 e01bb662 280079e0 bf30d100     .h.ab....y.(..0.
    f76c:	78284d73 d1a52801 fb0cf001 f001702e     sM(x.(.......p..
    f77c:	4870fb0f 28006800 486ed19c faccf001     ..pH.h.(..nH....
    f78c:	2004e798 fb0af001 47806838 d0012800     ... ....8h.G.(..
    f79c:	e78f7226 fb08f001 fb0cf001 d1fb2800     &r...........(..
    f7ac:	faf0f001 fb0cf001 28027a20 2702d03b     ........ z.(;..'
    f7bc:	48617227 07c86801 0438d004 79204305     'raH.h....8..C y
    f7cc:	71201c40 d4020788 28006960 2001d005     @. q....`i.(... 
    f7dc:	43050480 1c407960 20037160 faf6f001     ...C`y@.`q. ....
    f7ec:	d0232800 68084955 600843b8 1c4079a0     .(#.UI.h.C.`.y@.
    f7fc:	200171a0 49527060 68092001 4f3c4788     .q. `pRI. .h.G<O
    f80c:	28017c38 2000d01a 4328494e f0014308     8|.(... NI(C.C..
    f81c:	743efae3 20006aa1 4c4b4788 47806820     ..>t.j. .GKL h.G
    f82c:	d1fb2800 f001e7fe e743fab3 04002001     .(........C.. ..
    f83c:	70664305 1c4078e0 e7dc70e0 02402001     .Cfp.x@..p... @.
    f84c:	b510e7e2 8410f3ef b6724a40 68506811     ........@Jr..hPh
    f85c:	23001c49 60114158 f0016050 b662f9c9     I..#XA.`P`....b.
    f86c:	8810f384 493abd10 6048207c 7a08491c     ......:I| H`.I.z
    f87c:	d1242801 68004821 42904a36 4836d101     .($.!H.h6J.B..6H
    f88c:	4836e000 60904a36 4a36207d 801000c0     ..6H6J.`} 6J....
    f89c:	48354a36 4a378010 80104835 20014a27     6J5H..7J5H..'J. 
    f8ac:	61503a40 20034a34 4a2f8010 3ac14833     @:Pa4J. ../J3H.:
    f8bc:	4a336102 4a336002 20006042 49327208     .a3J.`3JB`. .r2I
    f8cc:	22076848 43100712 49316048 6208482f     Hh."...CH`1I/H.b
    f8dc:	21014770 0709482f f0016048 0000fa83     pG.!/H..H`......
    f8ec:	10006f14 fffdffff 40020800 ffff7fff     .o.........@....
    f8fc:	10040828 4000b200 40014000 4000b000     (......@.@.@...@
    f90c:	e000ed00 100400d9 20058000 1004018c     ........... ....
    f91c:	1004001c 10040094 100400a0 10040170     ............p...
    f92c:	10040160 100401c0 10040154 1004015c     `.......T...\...
    f93c:	10040141 100405ec 10040168 4000f040     A.......h...@..@
    f94c:	10040210 00400001 10040188 10040240     ......@.....@...
    f95c:	40025100 002000b1 00008c06 00000c06     .Q.@.. .........
    f96c:	4000f400 10040090 000009c4 10006f28     ...@........(o..
    f97c:	00001a07 10040096 1004009c 4000e040     ............@..@
    f98c:	03020000 06050403 40024000 00001602     .........@.@....
    f99c:	40041840 0001e1ad 4c39b5f8 28006920     @..@......9L i.(
    f9ac:	4838d006 28006800 4836d102 f9b4f001     ..8H.h.(..6H....
    f9bc:	4f364e35 2d006925 0628d060 2080d503     5N6O%i.-`.(.... 
    f9cc:	f00161a0 07a8fa15 2002d503 f00161a0     .a......... .a..
    f9dc:	0728fa15 2008d504 200061a0 fa14f001     ..(.... .a. ....
    f9ec:	d50505e8 300120ff 200161a0 fa0cf001     ..... .0.a. ....
    f9fc:	d50405a8 02402001 f00161a0 0668fa0b     ..... @..a....h.
    fa0c:	2040d503 f00161a0 06e8fa0b 2010d503     ..@ .a......... 
    fa1c:	f00161a0 0768fa0b 4919d51e 31c02001     .a....h....I. .1
    fa2c:	6bc863c8 d1fc2800 491969e0 49196008     .c.k.(...i.I.`.I
    fa3c:	68092004 20044788 491761a0 62082000     . .h.G. .a.I. .b
    fa4c:	68004816 88304780 d0052800 47806838     .H.h.G0..(..8h.G
    fa5c:	f9f2f001 f9ccf001 d00a07e8 28008830     ............0..(
    fa6c:	2001d107 683861a0 f0014780 f001f9e5     ... .a8h.G......
    fa7c:	06a8f9bf 2020d59e e79b61a0 0000bdf8     ......  .a......
    fa8c:	40040000 100405ec 10040094 10040174     ...@........t...
    fa9c:	10006f20 10040210 4000b000 10040110      o.........@....
    faac:	4604b5fe f9cef001 f0019000 4607f9d1     ...F...........F
    fabc:	46257a20 0f000700 90013564 78a84626      z%F....d5..&F.x
    facc:	28003624 f001d101 4630f9c9 f9ccf001     $6.(......0F....
    fadc:	48184621 f9cef001 481778a9 d1032900     !F.H.....x.H.)..
    faec:	42f99900 8801d000 22029901 4913008b     ...B......."...I
    fafc:	800a1859 804a8df2 78a99a00 431119d2     Y.....J....x...C
    fb0c:	4b104a0f 8801d10f d00c07c9 80112100     .J.K.........!..
    fb1c:	80518019 490c68a2 624a1e52 620a8882     ..Q..h.IR.Jb...b
    fb2c:	62888840 2001bdfe 21038010 80508019     @..b... ...!..P.
    fb3c:	0000bdfe 1004085c 1004007c 40030000     ....\...|......@
    fb4c:	10006f24 1004009c 40024040 68094911     $o......@@.@.I.h
    fb5c:	0a814348 18890bc2 18080c00 30ff30ff     HC...........0.0
    fb6c:	0a803002 b5304770 8800480b ffeef7ff     .0..pG0..H......
    fb7c:	46034d0a f7ff8828 b284ffe9 f7ff8868     .M.F(.......h...
    fb8c:	0559ffe5 b28002a2 43014311 63c14804     ..Y......C.C.H.c
    fb9c:	0000bd30 10040204 10006f28 10040090     0.......(o......
    fbac:	40040000 0a04b510 2810b2c0 dc0ed034     ...@.......(4...
    fbbc:	d023280c 2803dc06 280ad017 280bd020     .(#....(...( ..(
    fbcc:	e019d111 d013280d d10c280e 2837e012     .....(...(....7(
    fbdc:	dc04d01a d0152811 d1042812 2838e01a     .....(...(....8(
    fbec:	2839d014 f001d014 0221f94b bd104308     ..9(....K.!..C..
    fbfc:	e7fa200a e7f8200b e7f62008 e7f42009     . ... ... ... ..
    fc0c:	e7f22007 e7f02005 e7ee2014 e7ec200d     . ... ... ... ..
    fc1c:	e7ea200e e7e82006 e7e62004 2003b510     . ... ... ..... 
    fc2c:	f934f001 20034902 f840f001 0000bd10     ..4..I. ..@.....
    fc3c:	10006e5c 4618b570 4601460d 23822400     \n..p..F.F.F.$.#
    fc4c:	f001481e 7969f827 2900682a 2980d001     .H..'.iy*h.)...)
    fc5c:	2112d901 792be027 d0082b08 d00f2b10     ...!'.+y.+...+..
    fc6c:	d01b2b20 5d13e01e 70ab1905 428c1c64      +.....]...pd..B
    fc7c:	e016d3f9 19055b13 0a1b70ab 1ca470eb     .....[...p...p..
    fc8c:	d3f7428c e00c0049 19055913 0a1b70ab     .B..I....Y...p..
    fc9c:	0a1b70eb 0a1b712b 1d24716b d3f3428c     .p..+q..kq$..B..
    fcac:	70410089 70012100 78424601 1c92390c     ..Ap.!.p.FBx.9..
    fcbc:	4903814a 47886809 bd702000 00000319     J..I.h.G. p.....
    fccc:	100400e4 4604b570 3c0c4828 07c56ac0     ....p..F(H.<.j..
    fcdc:	0fed88e0 d0122805 8610f3ef 4824b672     .....(......r.$H
    fcec:	f0014621 b662f8c7 8810f386 492188a0     !F....b.......!I
    fcfc:	d10d4288 b2c188e0 d005290b 4621e008     .B.......)....!F
    fd0c:	f001481d e02cf8c9 02000a00 80e03014     .H....,......0..
    fd1c:	491a88a0 d1104288 88e04919 42886809     ...I.B...I...h.B
    fd2c:	201bd10b f8acf001 f0004606 2801ffad     ... .....F.....(
    fd3c:	2100d103 f0014630 88e0f8b5 d0102804     ...!0F.......(..
    fd4c:	28048920 2d00d10d 480ed004 28006800      ..(...-...H.h.(
    fd5c:	e006d004 2001490c e0026208 f0004809     .....I. .b...H..
    fd6c:	2001ffdb f8a4f001 0000bd70 4000b1c0     ... ....p......@
    fd7c:	10040bd4 00000c13 10040c20 00000e03     ........ .......
    fd8c:	10040018 100405ec 4000b000 49aab5fe     ...........@...I
    fd9c:	4ea84fa7 24006948 01c009c0 43102255     .O.NHi.$....U".C
    fdac:	48a66148 18280525 f001210d 9001f887     Ha.H%.(..!......
    fdbc:	210d48a3 f0011828 9000f881 006148a1     .H.!(........Ha.
    fdcc:	0480180d f0014629 4a9ef87f 43504629     ....)F.....J)FPC
    fddc:	f87af001 46294a9b f0014350 219df875     ..z..J)FPC..u..!
    fdec:	21014348 18400449 0c80219d 18420209     HC.!I.@..!....B.
    fdfc:	230c4621 98014359 4b935078 604319c8     !F.#YC..xP.K..C`
    fe0c:	98006082 48915070 60481989 b2e41c64     .`..pP.H..H`d...
    fe1c:	d3c62c28 488e2401 600405e4 60424a8d     (,...$.H...`.JB`
    fe2c:	60812100 60c34b8c 61416101 61c26184     .!.`.K.`.aAa.a.a
    fe3c:	62436204 62c16281 48884d7f 498861e8     .bCb.b.b.M.H.a.I
    fe4c:	6188200c 49874888 49886001 49886041     . .a.H.I.`.IA`.I
    fe5c:	f7ff6081 4887fb97 49886168 60084886     .`.....Hha.I.H.`
    fe6c:	158a6848 22804310 60484390 68084984     Hh...C.".CH`.I.h
    fe7c:	43100492 49836008 4a836808 439043a0     ...C.`.I.h.J.C.C
    fe8c:	bdfe6008 4c6cb510 21556960 01c009c0     .`....lL`iU!....
    fe9c:	61604308 49734874 49746001 49746041     .C`atHsI.`tIA`tI
    feac:	f7ff6081 4873fb6f 486c6160 69e061e0     .`..o.sH`alH.a.i
    febc:	03092103 61e04308 210168a0 60a04308     .!...C.a.h.!.C.`
    fecc:	6848496e 4310158a 496d6048 04526808     nIHh...CH`mI.hR.
    fedc:	60084310 6808496b 43904a6c bd106008     .C.`kI.hlJ.C.`..
    feec:	4770b240 2100b570 23154a69 021b460d     @.pGp..!iJ.#.F..
    fefc:	6025188c 42991d09 2103d3fa 04094a65     ..%`...B...!eJ..
    ff0c:	495e62d1 158b684a 604a431a 62014962     .b^IJh...CJ`bI.b
    ff1c:	62414962 22064962 212c6141 4961540a     bIAbbI."Aa,!.TaI
    ff2c:	49616281 49616001 49616041 496261c1     .baI.`aIA`aI.abI
    ff3c:	60084860 3c404c60 03896b20 43084388     `H.``L@< k...C.C
    ff4c:	f0006320 485dffc7 6ba06085 09000100      c....]H.`.k....
    ff5c:	430805a1 493863a0 63482003 49582009     ...C.c8I. Hc. XI
    ff6c:	60c80580 ff12f7ff 48564945 60483180     ...`....EIVH.1H`
    ff7c:	49554856 49566141 49566181 495161c1     VHUIAaVI.aVI.aQI
    ff8c:	62013113 30404838 4a5368c1 68120949     .1.b8H@0.hSJI..h
    ff9c:	43110149 bd7060c1 4850b510 28008800     I..C.`p...PH...(
    ffac:	2005d00a 21000200 23154a39 1884021b     ... ...!9J.#....
    ffbc:	1d006021 d3fa4298 49362003 62c80400     !`...B... 6I...b
    ffcc:	483c493d 4c3c6008 6b203c40 43880389     =I<H.`<L@< k...C
    ffdc:	63204308 ff7ef000 fc45f7ff 01006ba0     .C c..~...E..k..
    ffec:	05a10900 63a04308 6800483d 49124780     .....C.c=H.h.G.I
    fffc:	63482003 49322009 60c80580 ff42f7ff     . Hc. 2I...`..B.
   1000c:	4830491f 60483180 492f4830 49306141     .I0H.1H`0H/IAa0I
   1001c:	49306181 492b61c1 62013113 30404812     .a0I.a+I.1.b.H@0
   1002c:	4a2d68c1 68120949 43110149 bd1060c1     .h-JI..hI..C.`..
   1003c:	40022800 40022a00 40020000 4b100007     .(.@.*.@...@...K
   1004c:	4b180007 00000962 423d55af 420155af     ...Kb....U=B.U.B
   1005c:	40022c00 00048060 00008060 01103080     .,.@`...`....0..
   1006c:	4000e200 00002402 40020800 6438ee11     ...@.$.....@..8d
   1007c:	00010ee4 6a029143 0f600107 4000f400     ....C..j..`....@
   1008c:	40041800 40020180 04720700 04f20700     ...@...@..r.....
   1009c:	40030000 40041a80 0001b645 0001b637     ...@...@E...7...
   100ac:	0001b35b 0001b363 0001b32f 0001b349     [...c.../...I...
   100bc:	10005d75 054a0756 40040080 4000f000     u]..V.J....@...@
   100cc:	40024000 00000303 d6d6e8ff 40041900     .@.@...........@
   100dc:	8199afc4 0000516a 10006f2c 10006f24     ....jQ..,o..$o..
   100ec:	10040184 03892101 d3004288 496c4608     .....!...B...FlI
   100fc:	43486809 0b420ac1 0c421851 0c821851     .hHC..B.Q.B.Q...
   1010c:	0cc21851 0d021851 0d821851 0e021851     Q...Q...Q...Q...
   1011c:	0e421851 0e821851 18511c40 18400f80     Q.B.Q...@.Q...@.
   1012c:	1e40d000 47704770 2500b5f8 f3ef2040     ..@.pGpG...%@ ..
   1013c:	90008710 b6724e5b 80702001 fed0f000     ....[Nr.. p.....
   1014c:	d0732800 25012002 f0008070 2802fdfd     .(s.. .%p......(
   1015c:	2003d0fb f0008070 2800fdf7 4c51d066     ... p......(f.QL
   1016c:	80712104 78e1340c 29004630 2105d05e     .!q..4.x0F.)^..!
   1017c:	88218041 d1592900 80412107 9100494a     A.!..)Y..!A.JI..
   1018c:	8809494a d0042900 78a24949 18568809     JI...)..II.x..V.
   1019c:	78a1e002 188e6842 80412108 88004845     ...xBh...!A.EH..
   101ac:	d0032800 fea2f000 d0fb2800 2109483d     .(.......(..=H.!
   101bc:	46318041 f0004668 2800fe9f 4839d06a     A.1FhF.....(j.9H
   101cc:	8041210a fe9ef000 d0632800 210b4835     .!A......(c.5H.!
   101dc:	46318041 f0004668 2800fe9b 4834d05a     A.1FhF.....(Z.4H
   101ec:	88009900 28051a08 4e2ed354 8070200c     .......(T..N. p.
   101fc:	fe94f000 d01a2800 8070200f 6800482e     .....(... p..H.h
   1020c:	28004780 482dd003 07806800 2010d442     .G.(..-H.h..B.. 
   1021c:	492b8070 62082000 fe86f000 fe8af000     p.+I. .b........
   1022c:	98004921 d1044288 e00b2000 2500e032     !I...B... ..2..%
   1023c:	491ee030 29008809 491dd002 e0008809     0..I...)...I....
   1024c:	1a406871 20119000 491e8070 63c82001     qh@.... p..I. .c
   1025c:	28006bc8 481bd1fc 69c038c0 6008491a     .k.(...H.8.i.I.`
   1026c:	f7ff9800 60b0ff3f 80702012 68b07921     ....?..`. p.!y.h
   1027c:	fe66f000 49152001 60080780 1c407830     ..f.. .I...`0x@.
   1028c:	20137030 48128070 47806a80 68014811     0p. p..H.j.G.H.h
   1029c:	d5fc0049 f387b662 46288810 0000bdf8     I...b.....(F....
   102ac:	10040204 100400f0 0000ffff 10040094     ................
   102bc:	1004009c 10006f26 1004018c 4000e000     ....&o.........@
   102cc:	4000b000 400400c0 10006f30 e000e100     ...@...@0o......
   102dc:	10040d90 e000e200 0ec906c1 40882001     ............. .@
   102ec:	6008492f 06c14770 20010ec9 492c4088     /I.`pG..... .@,I
   102fc:	60083180 06c14770 20010ec9 49294088     .1.`pG..... .@)I
   1030c:	47706008 f000b570 2501fe21 106c03ed     .`pGp...!..%..l.
   1031c:	4a251063 d0122800 60102000 63901e40     c.%J.(... .`@..c
   1032c:	f7ff2018 6950ffe8 61504328 43206950     . ....Pi(CPaPi C
   1033c:	69506150 61504318 f7ff2018 481bffdc     PaPi.CPa. .....H
   1034c:	481b6390 07896801 6ad1d006 62d14329     .c.H.h.....j)C.b
   1035c:	43296b11 62156311 06896801 d0060f89     .k)C.c.b.h......
   1036c:	43216ad1 6b1162d1 63114321 68006214     .j!C.b.k!C.c.b.h
   1037c:	0f800580 6ad0d006 62d04318 43186b10     .......j.C.b.k.C
   1038c:	62136310 f7ff2018 201fffa7 ffa4f7ff     .c.b. ..... ....
   1039c:	f7ff2015 201bffa1 ff9ef7ff 0000bd70     . ..... ....p...
   103ac:	e000e100 e000e280 40011000 0000ffff     ...........@....
   103bc:	4000f000 4853b5f8 25017801 29014852     ...@..SH.x.%RH.)
   103cc:	4952d11e 29016849 4951d11a 4b516a8a     ..RIIh.)..QI.jQK
   103dc:	4b51401a 628a431a 4b506aca 432a401a     .@QK.C.b.jPK.@*C
   103ec:	688162ca 40114a4e 43114a4e 69016081     .b.hNJ.@NJ.C.`.i
   103fc:	4311220c 68416101 02122277 60414391     .".C.aAhw"...CA`
   1040c:	220f6901 43110292 48476101 e0006806     .i."...C.aGH.h..
   1041c:	69706930 d1fb07c0 68004844 0f400080     0ipi....DH.h..@.
   1042c:	f0000003 0508fd99 110e0b08 1c1a1714     ................
   1043c:	026424e1 24e1e013 e01002a4 02e424e1     .$d....$.....$..
   1044c:	24e1e00d e00a0324 022424e1 244be007     ...$$....$$...K$
   1045c:	e0040264 0224244b 244be001 483401e4     d...K$$...K$..4H
   1046c:	46216807 f0004638 b282fd2f 43504620     .h!F8F../... FPC
   1047c:	20001a39 e0020923 b2c01c40 428b1ac9     9.. #...@......B
   1048c:	1c40d3fa 20000841 00d262b0 6272430a     ..@.A.. .b...Crb
   1049c:	600d4928 3180491c 0912680a 600a0112     (I.`.I.1.h.....`
   104ac:	69b060b0 43082102 bdf861b0 4b22b430     .`.i.!.C.a..0."K
   104bc:	609a4c1d 60586019 290a6824 7805d10d     .L.`.`X`$h.)...x
   104cc:	d10a2d04 2d0e7845 7905d107 d1042d1f     .-..Ex.-...y.-..
   104dc:	28207940 1e49d101 29006019 6860d008     @y (..I..`.)..`h
   104ec:	d0fc07c0 78056858 1c406025 e7f26058     ....Xh.x%`@.X`..
   104fc:	60582000 d0022a00 bc306098 bc304710     . X`.*...`0..G0.
   1050c:	00004770 100400d9 4000b040 10006f6c     pG......@..@lo..
   1051c:	4000b180 c0c0ffff 02030000 ffffc0c0     ...@............
   1052c:	ff8888ff 00111100 1004015c 10040828     ........\...(...
   1053c:	10006f7c e000e100 10041968 493ab5fe     |o......h.....:I
   1054c:	68094838 4d394788 4a382000 3d504b38     8H.h.G9M. 8J8KP=
   1055c:	24261c41 43440749 0f49260a 434618a4     A.&$I.DC.&I...FC
   1056c:	807c18f7 4361240a 19494c31 19343c40     ..|..$aC1LI.@<4.
   1057c:	1c408761 dbeb2808 68204c2e 438821f0     a.@..(...L h.!.C
   1058c:	430821e0 482b6020 30c02196 0a526b02     .!.C `+H.!.0.kR.
   1059c:	430a0252 6b016302 40114a27 43114a27     R..C.c.k'J.@'J.C
   105ac:	48276301 682060e0 438800e1 68206020     .c'H.` h...C ` h
   105bc:	43881049 22066020 46684922 fb70f000     I..C `.""IhF..p.
   105cc:	88084669 04098849 62614301 88884669     iF..I....CabiF..
   105dc:	682062a0 43881561 60204308 21074815     .b ha..C.C `.H.!
   105ec:	61013080 39184916 49156301 63413124     .0.a.I.9.c.I$1Ac
   105fc:	39c0490e 48146381 7c00210a 19404348     .I.9.c.H.!.|HC@.
   1060c:	f7ff62e0 2001fab0 fcacf000 fcb0f000     .b..... ........
   1061c:	7800480e d0012800 fcb0f000 fcb4f000     .H.x.(..........
   1062c:	0000bdfe 10040d90 100400ec 00000aca     ................
   1063c:	40030a80 40040000 fc00ffff 01e50000     ...@...@........
   1064c:	0000033a 0001f8b2 10040b9c 100400a4     :...............
   1065c:	21004803 60016041 21026801 47706001     .H.!A`.`.h.!.`pG
   1066c:	4000d000 6802b510 43086b10 20046310     ...@...h.k.C.c. 
   1067c:	fe32f7ff b510bd10 6b106802 63104388     ..2......h.k.C.c
   1068c:	f7ff2004 bd10fe30 2101b5f0 0f240704     . ..0......!..$.
   1069c:	2300460a 40a24dac d82a2818 28074cab     .F.#.M.@.(*..L.(
   106ac:	6863d801 280fe006 68a3d801 2817e002     ..ch...(...h...(
   106bc:	68e3d800 0ef70746 40be2607 280743b3     ...hF....&.@.C.(
   106cc:	6063d801 280fe006 60a3d801 2817e002     ..c`...(...`...(
   106dc:	60e3d800 d2082810 68534a9d 430b4081     ...`.(...JSh.@.C
   106ec:	69136053 6113430b 499ae001 7728e00d     S`.i.C.a...I..(w
   106fc:	4603bdf0 2b033b2c 4c97d8fa 07866923     ...F,;.+...L#i..
   1070c:	40b10fb6 6123438b 684b4994 604b4313     ...@.C#a.IKh.CK`
   1071c:	4313690b e7ea610b 488bb530 7f022101     .i.C.a..0..H.!..
   1072c:	d2062a10 685c4b8a 4095460d 605c43ac     .*...K\h.F.@.C\`
   1073c:	4b85e009 071c7f1b 23010f24 2a1840a3     ...K....$..#.@.*
   1074c:	4a84d203 7741e005 3a2cbd30 d8042a03     ...J..Aw0.,:.*..
   1075c:	68544a82 6054439c 2100e7f5 b530e7f3     .JTh.CT`...!..0.
   1076c:	23004879 24017f01 d2052910 68554a78     yH.#...$.)..xJUh
   1077c:	4325408c e0096055 7f124a73 0f240714     .@%CU`..sJ....$.
   1078c:	40a22201 d2032918 e0054972 bd307743     .".@.)..rI..Cw0.
   1079c:	2903392c 4971d8fb 4314684c e7f5604c     ,9.)..qILh.CL`..
   107ac:	4606b570 460c4615 f7ff2004 4b66fd9c     p..F.F.F. ....fK
   107bc:	609e2001 605c60dd 841c7798 68006818     . .`.`\`.w...h.h
   107cc:	07c96881 21fed001 20046001 fd84f7ff     .h.....!.`. ....
   107dc:	ffa2f7ff b570bd70 250026fe e0384c5a     ....p.p..&.%ZL8.
   107ec:	68406961 d0342900 69207008 61201e40     ai@h.)4..p i@. a
   107fc:	1c406960 7fa06160 d0062800 68a06821     `i@.`a...(..!h.h
   1080c:	78006809 77a56008 6860e020 d01a2800     .h.x.`.w .`h.(..
   1081c:	60601e40 1c4968a1 280060a1 7808d009     @.``.hI..`.(...x
   1082c:	68096821 7f606008 d10f2801 ff97f7ff     !h.h.``..(......
   1083c:	6820e00c 60066800 290068e1 2000d006     .. h.h.`.h.)... 
   1084c:	478860e5 6820e002 60066800 28006920     .`.G.. h.h.` i.(
   1085c:	6820d005 68c16800 d1c107c9 6165bd70     .. h.h.h....p.ea
   1086c:	68202101 ff07f7ff 290069a1 2000d0f6     .! h.....i.)... 
   1087c:	478861a5 b5f0bd70 4606b087 4668211c     .a.Gp......F.!hF
   1088c:	fb88f000 2e004f36 7838d106 d1032800     ....6O....8x.(..
   1089c:	482d2124 fb7ef000 46692000 74087048     $!-H..~.. iFHp.t
   108ac:	744a2201 70887008 7b00482e 0f400740     ."Jt.p.p.H.{@.@.
   108bc:	d80b2803 492c00c2 5a8b4668 18518243     .(....,IhF.ZC.Q.
   108cc:	8282884a 82c2888a 830188c9 4c274d1e     J............M'L
   108dc:	d0022e01 d00d2e00 7820e012 d0022800     .......... x.(..
   108ec:	28027820 4820d10c 4921466a f0003808      x.(.. HjF!I.8..
   108fc:	e005fb57 28007838 481bd102 60283808     W...8x.(...H.8(`
   1090c:	28007820 7820d002 d1032802 78004819      x.(.. x.(...H.x
   1091c:	febaf7ff 68282101 feadf7ff f0002014     .....!(h..... ..
   1092c:	7820fb45 d00c2800 28027820 4912d107     E. x.(.. x.(...I
   1093c:	f0002014 2101fb41 f7ff6828 b007fe93     . ..A..!(h......
   1094c:	490ebdf0 0000e7f4 10041e00 4000b040     ...I........@..@
   1095c:	40010000 40011000 4000f400 40013000     ...@...@...@.0.@
   1096c:	10040000 10040828 10040198 100400d9     ....(...........
   1097c:	40006000 10006f78 1000666b 0001d1c7     .`.@xo..kf......
   1098c:	60032300 041b6803 2301d5fc 497c408b     .#.`.h.....#.@|I
   1099c:	600b4313 29006801 4608dafc b5084770     .C.`.h.)...FpG..
   109ac:	90000080 dd012800 e7fa1e40 b5f0bd08     .....(..@.......
   109bc:	b0874974 22006cca 68c99201 29004c72     tI...l."...hrL.)
   109cc:	2800d07e 4871d07d 04c06880 48700ec5     ~..(}.qH.h....pH
   109dc:	68c09504 0b804e6f d02b07c0 1d004868     ...hoN....+.hH..
   109ec:	91002107 69a19002 61a14331 99009a01     .!.....i1C.a....
   109fc:	ffc6f7ff 49680847 400f0440 43070c40     ....G.hI@..@@..C
   10a0c:	43b069a0 9a0161a0 98029900 ffb8f7ff     .i.C.a..........
   10a1c:	49610844 400c0440 43040c40 0b200b39     D.aI@..@@..C9. .
   10a2c:	1a409105 4240d500 f0000280 4606fa4d     ..@...@B....M..F
   10a3c:	e03e9403 4f594852 90023008 90002006     ..>.RHYO.0... ..
   10a4c:	6c804850 0209217d d1d94288 e7d74f54     PH.l}!...B..TO..
   10a5c:	95044606 42bc9403 2d1fd203 1c6dd204     .F.....B...-..m.
   10a6c:	2d00e002 1e6dd000 68884948 0212221f     ...-..m.HI.h."..
   10a7c:	022a4390 608a4302 f7ff2001 9a01ff90     .C*..C.`. ......
   10a8c:	98029900 ff7cf7ff 49430844 400c0440     ......|.D.CI@..@
   10a9c:	43040c40 0b219805 99051a08 4240d500     @..C..!.......@B
   10aac:	f0000280 2d1ffa11 2d00d005 42b0d003     .......-...-...B
   10abc:	2805da01 42b0dccc 4934dd0c e0019c03     ...(...B..4I....
   10acc:	e025e015 221f6888 43900212 02129a04     ..%..h."...C....
   10adc:	608a4302 0ba04a33 43500bb9 f9f4f000     .C.`3J....PC....
   10aec:	60084928 68096848 d10e4288 69a0e010     (I.`Hh.h.B.....i
   10afc:	43082104 210861a0 61a04308 49294821     .!.C.a.!.C.a!H)I
   10b0c:	68416001 42816800 4827d002 47806800     .`Ah.h.B..'H.h.G
   10b1c:	68a04c1c d1092801 60a02000 302c4620     .L.h.(... .` F,0
   10b2c:	f8a3f000 f864f000 f88df000 68216860     ......d.....`h!h
   10b3c:	d0034288 60606820 f885f000 bdf0b007     .B.. h``........
   10b4c:	e7342001 2800b510 2801d017 2804d014     . 4....(...(...(
   10b5c:	4816d112 49166800 1a406809 3171490d     ...H.h.I.h@..Iq1
   10b6c:	49144348 f9b0f000 21004a13 68536814     HC.I.....J.!.hSh
   10b7c:	41591900 60516010 f000bd10 bd10f864     ..YA.`Q`....d...
   10b8c:	4000c000 10006f7c 4000b000 4000f400     ...@|o.....@...@
   10b9c:	10040828 00000200 3fff8000 018cba80     (..........?....
   10bac:	01964000 00000a28 10040160 10006f20     .@..(...`... o..
   10bbc:	10006f30 0007a120 10040240 492c4602     0o.. ...@....F,I
   10bcc:	43c02000 e0046809 d101428a 47702000     . .C.h...B... pG
   10bdc:	29006989 4770d1f8 4604b510 4608460b     .i.)..pG...F.F.F
   10bec:	ffecf7ff d0022800 61986820 bd106023     .....(.. h.a#`..
   10bfc:	4e1fb5f8 462f2500 e0216830 69844a1d     ...N.%/F0h!..J.i
   10c0c:	68136881 1a596852 d31741ba 29007901     .h.hRhY..A...y.)
   10c1c:	4b18d00c 681968c2 1851685b 60814605     ...K.h.h[hQ..F.`
   10c2c:	29006901 6940d00b e0084788 42816831     .i.)..@i.G..1h.B
   10c3c:	6034d101 61ace000 e7f16187 46204605     ..4`...a.a...F F
   10c4c:	d1db2800 b510bdf8 6801480b 4341480b     .(.......H.h.HAC
   10c5c:	1e49480b 490b6141 69cb2207 0a24021c     .HI.Aa.I.".i..$.
   10c6c:	61cc2300 61026183 4601bd10 e7b34800     .#.a.a.a...F.H..
   10c7c:	1004021c 10040240 10006f7c 00001388     ....@...|o......
   10c8c:	e000e000 e000ed04 4801b403 bd019001     ...........H....
   10c9c:	0001a2f9 4801b403 bd019001 00019fe9     .......H........
   10cac:	4801b403 bd019001 0001de29 4801b403     ...H....)......H
   10cbc:	bd019001 0001a251 4801b403 bd019001     ....Q......H....
   10ccc:	0001de17 4801b403 bd019001 0001bb9d     .......H........
   10cdc:	4801b403 bd019001 0001bf11 4801b403     ...H...........H
   10cec:	bd019001 0001d0ad 4801b403 bd019001     ...........H....
   10cfc:	0001bb9f 4801b403 bd019001 0001bfd5     .......H........
   10d0c:	4801b403 bd019001 0001bdd1 4801b403     ...H...........H
   10d1c:	bd019001 0001bb7d 4801b403 bd019001     ....}......H....
   10d2c:	0001dbdd 4801b403 bd019001 00000215     .......H........
   10d3c:	4801b403 bd019001 0001b83b 4801b403     ...H....;......H
   10d4c:	bd019001 0001dc5b 4801b403 bd019001     ....[......H....
   10d5c:	0001cf37 4801b403 bd019001 0001d6f5     7......H........
   10d6c:	4801b403 bd019001 0001b7fb 4801b403     ...H...........H
   10d7c:	bd019001 00000b15 4801b403 bd019001     ...........H....
   10d8c:	0001bdd5 4801b403 bd019001 0001d4d1     .......H........
   10d9c:	4801b403 bd019001 0001d4ed 4801b403     ...H...........H
   10dac:	bd019001 0001cffb 4801b403 bd019001     ...........H....
   10dbc:	00000ab7 4801b403 bd019001 00000e17     .......H........
   10dcc:	4801b403 bd019001 000000d5 4801b403     ...H...........H
   10ddc:	bd019001 00019dab 4801b403 bd019001     ...........H....
   10dec:	0001cdbf 4801b403 bd019001 000011e3     .......H........
   10dfc:	4801b403 bd019001 00012edd 4801b403     ...H...........H
   10e0c:	bd019001 00006685 4801b403 bd019001     .....f.....H....
   10e1c:	00006651 4801b403 bd019001 00012faf     Qf.....H...../..
   10e2c:	4801b403 bd019001 00006647 4801b403     ...H....Gf.....H
   10e3c:	bd019001 00005081 4801b403 bd019001     .....P.....H....
   10e4c:	0001ba01 4801b403 bd019001 000131af     .......H.....1..
   10e5c:	4801b403 bd019001 00005df3 4801b403     ...H.....].....H
   10e6c:	bd019001 000082af 4801b403 bd019001     ...........H....
   10e7c:	0000533d 4801b403 bd019001 000190bf     =S.....H........
   10e8c:	4801b403 bd019001 00018bdb 4801b403     ...H...........H
   10e9c:	bd019001 0001a27d 4801b403 bd019001     ....}......H....
   10eac:	0001d577 4801b403 bd019001 0001a2a1     w......H........
   10ebc:	4801b403 bd019001 00019c81 4801b403     ...H...........H
   10ecc:	bd019001 0001dd01 4801b403 bd019001     ...........H....
   10edc:	0001dcd5 4801b403 bd019001 0001b2a7     .......H........
   10eec:	4801b403 bd019001 00019c47 4801b403     ...H....G......H
   10efc:	bd019001 0001b731 4801b403 bd019001     ....1......H....
   10f0c:	0001a543 4801b403 bd019001 00001399     C......H........
   10f1c:	4801b403 bd019001 000131d3 4801b403     ...H.....1.....H
   10f2c:	bd019001 000196d1 4801b403 bd019001     ...........H....
   10f3c:	0001c9db 4801b403 bd019001 0001c93d     .......H....=...
   10f4c:	4801b403 bd019001 00006839 4801b403     ...H....9h.....H
   10f5c:	bd019001 0001cc03 4801b403 bd019001     ...........H....
   10f6c:	0001e283 4801b403 bd019001 00006a2d     .......H....-j..
   10f7c:	4801b403 bd019001 0001c9ff 4801b403     ...H...........H
   10f8c:	bd019001 00006a01 4801b403 bd019001     .....j.....H....
   10f9c:	0001c999 4801b403 bd019001 0001de5b     .......H....[...
   10fac:	4801b403 bd019001 0001d25b 4801b403     ...H....[......H
   10fbc:	bd019001 000007bd 4801b403 bd019001     ...........H....
   10fcc:	000007d7 26100000 00000000 10006eec     .......&.....n..
   10fdc:	100400d8 00010001 00000805 00019685     ................
   10fec:	00000300 10005ac9 00000301 000192f7     .....Z..........
   10ffc:	00000302 00019379 00000303 000193a3     ....y...........
   1100c:	00000304 000193d5 0000030a 00019403     ................
   1101c:	00000305 0001947f 0000030f 000194b1     ................
   1102c:	00000312 000194e5 00000313 00019535     ............5...
   1103c:	00000314 0001956b 00000315 000195ab     ....k...........
   1104c:	00000316 000195f1 00000317 0001963b     ............;...
   1105c:	00000318 0001942b 10006e6c 00000010     ....+...ln......
   1106c:	0001befb 10006341 0001bef3 0001bef5     ....Ac..........
   1107c:	0001d099 10006635 0001d0fd 0001d0ff     ....5f..........
   1108c:	00000000 00000004 00000001 00000000     ................
   1109c:	00010001 00000000 00000011 00000000     ................
   110ac:	00000c13 10005185 00000e0b 100051ff     .....Q.......Q..
	...
   110c4:	10006f34 00000002 10006f44 10006f4c     4o......Do..Lo..
   110d4:	10006f64 00080001 00000000 00000000     do..............
   110e4:	00000101 00000000 0001cccb 0000002f     ............/...
   110f4:	018cba80 00000000 00000000 00000001     ................
   11104:	00000000 03e80fa0 0bb803e8 00000000     ................
	...

00011144 <dummy_buffer>:
   11144:	2000197c                                |.. 

00011148 <interface_send_msg>:
   11148:	20001ef4 732f2e2e 412f6372 742f4653     ... ../src/ASF/t
   11158:	64726968 74726170 69772f79 656c6572     hirdparty/wirele
   11168:	622f7373 735f656c 6c5f6b64 622f6269     ss/ble_sdk_lib/b
   11178:	735f656c 6b636174 6970612f 6e6f635f     le_stack/api_con
   11188:	6c6f7274 5f72656c 65746e69 63616672     troller_interfac
   11198:	61672f65 745f6370 2e6b7361 454c0063     e/gapc_task.c.LE
   111a8:	63204243 656e6e6f 6f697463 7263206e     CB connection cr
   111b8:	69746165 66206e6f 656c6961 000a2064     eation failed ..
   111c8:	4243454c 6e696c20 6964206b 6e6f6373     LECB link discon
   111d8:	7463656e 206e6f69 6c696166 20657275     nection failure 
   111e8:	6547000a 65702074 64207265 63697665     ..Get peer devic
   111f8:	6e692065 65206f66 726f7272 7453202c     e info error, St
   11208:	73757461 6425203a 50414700 45475f43     atus: %d.GAPC_GE
   11218:	4f435f54 48435f4e 454e4e41 414d5f4c     T_CON_CHANNEL_MA
   11228:	53202c50 75746174 30203a73 32302578     P, Status: 0x%02
   11238:	6e550058 646e6168 2064656c 3c20504f     X.Unhandled OP <
   11248:	58323025 000a0d3e 69766544 4e206563     %02X>...Device N
   11258:	20656d61 20746f6e 00746573              ame not set.

00011264 <__FUNCTION__.7275>:
   11264:	63706167 706d635f 7476655f 70616700              gapc_cmp_evt.

00011271 <__FUNCTION__.7504>:
   11271:	63706167 7665645f 666e695f 65725f6f     gapc_dev_info_re
   11281:	6e695f71 61685f64 656c646e 61670072              q_ind_handler.

0001128f <__FUNCTION__.7694>:
   1128f:	6d706167 7365725f 725f7465 685f7165     gapm_reset_req_h
   1129f:	6c646e61 2e007265 72732f2e 53412f63     andler.../src/AS
   112af:	68742f46 70647269 79747261 7269772f     F/thirdparty/wir
   112bf:	73656c65 6c622f73 64735f65 696c5f6b     eless/ble_sdk_li
   112cf:	6c622f62 74735f65 2f6b6361 5f697061     b/ble_stack/api_
   112df:	746e6f63 6c6c6f72 695f7265 7265746e     controller_inter
   112ef:	65636166 7061672f 61745f6d 632e6b73     face/gapm_task.c
   112ff:	4f2e5700 25203a50 2c783230 4f2e5220     .W.OP: %02x, R.O
   1130f:	30253a50 0a0d7832 686e5500 6c646e61     P:%02x...Unhandl
   1131f:	4f206465 78302050 3230253c 0a0d3e58     ed OP 0x<%02X>..
	...

00011330 <__FUNCTION__.7712>:
   11330:	6d706167 7465735f 7665645f 6e6f635f     gapm_set_dev_con
   11340:	5f676966 5f646d63 646e6168 0072656c     fig_cmd_handler.

00011350 <__FUNCTION__.7783>:
   11350:	6d706167 706d635f 7476655f 70616700              gapm_cmp_evt.

0001135d <__FUNCTION__.7726>:
   1135d:	6d706167 7465675f 7665645f 6e6f635f     gapm_get_dev_con
   1136d:	5f676966 5f646d63 646e6168 0072656c     fig_cmd_handler.
   1137d:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
   1138d:	74726170 69772f79 656c6572 622f7373     party/wireless/b
   1139d:	735f656c 6c5f6b64 622f6269 735f656c     le_sdk_lib/ble_s
   113ad:	6b636174 6970612f 6e6f635f 6c6f7274     tack/api_control
   113bd:	5f72656c 65746e69 63616672 61672f65     ler_interface/ga
   113cd:	5f637474 6b736174 4600632e 656c6961     ttc_task.c.Faile
   113dd:	65722064 6e696461 68632067 63617261     d reading charac
   113ed:	69726574 63697473 67000a20                       teristic ..

000113f8 <__FUNCTION__.7449>:
   113f8:	74746167 6f635f63 656c706d 655f6574     gattc_complete_e
   11408:	685f7476 6c646e61 67007265                       vt_handler.

00011413 <__FUNCTION__.7015>:
   11413:	74746167 64615f6d 74615f64 62697274     gattm_add_attrib
   11423:	5f657475 5f716572 646e6168 0072656c     ute_req_handler.
   11433:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
   11443:	74726170 69772f79 656c6572 622f7373     party/wireless/b
   11453:	735f656c 6c5f6b64 622f6269 735f656c     le_sdk_lib/ble_s
   11463:	6b636174 6970612f 6e6f635f 6c6f7274     tack/api_control
   11473:	5f72656c 65746e69 63616672 61672f65     ler_interface/ga
   11483:	5f6d7474 6b736174 4d00632e 64734951     ttm_task.c.MQIsd
   11493:	00000070 00c31400 00c20200 00c2e800     p...............
   114a3:	00c1ee00 00c2e800 00c2f200 00c2e800     ................
   114b3:	00c1ee00 00c20200 00c20200 00c2f200     ................
   114c3:	00c1ee00 00c1f800 00c1f800 00c1f800     ................
   114d3:	00c55a00 00c97400 00c95200 00c95200     .Z...t...R...R..
   114e3:	00c94600 00c83a00 00c83a00 00c93a00     .F...:...:...:..
   114f3:	00c94600 00c83a00 00c93a00 00c83a00     .F...:...:...:..
   11503:	00c94600 00c83e00 00c83e00 00c83e00     .F...>...>...>..
   11513:	00cb5400 00004300 00003c00                       .T...C...

0001151c <_global_impure_ptr>:
   1151c:	2000003c                                <.. 

00011520 <__sf_fake_stdin>:
	...

00011540 <__sf_fake_stdout>:
	...

00011560 <__sf_fake_stderr>:
	...
   11580:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   11590:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   115a0:	31300046 35343332 39383736 64636261     F.0123456789abcd
   115b0:	00006665                                ef..

000115b4 <_init>:
   115b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   115b6:	46c0      	nop			; (mov r8, r8)
   115b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   115ba:	bc08      	pop	{r3}
   115bc:	469e      	mov	lr, r3
   115be:	4770      	bx	lr

000115c0 <__init_array_start>:
   115c0:	000000dd 	.word	0x000000dd

000115c4 <_fini>:
   115c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   115c6:	46c0      	nop			; (mov r8, r8)
   115c8:	bcf8      	pop	{r3, r4, r5, r6, r7}
   115ca:	bc08      	pop	{r3}
   115cc:	469e      	mov	lr, r3
   115ce:	4770      	bx	lr

000115d0 <__fini_array_start>:
   115d0:	000000b5 	.word	0x000000b5
